Directory structure:
└── ecere-dggal/
    ├── README.md
    ├── BUILDING.md
    ├── CONTRIBUTORS
    ├── dgg.ec
    ├── dgg.epj
    ├── dggal.epj
    ├── fetchAndBuild.bat
    ├── fetchAndBuild.sh
    ├── fetchAndBuildWASM.sh
    ├── LICENSE
    ├── Makefile
    ├── Makefile.dgg
    ├── Makefile.dgg.static
    ├── Makefile.dggal
    ├── Makefile.dggal.static
    ├── Makefile.wasm
    ├── .onedev-buildspec.yml
    ├── bindings/
    │   ├── c/
    │   │   ├── dggal.c
    │   │   ├── Makefile
    │   │   ├── Makefile.dggal_c
    │   │   └── Makefile.dggal_c.static
    │   ├── c_fn/
    │   │   ├── dggal_c.c
    │   │   ├── dggal_c.h
    │   │   ├── Makefile
    │   │   └── Makefile.allinone
    │   ├── cpp/
    │   │   ├── Makefile
    │   │   └── Makefile.dggal_cpp
    │   ├── js/
    │   │   ├── dggal.d.ts
    │   │   └── dggal.js
    │   ├── py/
    │   │   ├── __init__.py
    │   │   ├── build_dggal.py
    │   │   └── cffi-dggal.h
    │   └── rust/
    │       ├── dggal.rs
    │       ├── Makefile
    │       ├── Makefile.dggal
    │       └── Makefile.dggal-sys
    ├── bindings_examples/
    │   ├── c/
    │   │   ├── info.c
    │   │   ├── info.epj
    │   │   ├── Makefile
    │   │   └── Makefile.static
    │   ├── c_fn/
    │   │   ├── info.c
    │   │   └── Makefile
    │   ├── cpp/
    │   │   ├── info.cpp
    │   │   ├── info.epj
    │   │   ├── Makefile
    │   │   └── Makefile.static
    │   ├── js/
    │   │   ├── dggalExample.js
    │   │   ├── dggalExample2.js
    │   │   ├── index.html
    │   │   └── indexSimple.html
    │   ├── py/
    │   │   ├── authalic.py
    │   │   ├── geom.py
    │   │   ├── info.py
    │   │   ├── list.py
    │   │   ├── togeo.py
    │   │   ├── togeo_json.py
    │   │   └── togeo_text.py
    │   └── rust/
    │       ├── geom.rs
    │       ├── info.rs
    │       ├── list.rs
    │       ├── Makefile
    │       ├── Makefile.geom
    │       ├── Makefile.list
    │       ├── Makefile.togeo
    │       ├── Makefile.zone
    │       ├── togeo.rs
    │       └── zone.rs
    ├── commands/
    │   ├── compact.ec
    │   ├── decompact.ec
    │   ├── geom.ec
    │   ├── grid.ec
    │   ├── index.ec
    │   ├── info.ec
    │   ├── level.ec
    │   ├── list.ec
    │   ├── rel.ec
    │   ├── sub.ec
    │   ├── togeo.ec
    │   └── zone.ec
    ├── dggal.org/
    │   └── index.html
    ├── docs/
    │   └── dggal/
    │       ├── _global-defs.econ
    │       ├── CRS.econ
    │       ├── CRSExtent.econ
    │       ├── CRSRegistry.econ
    │       ├── DGGRS.econ
    │       ├── DGGRSZone.econ
    │       ├── DGGSJSON.econ
    │       ├── DGGSJSONDepth.econ
    │       ├── DGGSJSONGrid.econ
    │       ├── DGGSJSONShape.econ
    │       ├── FieldType.econ
    │       ├── FieldTypeEx.econ
    │       ├── FieldValue.econ
    │       ├── FieldValueFormat.econ
    │       ├── GeoExtent.econ
    │       ├── GeoPoint.econ
    │       ├── GGGZone.econ
    │       ├── GNOSISGlobalGrid.econ
    │       ├── I3HZone.econ
    │       ├── I9RZone.econ
    │       ├── ISEA3H.econ
    │       ├── ISEA9R.econ
    │       ├── JSONSchema.econ
    │       └── JSONSchemaType.econ
    ├── high-vibes/
    │   ├── README.md
    │   ├── dgg-export.py
    │   ├── dgg-fetch.py
    │   ├── dgg-fg.py
    │   ├── dgg-import.py
    │   ├── dgg-serve.py
    │   ├── high-vibes.epj
    │   ├── clipping/
    │   │   ├── clipping.py
    │   │   ├── clippingCore.py
    │   │   └── clipUtils.py
    │   ├── dggsExport/
    │   │   ├── exportFeatures.py
    │   │   ├── raster.py
    │   │   └── rasterZoneGrid.py
    │   ├── dggsImport/
    │   │   ├── rasterImport.py
    │   │   ├── rasterSampling.py
    │   │   └── vectorImport.py
    │   ├── dggsStore/
    │   │   ├── aggregation.py
    │   │   ├── customDepths.py
    │   │   └── store.py
    │   ├── fg/
    │   │   ├── clippingShapely.py
    │   │   ├── dggsJSONFG.py
    │   │   ├── dgToGeoMulti.py
    │   │   ├── distance.py
    │   │   ├── faces.py
    │   │   ├── fix_topology_5x6.py
    │   │   ├── fixWGS84.py
    │   │   ├── interruption.py
    │   │   ├── reproj.py
    │   │   ├── sutherlandHodgman.py
    │   │   ├── unprojectToWGS84.py
    │   │   └── wkbc.py
    │   └── ogcapi/
    │       ├── utils.py
    │       ├── common/
    │       │   ├── collections.py
    │       │   ├── conformance.py
    │       │   └── landingPage.py
    │       └── dggs/
    │           ├── client.py
    │           ├── dggrs.py
    │           ├── zoneData.py
    │           ├── zoneInfo.py
    │           └── zones.py
    ├── src/
    │   ├── dggrs.ec
    │   ├── GeoExtent.ec
    │   ├── dggrs/
    │   │   ├── BCTA3H.ec
    │   │   ├── GNOSISGlobalGrid.ec
    │   │   ├── GPP3H.ec
    │   │   ├── HEALPixGrid.ec
    │   │   ├── ISEA3H.ec
    │   │   ├── ISEA4R.ec
    │   │   ├── ISEA7H.ec
    │   │   ├── ISEA7H_Z7.ec
    │   │   ├── ISEA9R.ec
    │   │   ├── IVEA3H.ec
    │   │   ├── IVEA4R.ec
    │   │   ├── IVEA7H.ec
    │   │   ├── IVEA7H_Z7.ec
    │   │   ├── IVEA9R.ec
    │   │   ├── rHEALPixGrid.ec
    │   │   ├── RI4R.ec
    │   │   ├── RI7H_Z7.ec
    │   │   ├── RI9R.ec
    │   │   ├── RTEA3H.ec
    │   │   ├── RTEA4R.ec
    │   │   ├── RTEA7H.ec
    │   │   ├── RTEA7H_Z7.ec
    │   │   └── RTEA9R.ec
    │   ├── dggsJSON/
    │   │   └── dggsJSON.ec
    │   ├── ecere3D/
    │   │   ├── Plane.ec
    │   │   ├── Quaternion.ec
    │   │   └── Vector3D.ec
    │   └── projections/
    │       ├── authalic.ec
    │       ├── barycentric5x6.ec
    │       ├── icoVertexGreatCircle.ec
    │       └── rHEALPix.ec
    └── tests/
        ├── dggalTest.ec
        ├── dggalTest.epj
        ├── dggrsTestCase.ec
        ├── Makefile
        ├── z7Test.ec
        ├── z7Test.epj
        └── testProjections/
            ├── testProjections.ec
            └── testProjections.epj

================================================
FILE: README.md
================================================
[![DGGAL docs](https://img.shields.io/badge/docs-API_documentation-green.svg)](https://dggal.org/docs/html/dggal/Classes/DGGRS.html)
[![PyPI Downloads](https://static.pepy.tech/personalized-badge/dggal?period=total&units=INTERNATIONAL_SYSTEM&left_color=gray&right_color=GREEN&left_text=downloads)](https://pepy.tech/projects/dggal)

# DGGAL, the Discrete Global Grid Abstraction Library

DGGAL provides a common interface to perform various operations on Discrete Global Grid Reference Systems (DGGRS), facilitating the implementation of Discrete Global Grid Systems (DGGS),
including implementing Web APIs based on the [OGC API - DGGS Standard](https://docs.ogc.org/is/21-038r1/21-038r1.html).

## Installation from PyPI

Both a source distribution and built distribution for Linux, Windows and macOS, including the `dgg` utility and Python bindings are available [from PyPI](https://pypi.org/project/dggal/) and can be installed with:

`pip install dggal`

## DGGAL integration in other software

DGGAL is already being integrated in several DGGS-enabled software, notably:

- [Vgrid plugin for QGIS](https://plugins.qgis.org/plugins/vgridtools/), [Vgrid DGGS](https://vgrid.gishub.vn/notebooks/08_dggal/), and [Vgrid plugin for Map Libre](https://github.com/opengeoshub/vgrid-maplibre/),
- FME Community Modules: [DGGS Indexer](https://community.safe.com/fme-hub-alerts-55/dggsindexer-38685), [DGGS Relator](https://community.safe.com/fme-hub-alerts-55/dggsrelator-38765),
[DGGS-JSON Decoder](https://community.safe.com/fme-hub-alerts-55/dggsjsondecoder-387740), and [DGGS-JSON Encoder](https://community.safe.com/fme-hub-alerts-55/dggsjsonencoder-38787),
- [a5geo](https://a5geo.org/) (adapting the DGGAL code for the DSEA / IVEA equal-area projection),
- [pydggsapi](https://github.com/LandscapeGeoinformatics/pydggsapi/tree/dggal),
- [GeoPlegma](https://github.com/GeoPlegma),
- [Geotoolkit](https://github.com/Geomatys/geotoolkit), a testing ground for [Apache SIS](https://sis.apache.org/),
- [Ecere](https://ecere.ca)'s [GNOSIS Software Development Kit](http://gnosis.earth/) and [GNOSIS Map Server](https://maps.gnosis.earth).

## Supported Discrete Global Grid Reference Systems

DGGAL currently supports all nine DGGRSs described in [OGC API - DGGS Annex B](https://docs.ogc.org/is/21-038r1/21-038r1.html#annex-dggrs-def), as well as additional DGGRSs:

### Axis-aligned DGGRS in WGS84 latitude and longitude (simple bounding boxes)

* [GNOSIS Global Grid](https://docs.ogc.org/is/21-038r1/21-038r1.html#ggg-dggrs): An axis-aligned quad-tree defined in WGS84 latitude and longitude, with special handling of polar regions achieving an approximate maximum of ~48% variance from median zone area, corresponding to the [OGC 2D Tile Matrix Set of the same name](https://docs.ogc.org/is/17-083r4/17-083r4.html#toc58)

### Equal-Area DGGRSs based on Icosahedral Projections (aperture 3 and 7 Hexagonal, aperture 4 and 9 Axis-Aligned Rhombic)

All of these Icosahedral DGGRSs achieve equal-area on the WGS84 ellipsoid, and are oriented with a first vertex of the icosahedron positioned at
authalic latitude of _arctan(φ)_ (where φ is the golden ratio), and longitude 11.20°E, with second vertex due North, resulting in only one
vertex / pentagon on land. Each of the 12 pentagons occupies 5/6th the area of a hexagon at the same refinement level.

Starting from version 0.0.6, the aperture 7 hexagonal grids and indexing are fully functional, including support for listing and resolving sub-zones for both hexagonal and pentagonal ancestral zones.

#### Icosahedral Snyder Equal Area (ISEA) projection

([An Equal-Area Map Projection for Polyhedral Globes (1992)](https://doi.org/10.3138%2F27H7-8K88-4882-1752), or dodecahedron configuration (DVEA) of [Slice & Dice (2006)](https://www.tandfonline.com/doi/abs/10.1559/152304006779500687))

* **ISEA4R**: An equal area rhombic grid with a refinement ratio of 4 defined in the  transformed into a 5x6 Cartesian space resulting in axis-aligned square zones
* [ISEA9R](https://docs.ogc.org/is/21-038r1/21-038r1.html#isea9r-dggrs): An equal area rhombic grid with a refinement ratio of 9 defined in the ISEA projection transformed into a 5x6 Cartesian space resulting in axis-aligned square zones
* [ISEA3H](https://docs.ogc.org/is/21-038r1/21-038r1.html#isea3h-dggrs): An equal area hexagonal grid with a refinement ratio of 3 defined in the ISEA projection
* [ISEA7H](https://docs.ogc.org/is/21-038r1/21-038r1.html#isea7h-dggrs): An equal area hexagonal grid with a refinement ratio of 7 defined in the ISEA projection
* **ISEA7H_Z7**: Same Discrete Global Grid Hierarchy (DGGH) and sub-zone order as ISEA7H, but using the Z7 indexing for interoperability with [DGGRID](https://github.com/sahrk/DGGRID) and [IGEO7](https://agile-giss.copernicus.org/articles/6/32/2025/).

**NOTE:** The DGGRID / IGEO7 interoperability of ISEA7H_Z7 relies on converting the authalic latitudes produced by DGGRID to geodetic latitudes to reference them to the WGS84 ellipsoid,
and using the orientation which can be specified in DGGRID with `dggs_vert0_lon 11.20`, `dggs_vert0_lat 58.282525588538994675786` and `dggs_vert0_azimuth 0.0`.
Efficient conversion from authalic latitude to geodetic latitudes is described by [Charles Karney's "On auxiliary latitudes"](https://arxiv.org/pdf/2212.05818)
and can be performed using [Geographiclib](https://geographiclib.sourceforge.io/doc/library.html) or with the `authalicSetup()`, `latGeodeticToAuthalic()` and `latAuthalicToGeodetic()`
[functions from DGGAL](https://github.com/ecere/dggal/blob/main/src/projections/authalic.ec).

#### Icosahedral Vertex-oriented great circle Equal Area (IVEA) projection

([Slice & Dice (2006)](https://www.tandfonline.com/doi/abs/10.1559/152304006779500687), or applying [Snyder 1992](https://doi.org/10.3138%2F27H7-8K88-4882-1752) to the dodecahedron (DSEA))

* **IVEA4R**: An equal area rhombic grid with a refinement ratio of 4 defined in the IVEA projection transformed into a 5x6 Cartesian space resulting in axis-aligned square zones, using the same global indexing and sub-zone ordering as for ISEA4R
* [IVEA9R](https://docs.ogc.org/is/21-038r1/21-038r1.html#ivea9r-dggrs): An equal area rhombic grid with a refinement ratio of 9 defined in the IVEA projection transformed into a 5x6 Cartesian space resulting in axis-aligned square zones, using the same global indexing and sub-zone ordering as for ISEA9R
* [IVEA3H](https://docs.ogc.org/is/21-038r1/21-038r1.html#ivea3h-dggrs): An equal area hexagonal grid with a refinement ratio of 3 defined in the IVEA projection, using the same global indexing and sub-zone ordering as for ISEA3H
* [IVEA7H](https://docs.ogc.org/is/21-038r1/21-038r1.html#ivea7h-dggrs): An equal area hexagonal grid with a refinement ratio of 7 defined in the IVEA projection, using the same global indexing and sub-zone ordering as for ISEA7H
* **IVEA7H_Z7**: Same DGGH and sub-zone order as IVEA7H, but using same Z7 indexing as for ISEA7H_Z7.

**NOTE:** This projection is superior to ISEA and RT(S)EA at avoiding perceptible cusps, resulting in more compact/regular zones.

#### Rhombic Triacontahedron (Snyder) Equal-Area (RT(S)EA) projection

(applying [Snyder 1992](https://doi.org/10.3138%2F27H7-8K88-4882-1752) to the Rhombic Triacontahedron,
 alternate configuration of [Slice & Dice (2006)](https://www.tandfonline.com/doi/abs/10.1559/152304006779500687),
[Disdyakis Triacontahedron Discrete Global Grid System](http://hdl.handle.net/1880/114595), or
[Construction of rhombic triacontahedron discrete global grid systems](https://doi.org/10.1080/17538947.2022.2130459))

* **RTEA4R**: An equal area rhombic grid with a refinement ratio of 4 defined in the RTEA projection transformed into a 5x6 Cartesian space resulting in axis-aligned square zones, using the same global indexing and sub-zone ordering as for ISEA4R
* **RTEA9R**: An equal area rhombic grid with a refinement ratio of 9 defined in the RTEA projection transformed into a 5x6 Cartesian space resulting in axis-aligned square zones, using the same global indexing and sub-zone ordering as for ISEA9R
* **RTEA3H**: An equal area hexagonal grid with a refinement ratio of 3 defined in the RTEA projection using the same global indexing and sub-zone ordering as for ISEA3H
* **RTEA7H**: An equal area hexagonal grid with a refinement ratio of 7 defined in the RTEA projection using the same global indexing and sub-zone ordering as for ISEA7H
* **RTEA7H_Z7**: Same DGGH and sub-zone order as RTEA7H, but using same Z7 indexing as for ISEA7H_Z7.

### Axis-aligned and Equal-Area DGGRSs based on HEALPix Projection

([HEALPix projection](https://arxiv.org/pdf/astro-ph/0409513))

* [HEALPix](https://docs.ogc.org/is/21-038r1/21-038r1.html#HEALPix-dggrs): An equal area and axis-aligned grid with square zones topology and a refinement ratio of 4 defined in the HEALPix projection, using configuration Nφ/H = 4, Nθ/K = 3 (same as default [PROJ implementation](https://proj.org/en/stable/operations/projections/healpix.html)), the new indexing described in OGC API - DGGS Annex B, and scanline-based sub-zone ordering
* [rHEALPix](https://docs.ogc.org/is/21-038r1/21-038r1.html#rHEALPix-dggrs): An equal area and axis-aligned grid with square zones topology and a refinement ratio of 9 defined in the rHEALPix projection using 50° E prime meridian (equivalent to [PROJ implementation](https://proj.org/en/stable/operations/projections/rhealpix.html) with parameters `+proj=rhealpix +lon_0=50 +ellps=WGS84`), the [original hierarchical indexing](https://iopscience.iop.org/article/10.1088/1755-1315/34/1/012012), and scanline-based sub-zone ordering

## libDGGAL API Documentation

The API documentation can be [found here](https://dggal.org/docs/html/dggal/Classes/DGGRS.html).

The `DGGRS` class provides most of the functionality of the library, allowing to resolve DGGRS zones by textual ID to a unique 64-bit zone integer identifier (`DGGRSZone`).
The geometry and sub-zones of a particular zone can also be queried.
The concept of [sub-zones](https://docs.ogc.org/is/21-038r1/21-038r1.html#term-sub-zone) is key to encoding both vector and raster geospatial data quantized to a DGGRS.
The DGGAL library also allows to resolve a sub-zone index at a particular depth from a parent zone, allowing to read DGGS-optimized data such as
[DGGS-JSON](http://dggs-json.org) and [DGGS-JSON-FG](https://docs.ogc.org/is/21-038r1/21-038r1.html#rc_data-dggs-jsonfg).

## Building DGGAL

The recommended method to obtain and build DGGAL and the `dgg` tool is to follow the instructions in [BUILDING.md](BUILDING.md),
or running [fetchAndBuild.sh](fetchAndBuild.sh) / [fetchAndBuild.bat](fetchAndBuild.bat).

DGGAL is now built using the [stand-alone eC development kit and eC runtime library](https://github.com/ecere/eC),
avoiding unnecessary dependencies on other components of the legacy monolithic Ecere SDK runtime library.

The script will clone both the eC and DGGAL repositories and build everything, including the C, C++, Rust and Python bindings
if the required development tools are properly installed and configured.

## Language bindings

While the library is written in the [eC programming language](https://ec-lang.org), object-oriented bindings for C, C++ and Python generated using the
Ecere SDK's [`bgen` tool](https://github.com/ecere/bgen) are provided. Bindings for Rust, Java and JavaScript (for WebAssembly build) are available as well.
Support for additional languages may be added in the future.

### C Bindings

C bindings with zero overhead invoking the eC methods, but relying on macros, are [available here](https://github.com/ecere/dggal/tree/main/bindings/c).

A C example implementing the `dgg info` command using these DGGAL C bindings is [available here](https://github.com/ecere/dggal/blob/main/bindings_examples/c/info.c).

A second set of C bindings with the small overhead of additional function calls but avoiding the need for macros are [available here](https://github.com/ecere/dggal/tree/main/bindings/c_fn).
These bindings still rely on the first set of C bindings with no overhead, but their C header file and function exports make them more suitable for third-party bindings generator for additional languages.

A C example implementing the `dgg info` command using the no-macros C bindings is [available here](https://github.com/ecere/dggal/blob/main/bindings_examples/c_fn/info.c).

### C++ Bindings

C++ bindings (depending on the C bindings) are [available here](https://github.com/ecere/dggal/tree/main/bindings/cpp).

A C++ example implementing the `dgg info` command using the DGGAL C++ bindings is [available here](https://github.com/ecere/dggal/blob/main/bindings_examples/cpp/info.cpp).

### Python Bindings

Python bindings (depending on the C bindings) are [available here](https://github.com/ecere/dggal/tree/main/bindings/py).

A Python example using the DGGAL Python bindings is [available here](https://github.com/ecere/dggal/blob/main/bindings_examples/py/info.py).

### Rust Bindings

Rust bindings (depending on the C bindings) are [available here](https://github.com/ecere/dggal/tree/main/bindings/rust).

A Rust example using the DGGAL Rust bindings is [available here](https://github.com/ecere/dggal/blob/main/bindings_examples/rust/info.rs).

### Java Bindings

Java bindings generated with the help of [Panama](https://openjdk.org/projects/panama/) (depending on both the zero overhead and no-macro bindings) are
[available here](https://github.com/jsorel/dggal-java/commits/main/), currently maintained by [Johann Sorel](https://github.com/jsorel) from [Geomatys](https://www.geomatys.com/).

### WebAssembly build and JavaScript Bindings

DGGAL can be built for WebAssembly for use in DGGS-aware Web clients.

JavaScript bindings (based on both the zero overhead and no-macro bindings) are available here: [dggal.js](https://github.com/ecere/dggal/blob/main/bindings/js/dggal.js),
depending on [libdggal.js](https://dggal.org/web/libdggal.js) and [libdggal_c_fn.js.0.0.wasm](https://dggal.org/web/libdggal_c_fn.js.0.0.wasm).

HTML / JavaScript examples using the DGGAL JavaScript bindings are [available here](https://github.com/ecere/dggal/tree/main/bindings_examples/js), with a [live demo here](https://dggal.org/web/).

See the [fetchAndBuildWASM.sh](https://raw.githubusercontent.com/ecere/dggal/refs/heads/main/fetchAndBuildWASM.sh) script for building the DGGAL WASM module from source.

## `dgg` tool

### Syntax
```
   dgg <dggrs> <command> [options] <arguments>
```

### Supported DGGRSs
* `gnosis` (Global Grid)
* `isea4r`, `isea9r`, `isea3h`, `isea7h`, `isea7h_z7`
* `ivea4r`, `ivea9r`, `ivea3h`, `ivea7h`, `ivea7h_z7`
* `rtea4r`, `rtea9r`, `rtea3h`, `rtea7h`, `rtea7h_z7`
* `rhealpix` (aperture 9, 50° E)
* `healpix` (aperture 4, Nφ/H = 4, Nθ/K = 3)

### Commands

[**info**](#info) [_zone_]

- Display information about a DGGRS or about a zone of a DGGRS

[**zone**](#zone) <_coord1,coord2_> [_level_]

- Return DGGRS zone at position -- specified in EPSG:4326 (lat,lon)

[**level**](#level) [_level_]

- Display information about a DGGRS refinement level

[**grid**](#grid) [_level_]
- Generate DGGRS grid at specified refinement level (default: 0)

[**geom**](#geom) <_zone_>
- Generate geometry for a particular zone

[**list**](#list) [_level_]
- List DGGRS zones (as JSON string array)

[**rel**](#rel) <_zone 1_> <_zone 2_>
- Display information about the relationships between two zones of a DGGRS

[**sub**](#sub) <_zone_> [_index_]
- List subzones of a DGGRS zone or resolve a sub-zone by index

[**index**](#index) <_parent zone_> <_sub-zone_>
- Display index of sub-zone within parent

**compact** <_JSON input zone file (zone ID strings array)_>
- Compact input zone list

**decompact** <_JSON input zone file (zone ID strings array)_> [_level_]
- Decompact zone list

[**togeo**](#togeo) <_DGGS-(UB)JSON(-FG) input file_>
- Convert DGGS-JSON (DGGS-quantized raster data) or DGGS-JSON-FG (DGGS-quantized vector data) to GeoJSON

### Options

**-o** <_filename_>
- Output to file instead of standard output

**-crs** <_crs_>
- Select an output coordinate reference system, one of:
EPSG:4326, OGC:CRS84, 5x6, ico (icosahedron net), rhp (rHEALPix), hpx (HEALPix)

**-depth** <_relative depth_>
- For sub, specify relative depth
Also to change depth considered for calculating optional [level] from -scale, -mpp and -pixels
default: depth corresponding to ~64K sub-zones (IS/VEA9R: 5, IS/VEA3H: 10, GNOSIS: 8)

**-bbox** <_llLat,llLon,urLat,urLon_>
- Specify extent for which to list zones, generate grid, or reference extent for -pixels
example: -bbox 60,-120,62,-118 -- specified in EPSG:4326 (lat,lon)

**-centroids**
- For sub, list centroids instead of sub-zone identifiers
For togeo, use centroid points for geometry instead of polygons

**-compact**
- For list and grid, return compact list of zones

**-mpp** <_physical meters per sub-zone_>
- Specify physical meters per sub-zone as substitute for optional [level] arguments

**-scale-denom** <_scale denominator_>
- Specify scale-denominator as substitute for optional [level] arguments (based on -depth)

**-pixels** <_with,height_>
- Specify display pixels as a substitute for optional [level] argument (in combination with -bbox)

**-display-res** <_mm-per-pixels_>
- Specify display resolution in millimeters/pixel in combination with -scale and -pixels (default: 0.28)

### Example Usage

#### `info`

##### Information about a particular DGGRS

```
> dgg isea3h info
DGGRS: https://maps.gnosis.earth/ogcapi/dggrs/ISEA3H
Refinement Ratio: 3
Maximum level for 64-bit global identifiers (DGGAL DGGRSZone): 33
Default ~64K sub-zones relative depth: 10
```

##### Information about a particular zone

```
> dgg isea3h info A4-0-A
DGGRS: https://maps.gnosis.earth/ogcapi/dggrs/ISEA3H
Textual Zone ID: A4-0-A
64-bit integer ID: 36028797018963968 (0x80000000000000)

Level 0 zone (5 edges, centroid child)
42505468477007.4 m² (42505468.4770074 km²)
49411 sub-zones at depth 10
WGS84 Centroid (lat, lon): 0, -20.517474730219
WGS84 Extent (lat, lon): { -35.385452137707, -57.8948427221833 }, { 35.385452137707, 11.2 }

No parent

Children (6):
   A4-0-B (centroid)
   A4-0-C
   A4-0-D
   A3-0-C
   A2-0-D
   A2-0-C

Neighbors (5):
   (direction 2): A2-0-A
   (direction 3): A6-0-A
   (direction 0): AA-0-A
   (direction 6): A3-0-A
   (direction 7): A5-0-A

[EPSG:4326] Vertices (5):
   20.9908527620464, 11.2
   -20.9908527620465, 11.2
   -35.385452137707, -33.8
   0, -57.8948427221833
   35.385452137707, -33.8
```

#### `zone`

Identify zone at a particular geodetic position.

```
> dgg isea3h zone 34,-70
DGGRS: https://maps.gnosis.earth/ogcapi/dggrs/ISEA3H
Textual Zone ID: A2-0-A
64-bit integer ID: 18014398509481984 (0x40000000000000)

Level 0 zone (5 edges, centroid child)
42505468477007.4 m² (42505468.4770074 km²)
49411 sub-zones at depth 10
WGS84 Centroid (lat, lon): 31.832357532016, -78.8
WGS84 Extent (lat, lon): { 0, -123.8 }, { 69.1802093248182, -33.8 }

No parent

Children (6):
   A2-0-B (centroid)
   A2-0-C
   A2-0-D
   A1-0-C
   A0-0-D
   A0-0-C

Neighbors (5):
   (direction 2): A0-0-A
   (direction 3): A4-0-A
   (direction 0): AA-0-A
   (direction 6): A1-0-A
   (direction 7): A3-0-A

[EPSG:4326] Vertices (5):
   35.385452137707, -33.8
   0, -57.8948427221833
   0, -99.7051575819393
   35.3854519371908, -123.8
   69.1802093248182, -78.8
```

#### `level`

##### Information about levels of a particular DGGRS

```
> dgg isea3h level
DGGRS: https://maps.gnosis.earth/ogcapi/dggrs/ISEA3H
Assuming sub-zone depth of 10 and display resolution of 0.28 mm/pixel:
Level       Reference Area                             Sub-zones count        Sub-zone area                                                 Scale                   Meters/Sub-zone
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 0: 42505468477007.39843750 m² (42505468.47700740 km²)          49411          860243032.46255684 m² (     8602430324625.56933594 cm²)   1:   104965840      29390.43523832 m (   2939043.52383217 cm)
 1: 15939550678877.77343750 m² (15939550.67887777 km²)          59293          268826854.41582942 m² (     2688268544158.29394531 cm²)   1:    60602124      16968.59485403 m (   1696859.48540341 cm)
 2:  5544191540479.22558594 m² ( 5544191.54047923 km²)          59293           93504992.84028849 m² (      935049928402.88488770 cm²)   1:    34988666       9796.82649363 m (    979682.64936343 cm)
 3:  1875241256338.56152344 m² ( 1875241.25633856 km²)          59293           31626688.75480346 m² (      316266887548.03460693 cm²)   1:    20200718       5656.20112285 m (    565620.11228463 cm)
 4:   628159632665.13391113 m² (  628159.63266513 km²)          59293           10594161.75037751 m² (      105941617503.77513123 cm²)   1:    11662891       3265.60937742 m (    326560.93774175 cm)
 5:   209730929985.23385620 m² (  209730.92998523 km²)          59293            3537195.45283986 m² (       35371954528.39860535 cm²)   1:     6733573       1885.40047940 m (    188540.04793995 cm)
 6:    69948659040.60459900 m² (   69948.65904060 km²)          59293            1179711.92283414 m² (       11797119228.34138870 cm²)   1:     3887630       1088.53647937 m (    108853.64793690 cm)
 7:    23320483802.30837250 m² (   23320.48380231 km²)          59293             393309.22372470 m² (        3933092237.24695539 cm²)   1:     2244524        628.46683036 m (     62846.68303597 cm)
 8:     7773968507.65239239 m² (    7773.96850765 km²)          59293             131111.06720275 m² (        1311110672.02745557 cm²)   1:     1295877        362.84549387 m (     36284.54938723 cm)
 9:     2591375496.48476219 m² (    2591.37549648 km²)          59293              43704.57720953 m² (         437045772.09531683 cm²)   1:      748175        209.48894360 m (     20948.89435974 cm)
10:      863797683.49797928 m² (     863.79768350 km²)          59293              14568.29108829 m² (         145682910.88290006 cm²)   1:      431959        120.94849799 m (     12094.84979852 cm)
11:      287933211.32035321 m² (     287.93321132 km²)          59293               4856.10799454 m² (          48561079.94541568 cm²)   1:      249392         69.82964787 m (      6982.96478712 cm)
12:       95977809.34637524 m² (      95.97780935 km²)          59293               1618.70388320 m² (          16187038.83196587 cm²)   1:      143986         40.31616600 m (      4031.61659961 cm)
13:       31992611.14208768 m² (      31.99261114 km²)          59293                539.56809644 m² (           5395680.96437820 cm²)   1:       83131         23.27654929 m (      2327.65492906 cm)
14:       10664204.60587722 m² (      10.66420461 km²)          59293                179.85604719 m² (           1798560.47187311 cm²)   1:       47995         13.43872200 m (      1343.87219987 cm)
15:        3554734.96771997 m² (       3.55473497 km²)          59293                 59.95201740 m² (            599520.17400367 cm²)   1:       27710          7.75884976 m (       775.88497635 cm)
16:        1184911.66691713 m² (       1.18491167 km²)          59293                 19.98400599 m² (            199840.05985818 cm²)   1:       15998          4.47957400 m (       447.95739996 cm)
17:         394970.55686243 m² (       0.39497056 km²)          59293                  6.66133535 m² (             66613.35349239 cm²)   1:        9237          2.58628325 m (       258.62832545 cm)
18:         131656.85242341 m² (       0.13165685 km²)          59293                  2.22044512 m² (             22204.45118706 cm²)   1:        5333          1.49319133 m (       149.31913332 cm)
19:          43885.61748957 m² (       0.04388562 km²)          59293                  0.74014837 m² (              7401.48373157 cm²)   1:        3079          0.86209442 m (        86.20944182 cm)
20:          14628.53916487 m² (       0.01462854 km²)          59293                  0.24671612 m² (              2467.16124414 cm²)   1:        1778          0.49773044 m (        49.77304444 cm)
21:           4876.17972181 m² (       0.00487618 km²)          59293                  0.08223871 m² (               822.38708141 cm²)   1:        1026          0.28736481 m (        28.73648061 cm)
22:           1625.39324062 m² (       0.00162539 km²)          59293                  0.02741290 m² (               274.12902714 cm²)   1:         593          0.16591015 m (        16.59101481 cm)
23:            541.79774688 m² (       0.00054180 km²)          59293                  0.00913763 m² (                91.37634238 cm²)   1:         342          0.09578827 m (         9.57882687 cm)
24:            180.59924896 m² (       0.00018060 km²)          59293                  0.00304588 m² (                30.45878079 cm²)   1:         129          0.03620456 m (         3.62045625 cm)
25:             60.19974965 m² (       0.00006020 km²)          59293                  0.00101529 m² (                10.15292693 cm²)   1:          95          0.02656689 m (         2.65668857 cm)
26:             20.06658322 m² (       0.00002007 km²)          59293                  0.00033843 m² (                 3.38430898 cm²)   1:          56          0.01574749 m (         1.57474944 cm)
27:              6.68886107 m² (       0.00000669 km²)          59293                  0.00011281 m² (                 1.12810299 cm²)   1:          36          0.01004134 m (         1.00413390 cm)
28:              2.22962036 m² (       0.00000223 km²)          59293                  0.00003760 m² (                 0.37603433 cm²)   1:          21          0.00581872 m (         0.58187229 cm)
29:              0.74320679 m² (       0.00000074 km²)          59293                  0.00001253 m² (                 0.12534478 cm²)   1:          12          0.00348148 m (         0.34814838 cm)
30:              0.24773560 m² (       0.00000025 km²)          59293                  0.00000418 m² (                 0.04178159 cm²)   1:           7          0.00201092 m (         0.20109213 cm)
31:              0.08257853 m² (       0.00000008 km²)          59293                  0.00000139 m² (                 0.01392720 cm²)   1:           4          0.00117525 m (         0.11752498 cm)
32:              0.02752618 m² (       0.00000003 km²)          59293                  0.00000046 m² (                 0.00464240 cm²)   1:           2          0.00067856 m (         0.06785649 cm)
33:              0.00917539 m² (       0.00000001 km²)          59293                  0.00000015 m² (                 0.00154747 cm²)   1:           1          0.00039338 m (         0.03933785 cm)
```

##### Information about a particular DGGRS level
```
>  dgg isea3h level 15
DGGRS: https://maps.gnosis.earth/ogcapi/dggrs/ISEA3H
Refinement Level: 15
Reference area: 3554734.96771997 m² (3.55473496771997 km²)

Assuming sub-zone depth of 10 (59293 sub-zones) and display resolution of 0.28 mm/pixel:
   Sub-zones area: 59.9520174003672 m² (599520.174003672 cm²)
   Cartographic scale: 1:27710
   Physical meters/sub-zone: 7.75884976353492 (775.884976353492 cm/sub-zone)
```

#### `grid`

##### Generate grid geometry for a particular refinement level

Output is [GeoJSON](https://geojson.org/):

```
> dgg isea3h -crs ico grid 3 > isea3h-level3-isea.geojson
```

![image](images/isea3h-grid-level3.png)

```
> dgg isea3h grid 3 > isea3h-level3-crs84.geojson
```

![image](images/isea3h-grid-level3-crs84.png)

##### Generate grid geometry for a given bounding box using compacted zones

```
> dgg isea3h grid 15 -compact -bbox 44,-76,46,-74
```

![image](images/compact-grid.png)


#### `geom`

Generate geometry of a specific zone

```
> dgg isea3h geom A4-0-A
```

```geojson
{
   "type" : "Feature",
   "id" : "A4-0-A",
   "geometry" : {
      "type" : "Polygon",
      "coordinates" : [
         [ [11.2, 20.9908533396875], [11.2, 18.9046368254835], [11.2, 16.817317021754], [11.2, 14.7282441160477], [11.2, 12.6367658994772], [11.2, 10.5422256002322], [11.2, 8.44395966388283], [11.2, 6.3412954618102], [11.2, 4.2335489079295], [11.2, 2.12002196235325], [11.2, -0.00000000000000958], [11.2, -2.12002196235327], [11.2, -4.2335489079295], [11.2, -6.34129546181022], [11.2, -8.44395966388284], [11.2, -10.5422256002322], [11.2, -12.6367658994773], [11.2, -14.7282441160477], [11.2, -16.817317021754], [11.2, -18.9046368254835], [11.2, -20.9908533396875], [9.25904611568614, -22.022704447347], [7.2894978850024, -23.0315860032884], [5.2895073521231, -24.0162595826945], [3.2572732870332, -24.9754140020123], [1.19105174674043, -25.907662551343], [-0.910831437312103, -26.8115406666264], [-3.04996620024865, -27.6855041419538], [-5.22784181139874, -28.5279279934546], [-7.44582852527487, -29.3371060956138], [-9.70515744760715, -30.111251717508], [-11.9990182364648, -30.8460627665615], [-14.3199274459944, -31.5377272377057], [-16.6678118661126, -32.1851262644314], [-19.0423550054196, -32.7871381036537], [-21.4429904142008, -33.3426478478608], [-23.868897601607, -33.8505577351568], [-26.319001132268, -34.3097979200868], [-28.791973441741, -34.7193375329077], [-31.2862418322802, -35.0781958218138], [-33.7999999994894, -35.385453143805], [-35.328584064796, -33.7294909375037], [-36.7997931901407, -32.0544538235723], [-38.2190895198383, -30.3615150627895], [-39.591520816704, -28.651669714028], [-40.9217621171856, -26.9257555850354], [-42.2141557503646, -25.184471421695], [-43.4727493595782, -23.4283926793226], [-44.7013318005733, -21.6579851878463], [-45.9034669523704, -19.8736169902905], [-47.0825255880168, -18.075568603016], [-48.2378134716698, -16.2702095110336], [-49.3687568644497, -14.463940351611], [-50.4786064975358, -12.656986739445], [-51.5704092970534, -10.8495265877445], [-52.647041014988, -9.04169850753405], [-53.7112358369818, -7.23360915100237], [-54.765613515085, -5.42533970970474], [-55.8127045186767, -3.61695174870332], [-56.8549736519885, -1.80849253470827], [-57.894842551487, 0.0000000010850795], [-56.8549736519113, 1.80849253683432], [-55.8127045185966, 3.61695175082982], [-54.7656135150002, 5.425339711832], [-53.7112358368904, 7.2336091531306], [-52.6470410148878, 9.04169850966353], [-51.5704092969423, 10.8495265898755], [-50.4786064974117, 12.6569867415778], [-49.36875686431, 14.4639403537457], [-48.237813471512, 16.2702095131705], [-47.082525588539, 18.0755686040723], [-45.9034669536086, 19.873616990275], [-44.7013318018277, 21.6579851878424], [-43.47274936085, 23.428392679331], [-42.214155751655, 25.1844714217162], [-40.9217621184958, 26.9257555850703], [-39.5915208180354, 28.651669714077], [-38.219089521192, 30.3615150628536], [-36.799793191518, 32.0544538236523], [-35.328584066198, 33.7294909376005], [-33.8000000009355, 35.3854531438384], [-31.2862418337828, 35.0781958220137], [-28.7919734432313, 34.7193375331383], [-26.3190011337452, 34.3097979203474], [-23.86889760307, 33.850557735447], [-21.442990415649, 33.34264784818], [-19.0423550068522, 32.787138104001], [-16.6678118675294, 32.1851262648063], [-14.319927447395, 31.5377272381076], [-11.9990182378492, 30.8460627669896], [-9.70515744897538, 30.1112517179616], [-9.7051574476072, 30.1112517175078], [-7.44582852527492, 29.3371060956137], [-5.2278418113988, 28.5279279934545], [-3.0499662002487, 27.6855041419537], [-0.91083143731212, 26.8115406666263], [1.1910517467404, 25.907662551343], [3.2572732870332, 24.9754140020123], [5.289507352124, 24.0162595826945], [7.28949788500238, 23.0315860032884], [9.259046115687, 22.022704447347], [11.2, 20.9908533396875] ]
      ]
   },
   "properties" : {
     "zoneID" : "A4-0-A"
   }
}
```

```
> dgg -crs ico isea3h geom A4-0-A
```

![image](images/zone-geom.png)

#### `list`

##### List zones of a given refinement level

```
> dgg isea3h list 0
```

```json
[ "A0-0-A", "A1-0-A", "A2-0-A", "A3-0-A", "A4-0-A", "A5-0-A",
"A6-0-A", "A7-0-A", "A8-0-A", "A9-0-A", "AA-0-A", "AB-0-A" ]
```

##### List compacted zones of a given refinement level for a particular bounding box

```
> dgg isea3h list 10 -compact -bbox 44,-76,46,-74
```

```json
[ "E0-1397-A", "F0-AAC7-A", "F0-ABB7-A", "F0-ABB8-A", "F0-ABB9-A", "F0-ABBA-A",
"F0-ABBB-A", "F0-ACA9-A", "F0-ACAA-A", "F0-ACAB-A", "F0-ACAC-A", "F0-ACAD-A",
"F0-ACAE-A", "F0-AD9D-A", "F0-AD9E-A", "F0-ADA1-A", "F0-ADA2-A", "F0-AE91-A",
"F0-AE95-A", "F0-AF84-A", "F0-AF85-A", "F0-AF88-A", "F0-AF89-A", "F0-B078-A",
"F0-B079-A", "F0-B07A-A", "F0-B07B-A", "F0-B07C-A", "F0-B16B-A", "F0-B16C-A",
"F0-B16D-A", "F0-B16E-A", "F0-B16F-A", "F0-B170-A", "F0-B25F-A", "F0-B260-A",
"F0-B261-A", "F0-B262-A", "F0-B263-A", "F0-B352-A", "F0-B353-A", "F0-B354-A",
"F0-B355-A", "F0-B356-A", "F0-B357-A", "F0-B446-A", "F0-B447-A", "F0-B448-A" ]
```

#### `rel`

Show relationships between two zones

```
> dgg isea3h rel A4-0-A D4-20-D
DGGRS: https://maps.gnosis.earth/ogcapi/dggrs/ISEA3H
Relationships between zones A4-0-A (A) and D4-20-D (B):

Zone A is coarser than zone B by 7 refinement levels
The area of zone A is greater than the area of zone B (area of B is 0.054869684499314 % of zone A)
Zone A is NOT an immediate child of zone B
Zone A is NOT an immediate parent of zone B
Zone A is NOT a descendant of zone B
Zone A is an ancestor of zone B
Zone A is NOT a sub-zone of zone B
Zone A has B as a sub-zone (at depth 7, index 1034)
These zones are NOT neighbors
These zones are NOT siblings
Zone A is NOT contained in zone B
Zone A contains zone B
Zone A and B overlap
```

#### `sub`

##### Query sub-zones of parent zone at a particular relative depth

```
> dgg isea3h sub A4-0-A -depth 3
```

```json
[ "B2-7-B", "B2-4-D", "B2-4-C", "B2-5-B", "B2-7-D", "B2-7-C", "B2-8-B",
"B2-5-D", "B2-5-C", "B3-1-C", "B3-2-B", "B2-8-D", "B2-8-C", "B4-1-B",
"B4-1-C", "B3-5-B", "B3-2-D", "B3-2-C", "B4-0-B", "B4-0-C", "B4-1-D",
"B4-5-B", "B3-5-C", "B4-3-B", "B4-0-D", "B4-4-B", "B4-4-C", "B4-3-D",
"B4-3-C", "B4-4-D", "B4-7-B" ]
```

##### Identify sub-zone of parent zone at a particular relative depth and index

```
> dgg isea3h sub A4-0-A 8 -depth 3
```

```json
"B2-5-C"
```

#### `index`

##### Query index of sub-zone

```
> dgg isea3h index A4-0-A B2-5-C
DGGRS: https://maps.gnosis.earth/ogcapi/dggrs/ISEA3H
B2-5-C is at index 8 of A4-0-A at depth 3
```

```
> dgg isea3h index A4-0-A B6-5-C
DGGRS: https://maps.gnosis.earth/ogcapi/dggrs/ISEA3H
sub-zone B6-5-C not found within parent A4-0-A
```

#### `togeo`

Converts [DGGS-JSON](http://dggs-json.org) (and eventually [DGGS-JSON-FG](https://docs.ogc.org/is/21-038r1/21-038r1.html#rc_data-dggs-jsonfg) and [UBJSON](https://ubjson.org/) variants) to GeoJSON
to facilitate interoperability with traditional GIS software / software not aware of the DGGRS.

https://maps.gnosis.earth/ogcapi/collections/sentinel2-l2a/dggs/ISEA3H/zones/G7-67252-B/data.json?zone-depth=8&datetime=2022-10-28&properties=B08

```
> dgg isea3h togeo -crs ico G7-67252-B-B08.json
```

![image](images/B08.png)

_B08 (near-infrared) band retrieved as DGGS-JSON data from [Copernicus/ESA sentinel-2](https://sentinel.esa.int/web/sentinel/missions/sentinel-2) converted to GeoJSON and visualized in QGIS_



================================================
FILE: BUILDING.md
================================================
# Instructions for building DGGAL

See also [this script](fetchAndBuild.sh) (running all of these commands), fetching and building everything, and [this batch file](fetchAndBuild.bat) (for the equivalent on Windows).

## Pre-requisites

- ensure git is installed (for fetching the source code)
- ensure zlib is installed, including the "dev" package with header files
- ensure GCC or Clang is installed with working C support
- ensure GNU Make is installed

## Optional build dependenices

- (if wanting to build and use the C++ bindings)         ensure GCC or Clang C++ support is installed
- (if wanting to build Python bindings)                  ensure Python is installed with cffi (pip3 install cffi)
- (if wanting to build Rust bindings)                    ensure the Rust compiler (rustc) is installed and working
- (if wanting to build smaller compressed executables)   ensure UPX is installed

## Fetching and building

```
mkdir dgbuild
cd dgbuild
git clone -b main --single-branch https://github.com/ecere/eC.git
git clone -b main --single-branch https://github.com/ecere/dggal.git
cd eC
make
cd ../dggal/
make
```

## Running the DGG tool

```
export LD_LIBRARY_PATH=$(pwd)/../eC/obj/linux/lib/:$(pwd)/obj/release.linux
obj/release.linux/dgg ISEA3H info A4-0-A
obj/static.linux/dgg ISEA3H info A4-0-A
```

## C bindings

```
cd ../eC/bindings/c
make
cd ../../../dggal/bindings/c
make
cd ../../bindings_examples/c
make
obj/release.linux/info ISEA3H A4-0-A
make -f Makefile.static
obj/static.linux/info ISEA3H A4-0-A
cd ../..
```

## C++ bindings (after building the C bindings)

```
cd ../eC/bindings/cpp
make
cd ../../../dggal/bindings/cpp
make
cd ../../bindings_examples/cpp
make
obj/release.linux/info ISEA3H A4-0-A
make -f Makefile.static
obj/static.linux/info ISEA3H A4-0-A
cd ../..
```

## Rust bindings (after building the C bindings)

```
cd ../eC/bindings/rust
make
cd ../../../dggal/bindings/rust
make
cd ../../bindings_examples/rust
make
obj/linux/info ISEA3H A4-0-A
cd ../..
```

## Python bindings (after building the C bindings)

```
cd ../eC/bindings/py
python3 build_ecrt.py
cd ../../../dggal/bindings/py
python3 build_dggal.py
export PYTHONPATH=$(pwd)
cd ../../bindings_examples/py/
python3 info.py
cd ../..
```



================================================
FILE: CONTRIBUTORS
================================================
The Discrete Global Grid Abstraction Library was developed and is being maintained by Jérôme Jacovella-St-Louis at Ecere Corporation.

Significant progress was achieved as part of a number of initiatives including:

- the Open Geospatial Consortium (OGC) Federated Marine Spatial Data Infrastructure - Phase 3 (FMSDI-3) pilot project ( https://docs.ogc.org/per/23-010.html ),
- the Ecere GeoConnections 2020-2021 project entitled "Flexible real-time data processing and visualization workflows emerging from OGC API modules" ("Modular OGC API Workflows" a.k.a "MOAW"), and
- the Ecere GeoConnections 2025-2027 project entitled "Advancing and Implementing OGC Standards for GeoDataCubes, DGGSs, Data Stores for Digital Twins and Cartographic Symbology").

Special thanks to Perry Peterson, Matthew Purss, Robert Gibb, Idan Shatz, Marta Padilla Ruiz, Brenton R S Recht, Kevin Sahr,
Alexander Kmoch, Luís Moreira de Sousa, Daniel Strebe, Diederik van Leeuwen, Charles Karney and Felix Palmer for several insights making DGGAL possible.

Many thanks to early adopters for reporting bugs, in particular Samantha Lavander, Taras Zakharko, Erin Li, Johann Sorel, Wai Tik Chan and Francis Charette-Migneault.

Thanks to Johann Sorel for the Java bindings ( https://github.com/jsorel/dggal-java ).

Thanks to Jeremy Costello and Réjean Loyer (Ecere) for help with the WebAssembly build and JavaScript bindings.

Acknowledgements

Financial support provided by GeoConnections, a national collaborative initiative led by Natural Resources Canada.
GeoConnections supports the modernization of the Canadian Geospatial Data Infrastructure (CGDI).
The CGDI is the collection of geospatial data, standards, policies, applications, and governance that facilitate its access, use, integration, and preservation.

Soutien financier fourni par GéoConnexions, une initiative de collaboration nationale dirigée par Ressources naturelles Canada.
GéoConnexions appuie la modernisation de l'Infrastructure canadienne de données géospatiales (ICDG).
L'ICDG est l'ensemble de données géospatiales, de normes, de politiques, d'applications et de la gouvernance qui en facilitent l'accès, l'utilisation, l'intégration et la préservation.



================================================
FILE: dgg.ec
================================================
public import IMPORT_STATIC "ecrt"
import IMPORT_STATIC "dggal"

import "info"
import "zone"
import "grid"
import "geom"
import "level"
import "list"
import "rel"
import "sub"
import "index"
import "compact"
import "decompact"
import "togeo"

static void showSyntax()
{
   PrintLn(
     $"DGGAL, the Discrete Global Grid Abstraction Library\n"
      "Copyright (c) 2014-2025 Ecere Corporation\n"
      "Syntax:\n"
      "   dgg <dggrs> <command> [options] <arguments>\n"
      "\n"
      "Supported DGGRSs:\n"
      "   GNOSIS (Global Grid), ISEA(4R/9R/3H/7H/7H_Z7), IVEA(4R/9R/3H/7H/7H_Z7), RTEA(9R/4R/3H/7H/7H_Z7), rHEALPix (A9 50° E), HEALPix (A4 H=4, K=3)\n"
      "\n"
      "Commands:\n"
      "   info       [zone]\n"
      "      Display information about a DGGRS or about a zone of a DGGRS\n"
      "   zone       <coord1,coord2> [level]\n"
      "      Return DGGRS zone at position -- specified in EPSG:4236 (lat,lon)\n"
      "   level      [level]\n"
      "      Display information about a DGGRS refinement level\n"
      "   grid       [level]\n"
      "      Generate DGGRS grid at specified refinement level (default: 0)\n"
      "   geom       <zone>\n"
      "      Generate geometry for a particular zone\n"
      "   list       [level]\n"
      "      List DGGRS zones (as JSON string array)\n"
      "   rel        <zone 1> <zone 2>\n"
      "      Display information about the relationships between two zones of a DGGRS\n"
      "   sub        <zone> [index]\n"
      "      List subzones of a DGGRS zone or resolve a sub-zone by index\n"
      "   index      <parent zone> <sub-zone>\n"
      "      Display index of sub-zone within parent\n"
      "   compact    <JSON input zone file (zone ID strings array)> \n"
      "      Compact input zone list\n"
      "   decompact  <JSON input zone file (zone ID strings array)> [level]\n"
      "      Decompact zone list\n"
      "   togeo      <DGGS-(UB)JSON(-FG) input file>\n"
      "      Convert DGGS-JSON (DGGS-quantized raster data) or DGGS-JSON-FG (DGGS-quantized vector data) to GeoJSON\n"
      "\n"
      "Options:\n"
      "   -o <filename>\n"
      "     Output to file instead of standard output\n"
      "   -crs <crs>\n"
      "     Select an output coordinate reference system, one of:\n"
      "        EPSG:4326, OGC:CRS84, 5x6, ico (icosahedron net), rhp (rHEALPix), hpx (HEALPix)\n"
      "   -depth <relative depth>\n"
      "      For sub, specify relative depth\n"
      "      Also to change depth considered for calculating optional [level] from -scale, -mpp and -pixels\n"
      "        default: depth corresponding to ~64K sub-zones (IS/VEA9R: 5, IS/VEA3H: 10, GNOSIS: 8, rHEALPix: 5)\n"
      "   -bbox <llLat,llLon,urLat,urLon>\n"
      "      Specify extent for which to list zones, generate grid, or reference extent for -pixels\n"
      "      example: -bbox 60,-120,62,-118 -- specified in EPSG:4326 (lat,lon)\n"
      "   -centroids\n"
      "      For sub, list centroids instead of sub-zone identifiers\n"
      "      For togeo, use centroid points for geometry instead of polygons\n"
      "   -compact\n"
      "      For list and grid, return compact list of zones\n"
      "   -mpp <physical meters per sub-zone>\n"
      "      Specify physical meters per sub-zone as substitute for optional [level] arguments\n"
      "   -scale-denom <scale denominator>\n"
      "      Specify scale-denominator as substitute for optional [level] arguments (based on -depth)\n"
      "   -pixels <with,height>\n"
      "      Specify display pixels as a substitute for optional [level] argument (in combination with -bbox)\n"
      "   -display-res <mm-per-pixels>\n"
      "      Specify display resolution in millimeters/pixel in combination with -scale and -pixels (default: 0.28)\n"
      );
}

enum DGGALCommand
{
   info = 1, zone, grid, geom, level, list, rel, sub, index, compact, decompact, togeo
};

class DGGAL : Application
{
   void Main()
   {
      DGGALCommand command = 0;
      Map<String, const String> options = null;
      int a;
      const String currentOption = null;
      bool syntaxError = false;
      int cmdArg = 0;
      subclass(DGGRS) dggrsClass = null;
      // Command arguments
      int gLevel = -1;
      int64 subIndex = -1;
      const String zone1ID = null, zone2ID = null, input = null, coordinates = null;

           if(!strcmpi(argv[0], "i3h") || !strcmpi(argv[0], "isea3h")) dggrsClass = class(ISEA3H), cmdArg = 1;
      else if(!strcmpi(argv[0], "i9r") || !strcmpi(argv[0], "isea9r")) dggrsClass = class(ISEA9R), cmdArg = 1;
      else if(!strcmpi(argv[0], "i7h") || !strcmpi(argv[0], "isea7h")) dggrsClass = class(ISEA7H), cmdArg = 1;
      else if(!strcmpi(argv[0], "iz7") || !strcmpi(argv[0], "isea7h_z7")) dggrsClass = class(ISEA7H_Z7), cmdArg = 1;
      else if(!strcmpi(argv[0], "i4r") || !strcmpi(argv[0], "isea4r")) dggrsClass = class(ISEA4R), cmdArg = 1;

      else if(!strcmpi(argv[0], "r3h") || !strcmpi(argv[0], "rtea3h")) dggrsClass = class(RTEA3H), cmdArg = 1;
      else if(!strcmpi(argv[0], "r9r") || !strcmpi(argv[0], "rtea9r")) dggrsClass = class(RTEA9R), cmdArg = 1;
      else if(!strcmpi(argv[0], "r7h") || !strcmpi(argv[0], "rtea7h")) dggrsClass = class(RTEA7H), cmdArg = 1;
      else if(!strcmpi(argv[0], "rz7") || !strcmpi(argv[0], "rtea7h_z7")) dggrsClass = class(RTEA7H_Z7), cmdArg = 1;
      else if(!strcmpi(argv[0], "r4r") || !strcmpi(argv[0], "rtea4r")) dggrsClass = class(RTEA4R), cmdArg = 1;

      else if(!strcmpi(argv[0], "v3h") || !strcmpi(argv[0], "ivea3h")) dggrsClass = class(IVEA3H), cmdArg = 1;
      else if(!strcmpi(argv[0], "v9r") || !strcmpi(argv[0], "ivea9r")) dggrsClass = class(IVEA9R), cmdArg = 1;
      else if(!strcmpi(argv[0], "v7h") || !strcmpi(argv[0], "ivea7h")) dggrsClass = class(IVEA7H), cmdArg = 1;
      else if(!strcmpi(argv[0], "vz7") || !strcmpi(argv[0], "ivea7h_z7")) dggrsClass = class(IVEA7H_Z7), cmdArg = 1;
      else if(!strcmpi(argv[0], "v4r") || !strcmpi(argv[0], "ivea4r")) dggrsClass = class(IVEA4R), cmdArg = 1;

      else if(!strcmpi(argv[0], "g3h") || !strcmpi(argv[0], "gpp3h"))  dggrsClass = class(GPP3H), cmdArg = 1;
      else if(!strcmpi(argv[0], "b3h") || !strcmpi(argv[0], "bcta3h")) dggrsClass = class(BCTA3H), cmdArg = 1;

      else if(!strcmpi(argv[0], "ggg") || !strcmpi(argv[0], "gnosis")) dggrsClass = class(GNOSISGlobalGrid), cmdArg = 1;

      else if(!strcmpi(argv[0], "rhp") || !strcmpi(argv[0], "rHEALPix")) dggrsClass = class(rHEALPix), cmdArg = 1;
      else if(!strcmpi(argv[0], "hpx") || !strcmpi(argv[0], "HEALPix")) dggrsClass = class(HEALPix), cmdArg = 1;

      for(a = 1; !syntaxError && a < argc; a++)
      {
         const char * arg = argv[a];
         if(arg[0] == '-' && !strchr(arg, ',')) // Avoid confusion with negative coordinates
         {
            if(!options) options = {};
            currentOption = arg + 1;

            // Boolean options
            if(!strcmpi(currentOption, "centroids") ||
               !strcmpi(currentOption, "compact"))
               options[currentOption] = "true", currentOption = null;
         }
         else if(currentOption)
         {
            options[currentOption] = arg;
            currentOption = null;
         }
         else
         {
            switch(cmdArg)
            {
               case 0:
                  // DGGRS
                  if(!strncasecmp(arg, "GNOSIS", 6)) dggrsClass = class(GNOSISGlobalGrid);

                  else if(!strcmpi(arg, "ISEA3H"))   dggrsClass = class(ISEA3H);
                  else if(!strcmpi(arg, "ISEA9R"))   dggrsClass = class(ISEA9R);
                  else if(!strcmpi(arg, "ISEA7H"))   dggrsClass = class(ISEA7H);
                  else if(!strcmpi(arg, "ISEA7H_Z7"))   dggrsClass = class(ISEA7H_Z7);
                  else if(!strcmpi(arg, "ISEA4R"))   dggrsClass = class(ISEA4R);

                  else if(!strcmpi(arg, "IVEA3H"))   dggrsClass = class(IVEA3H);
                  else if(!strcmpi(arg, "IVEA9R"))   dggrsClass = class(IVEA9R);
                  else if(!strcmpi(arg, "IVEA7H"))   dggrsClass = class(IVEA7H);
                  else if(!strcmpi(arg, "IVEA7H_Z7"))   dggrsClass = class(IVEA7H_Z7);
                  else if(!strcmpi(arg, "IVEA4R"))   dggrsClass = class(IVEA4R);

                  else if(!strcmpi(arg, "RTEA3H"))   dggrsClass = class(RTEA3H);
                  else if(!strcmpi(arg, "RTEA9R"))   dggrsClass = class(RTEA9R);
                  else if(!strcmpi(arg, "RTEA7H"))   dggrsClass = class(RTEA7H);
                  else if(!strcmpi(arg, "RTEA7H_Z7"))   dggrsClass = class(RTEA7H_Z7);
                  else if(!strcmpi(arg, "RTEA4R"))   dggrsClass = class(RTEA4R);

                  else if(!strcmpi(arg, "rHEALPix")) dggrsClass = class(rHEALPix);
                  else if(!strcmpi(arg, "HEALPix"))  dggrsClass = class(HEALPix);

                  else if(!strcmpi(arg, "GPP3H"))    dggrsClass = class(GPP3H);
                  else if(!strcmpi(arg, "BCTA3H"))   dggrsClass = class(BCTA3H);

                  else if(!strcmpi(arg, "togeo"))
                     command = togeo;
                  else
                     syntaxError = true;
                  break;
               case 1:
                  if(command == togeo)
                     input = arg;
                  else
                     // Command
                     syntaxError = !command.OnGetDataFromString(arg);
                  break;
               case 2:
                  // First command argument
                  switch(command)
                  {
                     case grid: case level: case list:
                        if(!gLevel.OnGetDataFromString(arg))
                           syntaxError = true;
                        break;
                     case zone:
                        coordinates = arg;
                        break;
                     case info: case geom: case rel: case sub: case index:
                        zone1ID = arg;
                        break;
                     case togeo: case compact: case decompact:
                        input = arg;
                        break;
                     default: syntaxError = true; break;
                  }
                  break;
               case 3:
                  // Second command argument
                  switch(command)
                  {
                     case rel: case index:
                        zone2ID = arg;
                        break;
                     case sub:
                        if(!subIndex.OnGetDataFromString(arg))
                           syntaxError = true;
                        break;
                     case decompact: case zone:
                        if(!gLevel.OnGetDataFromString(arg))
                           syntaxError = true;
                        break;
                     default: syntaxError = true; break;
                  }
                  break;
               default: syntaxError = true; break;
            }
            cmdArg++;
         }
      }
      if((!dggrsClass && command != togeo) || !command) syntaxError = true;

      if(syntaxError)
      {
         showSyntax();
         exitCode = 1;
      }
      else
      {
         DGGRSZone zone1 = nullZone, zone2 = nullZone;
         DGGRS dggrs = eInstance_New(dggrsClass);
         bool jsonOutput = (command == grid || command == geom || command == compact || command == decompact ||
            command == togeo || command == list || command == sub);

         if(!jsonOutput)
            PrintLn($"DGGRS: https://maps.gnosis.earth/ogcapi/dggrs/", dggrs._class.name);

         if(zone1ID)
         {
            zone1 = dggrs.getZoneFromTextID(zone1ID);
            if(zone1 == nullZone)
            {
               PrintLn($"Invalid ", ((Class)dggrsClass).name, $" zone identifier: ", zone1ID);
               exitCode = 1;
            }
         }
         if(zone2ID)
         {
            zone2 = dggrs.getZoneFromTextID(zone2ID);
            if(zone2 == nullZone)
            {
               PrintLn($"Invalid ", ((Class)dggrsClass).name, $" zone identifier: ", zone2ID);
               exitCode = 1;
            }
         }

         if(gLevel != -1)
         {
            int maxZoneLevel = dggrs.getMaxDGGRSZoneLevel();
            int maxLevel = maxZoneLevel + dggrs.get64KDepth() * 2;
            if(gLevel < 0 || gLevel > maxLevel)
            {
               PrintLn($"Invalid refinement level ", gLevel, $" (max zone level: ", maxZoneLevel, $", max zone + depth: ", maxLevel, ")");
               exitCode = 1;
            }
         }

         if(!exitCode)
            switch(command)
            {
               case info: exitCode = displayInfo(dggrs, zone1, options); break;
               case zone: exitCode = queryZone(dggrs, coordinates, gLevel, options); break;
               case level: exitCode = levelInfo(dggrs, gLevel, options, false); break;
               case rel: exitCode = relationInfo(dggrs, zone1, zone2, options); break;
               case index: exitCode = subZoneIndex(dggrs, zone1, zone2, options); break;

               case grid: exitCode = generateGrid(dggrs, gLevel, options); break;
               case geom: exitCode = generateGeometry(dggrs, zone1, options); break;
               case list: exitCode = listZones(dggrs, gLevel, options); break;
               case sub: exitCode = subZones(dggrs, zone1, subIndex, options); break;
               case compact: exitCode = compactZones(dggrs, input, options); break;
               case decompact: exitCode = decompactZones(dggrs, input, options); break;
               case togeo: exitCode = convertToGeoJSON(input, options); break;
            }
         delete dggrs;
      }
      delete options;
   }
}



================================================
FILE: dgg.epj
================================================
{
   "Version" : 0.2,
   "ModuleName" : "dgg",
   "Options" : {
      "Warnings" : "All",
      "TargetType" : "Executable",
      "TargetFileName" : "dgg",
      "Libraries" : [
         "ecrt"
      ],
      "Console" : true
   },
   "Configurations" : [
      {
         "Name" : "Debug",
         "Options" : {
            "Debug" : true,
            "Optimization" : "None",
            "PreprocessorDefinitions" : [
               "_DEBUG",
               "IMPORT_STATIC=\"\""
            ],
            "FastMath" : false
         }
      },
      {
         "Name" : "Release",
         "Options" : {
            "Debug" : false,
            "Optimization" : "Speed",
            "PreprocessorDefinitions" : [
               "IMPORT_STATIC=\"\""
            ],
            "FastMath" : true
         }
      },
      {
         "Name" : "Static",
         "Options" : {
            "Optimization" : "Speed",
            "PreprocessorDefinitions" : [
               "IMPORT_STATIC=static"
            ],
            "Libraries" : [
               "dggalStatic",
               "ecrtStatic"
            ],
            "LibraryDirs" : [
               "obj/static.$(PLATFORM)$(COMPILER_SUFFIX)"
            ],
            "Compress" : true,
            "FastMath" : true
         },
         "Platforms" : [
            {
               "Name" : "linux",
               "Options" : {
                  "Libraries" : [
                     "m",
                     "z",
                     "dl",
                     "pthread"
                  ]
               }
            },
            {
               "Name" : "win32",
               "Options" : {
                  "Libraries" : [
                     "kernel32",
                     "gdi32",
                     "user32",
                     "winmm",
                     "mpr",
                     "imm32",
                     "z"
                  ]
               }
            }
         ]
      }
   ],
   "Files" : [
      {
         "Folder" : "commands",
         "Files" : [
            "info.ec",
            "grid.ec",
            "geom.ec",
            "level.ec",
            "list.ec",
            "rel.ec",
            "sub.ec",
            "index.ec",
            "compact.ec",
            "decompact.ec",
            "togeo.ec",
            "zone.ec"
         ]
      },
      "dgg.ec"
   ],
   "ResourcesPath" : "",
   "Resources" : [

   ]
}



================================================
FILE: dggal.epj
================================================
{
   "Version" : 0.2,
   "ModuleName" : "dggal",
   "Options" : {
      "Warnings" : "All",
      "TargetType" : "SharedLibrary",
      "TargetFileName" : "dggal",
      "Libraries" : [
         "ecrt"
      ]
   },
   "Platforms" : [
      {
         "Name" : "linux",
         "Options" : {
            "Libraries" : [
               "m"
            ]
         }
      }
   ],
   "Configurations" : [
      {
         "Name" : "Debug",
         "Options" : {
            "Debug" : true,
            "Optimization" : "None",
            "PreprocessorDefinitions" : [
               "_DEBUG",
               "IMPORT_STATIC=\"\""
            ],
            "FastMath" : false
         }
      },
      {
         "Name" : "Release",
         "Options" : {
            "Optimization" : "Speed",
            "PreprocessorDefinitions" : [
               "IMPORT_STATIC=\"\""
            ],
            "FastMath" : true
         }
      },
      {
         "Name" : "Static",
         "Options" : {
            "Optimization" : "Speed",
            "PreprocessorDefinitions" : [
               "IMPORT_STATIC=static",
               "EC_STATIC"
            ],
            "TargetType" : "StaticLibrary",
            "TargetFileName" : "dggalStatic",
            "Libraries" : [

            ],
            "FastMath" : true
         }
      }
   ],
   "Files" : [
      {
         "Folder" : "src",
         "Files" : [
            {
               "Folder" : "dggrs",
               "Files" : [
                  "I3HSubZones.ec",
                  "RI3H.ec",
                  "RI9R.ec",
                  "GNOSISGlobalGrid.ec",
                  "ISEA9R.ec",
                  "ISEA3H.ec",
                  "GPP3H.ec",
                  "IVEA3H.ec",
                  "IVEA9R.ec",
                  "BCTA3H.ec",
                  "RTEA3H.ec",
                  "RTEA9R.ec",
                  "rHEALPixGrid.ec",
                  "RI7H.ec",
                  "IVEA7H.ec",
                  "ISEA7H.ec",
                  "HEALPixGrid.ec",
                  "RTEA7H.ec",
                  "RI4R.ec",
                  "IVEA4R.ec",
                  "ISEA4R.ec",
                  "RTEA4R.ec",
                  "RI7H_Z7.ec",
                  "ISEA7H_Z7.ec",
                  "IVEA7H_Z7.ec",
                  "RTEA7H_Z7.ec"
               ]
            },
            {
               "Folder" : "projections",
               "Files" : [
                  "ri5x6.ec",
                  "authalic.ec",
                  "barycentric5x6.ec",
                  "icoVertexGreatCircle.ec",
                  "rHEALPix.ec"
               ]
            },
            {
               "Folder" : "dggsJSON",
               "Files" : [
                  "dggsJSON.ec",
                  "$(EC_SDK_SRC)/extras/JSONSchema.ec"
               ]
            },
            {
               "Folder" : "ecere3D",
               "Files" : [
                  "Plane.ec",
                  "Vector3D.ec",
                  "Quaternion.ec"
               ],
               "Configurations" : [
                  {
                     "Name" : "Static",
                     "Options" : {
                        "ExcludeFromBuild" : false
                     }
                  }
               ]
            },
            "GeoExtent.ec",
            "dggrs.ec"
         ]
      }
   ],
   "ResourcesPath" : "",
   "Resources" : [

   ]
}



================================================
FILE: fetchAndBuild.bat
================================================
@echo off
echo This script attempts to fetch and build DGGAL, DGG and its bindings and examples for C, C++, Python and Rust.
echo Please make sure you have git installed to fetch the source code from the eC and DGGAL repositories.
echo Please make sure you have GCC (MinGW-w64) or Clang, and GNU Make (mingw32-make) installed.
echo Please make sure you have zlib (header files and library) installed.
echo Please make sure you have GCC or Clang C++ support installed for C++.
echo Please make sure you have the Rust compiler (rustc) edition 2021+ installed for Rust.
echo Please make sure you have cffi installed for Python (python -m pip install cffi).
echo:
echo Building in 'dgbuild' directory...

mkdir dgbuild
cd dgbuild

echo Fetching eC core development environment...
git clone -b main --single-branch https://github.com/ecere/eC.git

echo Fetching DGGAL...
git clone -b main --single-branch https://github.com/ecere/dggal.git

echo Building eC development environment...
cd eC
mingw32-make -j4

echo Building DGGAL...
cd ..\dggal\
mingw32-make -j4

echo:
echo **************************************
echo ************ DGGAL for eC ************
echo **************************************
echo Execution test for DGG tool:
SET PATH=%PATH%;%cd%\..\eC\obj\win32\bin;%cd%\obj\release.win32;%cd%\obj\win32\bin
obj\release.win32\dgg ISEA3H info A4-0-A
echo Execution test for (static) DGG tool:
obj\static.win32\dgg ISEA3H info A4-0-A

echo:
echo **************************************
echo ************ DGGAL for C *************
echo **************************************
echo Building DGGAL for C...
cd ..\eC\bindings\c
mingw32-make
cd ..\..\..\dggal\bindings\c
mingw32-make
echo Building DGGAL sample C application...
cd ..\..\bindings_examples\c
mingw32-make
echo Execution test for DGGAL sample C application:
obj\release.win32\info ISEA3H A4-0-A
echo Building DGGAL (static) sample C application...
mingw32-make -f Makefile.static
echo Execution test for DGGAL (static) sample C application:
obj\static.win32\info ISEA3H A4-0-A
cd ..\..

echo:
echo **************************************
echo *** DGGAL for C (function wrappers) **
echo **************************************
echo Building DGGAL for C (function wrappers)...
cd bindings\c_fn
mingw32-make
echo Building DGGAL sample C (function wrappers) application...
cd ..\..\bindings_examples\c_fn
mingw32-make
echo Execution test for DGGAL sample C (function wrappers) application:
obj\release.win32\info ISEA3H A4-0-A
cd ..\..

echo:
echo **************************************
echo ************ DGGAL for C++ ***********
echo **************************************
echo Building DGGAL for C++...
cd ..\eC\bindings\cpp
mingw32-make
cd ..\..\..\dggal\bindings\cpp
mingw32-make
echo Building DGGAL sample C++ application...
cd ..\..\bindings_examples\cpp
mingw32-make
echo Execution test for DGGAL sample C++ application:
obj\release.win32\info ISEA3H A4-0-A
echo Building DGGAL (static) sample C++ application...
mingw32-make -f Makefile.static
echo Execution test for DGGAL (static) sample C++ application:
obj\static.win32\info ISEA3H A4-0-A
cd ..\..

echo:
echo **************************************
echo *********** DGGAL for Rust ***********
echo **************************************
echo Building DGGAL for Rust...
cd ..\eC\bindings\rust
mingw32-make
cd ..\..\..\dggal\bindings\rust
mingw32-make
echo Building DGGAL sample Rust application...
cd ..\..\bindings_examples\rust
mingw32-make
echo Execution test for DGGAL sample Rust application:
obj\win32\info ISEA3H A4-0-A
cd ..\..

echo:
echo **************************************
echo ********** DGGAL for Python **********
echo **************************************
echo Building DGGAL for Python...
cd ..\eC\bindings\py
python build_ecrt.py
cd ..\..\..\dggal\bindings\py
python build_dggal.py
echo Execution test for DGGAL sample Python application:
SET PYTHONPATH=%cd%:%cd%\..\..\..\eC\bindings\py
cd ..\..\bindings_examples\py\
python info.py
cd ..\..

echo:
echo All done! Thank you for trying out and using DGGAL.



================================================
FILE: fetchAndBuild.sh
================================================
#!/bin/sh

echo "This script attempts to fetch and build DGGAL, DGG and its bindings and examples for C, C++, Python and Rust."
echo "Please make sure you have git installed to fetch the source code from the eC and DGGAL repositories."
echo "Please make sure you have zlib (dev package) installed, as well as GCC or Clang, and GNU Make."
echo "Please make sure you have GCC or Clang C++ support installed."
echo "Please make sure you have the Rust compiler (rustc) edition 2021+ installed."
echo "Please make sure you have cffi installed for Python (pip3 install cffi)."
echo ""
echo "Building in 'dgbuild' directory..."

mkdir dgbuild
cd dgbuild

echo "Fetching eC core development environment..."
git clone -b main --single-branch https://github.com/ecere/eC.git

echo "Fetching DGGAL..."
git clone -b main --single-branch https://github.com/ecere/dggal.git

echo "Building eC development environment..."
cd eC
make -j4

echo "Building DGGAL..."
cd ../dggal/
make -j4

echo ""
echo "**************************************"
echo "************ DGGAL for eC ************"
echo "**************************************"
echo "Execution test for DGG tool:"
export LD_LIBRARY_PATH=$(pwd)/../eC/obj/linux/lib/:$(pwd)/obj/release.linux:$(pwd)/obj/linux/lib
obj/release.linux/dgg ISEA3H info A4-0-A
echo "Execution test for (static) DGG tool:"
obj/static.linux/dgg ISEA3H info A4-0-A

echo ""
echo "**************************************"
echo "************ DGGAL for C *************"
echo "**************************************"
echo "Building DGGAL for C..."
cd ../eC/bindings/c
make
cd ../../../dggal/bindings/c
make
echo "Building DGGAL sample C application..."
cd ../../bindings_examples/c
make
echo "Execution test for DGGAL sample C application:"
obj/release.linux/info ISEA3H A4-0-A
echo "Building DGGAL (static) sample C application..."
make -f Makefile.static
echo "Execution test for DGGAL (static) sample C application:"
obj/static.linux/info ISEA3H A4-0-A
cd ../..

echo ""
echo "**************************************"
echo "*** DGGAL for C (function wrappers) **"
echo "**************************************"
echo "Building DGGAL for C (function wrappers)..."
cd bindings/c_fn
make
echo "Building DGGAL sample C (function wrappers) application..."
cd ../../bindings_examples/c_fn
make
echo "Execution test for DGGAL sample C (function wrappers) application:"
obj/release.linux/info ISEA3H A4-0-A
cd ../..

echo ""
echo "**************************************"
echo "************ DGGAL for C++ ***********"
echo "**************************************"
echo "Building DGGAL for C++..."
cd ../eC/bindings/cpp
make
cd ../../../dggal/bindings/cpp
make
echo "Building DGGAL sample C++ application..."
cd ../../bindings_examples/cpp
make
echo "Execution test for DGGAL sample C++ application:"
obj/release.linux/info ISEA3H A4-0-A
echo "Building DGGAL (static) sample C++ application..."
make -f Makefile.static
echo "Execution test for DGGAL (static) sample C++ application:"
obj/static.linux/info ISEA3H A4-0-A
cd ../..

echo ""
echo "**************************************"
echo "*********** DGGAL for Rust ***********"
echo "**************************************"
echo "Building DGGAL for Rust..."
cd ../eC/bindings/rust
make
cd ../../../dggal/bindings/rust
make
echo "Building DGGAL sample Rust application..."
cd ../../bindings_examples/rust
make
echo "Execution test for DGGAL sample Rust application:"
obj/linux/info ISEA3H A4-0-A
cd ../..

echo ""
echo "**************************************"
echo "********** DGGAL for Python **********"
echo "**************************************"
echo "Building DGGAL for Python..."
cd ../eC/bindings/py
python3 build_ecrt.py
cd ../../../dggal/bindings/py
python3 build_dggal.py
echo "Execution test for DGGAL sample Python application:"
export PYTHONPATH=$(pwd):$(pwd)/../../../eC/bindings/py
cd ../../bindings_examples/py/
python3 info.py
cd ../..

echo ""
echo "All done! Thank you for trying out and using DGGAL."



================================================
FILE: fetchAndBuildWASM.sh
================================================
#!/bin/sh

echo "This script attempts to fetch and build the DGGAL WebAssembly module and its bindings for JavaScript ."
echo "Please make sure you have git installed to fetch the source code from the eC, zlib and DGGAL repositories."
echo "Please make sure you have GCC or Clang installed for your host platform, with 32-bit architecture support."
echo "Please make sure you have the Emscripten SDK installed (confirmed to work with 2.0.34)."
echo "  (git clone https://github.com/emscripten-core/emsdk.git ; cd emsdk ; ./emsdk install 2.0.34 ; ./emsdk activate 2.0.34; source ./emsdk_env.sh)"
echo ""
echo "Building in 'dgbuild' directory..."

mkdir dgbuild
cd dgbuild

echo "Fetching eC core development environment..."
git clone -b main --single-branch https://github.com/ecere/eC.git
cd eC
git submodule update --init --recursive
cd ..

echo "Fetching DGGAL..."
git clone -b main --single-branch https://github.com/ecere/dggal.git

echo "Building eC SDK for WASM..."
cd eC
make -f Makefile.wasm -j4

echo "Building DGGAL for WASM..."
cd ../dggal/
make -f Makefile.wasm -j4

echo ""
echo "All done!"

echo ""
echo "You can find examples of using DGGAL in JavaScript in bindings_examples/js/."
echo "You will need to serve the example files on a Web server together with the following files:"
echo "   dgbuild/dggal/bindings/js/dggal.js"
echo "   dgbuild/dggal/bindings/c_fn/obj/dggal.allinone.linux.wasm/libdggal_c_fn.js.0.0.wasm"
echo "   dgbuild/dggal/bindings/c_fn/obj/dggal.allinone.linux.wasm/libdggal_c_fn.js.0.0.6 (symlinked or renamed as libdggal.js)"

echo "Thank you for trying out and using DGGAL."



================================================
FILE: LICENSE
================================================
BSD 3-Clause License

Copyright (c) 2014-2025, Ecere Corporation

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its
   contributors may be used to endorse or promote products derived from
   this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.



================================================
FILE: Makefile
================================================
.PHONY: all clean realclean distclean test dggal dgg bindings c_bindings cpp_bindings py_bindings rust_bindings clean_python

DGGAL_ABSPATH := $(dir $(realpath $(firstword $(MAKEFILE_LIST))))

ifndef EC_SDK_SRC
EC_SDK_SRC := $(DGGAL_ABSPATH)../eC
endif

export _CF_DIR = $(EC_SDK_SRC)/
include $(_CF_DIR)crossplatform.mk

ifdef WINDOWS_HOST
PYTHON := python
else
PYTHON := python3
endif

# TARGETS

all: dgg

dggal:
	+$(_MAKE) -f Makefile.dggal
# NOTE: Still building the library itself which will not need the .a libraries
#ifndef DISABLED_STATIC_BUILDS
	+$(_MAKE) -f Makefile.dggal.static
#endif

dgg: dggal
	+$(_MAKE) -f Makefile.dgg
ifndef DISABLED_STATIC_BUILDS
	+$(_MAKE) -f Makefile.dgg.static
endif

c_bindings:
	+cd bindings/c && $(_MAKE)
	+cd bindings/c_fn && $(_MAKE)
	+cd bindings/c_fn && $(_MAKE) -f Makefile.allinone

cpp_bindings: c_bindings
	+cd bindings/cpp && $(_MAKE)

py_bindings: c_bindings
	+cd bindings/py && $(PYTHON) build_dggal.py

rust_bindings: c_bindings
	+cd bindings/rust && $(_MAKE)

bindings: c_bindings cpp_bindings py_bindings rust_bindings

test: all
	+cd tests && $(_MAKE) test

clean_python:
	+cd bindings/py
	+$(call rm,*.c)
	+$(call rm,*.o)
	+$(call rm,*.so)
	+$(call rm,*.dyld)
	+$(call rm,*.dll)
	+$(call rm,__pycache__)
	+$(call rm,projects)

clean: clean_python
	+$(_MAKE) -f Makefile.dgg clean
	+$(_MAKE) -f Makefile.dgg.static clean
	+$(_MAKE) -f Makefile.dggal clean
	+$(_MAKE) -f Makefile.dggal.static clean
	+cd bindings/c && $(_MAKE) clean
	+cd bindings/c_fn && $(_MAKE) clean
	+cd bindings/c_fn && $(_MAKE) -f Makefile.allinone clean
	+cd bindings/cpp && $(_MAKE) clean
	+cd bindings/rust && $(_MAKE) clean
	+cd tests && $(_MAKE) clean
	
realclean: clean_python
	+$(_MAKE) -f Makefile.dgg realclean
	+$(_MAKE) -f Makefile.dgg.static realclean
	+$(_MAKE) -f Makefile.dggal realclean
	+$(_MAKE) -f Makefile.dggal.static realclean
	+cd bindings/c && $(_MAKE) realclean
	+cd bindings/c_fn && $(_MAKE) realclean
	+cd bindings/c_fn && $(_MAKE) -f Makefile.allinone realclean
	+cd bindings/cpp && $(_MAKE) realclean
	+cd bindings/rust && $(_MAKE) realclean
	+cd tests && $(_MAKE) realclean
	
distclean: clean_python
	+$(_MAKE) -f Makefile.dgg distclean
	+$(_MAKE) -f Makefile.dgg.static distclean
	+$(_MAKE) -f Makefile.dggal distclean
	+$(_MAKE) -f Makefile.dggal.static distclean
	+cd bindings/c && $(_MAKE) distclean
	+cd bindings/c_fn && $(_MAKE) distclean
	+cd bindings/c_fn && $(_MAKE) -f Makefile.allinone distclean
	+cd bindings/cpp && $(_MAKE) distclean
	+cd bindings/rust && $(_MAKE) distclean
	+cd tests && $(_MAKE) distclean



================================================
FILE: Makefile.dgg
================================================
.PHONY: all objdir cleantarget clean realclean distclean

# CORE VARIABLES

MODULE := dgg
VERSION :=
CONFIG := release
ifndef COMPILER
COMPILER := default
endif

TARGET_TYPE = executable

# FLAGS

ECFLAGS =
ifndef DEBIAN_PACKAGE
CFLAGS =
LDFLAGS =
endif
PRJ_CFLAGS =
CECFLAGS =
OFLAGS =
LIBS =

ifdef DEBUG
NOSTRIP := y
endif

CONSOLE = -mconsole

# INCLUDES

DGGAL_ABSPATH := $(dir $(realpath $(firstword $(MAKEFILE_LIST))))

ifndef EC_SDK_SRC
EC_SDK_SRC := $(DGGAL_ABSPATH)../eC
endif

export _CF_DIR = $(EC_SDK_SRC)/
include $(_CF_DIR)crossplatform.mk

ifndef WINDOWS_HOST
ifdef OSX_HOST
export DYLD_LIBRARY_PATH := $(DYLD_LIBRARY_PATH):$(DGGAL_ABSPATH)obj/$(CONFIG).$(HOST_PLATFORM)$(COMPILER_SUFFIX)$(DEBUG_SUFFIX)/
else
export LD_LIBRARY_PATH := $(LD_LIBRARY_PATH):$(DGGAL_ABSPATH)obj/$(CONFIG).$(HOST_PLATFORM)$(COMPILER_SUFFIX)$(DEBUG_SUFFIX)/
endif
else
export PATH := $(PATH);$(DGGAL_ABSPATH)obj/$(CONFIG).$(HOST_PLATFORM)$(COMPILER_SUFFIX)$(DEBUG_SUFFIX)/
endif

include $(_CF_DIR)default.cf

# POST-INCLUDES VARIABLES

OBJ = obj/$(CONFIG).$(PLATFORM)$(COMPILER_SUFFIX)$(DEBUG_SUFFIX)/

RES =

TARGET_NAME := dgg

TARGET = obj/$(CONFIG).$(PLATFORM)$(COMPILER_SUFFIX)$(DEBUG_SUFFIX)/$(TARGET_NAME)$(OUT)

_ECSOURCES = \
	commands/info.ec \
	commands/grid.ec \
	commands/geom.ec \
	commands/level.ec \
	commands/list.ec \
	commands/rel.ec \
	commands/sub.ec \
	commands/index.ec \
	commands/compact.ec \
	commands/decompact.ec \
	commands/togeo.ec \
	commands/zone.ec \
	dgg.ec

ECSOURCES = $(call shwspace,$(_ECSOURCES))

_COBJECTS = $(addprefix $(OBJ),$(patsubst %.ec,%$(C),$(notdir $(_ECSOURCES))))

_SYMBOLS = $(addprefix $(OBJ),$(patsubst %.ec,%$(S),$(notdir $(_ECSOURCES))))

_IMPORTS = $(addprefix $(OBJ),$(patsubst %.ec,%$(I),$(notdir $(_ECSOURCES))))

_ECOBJECTS = $(addprefix $(OBJ),$(patsubst %.ec,%$(O),$(notdir $(_ECSOURCES))))

_BOWLS = $(addprefix $(OBJ),$(patsubst %.ec,%$(B),$(notdir $(_ECSOURCES))))

COBJECTS = $(call shwspace,$(_COBJECTS))

SYMBOLS = $(call shwspace,$(_SYMBOLS))

IMPORTS = $(call shwspace,$(_IMPORTS))

ECOBJECTS = $(call shwspace,$(_ECOBJECTS))

BOWLS = $(call shwspace,$(_BOWLS))

OBJECTS = $(ECOBJECTS) $(OBJ)$(MODULE).main$(O)

SOURCES = $(ECSOURCES)

RESOURCES =

ifdef USE_RESOURCES_EAR
RESOURCES_EAR =
else
RESOURCES_EAR = $(RESOURCES)
endif

LIBS += $(SHAREDLIB) $(EXECUTABLE) $(LINKOPT)

ifndef STATIC_LIBRARY_TARGET
LIBS += \
	$(call _L,ecrt) $(call _L,dggal)

OFLAGS += -L$(DGGAL_ABSPATH)obj/$(CONFIG).$(PLATFORM)$(COMPILER_SUFFIX)$(DEBUG_SUFFIX)/
ifdef OSX_TARGET
OFLAGS += $(if $(ENABLE_PYTHON_RPATHS),-Wl$(comma)-rpath$(comma)'@executable_path/../lib' -Wl$(comma)-rpath$(comma)'@executable_path/../../ecrt/lib',)
else
OFLAGS += $(if $(ENABLE_PYTHON_RPATHS),-Wl$(comma)-rpath='$$ORIGIN/../lib:$$ORIGIN/../../ecrt/lib',)
endif
OFLAGS += $(RPATHS_FOR_PORTABLE_BINARIES)
endif

PRJ_CFLAGS += \
	 $(if $(DEBUG), -g, -O2 -ffast-math) $(FPIC) -Wall -DREPOSITORY_VERSION="\"$(REPOSITORY_VER)\"" \
			 -DIMPORT_STATIC=\"\"

ECFLAGS += -module $(MODULE)
# PLATFORM-SPECIFIC OPTIONS

ifdef WINDOWS_TARGET
OFLAGS += \
	$(if $(EC_SDK_SRC)/deps/zlib-1.2.8/obj/release.$(PLATFORM)$(COMPILER_SUFFIX),-L$(call quote_path,$(EC_SDK_SRC)/deps/zlib-1.2.8/obj/release.$(PLATFORM)$(COMPILER_SUFFIX)),) \
	$(if $(EC_SDK_SRC)/obj/$(PLATFORM)$(COMPILER_SUFFIX)/bin,-L$(call quote_path,$(EC_SDK_SRC)/obj/$(PLATFORM)$(COMPILER_SUFFIX)/bin),) \
	-static-libgcc
else
OFLAGS += $(if $(EC_SDK_SRC)/obj/$(PLATFORM)$(COMPILER_SUFFIX)/lib,-L$(call quote_path,$(EC_SDK_SRC)/obj/$(PLATFORM)$(COMPILER_SUFFIX)/lib),)
endif

CECFLAGS += -cpp $(_CPP)

# TARGETS

all: objdir $(TARGET)

objdir:
	$(if $(wildcard $(OBJ)),,$(call mkdir,$(OBJ)))
	$(if $(EC_SDK_SRC),$(if $(wildcard $(call escspace,$(EC_SDK_SRC)/crossplatform.mk)),,@$(call echo,Ecere SDK Source Warning: The value of EC_SDK_SRC is pointing to an incorrect ($(EC_SDK_SRC)) location.)),)
	$(if $(EC_SDK_SRC),,$(if $(ECP_DEBUG)$(ECC_DEBUG)$(ECS_DEBUG),@$(call echo,ECC Debug Warning: Please define EC_SDK_SRC before using ECP_DEBUG, ECC_DEBUG or ECS_DEBUG),))

$(OBJ)$(MODULE).main.ec: $(SYMBOLS) $(COBJECTS)
	@$(call rm,$(OBJ)symbols.lst)
	@$(call touch,$(OBJ)symbols.lst)
	$(call addtolistfile,$(SYMBOLS),$(OBJ)symbols.lst)
	$(call addtolistfile,$(IMPORTS),$(OBJ)symbols.lst)
	$(ECS) -console $(ARCH_FLAGS) $(ECSLIBOPT) @$(OBJ)symbols.lst -symbols obj/$(CONFIG).$(PLATFORM)$(COMPILER_SUFFIX)$(DEBUG_SUFFIX) -o $(call quote_path,$@)

$(OBJ)$(MODULE).main.c: $(OBJ)$(MODULE).main.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(OBJ)$(MODULE).main.ec -o $(OBJ)$(MODULE).main.sym -symbols $(OBJ)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(OBJ)$(MODULE).main.ec -o $(call quote_path,$@) -symbols $(OBJ)

$(SYMBOLS): | objdir
$(OBJECTS): | objdir
$(TARGET): $(SOURCES) $(RESOURCES_EAR) $(SYMBOLS) $(OBJECTS) | objdir
	@$(call rm,$(OBJ)objects.lst)
	@$(call touch,$(OBJ)objects.lst)
	$(call addtolistfile,$(OBJ)$(MODULE).main$(O),$(OBJ)objects.lst)
	$(call addtolistfile,$(ECOBJECTS),$(OBJ)objects.lst)
	$(LD) $(OFLAGS) @$(OBJ)objects.lst $(LIBS) -o $(TARGET) $(INSTALLNAME) $(SONAME)
ifndef NOSTRIP
	$(STRIP) $(STRIPOPT) $(TARGET)
endif

# SYMBOL RULES

$(OBJ)info.sym: commands/info.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,commands/info.ec) -o $(call quote_path,$@)

$(OBJ)grid.sym: commands/grid.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,commands/grid.ec) -o $(call quote_path,$@)

$(OBJ)geom.sym: commands/geom.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,commands/geom.ec) -o $(call quote_path,$@)

$(OBJ)level.sym: commands/level.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,commands/level.ec) -o $(call quote_path,$@)

$(OBJ)list.sym: commands/list.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,commands/list.ec) -o $(call quote_path,$@)

$(OBJ)rel.sym: commands/rel.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,commands/rel.ec) -o $(call quote_path,$@)

$(OBJ)sub.sym: commands/sub.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,commands/sub.ec) -o $(call quote_path,$@)

$(OBJ)index.sym: commands/index.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,commands/index.ec) -o $(call quote_path,$@)

$(OBJ)compact.sym: commands/compact.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,commands/compact.ec) -o $(call quote_path,$@)

$(OBJ)decompact.sym: commands/decompact.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,commands/decompact.ec) -o $(call quote_path,$@)

$(OBJ)togeo.sym: commands/togeo.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,commands/togeo.ec) -o $(call quote_path,$@)

$(OBJ)zone.sym: commands/zone.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,commands/zone.ec) -o $(call quote_path,$@)

$(OBJ)dgg.sym: dgg.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,dgg.ec) -o $(call quote_path,$@)

# C OBJECT RULES

$(OBJ)info.c: commands/info.ec $(OBJ)info.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,commands/info.ec) -o $(call quote_path,$@) -symbols $(OBJ)

$(OBJ)grid.c: commands/grid.ec $(OBJ)grid.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,commands/grid.ec) -o $(call quote_path,$@) -symbols $(OBJ)

$(OBJ)geom.c: commands/geom.ec $(OBJ)geom.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,commands/geom.ec) -o $(call quote_path,$@) -symbols $(OBJ)

$(OBJ)level.c: commands/level.ec $(OBJ)level.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,commands/level.ec) -o $(call quote_path,$@) -symbols $(OBJ)

$(OBJ)list.c: commands/list.ec $(OBJ)list.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,commands/list.ec) -o $(call quote_path,$@) -symbols $(OBJ)

$(OBJ)rel.c: commands/rel.ec $(OBJ)rel.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,commands/rel.ec) -o $(call quote_path,$@) -symbols $(OBJ)

$(OBJ)sub.c: commands/sub.ec $(OBJ)sub.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,commands/sub.ec) -o $(call quote_path,$@) -symbols $(OBJ)

$(OBJ)index.c: commands/index.ec $(OBJ)index.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,commands/index.ec) -o $(call quote_path,$@) -symbols $(OBJ)

$(OBJ)compact.c: commands/compact.ec $(OBJ)compact.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,commands/compact.ec) -o $(call quote_path,$@) -symbols $(OBJ)

$(OBJ)decompact.c: commands/decompact.ec $(OBJ)decompact.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,commands/decompact.ec) -o $(call quote_path,$@) -symbols $(OBJ)

$(OBJ)togeo.c: commands/togeo.ec $(OBJ)togeo.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,commands/togeo.ec) -o $(call quote_path,$@) -symbols $(OBJ)

$(OBJ)zone.c: commands/zone.ec $(OBJ)zone.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,commands/zone.ec) -o $(call quote_path,$@) -symbols $(OBJ)

$(OBJ)dgg.c: dgg.ec $(OBJ)dgg.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,dgg.ec) -o $(call quote_path,$@) -symbols $(OBJ)

# OBJECT RULES

$(OBJ)info$(O): $(OBJ)info.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)info.c) -o $(call quote_path,$@)

$(OBJ)grid$(O): $(OBJ)grid.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)grid.c) -o $(call quote_path,$@)

$(OBJ)geom$(O): $(OBJ)geom.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)geom.c) -o $(call quote_path,$@)

$(OBJ)level$(O): $(OBJ)level.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)level.c) -o $(call quote_path,$@)

$(OBJ)list$(O): $(OBJ)list.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)list.c) -o $(call quote_path,$@)

$(OBJ)rel$(O): $(OBJ)rel.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)rel.c) -o $(call quote_path,$@)

$(OBJ)sub$(O): $(OBJ)sub.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)sub.c) -o $(call quote_path,$@)

$(OBJ)index$(O): $(OBJ)index.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)index.c) -o $(call quote_path,$@)

$(OBJ)compact$(O): $(OBJ)compact.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)compact.c) -o $(call quote_path,$@)

$(OBJ)decompact$(O): $(OBJ)decompact.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)decompact.c) -o $(call quote_path,$@)

$(OBJ)togeo$(O): $(OBJ)togeo.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)togeo.c) -o $(call quote_path,$@)

$(OBJ)zone$(O): $(OBJ)zone.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)zone.c) -o $(call quote_path,$@)

$(OBJ)dgg$(O): $(OBJ)dgg.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)dgg.c) -o $(call quote_path,$@)

$(OBJ)$(MODULE).main$(O): $(OBJ)$(MODULE).main.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(OBJ)$(MODULE).main.c -o $(call quote_path,$@)

cleantarget:
	$(call rm,$(OBJ)$(MODULE).main$(O) $(OBJ)$(MODULE).main.c $(OBJ)$(MODULE).main.ec $(OBJ)$(MODULE).main$(I) $(OBJ)$(MODULE).main$(S))
	$(call rm,$(OBJ)symbols.lst)
	$(call rm,$(OBJ)objects.lst)
	$(call rm,$(TARGET))

clean: cleantarget
	$(call rm,$(_OBJECTS))
	$(call rm,$(_ECOBJECTS))
	$(call rm,$(_COBJECTS))
	$(call rm,$(_BOWLS))
	$(call rm,$(_IMPORTS))
	$(call rm,$(_SYMBOLS))

realclean: cleantarget
	$(call rmr,$(OBJ))

distclean: cleantarget
	$(call rmr,obj/)
	$(call rmr,.configs/)
	$(call rm,*.ews)
	$(call rm,*.Makefile)



================================================
FILE: Makefile.dgg.static
================================================
.PHONY: all objdir cleantarget clean realclean distclean

# CORE VARIABLES

MODULE := dgg
VERSION :=
CONFIG := static
ifndef COMPILER
COMPILER := default
endif

TARGET_TYPE = executable

# FLAGS

ECFLAGS =
ifndef DEBIAN_PACKAGE
CFLAGS =
LDFLAGS =
endif
PRJ_CFLAGS =
CECFLAGS =
OFLAGS =
LIBS =

ifdef DEBUG
NOSTRIP := y
endif

CONSOLE = -mconsole

# INCLUDES

DGGAL_ABSPATH := $(dir $(realpath $(firstword $(MAKEFILE_LIST))))

ifndef EC_SDK_SRC
EC_SDK_SRC := $(DGGAL_ABSPATH)../eC
endif

_CF_DIR = $(EC_SDK_SRC)/
include $(_CF_DIR)crossplatform.mk

ifndef WINDOWS_HOST
ifdef OSX_HOST
export DYLD_LIBRARY_PATH := $(DYLD_LIBRARY_PATH):$(DGGAL_ABSPATH)obj/release.$(HOST_PLATFORM)$(COMPILER_SUFFIX)$(DEBUG_SUFFIX)/
else
export LD_LIBRARY_PATH := $(LD_LIBRARY_PATH):$(DGGAL_ABSPATH)obj/release.$(HOST_PLATFORM)$(COMPILER_SUFFIX)$(DEBUG_SUFFIX)/
endif
else
export PATH := $(PATH);$(GNOSIS3_ABSPATH)obj/release.$(HOST_PLATFORM)$(COMPILER_SUFFIX)$(DEBUG_SUFFIX)/
endif

include $(_CF_DIR)default.cf

# POST-INCLUDES VARIABLES

OBJ = obj/$(CONFIG).$(PLATFORM)$(COMPILER_SUFFIX)$(DEBUG_SUFFIX)/

RES =

TARGET_NAME := dgg

TARGET = obj/$(CONFIG).$(PLATFORM)$(COMPILER_SUFFIX)$(DEBUG_SUFFIX)/$(TARGET_NAME)$(OUT)

_ECSOURCES = \
	commands/info.ec \
	commands/grid.ec \
	commands/geom.ec \
	commands/level.ec \
	commands/list.ec \
	commands/rel.ec \
	commands/sub.ec \
	commands/index.ec \
	commands/compact.ec \
	commands/decompact.ec \
	commands/togeo.ec \
	commands/zone.ec \
	dgg.ec

ECSOURCES = $(call shwspace,$(_ECSOURCES))

_COBJECTS = $(addprefix $(OBJ),$(patsubst %.ec,%$(C),$(notdir $(_ECSOURCES))))

_SYMBOLS = $(addprefix $(OBJ),$(patsubst %.ec,%$(S),$(notdir $(_ECSOURCES))))

_IMPORTS = $(addprefix $(OBJ),$(patsubst %.ec,%$(I),$(notdir $(_ECSOURCES))))

_ECOBJECTS = $(addprefix $(OBJ),$(patsubst %.ec,%$(O),$(notdir $(_ECSOURCES))))

_BOWLS = $(addprefix $(OBJ),$(patsubst %.ec,%$(B),$(notdir $(_ECSOURCES))))

COBJECTS = $(call shwspace,$(_COBJECTS))

SYMBOLS = $(call shwspace,$(_SYMBOLS))

IMPORTS = $(call shwspace,$(_IMPORTS))

ECOBJECTS = $(call shwspace,$(_ECOBJECTS))

BOWLS = $(call shwspace,$(_BOWLS))

OBJECTS = $(ECOBJECTS) $(OBJ)$(MODULE).main$(O)

SOURCES = $(ECSOURCES)

RESOURCES =

ifdef USE_RESOURCES_EAR
RESOURCES_EAR =
else
RESOURCES_EAR = $(RESOURCES)
endif

LIBS += $(SHAREDLIB) $(EXECUTABLE) $(LINKOPT)

ifndef STATIC_LIBRARY_TARGET

ifdef OSX_TARGET
LIBS += \
	$(call _L,dggalStatic) \
	$(call _L,ecrtStatic)
else
LIBS += \
	-Wl,-Bstatic \
	$(call _L,dggalStatic) \
	$(call _L,ecrtStatic)
endif
endif

PRJ_CFLAGS += \
	 $(if $(DEBUG), -g, -O2 -ffast-math) $(FPIC) -Wall -DREPOSITORY_VERSION="\"$(REPOSITORY_VER)\"" \
			 -DIMPORT_STATIC=static

ECFLAGS += -module $(MODULE)
# PLATFORM-SPECIFIC OPTIONS

OFLAGS += \
	$(if $(EC_SDK_SRC)/obj/$(PLATFORM)$(COMPILER_SUFFIX)/lib,-L$(call quote_path,$(EC_SDK_SRC)/obj/$(PLATFORM)$(COMPILER_SUFFIX)/lib),)

ifdef WINDOWS_TARGET
OFLAGS += \
	$(if $(EC_SDK_SRC)/deps/zlib-1.2.8/obj/release.$(PLATFORM)$(COMPILER_SUFFIX),-L$(call quote_path,$(EC_SDK_SRC)/deps/zlib-1.2.8/obj/release.$(PLATFORM)$(COMPILER_SUFFIX)),) \
	-static-libgcc
LIBS += \
	-Wl,-Bdynamic \
	$(call _L,winmm) \
	$(call _L,mpr) \
	-Wl,-Bstatic \
	$(call _L,z)
endif

ifdef LINUX_TARGET

LIBS += -Wl,-Bstatic \
	$(call _L,z) \

LIBS += -Wl,-Bdynamic \
	$(call _L,m) \
	$(call _L,dl) \
	$(call _L,pthread)

endif

ifdef OSX_TARGET
LIBS += $(call _L,z)
endif

CECFLAGS += -cpp $(_CPP)

ifndef STATIC_LIBRARY_TARGET
OFLAGS += \
	 -L$(call quote_path,obj/static.$(PLATFORM)$(COMPILER_SUFFIX))
endif

# TARGETS

all: objdir $(TARGET)

objdir:
	$(if $(wildcard $(OBJ)),,$(call mkdir,$(OBJ)))
	$(if $(EC_SDK_SRC),$(if $(wildcard $(call escspace,$(EC_SDK_SRC)/crossplatform.mk)),,@$(call echo,Ecere SDK Source Warning: The value of EC_SDK_SRC is pointing to an incorrect ($(EC_SDK_SRC)) location.)),)
	$(if $(EC_SDK_SRC),,$(if $(ECP_DEBUG)$(ECC_DEBUG)$(ECS_DEBUG),@$(call echo,ECC Debug Warning: Please define EC_SDK_SRC before using ECP_DEBUG, ECC_DEBUG or ECS_DEBUG),))

$(OBJ)$(MODULE).main.ec: $(SYMBOLS) $(COBJECTS)
	@$(call rm,$(OBJ)symbols.lst)
	@$(call touch,$(OBJ)symbols.lst)
	$(call addtolistfile,$(SYMBOLS),$(OBJ)symbols.lst)
	$(call addtolistfile,$(IMPORTS),$(OBJ)symbols.lst)
	$(ECS) -console $(ARCH_FLAGS) $(ECSLIBOPT) @$(OBJ)symbols.lst -symbols obj/$(CONFIG).$(PLATFORM)$(COMPILER_SUFFIX)$(DEBUG_SUFFIX) -o $(call quote_path,$@)

$(OBJ)$(MODULE).main.c: $(OBJ)$(MODULE).main.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(OBJ)$(MODULE).main.ec -o $(OBJ)$(MODULE).main.sym -symbols $(OBJ)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(OBJ)$(MODULE).main.ec -o $(call quote_path,$@) -symbols $(OBJ)

$(SYMBOLS): | objdir
$(OBJECTS): | objdir
$(TARGET): $(SOURCES) $(RESOURCES_EAR) $(SYMBOLS) $(OBJECTS) | objdir
	@$(call rm,$(OBJ)objects.lst)
	@$(call touch,$(OBJ)objects.lst)
	$(call addtolistfile,$(OBJ)$(MODULE).main$(O),$(OBJ)objects.lst)
	$(call addtolistfile,$(ECOBJECTS),$(OBJ)objects.lst)
	$(LD) $(OFLAGS) @$(OBJ)objects.lst $(LIBS) -o $(TARGET) $(INSTALLNAME) $(SONAME)
ifndef NOSTRIP
	$(STRIP) $(STRIPOPT) $(TARGET)
endif
	-$(UPX) $(UPXFLAGS) $(TARGET)

# SYMBOL RULES

$(OBJ)info.sym: commands/info.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,commands/info.ec) -o $(call quote_path,$@)

$(OBJ)grid.sym: commands/grid.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,commands/grid.ec) -o $(call quote_path,$@)

$(OBJ)geom.sym: commands/geom.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,commands/geom.ec) -o $(call quote_path,$@)

$(OBJ)level.sym: commands/level.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,commands/level.ec) -o $(call quote_path,$@)

$(OBJ)list.sym: commands/list.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,commands/list.ec) -o $(call quote_path,$@)

$(OBJ)rel.sym: commands/rel.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,commands/rel.ec) -o $(call quote_path,$@)

$(OBJ)sub.sym: commands/sub.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,commands/sub.ec) -o $(call quote_path,$@)

$(OBJ)index.sym: commands/index.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,commands/index.ec) -o $(call quote_path,$@)

$(OBJ)compact.sym: commands/compact.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,commands/compact.ec) -o $(call quote_path,$@)

$(OBJ)decompact.sym: commands/decompact.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,commands/decompact.ec) -o $(call quote_path,$@)

$(OBJ)togeo.sym: commands/togeo.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,commands/togeo.ec) -o $(call quote_path,$@)

$(OBJ)zone.sym: commands/zone.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,commands/zone.ec) -o $(call quote_path,$@)

$(OBJ)dgg.sym: dgg.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,dgg.ec) -o $(call quote_path,$@)

# C OBJECT RULES

$(OBJ)info.c: commands/info.ec $(OBJ)info.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,commands/info.ec) -o $(call quote_path,$@) -symbols $(OBJ)

$(OBJ)grid.c: commands/grid.ec $(OBJ)grid.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,commands/grid.ec) -o $(call quote_path,$@) -symbols $(OBJ)

$(OBJ)geom.c: commands/geom.ec $(OBJ)geom.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,commands/geom.ec) -o $(call quote_path,$@) -symbols $(OBJ)

$(OBJ)level.c: commands/level.ec $(OBJ)level.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,commands/level.ec) -o $(call quote_path,$@) -symbols $(OBJ)

$(OBJ)list.c: commands/list.ec $(OBJ)list.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,commands/list.ec) -o $(call quote_path,$@) -symbols $(OBJ)

$(OBJ)rel.c: commands/rel.ec $(OBJ)rel.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,commands/rel.ec) -o $(call quote_path,$@) -symbols $(OBJ)

$(OBJ)sub.c: commands/sub.ec $(OBJ)sub.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,commands/sub.ec) -o $(call quote_path,$@) -symbols $(OBJ)

$(OBJ)index.c: commands/index.ec $(OBJ)index.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,commands/index.ec) -o $(call quote_path,$@) -symbols $(OBJ)

$(OBJ)compact.c: commands/compact.ec $(OBJ)compact.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,commands/compact.ec) -o $(call quote_path,$@) -symbols $(OBJ)

$(OBJ)decompact.c: commands/decompact.ec $(OBJ)decompact.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,commands/decompact.ec) -o $(call quote_path,$@) -symbols $(OBJ)

$(OBJ)togeo.c: commands/togeo.ec $(OBJ)togeo.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,commands/togeo.ec) -o $(call quote_path,$@) -symbols $(OBJ)

$(OBJ)zone.c: commands/zone.ec $(OBJ)zone.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,commands/zone.ec) -o $(call quote_path,$@) -symbols $(OBJ)

$(OBJ)dgg.c: dgg.ec $(OBJ)dgg.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,dgg.ec) -o $(call quote_path,$@) -symbols $(OBJ)

# OBJECT RULES

$(OBJ)info$(O): $(OBJ)info.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)info.c) -o $(call quote_path,$@)

$(OBJ)grid$(O): $(OBJ)grid.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)grid.c) -o $(call quote_path,$@)

$(OBJ)geom$(O): $(OBJ)geom.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)geom.c) -o $(call quote_path,$@)

$(OBJ)level$(O): $(OBJ)level.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)level.c) -o $(call quote_path,$@)

$(OBJ)list$(O): $(OBJ)list.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)list.c) -o $(call quote_path,$@)

$(OBJ)rel$(O): $(OBJ)rel.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)rel.c) -o $(call quote_path,$@)

$(OBJ)sub$(O): $(OBJ)sub.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)sub.c) -o $(call quote_path,$@)

$(OBJ)index$(O): $(OBJ)index.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)index.c) -o $(call quote_path,$@)

$(OBJ)compact$(O): $(OBJ)compact.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)compact.c) -o $(call quote_path,$@)

$(OBJ)decompact$(O): $(OBJ)decompact.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)decompact.c) -o $(call quote_path,$@)

$(OBJ)togeo$(O): $(OBJ)togeo.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)togeo.c) -o $(call quote_path,$@)

$(OBJ)zone$(O): $(OBJ)zone.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)zone.c) -o $(call quote_path,$@)

$(OBJ)dgg$(O): $(OBJ)dgg.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)dgg.c) -o $(call quote_path,$@)

$(OBJ)$(MODULE).main$(O): $(OBJ)$(MODULE).main.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(OBJ)$(MODULE).main.c -o $(call quote_path,$@)

cleantarget:
	$(call rm,$(OBJ)$(MODULE).main$(O) $(OBJ)$(MODULE).main.c $(OBJ)$(MODULE).main.ec $(OBJ)$(MODULE).main$(I) $(OBJ)$(MODULE).main$(S))
	$(call rm,$(OBJ)symbols.lst)
	$(call rm,$(OBJ)objects.lst)
	$(call rm,$(TARGET))

clean: cleantarget
	$(call rm,$(_OBJECTS))
	$(call rm,$(_ECOBJECTS))
	$(call rm,$(_COBJECTS))
	$(call rm,$(_BOWLS))
	$(call rm,$(_IMPORTS))
	$(call rm,$(_SYMBOLS))

realclean: cleantarget
	$(call rmr,$(OBJ))

distclean: cleantarget
	$(call rmr,obj/)
	$(call rmr,.configs/)
	$(call rm,*.ews)
	$(call rm,*.Makefile)



================================================
FILE: Makefile.dggal
================================================
.PHONY: all objdir cleantarget clean realclean distclean

# CORE VARIABLES

MODULE := dggal
VERSION :=
CONFIG := release
ifndef COMPILER
COMPILER := default
endif

TARGET_TYPE = sharedlib

# FLAGS

ECFLAGS =
ifndef DEBIAN_PACKAGE
CFLAGS =
LDFLAGS =
endif
PRJ_CFLAGS =
CECFLAGS =
OFLAGS =
LIBS =

ifdef DEBUG
NOSTRIP := y
endif

CONSOLE = -mwindows

# INCLUDES

DGGAL_ABSPATH := $(dir $(realpath $(firstword $(MAKEFILE_LIST))))

ifndef EC_SDK_SRC
EC_SDK_SRC := $(DGGAL_ABSPATH)../eC
endif

_CF_DIR = $(EC_SDK_SRC)/
include $(_CF_DIR)crossplatform.mk
include $(_CF_DIR)$(COMPILER).cf

# POST-INCLUDES VARIABLES

OBJ = obj/$(CONFIG).$(PLATFORM)$(COMPILER_SUFFIX)$(DEBUG_SUFFIX)/

RES =

TARGET_NAME := dggal

TARGET = obj/$(CONFIG).$(PLATFORM)$(COMPILER_SUFFIX)$(DEBUG_SUFFIX)/$(LP)$(TARGET_NAME)$(OUT)

_ECSOURCES = \
	src/dggrs/I3HSubZones.ec \
	src/dggrs/RI3H.ec \
	src/dggrs/RI9R.ec \
	src/dggrs/GNOSISGlobalGrid.ec \
	src/dggrs/ISEA9R.ec \
	src/dggrs/ISEA3H.ec \
	src/dggrs/GPP3H.ec \
	src/dggrs/IVEA3H.ec \
	src/dggrs/IVEA9R.ec \
	src/dggrs/BCTA3H.ec \
	src/dggrs/RTEA3H.ec \
	src/dggrs/RTEA9R.ec \
	src/dggrs/rHEALPixGrid.ec \
	src/dggrs/RI7H.ec \
	src/dggrs/IVEA7H.ec \
	src/dggrs/ISEA7H.ec \
	src/dggrs/HEALPixGrid.ec \
	src/dggrs/RTEA7H.ec \
	src/dggrs/RI4R.ec \
	src/dggrs/IVEA4R.ec \
	src/dggrs/ISEA4R.ec \
	src/dggrs/RTEA4R.ec \
	src/dggrs/RI7H_Z7.ec \
	src/dggrs/ISEA7H_Z7.ec \
	src/dggrs/IVEA7H_Z7.ec \
	src/dggrs/RTEA7H_Z7.ec \
	src/projections/ri5x6.ec \
	src/projections/authalic.ec \
	src/projections/barycentric5x6.ec \
	src/projections/icoVertexGreatCircle.ec \
	src/projections/rHEALPix.ec \
	src/dggsJSON/dggsJSON.ec \
	$(EC_SDK_SRC)/extras/JSONSchema.ec \
	src/ecere3D/Plane.ec \
	src/ecere3D/Vector3D.ec \
	src/ecere3D/Quaternion.ec \
	src/GeoExtent.ec \
	src/dggrs.ec

ECSOURCES = $(call shwspace,$(_ECSOURCES))

_COBJECTS = $(addprefix $(OBJ),$(patsubst %.ec,%$(C),$(notdir $(_ECSOURCES))))

_SYMBOLS = $(addprefix $(OBJ),$(patsubst %.ec,%$(S),$(notdir $(_ECSOURCES))))

_IMPORTS = $(addprefix $(OBJ),$(patsubst %.ec,%$(I),$(notdir $(_ECSOURCES))))

_ECOBJECTS = $(addprefix $(OBJ),$(patsubst %.ec,%$(O),$(notdir $(_ECSOURCES))))

_BOWLS = $(addprefix $(OBJ),$(patsubst %.ec,%$(B),$(notdir $(_ECSOURCES))))

COBJECTS = $(call shwspace,$(_COBJECTS))

SYMBOLS = $(call shwspace,$(_SYMBOLS))

IMPORTS = $(call shwspace,$(_IMPORTS))

ECOBJECTS = $(call shwspace,$(_ECOBJECTS))

BOWLS = $(call shwspace,$(_BOWLS))

OBJECTS = $(ECOBJECTS) $(OBJ)$(MODULE).main$(O)

SOURCES = $(ECSOURCES)

RESOURCES =

ifdef USE_RESOURCES_EAR
RESOURCES_EAR =
else
RESOURCES_EAR = $(RESOURCES)
endif

LIBS += $(SHAREDLIB) $(EXECUTABLE) $(LINKOPT)

LIBS += $(call _L,ecrt)

PRJ_CFLAGS += \
	 $(if $(DEBUG), -g, -O2 -ffast-math) $(FPIC) -Wall -DREPOSITORY_VERSION="\"$(REPOSITORY_VER)\"" \
			 -DIMPORT_STATIC=\"\"

ECFLAGS += -module $(MODULE)
# PLATFORM-SPECIFIC OPTIONS

ifdef WINDOWS_TARGET
OFLAGS += \
	$(if $(EC_SDK_SRC)/deps/zlib-1.2.8/obj/release.$(PLATFORM)$(COMPILER_SUFFIX),-L$(call quote_path,$(EC_SDK_SRC)/deps/zlib-1.2.8/obj/release.$(PLATFORM)$(COMPILER_SUFFIX)),) \
	$(if $(EC_SDK_SRC)/obj/$(PLATFORM)$(COMPILER_SUFFIX)/bin,-L$(call quote_path,$(EC_SDK_SRC)/obj/$(PLATFORM)$(COMPILER_SUFFIX)/bin),) \
	-static-libgcc
LIBS += \
	-Wl,-Bstatic
else
OFLAGS += \
	$(if $(EC_SDK_SRC)/obj/$(PLATFORM)$(COMPILER_SUFFIX)/lib,-L$(call quote_path,$(EC_SDK_SRC)/obj/$(PLATFORM)$(COMPILER_SUFFIX)/lib),)

ifdef OSX_TARGET
OFLAGS += $(if $(ENABLE_PYTHON_RPATHS),-Wl$(comma)-rpath$(comma)'@loader_path/../../ecrt/lib',)
else
OFLAGS += $(if $(ENABLE_PYTHON_RPATHS),-Wl$(comma)-rpath='$$ORIGIN/../../ecrt/lib',)
endif
OFLAGS += $(RPATHS_FOR_PORTABLE_BINARIES)
endif

ifdef LINUX_TARGET

LIBS += \
	$(call _L,m)

endif

CECFLAGS += -cpp $(_CPP)

# TARGETS

all: objdir $(TARGET)

objdir:
	$(if $(wildcard $(OBJ)),,$(call mkdir,$(OBJ)))
	$(if $(EC_SDK_SRC),$(if $(wildcard $(call escspace,$(EC_SDK_SRC)/crossplatform.mk)),,@$(call echo,Ecere SDK Source Warning: The value of EC_SDK_SRC is pointing to an incorrect ($(EC_SDK_SRC)) location.)),)
	$(if $(EC_SDK_SRC),,$(if $(ECP_DEBUG)$(ECC_DEBUG)$(ECS_DEBUG),@$(call echo,ECC Debug Warning: Please define EC_SDK_SRC before using ECP_DEBUG, ECC_DEBUG or ECS_DEBUG),))

$(OBJ)$(MODULE).main.ec: $(SYMBOLS) $(COBJECTS)
	@$(call rm,$(OBJ)symbols.lst)
	@$(call touch,$(OBJ)symbols.lst)
	$(call addtolistfile,$(SYMBOLS),$(OBJ)symbols.lst)
	$(call addtolistfile,$(IMPORTS),$(OBJ)symbols.lst)
	$(ECS) $(ARCH_FLAGS) $(ECSLIBOPT) @$(OBJ)symbols.lst -symbols obj/$(CONFIG).$(PLATFORM)$(COMPILER_SUFFIX)$(DEBUG_SUFFIX) -o $(call quote_path,$@)

$(OBJ)$(MODULE).main.c: $(OBJ)$(MODULE).main.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(OBJ)$(MODULE).main.ec -o $(OBJ)$(MODULE).main.sym -symbols $(OBJ)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(OBJ)$(MODULE).main.ec -o $(call quote_path,$@) -symbols $(OBJ)

$(SYMBOLS): | objdir
$(OBJECTS): | objdir
$(TARGET): $(SOURCES) $(RESOURCES_EAR) $(SYMBOLS) $(OBJECTS) | objdir
	@$(call rm,$(OBJ)objects.lst)
	@$(call touch,$(OBJ)objects.lst)
	$(call addtolistfile,$(OBJ)$(MODULE).main$(O),$(OBJ)objects.lst)
	$(call addtolistfile,$(ECOBJECTS),$(OBJ)objects.lst)
	$(LD) $(OFLAGS) @$(OBJ)objects.lst $(LIBS) -o $(TARGET) $(INSTALLNAME) $(SONAME)
ifdef OSX_TARGET
	install_name_tool -id @rpath/lib$(MODULE).dylib $(TARGET)
endif
ifndef NOSTRIP
	$(STRIP) $(STRIPOPT) $(TARGET)
endif

ifndef SKIP_SONAME
ifdef LINUX_TARGET
ifdef LINUX_HOST
	$(if $(basename $(VER)),ln -sf $(LP)$(MODULE)$(SO)$(VER) $(OBJ)$(LP)$(MODULE)$(SO)$(basename $(VER)),)
	$(if $(VER),ln -sf $(LP)$(MODULE)$(SO)$(VER) $(OBJ)$(LP)$(MODULE)$(SO),)
endif
endif
endif
	$(call mkdir,$(DGGAL_ABSPATH)$(SODESTDIR))
	$(call cp,$(TARGET),$(DGGAL_ABSPATH)$(SODESTDIR))

# SYMBOL RULES

$(OBJ)I3HSubZones.sym: src/dggrs/I3HSubZones.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,src/dggrs/I3HSubZones.ec) -o $(call quote_path,$@)

$(OBJ)RI3H.sym: src/dggrs/RI3H.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,src/dggrs/RI3H.ec) -o $(call quote_path,$@)

$(OBJ)RI9R.sym: src/dggrs/RI9R.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,src/dggrs/RI9R.ec) -o $(call quote_path,$@)

$(OBJ)GNOSISGlobalGrid.sym: src/dggrs/GNOSISGlobalGrid.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,src/dggrs/GNOSISGlobalGrid.ec) -o $(call quote_path,$@)

$(OBJ)ISEA9R.sym: src/dggrs/ISEA9R.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,src/dggrs/ISEA9R.ec) -o $(call quote_path,$@)

$(OBJ)ISEA3H.sym: src/dggrs/ISEA3H.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,src/dggrs/ISEA3H.ec) -o $(call quote_path,$@)

$(OBJ)GPP3H.sym: src/dggrs/GPP3H.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,src/dggrs/GPP3H.ec) -o $(call quote_path,$@)

$(OBJ)IVEA3H.sym: src/dggrs/IVEA3H.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,src/dggrs/IVEA3H.ec) -o $(call quote_path,$@)

$(OBJ)IVEA9R.sym: src/dggrs/IVEA9R.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,src/dggrs/IVEA9R.ec) -o $(call quote_path,$@)

$(OBJ)BCTA3H.sym: src/dggrs/BCTA3H.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,src/dggrs/BCTA3H.ec) -o $(call quote_path,$@)

$(OBJ)RTEA3H.sym: src/dggrs/RTEA3H.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,src/dggrs/RTEA3H.ec) -o $(call quote_path,$@)

$(OBJ)RTEA9R.sym: src/dggrs/RTEA9R.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,src/dggrs/RTEA9R.ec) -o $(call quote_path,$@)

$(OBJ)rHEALPixGrid.sym: src/dggrs/rHEALPixGrid.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,src/dggrs/rHEALPixGrid.ec) -o $(call quote_path,$@)

$(OBJ)RI7H.sym: src/dggrs/RI7H.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,src/dggrs/RI7H.ec) -o $(call quote_path,$@)

$(OBJ)IVEA7H.sym: src/dggrs/IVEA7H.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,src/dggrs/IVEA7H.ec) -o $(call quote_path,$@)

$(OBJ)ISEA7H.sym: src/dggrs/ISEA7H.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,src/dggrs/ISEA7H.ec) -o $(call quote_path,$@)

$(OBJ)HEALPixGrid.sym: src/dggrs/HEALPixGrid.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,src/dggrs/HEALPixGrid.ec) -o $(call quote_path,$@)

$(OBJ)RTEA7H.sym: src/dggrs/RTEA7H.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,src/dggrs/RTEA7H.ec) -o $(call quote_path,$@)

$(OBJ)RI4R.sym: src/dggrs/RI4R.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,src/dggrs/RI4R.ec) -o $(call quote_path,$@)

$(OBJ)IVEA4R.sym: src/dggrs/IVEA4R.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,src/dggrs/IVEA4R.ec) -o $(call quote_path,$@)

$(OBJ)ISEA4R.sym: src/dggrs/ISEA4R.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,src/dggrs/ISEA4R.ec) -o $(call quote_path,$@)

$(OBJ)RTEA4R.sym: src/dggrs/RTEA4R.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,src/dggrs/RTEA4R.ec) -o $(call quote_path,$@)

$(OBJ)RI7H_Z7.sym: src/dggrs/RI7H_Z7.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,src/dggrs/RI7H_Z7.ec) -o $(call quote_path,$@)

$(OBJ)ISEA7H_Z7.sym: src/dggrs/ISEA7H_Z7.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,src/dggrs/ISEA7H_Z7.ec) -o $(call quote_path,$@)

$(OBJ)IVEA7H_Z7.sym: src/dggrs/IVEA7H_Z7.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,src/dggrs/IVEA7H_Z7.ec) -o $(call quote_path,$@)

$(OBJ)RTEA7H_Z7.sym: src/dggrs/RTEA7H_Z7.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,src/dggrs/RTEA7H_Z7.ec) -o $(call quote_path,$@)

$(OBJ)ri5x6.sym: src/projections/ri5x6.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,src/projections/ri5x6.ec) -o $(call quote_path,$@)

$(OBJ)authalic.sym: src/projections/authalic.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,src/projections/authalic.ec) -o $(call quote_path,$@)

$(OBJ)barycentric5x6.sym: src/projections/barycentric5x6.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,src/projections/barycentric5x6.ec) -o $(call quote_path,$@)

$(OBJ)icoVertexGreatCircle.sym: src/projections/icoVertexGreatCircle.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,src/projections/icoVertexGreatCircle.ec) -o $(call quote_path,$@)

$(OBJ)rHEALPix.sym: src/projections/rHEALPix.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,src/projections/rHEALPix.ec) -o $(call quote_path,$@)

$(OBJ)dggsJSON.sym: src/dggsJSON/dggsJSON.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,src/dggsJSON/dggsJSON.ec) -o $(call quote_path,$@)

$(OBJ)JSONSchema.sym: $(EC_SDK_SRC)/extras/JSONSchema.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,$(EC_SDK_SRC)/extras/JSONSchema.ec) -o $(call quote_path,$@)

$(OBJ)Plane.sym: src/ecere3D/Plane.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,src/ecere3D/Plane.ec) -o $(call quote_path,$@)

$(OBJ)Vector3D.sym: src/ecere3D/Vector3D.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,src/ecere3D/Vector3D.ec) -o $(call quote_path,$@)

$(OBJ)Quaternion.sym: src/ecere3D/Quaternion.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,src/ecere3D/Quaternion.ec) -o $(call quote_path,$@)

$(OBJ)GeoExtent.sym: src/GeoExtent.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,src/GeoExtent.ec) -o $(call quote_path,$@)

$(OBJ)dggrs.sym: src/dggrs.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,src/dggrs.ec) -o $(call quote_path,$@)

# C OBJECT RULES

$(OBJ)I3HSubZones.c: src/dggrs/I3HSubZones.ec $(OBJ)I3HSubZones.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,src/dggrs/I3HSubZones.ec) -o $(call quote_path,$@) -symbols $(OBJ)

$(OBJ)RI3H.c: src/dggrs/RI3H.ec $(OBJ)RI3H.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,src/dggrs/RI3H.ec) -o $(call quote_path,$@) -symbols $(OBJ)

$(OBJ)RI9R.c: src/dggrs/RI9R.ec $(OBJ)RI9R.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,src/dggrs/RI9R.ec) -o $(call quote_path,$@) -symbols $(OBJ)

$(OBJ)GNOSISGlobalGrid.c: src/dggrs/GNOSISGlobalGrid.ec $(OBJ)GNOSISGlobalGrid.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,src/dggrs/GNOSISGlobalGrid.ec) -o $(call quote_path,$@) -symbols $(OBJ)

$(OBJ)ISEA9R.c: src/dggrs/ISEA9R.ec $(OBJ)ISEA9R.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,src/dggrs/ISEA9R.ec) -o $(call quote_path,$@) -symbols $(OBJ)

$(OBJ)ISEA3H.c: src/dggrs/ISEA3H.ec $(OBJ)ISEA3H.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,src/dggrs/ISEA3H.ec) -o $(call quote_path,$@) -symbols $(OBJ)

$(OBJ)GPP3H.c: src/dggrs/GPP3H.ec $(OBJ)GPP3H.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,src/dggrs/GPP3H.ec) -o $(call quote_path,$@) -symbols $(OBJ)

$(OBJ)IVEA3H.c: src/dggrs/IVEA3H.ec $(OBJ)IVEA3H.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,src/dggrs/IVEA3H.ec) -o $(call quote_path,$@) -symbols $(OBJ)

$(OBJ)IVEA9R.c: src/dggrs/IVEA9R.ec $(OBJ)IVEA9R.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,src/dggrs/IVEA9R.ec) -o $(call quote_path,$@) -symbols $(OBJ)

$(OBJ)BCTA3H.c: src/dggrs/BCTA3H.ec $(OBJ)BCTA3H.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,src/dggrs/BCTA3H.ec) -o $(call quote_path,$@) -symbols $(OBJ)

$(OBJ)RTEA3H.c: src/dggrs/RTEA3H.ec $(OBJ)RTEA3H.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,src/dggrs/RTEA3H.ec) -o $(call quote_path,$@) -symbols $(OBJ)

$(OBJ)RTEA9R.c: src/dggrs/RTEA9R.ec $(OBJ)RTEA9R.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,src/dggrs/RTEA9R.ec) -o $(call quote_path,$@) -symbols $(OBJ)

$(OBJ)rHEALPixGrid.c: src/dggrs/rHEALPixGrid.ec $(OBJ)rHEALPixGrid.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,src/dggrs/rHEALPixGrid.ec) -o $(call quote_path,$@) -symbols $(OBJ)

$(OBJ)RI7H.c: src/dggrs/RI7H.ec $(OBJ)RI7H.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,src/dggrs/RI7H.ec) -o $(call quote_path,$@) -symbols $(OBJ)

$(OBJ)IVEA7H.c: src/dggrs/IVEA7H.ec $(OBJ)IVEA7H.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,src/dggrs/IVEA7H.ec) -o $(call quote_path,$@) -symbols $(OBJ)

$(OBJ)ISEA7H.c: src/dggrs/ISEA7H.ec $(OBJ)ISEA7H.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,src/dggrs/ISEA7H.ec) -o $(call quote_path,$@) -symbols $(OBJ)

$(OBJ)HEALPixGrid.c: src/dggrs/HEALPixGrid.ec $(OBJ)HEALPixGrid.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,src/dggrs/HEALPixGrid.ec) -o $(call quote_path,$@) -symbols $(OBJ)

$(OBJ)RTEA7H.c: src/dggrs/RTEA7H.ec $(OBJ)RTEA7H.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,src/dggrs/RTEA7H.ec) -o $(call quote_path,$@) -symbols $(OBJ)

$(OBJ)RI4R.c: src/dggrs/RI4R.ec $(OBJ)RI4R.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,src/dggrs/RI4R.ec) -o $(call quote_path,$@) -symbols $(OBJ)

$(OBJ)IVEA4R.c: src/dggrs/IVEA4R.ec $(OBJ)IVEA4R.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,src/dggrs/IVEA4R.ec) -o $(call quote_path,$@) -symbols $(OBJ)

$(OBJ)ISEA4R.c: src/dggrs/ISEA4R.ec $(OBJ)ISEA4R.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,src/dggrs/ISEA4R.ec) -o $(call quote_path,$@) -symbols $(OBJ)

$(OBJ)RTEA4R.c: src/dggrs/RTEA4R.ec $(OBJ)RTEA4R.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,src/dggrs/RTEA4R.ec) -o $(call quote_path,$@) -symbols $(OBJ)

$(OBJ)RI7H_Z7.c: src/dggrs/RI7H_Z7.ec $(OBJ)RI7H_Z7.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,src/dggrs/RI7H_Z7.ec) -o $(call quote_path,$@) -symbols $(OBJ)

$(OBJ)ISEA7H_Z7.c: src/dggrs/ISEA7H_Z7.ec $(OBJ)ISEA7H_Z7.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,src/dggrs/ISEA7H_Z7.ec) -o $(call quote_path,$@) -symbols $(OBJ)

$(OBJ)IVEA7H_Z7.c: src/dggrs/IVEA7H_Z7.ec $(OBJ)IVEA7H_Z7.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,src/dggrs/IVEA7H_Z7.ec) -o $(call quote_path,$@) -symbols $(OBJ)

$(OBJ)RTEA7H_Z7.c: src/dggrs/RTEA7H_Z7.ec $(OBJ)RTEA7H_Z7.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,src/dggrs/RTEA7H_Z7.ec) -o $(call quote_path,$@) -symbols $(OBJ)

$(OBJ)ri5x6.c: src/projections/ri5x6.ec $(OBJ)ri5x6.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,src/projections/ri5x6.ec) -o $(call quote_path,$@) -symbols $(OBJ)

$(OBJ)authalic.c: src/projections/authalic.ec $(OBJ)authalic.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,src/projections/authalic.ec) -o $(call quote_path,$@) -symbols $(OBJ)

$(OBJ)barycentric5x6.c: src/projections/barycentric5x6.ec $(OBJ)barycentric5x6.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,src/projections/barycentric5x6.ec) -o $(call quote_path,$@) -symbols $(OBJ)

$(OBJ)icoVertexGreatCircle.c: src/projections/icoVertexGreatCircle.ec $(OBJ)icoVertexGreatCircle.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,src/projections/icoVertexGreatCircle.ec) -o $(call quote_path,$@) -symbols $(OBJ)

$(OBJ)rHEALPix.c: src/projections/rHEALPix.ec $(OBJ)rHEALPix.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,src/projections/rHEALPix.ec) -o $(call quote_path,$@) -symbols $(OBJ)

$(OBJ)dggsJSON.c: src/dggsJSON/dggsJSON.ec $(OBJ)dggsJSON.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,src/dggsJSON/dggsJSON.ec) -o $(call quote_path,$@) -symbols $(OBJ)

$(OBJ)JSONSchema.c: $(EC_SDK_SRC)/extras/JSONSchema.ec $(OBJ)JSONSchema.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(EC_SDK_SRC)/extras/JSONSchema.ec) -o $(call quote_path,$@) -symbols $(OBJ)

$(OBJ)Plane.c: src/ecere3D/Plane.ec $(OBJ)Plane.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,src/ecere3D/Plane.ec) -o $(call quote_path,$@) -symbols $(OBJ)

$(OBJ)Vector3D.c: src/ecere3D/Vector3D.ec $(OBJ)Vector3D.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,src/ecere3D/Vector3D.ec) -o $(call quote_path,$@) -symbols $(OBJ)

$(OBJ)Quaternion.c: src/ecere3D/Quaternion.ec $(OBJ)Quaternion.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,src/ecere3D/Quaternion.ec) -o $(call quote_path,$@) -symbols $(OBJ)

$(OBJ)GeoExtent.c: src/GeoExtent.ec $(OBJ)GeoExtent.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,src/GeoExtent.ec) -o $(call quote_path,$@) -symbols $(OBJ)

$(OBJ)dggrs.c: src/dggrs.ec $(OBJ)dggrs.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,src/dggrs.ec) -o $(call quote_path,$@) -symbols $(OBJ)

# OBJECT RULES

$(OBJ)I3HSubZones$(O): $(OBJ)I3HSubZones.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)I3HSubZones.c) -o $(call quote_path,$@)

$(OBJ)RI3H$(O): $(OBJ)RI3H.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)RI3H.c) -o $(call quote_path,$@)

$(OBJ)RI9R$(O): $(OBJ)RI9R.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)RI9R.c) -o $(call quote_path,$@)

$(OBJ)GNOSISGlobalGrid$(O): $(OBJ)GNOSISGlobalGrid.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)GNOSISGlobalGrid.c) -o $(call quote_path,$@)

$(OBJ)ISEA9R$(O): $(OBJ)ISEA9R.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)ISEA9R.c) -o $(call quote_path,$@)

$(OBJ)ISEA3H$(O): $(OBJ)ISEA3H.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)ISEA3H.c) -o $(call quote_path,$@)

$(OBJ)GPP3H$(O): $(OBJ)GPP3H.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)GPP3H.c) -o $(call quote_path,$@)

$(OBJ)IVEA3H$(O): $(OBJ)IVEA3H.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)IVEA3H.c) -o $(call quote_path,$@)

$(OBJ)IVEA9R$(O): $(OBJ)IVEA9R.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)IVEA9R.c) -o $(call quote_path,$@)

$(OBJ)BCTA3H$(O): $(OBJ)BCTA3H.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)BCTA3H.c) -o $(call quote_path,$@)

$(OBJ)RTEA3H$(O): $(OBJ)RTEA3H.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)RTEA3H.c) -o $(call quote_path,$@)

$(OBJ)RTEA9R$(O): $(OBJ)RTEA9R.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)RTEA9R.c) -o $(call quote_path,$@)

$(OBJ)rHEALPixGrid$(O): $(OBJ)rHEALPixGrid.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)rHEALPixGrid.c) -o $(call quote_path,$@)

$(OBJ)RI7H$(O): $(OBJ)RI7H.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)RI7H.c) -o $(call quote_path,$@)

$(OBJ)IVEA7H$(O): $(OBJ)IVEA7H.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)IVEA7H.c) -o $(call quote_path,$@)

$(OBJ)ISEA7H$(O): $(OBJ)ISEA7H.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)ISEA7H.c) -o $(call quote_path,$@)

$(OBJ)HEALPixGrid$(O): $(OBJ)HEALPixGrid.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)HEALPixGrid.c) -o $(call quote_path,$@)

$(OBJ)RTEA7H$(O): $(OBJ)RTEA7H.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)RTEA7H.c) -o $(call quote_path,$@)

$(OBJ)RI4R$(O): $(OBJ)RI4R.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)RI4R.c) -o $(call quote_path,$@)

$(OBJ)IVEA4R$(O): $(OBJ)IVEA4R.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)IVEA4R.c) -o $(call quote_path,$@)

$(OBJ)ISEA4R$(O): $(OBJ)ISEA4R.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)ISEA4R.c) -o $(call quote_path,$@)

$(OBJ)RTEA4R$(O): $(OBJ)RTEA4R.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)RTEA4R.c) -o $(call quote_path,$@)

$(OBJ)RI7H_Z7$(O): $(OBJ)RI7H_Z7.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)RI7H_Z7.c) -o $(call quote_path,$@)

$(OBJ)ISEA7H_Z7$(O): $(OBJ)ISEA7H_Z7.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)ISEA7H_Z7.c) -o $(call quote_path,$@)

$(OBJ)IVEA7H_Z7$(O): $(OBJ)IVEA7H_Z7.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)IVEA7H_Z7.c) -o $(call quote_path,$@)

$(OBJ)RTEA7H_Z7$(O): $(OBJ)RTEA7H_Z7.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)RTEA7H_Z7.c) -o $(call quote_path,$@)

$(OBJ)ri5x6$(O): $(OBJ)ri5x6.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)ri5x6.c) -o $(call quote_path,$@)

$(OBJ)authalic$(O): $(OBJ)authalic.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)authalic.c) -o $(call quote_path,$@)

$(OBJ)barycentric5x6$(O): $(OBJ)barycentric5x6.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)barycentric5x6.c) -o $(call quote_path,$@)

$(OBJ)icoVertexGreatCircle$(O): $(OBJ)icoVertexGreatCircle.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)icoVertexGreatCircle.c) -o $(call quote_path,$@)

$(OBJ)rHEALPix$(O): $(OBJ)rHEALPix.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)rHEALPix.c) -o $(call quote_path,$@)

$(OBJ)dggsJSON$(O): $(OBJ)dggsJSON.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)dggsJSON.c) -o $(call quote_path,$@)

$(OBJ)JSONSchema$(O): $(OBJ)JSONSchema.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)JSONSchema.c) -o $(call quote_path,$@)

$(OBJ)Plane$(O): $(OBJ)Plane.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)Plane.c) -o $(call quote_path,$@)

$(OBJ)Vector3D$(O): $(OBJ)Vector3D.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)Vector3D.c) -o $(call quote_path,$@)

$(OBJ)Quaternion$(O): $(OBJ)Quaternion.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)Quaternion.c) -o $(call quote_path,$@)

$(OBJ)GeoExtent$(O): $(OBJ)GeoExtent.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)GeoExtent.c) -o $(call quote_path,$@)

$(OBJ)dggrs$(O): $(OBJ)dggrs.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)dggrs.c) -o $(call quote_path,$@)

$(OBJ)$(MODULE).main$(O): $(OBJ)$(MODULE).main.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(OBJ)$(MODULE).main.c -o $(call quote_path,$@)

cleantarget:
	$(call rm,$(OBJ)$(MODULE).main$(O) $(OBJ)$(MODULE).main.c $(OBJ)$(MODULE).main.ec $(OBJ)$(MODULE).main$(I) $(OBJ)$(MODULE).main$(S))
	$(call rm,$(OBJ)symbols.lst)
	$(call rm,$(OBJ)objects.lst)
	$(call rm,$(TARGET))
ifdef LINUX_TARGET
ifdef LINUX_HOST
	$(call rm,$(OBJ)$(LP)$(MODULE)$(SO)$(basename $(VER)))
	$(call rm,$(OBJ)$(LP)$(MODULE)$(SO))
endif
endif

clean: cleantarget
	$(call rm,$(_OBJECTS))
	$(call rm,$(_ECOBJECTS))
	$(call rm,$(_COBJECTS))
	$(call rm,$(_BOWLS))
	$(call rm,$(_IMPORTS))
	$(call rm,$(_SYMBOLS))

realclean: cleantarget
	$(call rmr,$(OBJ))

distclean: cleantarget
	$(call rmr,obj/)
	$(call rmr,.configs/)
	$(call rm,*.ews)
	$(call rm,*.Makefile)



================================================
FILE: Makefile.dggal.static
================================================
.PHONY: all objdir cleantarget clean realclean distclean

# CORE VARIABLES

MODULE := dggal
VERSION :=
CONFIG := static
ifndef COMPILER
COMPILER := default
endif

TARGET_TYPE = staticlib

# FLAGS

ECFLAGS =
ifndef DEBIAN_PACKAGE
CFLAGS =
LDFLAGS =
endif
PRJ_CFLAGS =
CECFLAGS =
OFLAGS =
LIBS =

ifdef DEBUG
NOSTRIP := y
endif

CONSOLE = -mwindows

# INCLUDES

DGGAL_ABSPATH := $(dir $(realpath $(firstword $(MAKEFILE_LIST))))

ifndef EC_SDK_SRC
EC_SDK_SRC := $(DGGAL_ABSPATH)../eC
endif

_CF_DIR = $(EC_SDK_SRC)/
include $(_CF_DIR)crossplatform.mk
include $(_CF_DIR)$(COMPILER).cf

# POST-INCLUDES VARIABLES

OBJ = obj/$(CONFIG).$(PLATFORM)$(COMPILER_SUFFIX)$(DEBUG_SUFFIX)/

RES =

TARGET_NAME := dggalStatic

TARGET = obj/$(CONFIG).$(PLATFORM)$(COMPILER_SUFFIX)$(DEBUG_SUFFIX)/$(LP)$(TARGET_NAME)$(OUT)

_ECSOURCES = \
	src/dggrs/I3HSubZones.ec \
	src/dggrs/RI3H.ec \
	src/dggrs/RI9R.ec \
	src/dggrs/GNOSISGlobalGrid.ec \
	src/dggrs/ISEA9R.ec \
	src/dggrs/ISEA3H.ec \
	src/dggrs/GPP3H.ec \
	src/dggrs/IVEA3H.ec \
	src/dggrs/IVEA9R.ec \
	src/dggrs/BCTA3H.ec \
	src/dggrs/RTEA3H.ec \
	src/dggrs/RTEA9R.ec \
	src/dggrs/rHEALPixGrid.ec \
	src/dggrs/RI7H.ec \
	src/dggrs/IVEA7H.ec \
	src/dggrs/ISEA7H.ec \
	src/dggrs/HEALPixGrid.ec \
	src/dggrs/RTEA7H.ec \
	src/dggrs/RI4R.ec \
	src/dggrs/IVEA4R.ec \
	src/dggrs/ISEA4R.ec \
	src/dggrs/RTEA4R.ec \
	src/dggrs/RI7H_Z7.ec \
	src/dggrs/ISEA7H_Z7.ec \
	src/dggrs/IVEA7H_Z7.ec \
	src/dggrs/RTEA7H_Z7.ec \
	src/projections/ri5x6.ec \
	src/projections/authalic.ec \
	src/projections/barycentric5x6.ec \
	src/projections/icoVertexGreatCircle.ec \
	src/projections/rHEALPix.ec \
	src/dggsJSON/dggsJSON.ec \
	$(EC_SDK_SRC)/extras/JSONSchema.ec \
	src/ecere3D/Plane.ec \
	src/ecere3D/Vector3D.ec \
	src/ecere3D/Quaternion.ec \
	src/GeoExtent.ec \
	src/dggrs.ec

ECSOURCES = $(call shwspace,$(_ECSOURCES))

_COBJECTS = $(addprefix $(OBJ),$(patsubst %.ec,%$(C),$(notdir $(_ECSOURCES))))

_SYMBOLS = $(addprefix $(OBJ),$(patsubst %.ec,%$(S),$(notdir $(_ECSOURCES))))

_IMPORTS = $(addprefix $(OBJ),$(patsubst %.ec,%$(I),$(notdir $(_ECSOURCES))))

_ECOBJECTS = $(addprefix $(OBJ),$(patsubst %.ec,%$(O),$(notdir $(_ECSOURCES))))

_BOWLS = $(addprefix $(OBJ),$(patsubst %.ec,%$(B),$(notdir $(_ECSOURCES))))

COBJECTS = $(call shwspace,$(_COBJECTS))

SYMBOLS = $(call shwspace,$(_SYMBOLS))

IMPORTS = $(call shwspace,$(_IMPORTS))

ECOBJECTS = $(call shwspace,$(_ECOBJECTS))

BOWLS = $(call shwspace,$(_BOWLS))

OBJECTS = $(ECOBJECTS) $(OBJ)$(MODULE).main$(O)

SOURCES = $(ECSOURCES)

RESOURCES =

ifdef USE_RESOURCES_EAR
RESOURCES_EAR =
else
RESOURCES_EAR = $(RESOURCES)
endif

PRJ_CFLAGS += \
	 $(if $(DEBUG), -g, -O2 -ffast-math) $(FPIC) -Wall -DREPOSITORY_VERSION="\"$(REPOSITORY_VER)\"" \
			 -DEC_STATIC \
			 -DIMPORT_STATIC=static

ECFLAGS += -module $(MODULE)
# PLATFORM-SPECIFIC OPTIONS

CECFLAGS += -cpp $(_CPP)

# TARGETS

all: objdir $(TARGET)

objdir:
	$(if $(wildcard $(OBJ)),,$(call mkdir,$(OBJ)))
	$(if $(EC_SDK_SRC),$(if $(wildcard $(call escspace,$(EC_SDK_SRC)/crossplatform.mk)),,@$(call echo,eC SDK Source Warning: The value of EC_SDK_SRC is pointing to an incorrect ($(EC_SDK_SRC)) location.)),)
	$(if $(EC_SDK_SRC),,$(if $(ECP_DEBUG)$(ECC_DEBUG)$(ECS_DEBUG),@$(call echo,ECC Debug Warning: Please define EC_SDK_SRC before using ECP_DEBUG, ECC_DEBUG or ECS_DEBUG),))

$(OBJ)$(MODULE).main.ec: $(SYMBOLS) $(COBJECTS)
	@$(call rm,$(OBJ)symbols.lst)
	@$(call touch,$(OBJ)symbols.lst)
	$(call addtolistfile,$(SYMBOLS),$(OBJ)symbols.lst)
	$(call addtolistfile,$(IMPORTS),$(OBJ)symbols.lst)
	$(ECS) $(ARCH_FLAGS) $(ECSLIBOPT) @$(OBJ)symbols.lst -symbols obj/$(CONFIG).$(PLATFORM)$(COMPILER_SUFFIX)$(DEBUG_SUFFIX) -o $(call quote_path,$@)

$(OBJ)$(MODULE).main.c: $(OBJ)$(MODULE).main.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(OBJ)$(MODULE).main.ec -o $(OBJ)$(MODULE).main.sym -symbols $(OBJ)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(OBJ)$(MODULE).main.ec -o $(call quote_path,$@) -symbols $(OBJ)

$(SYMBOLS): | objdir
$(OBJECTS): | objdir
$(TARGET): $(SOURCES) $(RESOURCES_EAR) $(SYMBOLS) $(OBJECTS) | objdir
	@$(call rm,$(OBJ)objects.lst)
	@$(call touch,$(OBJ)objects.lst)
	$(call addtolistfile,$(OBJ)$(MODULE).main$(O),$(OBJ)objects.lst)
	$(call addtolistfile,$(ECOBJECTS),$(OBJ)objects.lst)
ifdef WINDOWS_HOST
	$(AR) rcs $(TARGET) @$(OBJ)objects.lst $(LIBS)
else
	$(AR) rcs $(TARGET) $(OBJECTS) $(LIBS)
endif
	$(call mkdir,$(DGGAL_ABSPATH)obj/$(PLATFORM)$(COMPILER_SUFFIX)$(DEBUG_SUFFIX)/lib)
	$(call cp,$(TARGET),$(DGGAL_ABSPATH)obj/$(PLATFORM)$(COMPILER_SUFFIX)$(DEBUG_SUFFIX)/lib)

# SYMBOL RULES

$(OBJ)I3HSubZones.sym: src/dggrs/I3HSubZones.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,src/dggrs/I3HSubZones.ec) -o $(call quote_path,$@)

$(OBJ)RI3H.sym: src/dggrs/RI3H.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,src/dggrs/RI3H.ec) -o $(call quote_path,$@)

$(OBJ)RI9R.sym: src/dggrs/RI9R.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,src/dggrs/RI9R.ec) -o $(call quote_path,$@)

$(OBJ)GNOSISGlobalGrid.sym: src/dggrs/GNOSISGlobalGrid.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,src/dggrs/GNOSISGlobalGrid.ec) -o $(call quote_path,$@)

$(OBJ)ISEA9R.sym: src/dggrs/ISEA9R.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,src/dggrs/ISEA9R.ec) -o $(call quote_path,$@)

$(OBJ)ISEA3H.sym: src/dggrs/ISEA3H.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,src/dggrs/ISEA3H.ec) -o $(call quote_path,$@)

$(OBJ)GPP3H.sym: src/dggrs/GPP3H.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,src/dggrs/GPP3H.ec) -o $(call quote_path,$@)

$(OBJ)IVEA3H.sym: src/dggrs/IVEA3H.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,src/dggrs/IVEA3H.ec) -o $(call quote_path,$@)

$(OBJ)IVEA9R.sym: src/dggrs/IVEA9R.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,src/dggrs/IVEA9R.ec) -o $(call quote_path,$@)

$(OBJ)BCTA3H.sym: src/dggrs/BCTA3H.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,src/dggrs/BCTA3H.ec) -o $(call quote_path,$@)

$(OBJ)RTEA3H.sym: src/dggrs/RTEA3H.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,src/dggrs/RTEA3H.ec) -o $(call quote_path,$@)

$(OBJ)RTEA9R.sym: src/dggrs/RTEA9R.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,src/dggrs/RTEA9R.ec) -o $(call quote_path,$@)

$(OBJ)rHEALPixGrid.sym: src/dggrs/rHEALPixGrid.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,src/dggrs/rHEALPixGrid.ec) -o $(call quote_path,$@)

$(OBJ)RI7H.sym: src/dggrs/RI7H.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,src/dggrs/RI7H.ec) -o $(call quote_path,$@)

$(OBJ)IVEA7H.sym: src/dggrs/IVEA7H.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,src/dggrs/IVEA7H.ec) -o $(call quote_path,$@)

$(OBJ)ISEA7H.sym: src/dggrs/ISEA7H.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,src/dggrs/ISEA7H.ec) -o $(call quote_path,$@)

$(OBJ)HEALPixGrid.sym: src/dggrs/HEALPixGrid.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,src/dggrs/HEALPixGrid.ec) -o $(call quote_path,$@)

$(OBJ)RTEA7H.sym: src/dggrs/RTEA7H.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,src/dggrs/RTEA7H.ec) -o $(call quote_path,$@)

$(OBJ)RI4R.sym: src/dggrs/RI4R.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,src/dggrs/RI4R.ec) -o $(call quote_path,$@)

$(OBJ)IVEA4R.sym: src/dggrs/IVEA4R.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,src/dggrs/IVEA4R.ec) -o $(call quote_path,$@)

$(OBJ)ISEA4R.sym: src/dggrs/ISEA4R.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,src/dggrs/ISEA4R.ec) -o $(call quote_path,$@)

$(OBJ)RTEA4R.sym: src/dggrs/RTEA4R.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,src/dggrs/RTEA4R.ec) -o $(call quote_path,$@)

$(OBJ)RI7H_Z7.sym: src/dggrs/RI7H_Z7.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,src/dggrs/RI7H_Z7.ec) -o $(call quote_path,$@)

$(OBJ)ISEA7H_Z7.sym: src/dggrs/ISEA7H_Z7.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,src/dggrs/ISEA7H_Z7.ec) -o $(call quote_path,$@)

$(OBJ)IVEA7H_Z7.sym: src/dggrs/IVEA7H_Z7.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,src/dggrs/IVEA7H_Z7.ec) -o $(call quote_path,$@)

$(OBJ)RTEA7H_Z7.sym: src/dggrs/RTEA7H_Z7.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,src/dggrs/RTEA7H_Z7.ec) -o $(call quote_path,$@)

$(OBJ)ri5x6.sym: src/projections/ri5x6.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,src/projections/ri5x6.ec) -o $(call quote_path,$@)

$(OBJ)authalic.sym: src/projections/authalic.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,src/projections/authalic.ec) -o $(call quote_path,$@)

$(OBJ)barycentric5x6.sym: src/projections/barycentric5x6.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,src/projections/barycentric5x6.ec) -o $(call quote_path,$@)

$(OBJ)icoVertexGreatCircle.sym: src/projections/icoVertexGreatCircle.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,src/projections/icoVertexGreatCircle.ec) -o $(call quote_path,$@)

$(OBJ)rHEALPix.sym: src/projections/rHEALPix.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,src/projections/rHEALPix.ec) -o $(call quote_path,$@)

$(OBJ)dggsJSON.sym: src/dggsJSON/dggsJSON.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,src/dggsJSON/dggsJSON.ec) -o $(call quote_path,$@)

$(OBJ)JSONSchema.sym: $(EC_SDK_SRC)/extras/JSONSchema.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,$(EC_SDK_SRC)/extras/JSONSchema.ec) -o $(call quote_path,$@)

$(OBJ)Plane.sym: src/ecere3D/Plane.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,src/ecere3D/Plane.ec) -o $(call quote_path,$@)

$(OBJ)Vector3D.sym: src/ecere3D/Vector3D.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,src/ecere3D/Vector3D.ec) -o $(call quote_path,$@)

$(OBJ)Quaternion.sym: src/ecere3D/Quaternion.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,src/ecere3D/Quaternion.ec) -o $(call quote_path,$@)

$(OBJ)GeoExtent.sym: src/GeoExtent.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,src/GeoExtent.ec) -o $(call quote_path,$@)

$(OBJ)dggrs.sym: src/dggrs.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,src/dggrs.ec) -o $(call quote_path,$@)

# C OBJECT RULES

$(OBJ)I3HSubZones.c: src/dggrs/I3HSubZones.ec $(OBJ)I3HSubZones.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,src/dggrs/I3HSubZones.ec) -o $(call quote_path,$@) -symbols $(OBJ)

$(OBJ)RI3H.c: src/dggrs/RI3H.ec $(OBJ)RI3H.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,src/dggrs/RI3H.ec) -o $(call quote_path,$@) -symbols $(OBJ)

$(OBJ)RI9R.c: src/dggrs/RI9R.ec $(OBJ)RI9R.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,src/dggrs/RI9R.ec) -o $(call quote_path,$@) -symbols $(OBJ)

$(OBJ)GNOSISGlobalGrid.c: src/dggrs/GNOSISGlobalGrid.ec $(OBJ)GNOSISGlobalGrid.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,src/dggrs/GNOSISGlobalGrid.ec) -o $(call quote_path,$@) -symbols $(OBJ)

$(OBJ)ISEA9R.c: src/dggrs/ISEA9R.ec $(OBJ)ISEA9R.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,src/dggrs/ISEA9R.ec) -o $(call quote_path,$@) -symbols $(OBJ)

$(OBJ)ISEA3H.c: src/dggrs/ISEA3H.ec $(OBJ)ISEA3H.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,src/dggrs/ISEA3H.ec) -o $(call quote_path,$@) -symbols $(OBJ)

$(OBJ)GPP3H.c: src/dggrs/GPP3H.ec $(OBJ)GPP3H.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,src/dggrs/GPP3H.ec) -o $(call quote_path,$@) -symbols $(OBJ)

$(OBJ)IVEA3H.c: src/dggrs/IVEA3H.ec $(OBJ)IVEA3H.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,src/dggrs/IVEA3H.ec) -o $(call quote_path,$@) -symbols $(OBJ)

$(OBJ)IVEA9R.c: src/dggrs/IVEA9R.ec $(OBJ)IVEA9R.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,src/dggrs/IVEA9R.ec) -o $(call quote_path,$@) -symbols $(OBJ)

$(OBJ)BCTA3H.c: src/dggrs/BCTA3H.ec $(OBJ)BCTA3H.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,src/dggrs/BCTA3H.ec) -o $(call quote_path,$@) -symbols $(OBJ)

$(OBJ)RTEA3H.c: src/dggrs/RTEA3H.ec $(OBJ)RTEA3H.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,src/dggrs/RTEA3H.ec) -o $(call quote_path,$@) -symbols $(OBJ)

$(OBJ)RTEA9R.c: src/dggrs/RTEA9R.ec $(OBJ)RTEA9R.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,src/dggrs/RTEA9R.ec) -o $(call quote_path,$@) -symbols $(OBJ)

$(OBJ)rHEALPixGrid.c: src/dggrs/rHEALPixGrid.ec $(OBJ)rHEALPixGrid.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,src/dggrs/rHEALPixGrid.ec) -o $(call quote_path,$@) -symbols $(OBJ)

$(OBJ)RI7H.c: src/dggrs/RI7H.ec $(OBJ)RI7H.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,src/dggrs/RI7H.ec) -o $(call quote_path,$@) -symbols $(OBJ)

$(OBJ)IVEA7H.c: src/dggrs/IVEA7H.ec $(OBJ)IVEA7H.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,src/dggrs/IVEA7H.ec) -o $(call quote_path,$@) -symbols $(OBJ)

$(OBJ)ISEA7H.c: src/dggrs/ISEA7H.ec $(OBJ)ISEA7H.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,src/dggrs/ISEA7H.ec) -o $(call quote_path,$@) -symbols $(OBJ)

$(OBJ)HEALPixGrid.c: src/dggrs/HEALPixGrid.ec $(OBJ)HEALPixGrid.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,src/dggrs/HEALPixGrid.ec) -o $(call quote_path,$@) -symbols $(OBJ)

$(OBJ)RTEA7H.c: src/dggrs/RTEA7H.ec $(OBJ)RTEA7H.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,src/dggrs/RTEA7H.ec) -o $(call quote_path,$@) -symbols $(OBJ)

$(OBJ)RI4R.c: src/dggrs/RI4R.ec $(OBJ)RI4R.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,src/dggrs/RI4R.ec) -o $(call quote_path,$@) -symbols $(OBJ)

$(OBJ)IVEA4R.c: src/dggrs/IVEA4R.ec $(OBJ)IVEA4R.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,src/dggrs/IVEA4R.ec) -o $(call quote_path,$@) -symbols $(OBJ)

$(OBJ)ISEA4R.c: src/dggrs/ISEA4R.ec $(OBJ)ISEA4R.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,src/dggrs/ISEA4R.ec) -o $(call quote_path,$@) -symbols $(OBJ)

$(OBJ)RTEA4R.c: src/dggrs/RTEA4R.ec $(OBJ)RTEA4R.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,src/dggrs/RTEA4R.ec) -o $(call quote_path,$@) -symbols $(OBJ)

$(OBJ)RI7H_Z7.c: src/dggrs/RI7H_Z7.ec $(OBJ)RI7H_Z7.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,src/dggrs/RI7H_Z7.ec) -o $(call quote_path,$@) -symbols $(OBJ)

$(OBJ)ISEA7H_Z7.c: src/dggrs/ISEA7H_Z7.ec $(OBJ)ISEA7H_Z7.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,src/dggrs/ISEA7H_Z7.ec) -o $(call quote_path,$@) -symbols $(OBJ)

$(OBJ)IVEA7H_Z7.c: src/dggrs/IVEA7H_Z7.ec $(OBJ)IVEA7H_Z7.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,src/dggrs/IVEA7H_Z7.ec) -o $(call quote_path,$@) -symbols $(OBJ)

$(OBJ)RTEA7H_Z7.c: src/dggrs/RTEA7H_Z7.ec $(OBJ)RTEA7H_Z7.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,src/dggrs/RTEA7H_Z7.ec) -o $(call quote_path,$@) -symbols $(OBJ)

$(OBJ)ri5x6.c: src/projections/ri5x6.ec $(OBJ)ri5x6.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,src/projections/ri5x6.ec) -o $(call quote_path,$@) -symbols $(OBJ)

$(OBJ)authalic.c: src/projections/authalic.ec $(OBJ)authalic.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,src/projections/authalic.ec) -o $(call quote_path,$@) -symbols $(OBJ)

$(OBJ)barycentric5x6.c: src/projections/barycentric5x6.ec $(OBJ)barycentric5x6.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,src/projections/barycentric5x6.ec) -o $(call quote_path,$@) -symbols $(OBJ)

$(OBJ)icoVertexGreatCircle.c: src/projections/icoVertexGreatCircle.ec $(OBJ)icoVertexGreatCircle.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,src/projections/icoVertexGreatCircle.ec) -o $(call quote_path,$@) -symbols $(OBJ)

$(OBJ)rHEALPix.c: src/projections/rHEALPix.ec $(OBJ)rHEALPix.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,src/projections/rHEALPix.ec) -o $(call quote_path,$@) -symbols $(OBJ)

$(OBJ)dggsJSON.c: src/dggsJSON/dggsJSON.ec $(OBJ)dggsJSON.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,src/dggsJSON/dggsJSON.ec) -o $(call quote_path,$@) -symbols $(OBJ)

$(OBJ)JSONSchema.c: $(EC_SDK_SRC)/extras/JSONSchema.ec $(OBJ)JSONSchema.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(EC_SDK_SRC)/extras/JSONSchema.ec) -o $(call quote_path,$@) -symbols $(OBJ)

$(OBJ)Plane.c: src/ecere3D/Plane.ec $(OBJ)Plane.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,src/ecere3D/Plane.ec) -o $(call quote_path,$@) -symbols $(OBJ)

$(OBJ)Vector3D.c: src/ecere3D/Vector3D.ec $(OBJ)Vector3D.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,src/ecere3D/Vector3D.ec) -o $(call quote_path,$@) -symbols $(OBJ)

$(OBJ)Quaternion.c: src/ecere3D/Quaternion.ec $(OBJ)Quaternion.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,src/ecere3D/Quaternion.ec) -o $(call quote_path,$@) -symbols $(OBJ)

$(OBJ)GeoExtent.c: src/GeoExtent.ec $(OBJ)GeoExtent.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,src/GeoExtent.ec) -o $(call quote_path,$@) -symbols $(OBJ)

$(OBJ)dggrs.c: src/dggrs.ec $(OBJ)dggrs.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,src/dggrs.ec) -o $(call quote_path,$@) -symbols $(OBJ)

# OBJECT RULES

$(OBJ)I3HSubZones$(O): $(OBJ)I3HSubZones.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)I3HSubZones.c) -o $(call quote_path,$@)

$(OBJ)RI3H$(O): $(OBJ)RI3H.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)RI3H.c) -o $(call quote_path,$@)

$(OBJ)RI9R$(O): $(OBJ)RI9R.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)RI9R.c) -o $(call quote_path,$@)

$(OBJ)GNOSISGlobalGrid$(O): $(OBJ)GNOSISGlobalGrid.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)GNOSISGlobalGrid.c) -o $(call quote_path,$@)

$(OBJ)ISEA9R$(O): $(OBJ)ISEA9R.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)ISEA9R.c) -o $(call quote_path,$@)

$(OBJ)ISEA3H$(O): $(OBJ)ISEA3H.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)ISEA3H.c) -o $(call quote_path,$@)

$(OBJ)GPP3H$(O): $(OBJ)GPP3H.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)GPP3H.c) -o $(call quote_path,$@)

$(OBJ)IVEA3H$(O): $(OBJ)IVEA3H.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)IVEA3H.c) -o $(call quote_path,$@)

$(OBJ)IVEA9R$(O): $(OBJ)IVEA9R.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)IVEA9R.c) -o $(call quote_path,$@)

$(OBJ)BCTA3H$(O): $(OBJ)BCTA3H.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)BCTA3H.c) -o $(call quote_path,$@)

$(OBJ)RTEA3H$(O): $(OBJ)RTEA3H.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)RTEA3H.c) -o $(call quote_path,$@)

$(OBJ)RTEA9R$(O): $(OBJ)RTEA9R.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)RTEA9R.c) -o $(call quote_path,$@)

$(OBJ)rHEALPixGrid$(O): $(OBJ)rHEALPixGrid.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)rHEALPixGrid.c) -o $(call quote_path,$@)

$(OBJ)RI7H$(O): $(OBJ)RI7H.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)RI7H.c) -o $(call quote_path,$@)

$(OBJ)IVEA7H$(O): $(OBJ)IVEA7H.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)IVEA7H.c) -o $(call quote_path,$@)

$(OBJ)ISEA7H$(O): $(OBJ)ISEA7H.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)ISEA7H.c) -o $(call quote_path,$@)

$(OBJ)HEALPixGrid$(O): $(OBJ)HEALPixGrid.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)HEALPixGrid.c) -o $(call quote_path,$@)

$(OBJ)RTEA7H$(O): $(OBJ)RTEA7H.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)RTEA7H.c) -o $(call quote_path,$@)

$(OBJ)RI4R$(O): $(OBJ)RI4R.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)RI4R.c) -o $(call quote_path,$@)

$(OBJ)IVEA4R$(O): $(OBJ)IVEA4R.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)IVEA4R.c) -o $(call quote_path,$@)

$(OBJ)ISEA4R$(O): $(OBJ)ISEA4R.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)ISEA4R.c) -o $(call quote_path,$@)

$(OBJ)RTEA4R$(O): $(OBJ)RTEA4R.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)RTEA4R.c) -o $(call quote_path,$@)

$(OBJ)RI7H_Z7$(O): $(OBJ)RI7H_Z7.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)RI7H_Z7.c) -o $(call quote_path,$@)

$(OBJ)ISEA7H_Z7$(O): $(OBJ)ISEA7H_Z7.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)ISEA7H_Z7.c) -o $(call quote_path,$@)

$(OBJ)IVEA7H_Z7$(O): $(OBJ)IVEA7H_Z7.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)IVEA7H_Z7.c) -o $(call quote_path,$@)

$(OBJ)RTEA7H_Z7$(O): $(OBJ)RTEA7H_Z7.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)RTEA7H_Z7.c) -o $(call quote_path,$@)

$(OBJ)ri5x6$(O): $(OBJ)ri5x6.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)ri5x6.c) -o $(call quote_path,$@)

$(OBJ)authalic$(O): $(OBJ)authalic.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)authalic.c) -o $(call quote_path,$@)

$(OBJ)barycentric5x6$(O): $(OBJ)barycentric5x6.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)barycentric5x6.c) -o $(call quote_path,$@)

$(OBJ)icoVertexGreatCircle$(O): $(OBJ)icoVertexGreatCircle.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)icoVertexGreatCircle.c) -o $(call quote_path,$@)

$(OBJ)rHEALPix$(O): $(OBJ)rHEALPix.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)rHEALPix.c) -o $(call quote_path,$@)

$(OBJ)dggsJSON$(O): $(OBJ)dggsJSON.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)dggsJSON.c) -o $(call quote_path,$@)

$(OBJ)JSONSchema$(O): $(OBJ)JSONSchema.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)JSONSchema.c) -o $(call quote_path,$@)

$(OBJ)Plane$(O): $(OBJ)Plane.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)Plane.c) -o $(call quote_path,$@)

$(OBJ)Vector3D$(O): $(OBJ)Vector3D.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)Vector3D.c) -o $(call quote_path,$@)

$(OBJ)Quaternion$(O): $(OBJ)Quaternion.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)Quaternion.c) -o $(call quote_path,$@)

$(OBJ)GeoExtent$(O): $(OBJ)GeoExtent.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)GeoExtent.c) -o $(call quote_path,$@)

$(OBJ)dggrs$(O): $(OBJ)dggrs.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)dggrs.c) -o $(call quote_path,$@)

$(OBJ)$(MODULE).main$(O): $(OBJ)$(MODULE).main.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(OBJ)$(MODULE).main.c -o $(call quote_path,$@)

cleantarget:
	$(call rm,$(OBJ)$(MODULE).main$(O) $(OBJ)$(MODULE).main.c $(OBJ)$(MODULE).main.ec $(OBJ)$(MODULE).main$(I) $(OBJ)$(MODULE).main$(S))
	$(call rm,$(OBJ)symbols.lst)
	$(call rm,$(OBJ)objects.lst)
	$(call rm,$(TARGET))

clean: cleantarget
	$(call rm,$(_OBJECTS))
	$(call rm,$(_ECOBJECTS))
	$(call rm,$(_COBJECTS))
	$(call rm,$(_BOWLS))
	$(call rm,$(_IMPORTS))
	$(call rm,$(_SYMBOLS))

realclean: cleantarget
	$(call rmr,$(OBJ))

distclean: cleantarget
	$(call rmr,obj/)
	$(call rmr,.configs/)
	$(call rm,*.ews)
	$(call rm,*.Makefile)



================================================
FILE: Makefile.wasm
================================================
ifneq ($(V),1)
.SILENT:
endif

.PHONY: all clean

all:
	@echo "Building 32-bit DGGAL (host)..."
	+$(MAKE) -f Makefile.dggal ARCH=x32
	@echo "Building WebAssembly DGGAL..."
	+COMPILER=wasm $(MAKE) -f Makefile.dggal.static
	@echo "Building WebAssembly C bindings to DGGAL..."
	+cd bindings/c && COMPILER=wasm $(MAKE) -f Makefile.dggal_c.static
	@echo "Building WebAssembly C function bindings and JavaScript module for DGGAL..."
	+cd bindings/c_fn && COMPILER=wasm $(MAKE) -f Makefile.allinone
	@echo "All done!"

clean:
	+COMPILER=wasm $(MAKE) -f Makefile.dggal.static clean
	+cd bindings/c && COMPILER=wasm $(MAKE) -f Makefile.dggal_c.static clean
	+cd bindings/c_fn && COMPILER=wasm $(MAKE) -f Makefile.allinone clean



================================================
FILE: .onedev-buildspec.yml
================================================
version: 20
jobs:
- name: Build
  jobExecutor: DockerExecutor
  steps:
  - !CheckoutStep
    name: Checkout
    cloneCredential: !DefaultCredential {}
    withLfs: false
    withSubmodules: false
    condition: ALL_PREVIOUS_STEPS_WERE_SUCCESSFUL
  - !CommandStep
    name: Build
    runInContainer: true
    image: ubuntu:18.04
    interpreter: !DefaultInterpreter
      commands:
      - rm /etc/apt/apt.conf.d/docker-clean
      - echo 'Binary::apt::APT::Keep-Downloaded-Packages "true";' > /etc/apt/apt.conf.d/98keep-debs
      - echo 'APT::Keep-Downloaded-Packages "true";' > /etc/apt/apt.conf.d/99keep-debs
      - dpkg --add-architecture i386
      - apt -y update
      - apt -y install build-essential
      - apt -y install gcc-8
      - apt -y install g++-8
      - apt -y install gcc-multilib
      - apt -y install g++-8-multilib
      - apt -y install binutils-mingw-w64
      - apt -y install pkg-config
      - apt -y install python3-pip
#      - apt -y install rustc
# make ARCH=x32 py_bindings &&
# make ARCH=x32 rust_bindings &&
      - apt -y install curl && export RUSTUP_HOME="/usr" && export CARGO_HOME="/usr" && curl https://sh.rustup.rs -sSf | sh -s -- -y
      - pip3 install cffi
      - pip3 install importlib_metadata
      - tar xf mingw-w64/*.tar.gz &&
        tar xf mingw-w64-runtime/*.tar.gz &&
        dpkg -i mingw-w64-common_6.0.0-3_all.deb &&
        dpkg -i mingw-w64-x86-64-dev_6.0.0-3_all.deb &&
        dpkg -i mingw-w64-i686-dev_6.0.0-3_all.deb &&
        dpkg -i mingw-w64-tools_6.0.0-3_amd64.deb &&
        dpkg -i gcc-mingw-w64-base_8.4.0-1ubuntu1~18.04+21.4_amd64.deb &&
        dpkg -i gcc-mingw-w64-x86-64_8.4.0-1ubuntu1~18.04+21.4_amd64.deb &&
        dpkg -i gcc-mingw-w64-i686_8.4.0-1ubuntu1~18.04+21.4_amd64.deb &&
        dpkg -i gcc-mingw-w64_8.4.0-1ubuntu1~18.04+21.4_all.deb &&
        dpkg -i g++-mingw-w64-x86-64_8.4.0-1ubuntu1~18.04+21.4_amd64.deb &&
        dpkg -i g++-mingw-w64-i686_8.4.0-1ubuntu1~18.04+21.4_amd64.deb &&
        dpkg -i g++-mingw-w64_8.4.0-1ubuntu1~18.04+21.4_all.deb &&
        dpkg -i mingw-w64_6.0.0-3_all.deb
      - apt -y install make
      - apt -y install zlib1g-dev
      - apt -y install zlib1g-dev:i386
      - apt -y install git
      - apt -y install wine-stable
      - apt -y install wine64
      - update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-8 100
      - update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-8 100
      - tar xf eC/*output-linux*.tar.gz -C / &&
        tar xf eC/*extras*.tar.gz -C eC/ &&
        tar xf eC/*bindings*.tar.gz -C eC/ &&
        mkdir eC/obj/ && tar xf eC/*binaries-linux-x86_64.tar.gz -C eC/obj/ &&
        tar xf eC/*binaries-windows-x86_64.tar.gz -C eC/obj/ &&
        tar xf eC/*binaries-linux-i686.tar.gz -C eC/obj/ &&
        tar xf eC/*binaries-windows-i686.tar.gz -C eC/obj/ &&
        tar xf win32-patches/*.tar.gz &&
        tar xf zlib-win32/*zlib-windows-x64.tar.gz &&
        ln -sf $(pwd)/zlib-windows-x64/include/zlib.h /usr/x86_64-w64-mingw32/include/ &&
        ln -sf $(pwd)/zlib-windows-x64/include/zconf.h /usr/x86_64-w64-mingw32/include/ &&
        ln -sf $(pwd)/zlib-windows-x64/lib/libz.a /usr/x86_64-w64-mingw32/lib/ &&
        tar xf zlib-win32/*zlib-windows-x32.tar.gz &&
        ln -sf $(pwd)/zlib-windows-x32/include/zlib.h /usr/i686-w64-mingw32/include/ &&
        ln -sf $(pwd)/zlib-windows-x32/include/zconf /usr/i686-w64-mingw32/include/ &&
        ln -sf $(pwd)/zlib-windows-x32/lib/libz.a /usr/i686-w64-mingw32/lib/ &&
        tar xf upx/*linux-x86_64.tar.gz -C /usr/bin &&
        mkdir $(pwd)/.wine && export WINEPREFIX=$(pwd)/.wine &&
        git config --global --add safe.directory '*' &&
        export EC_SDK_SRC=$(pwd)/eC &&
        make STATIC_SYSLIBS=y -j2 && make test && mkdir linux && mkdir linux/bin && mkdir linux/lib &&
        cp obj/release.linux/libdggal.so linux/lib &&
        cp obj/static.linux/libdggalStatic.a linux/lib &&
        cp obj/static.linux/dgg linux/bin && cp obj/release.linux/dgg linux/bin/dgg-dynamic &&
        tar czf @project_name@-@tag@-@branch@-@commit_hash@-@build_number@-linux-x86_64.tar.gz linux &&
        make ARCH=x32 STATIC_SYSLIBS=y -j2 && make ARCH=x32 test && mkdir linux.x32 && mkdir linux.x32/bin && mkdir linux.x32/lib &&
        cp obj/release.linux.x32/libdggal.so linux.x32/lib &&
        cp obj/static.linux.x32/libdggalStatic.a linux.x32/lib &&
        cp obj/static.linux.x32/dgg32 linux.x32/bin && cp obj/release.linux.x32/dgg32 linux.x32/bin/dgg32-dynamic &&
        tar czf @project_name@-@tag@-@branch@-@commit_hash@-@build_number@-linux-i686.tar.gz linux.x32 &&
        rm /usr/bin/gcc && rm /usr/bin/g++ && ln -s /usr/bin/gcc-8 /usr/bin/gcc && ln -s /usr/bin/g++-8 /usr/bin/g++ &&
        make bindings &&
        rm /usr/bin/gcc && rm /usr/bin/g++ && ln -s /usr/bin/gcc-7 /usr/bin/gcc && ln -s /usr/bin/g++-7 /usr/bin/g++ &&
        make ARCH=x32 c_bindings &&
        rm /usr/bin/gcc && rm /usr/bin/g++ && ln -s /usr/bin/gcc-8 /usr/bin/gcc && ln -s /usr/bin/g++-8 /usr/bin/g++ &&
        make ARCH=x32 cpp_bindings &&
        rm /usr/bin/gcc && rm /usr/bin/g++ && ln -s /usr/bin/gcc-7 /usr/bin/gcc && ln -s /usr/bin/g++-7 /usr/bin/g++ &&
        make PLATFORM=win32 -j2 && make PLATFORM=win32 test &&
        make PLATFORM=win32 cpp_bindings &&
        mkdir windows && mkdir windows/bin && mkdir windows/lib &&
        cp obj/release.win32/dggal.dll windows/bin &&
        cp obj/static.win32/libdggalStatic.a windows/lib &&
        cp obj/release.win32/dgg.exe windows/bin/dgg-dynamic.exe &&
        cp obj/static.win32/dgg.exe windows/bin &&
        tar czf @project_name@-@tag@-@branch@-@commit_hash@-@build_number@-windows-x86_64.tar.gz windows &&
        make PLATFORM=win32 ARCH=x32 -j2 && make PLATFORM=win32 ARCH=x32 test &&
        make PLATFORM=win32 ARCH=x32 cpp_bindings &&
        mkdir windows.x32 && mkdir windows.x32/bin && mkdir windows.x32/lib &&
        cp obj/release.win32.x32/dggal.dll windows.x32/bin &&
        cp obj/static.win32.x32/libdggalStatic.a windows.x32/lib &&
        cp obj/release.win32.x32/dgg32.exe windows.x32/bin/dgg32-dynamic.exe &&
        cp obj/static.win32.x32/dgg32.exe windows.x32/bin &&
        tar czf @project_name@-@tag@-@branch@-@commit_hash@-@build_number@-windows-i686.tar.gz windows.x32 &&
        tar czf @project_name@-@tag@-@branch@-@commit_hash@-@build_number@-bindings.tar.gz bindings/
    useTTY: true
    condition: ALL_PREVIOUS_STEPS_WERE_SUCCESSFUL
  - !PublishArtifactStep
    name: Artefacts
    artifacts: '@project_name@-@tag@-@branch@-@commit_hash@-@build_number@-linux-x86_64.tar.gz'
    condition: ALL_PREVIOUS_STEPS_WERE_SUCCESSFUL
  - !PublishArtifactStep
    name: Artefacts32bit
    artifacts: '@project_name@-@tag@-@branch@-@commit_hash@-@build_number@-linux-i686.tar.gz'
    condition: ALL_PREVIOUS_STEPS_WERE_SUCCESSFUL
  - !PublishArtifactStep
    name: ArtefactsWindows
    artifacts: '@project_name@-@tag@-@branch@-@commit_hash@-@build_number@-windows-x86_64.tar.gz'
    condition: ALL_PREVIOUS_STEPS_WERE_SUCCESSFUL
  - !PublishArtifactStep
    name: ArtefactsWindows32Bit
    artifacts: '@project_name@-@tag@-@branch@-@commit_hash@-@build_number@-windows-i686.tar.gz'
    condition: ALL_PREVIOUS_STEPS_WERE_SUCCESSFUL
  - !PublishArtifactStep
    name: ArtefactsBindings
    artifacts: '@project_name@-@tag@-@branch@-@commit_hash@-@build_number@-bindings.tar.gz'
    condition: ALL_PREVIOUS_STEPS_WERE_SUCCESSFUL
  triggers:
  - !PullRequestUpdateTrigger
    projects: dggal
  - !BranchUpdateTrigger
    projects: dggal
  projectDependencies:
  - projectPath: zlib-win32
    buildProvider: !LastFinishedBuild
      jobName: Build
      refName: refs/heads/main
    artifacts: '**'
    accessTokenSecret: ecere-sdk-access
    destinationPath: zlib-win32
  - projectPath: win32-patches
    buildProvider: !LastFinishedBuild
      jobName: Build
      refName: refs/heads/master
    artifacts: '**'
    accessTokenSecret: ecere-sdk-access
    destinationPath: win32-patches
  - projectPath: eC
    buildProvider: !LastFinishedBuild
      jobName: Build
      refName: refs/heads/main
    artifacts: '**'
    accessTokenSecret: ecere-sdk-access
    destinationPath: eC
  - projectPath: upx
    buildProvider: !LastFinishedBuild
      jobName: Build
      refName: refs/heads/master
    artifacts: '**'
    accessTokenSecret: ecere-sdk-access
    destinationPath: upx
  - projectPath: mingw-w64
    buildProvider: !LastFinishedBuild
      jobName: Build
      refName: refs/heads/master
    artifacts: '**'
    accessTokenSecret: ecere-sdk-access
    destinationPath: mingw-w64
  - projectPath: mingw-w64-runtime
    buildProvider: !LastFinishedBuild
      jobName: Build
      refName: refs/heads/master
    artifacts: '**'
    accessTokenSecret: ecere-sdk-access
    destinationPath: mingw-w64-runtime
  retryCondition: never
  maxRetries: 3
  retryDelay: 30
  caches:
  - key: AptCache
    path: /var/cache/apt
  - key: AptList
    path: /var/lib/apt/lists
  timeout: 3600
  postBuildActions:
  - !SendNotificationAction
    condition: failed or (successful and previous is failed)
    receivers: committers and submitter



================================================
FILE: bindings/c/dggal.c
================================================
#include "dggal.h"

#if defined(EC_STATIC)
// REVIEW: Clashes between function pointers and functions building statically?
#define i3HZoneFromI9R fnptr_i3HZoneFromI9R
#define i9RZoneFromI3H fnptr_i9RZoneFromI3H
#define authalicSetup fnptr_authalicSetup
#define canonicalize5x6 fnptr_canonicalize5x6
#define compactGGGZones fnptr_compactGGGZones
#define latAuthalicToGeodetic fnptr_latAuthalicToGeodetic
#define latGeodeticToAuthalic fnptr_latGeodeticToAuthalic
#define readDGGSJSON fnptr_readDGGSJSON
#endif

// Global Functions Pointers

LIB_EXPORT C(GlobalFunction) * FUNCTION(i3HZoneFromI9R);
LIB_EXPORT C(GlobalFunction) * FUNCTION(i9RZoneFromI3H);
LIB_EXPORT C(GlobalFunction) * FUNCTION(authalicSetup);
LIB_EXPORT C(GlobalFunction) * FUNCTION(canonicalize5x6);
LIB_EXPORT C(GlobalFunction) * FUNCTION(compactGGGZones);
LIB_EXPORT C(GlobalFunction) * FUNCTION(latAuthalicToGeodetic);
LIB_EXPORT C(GlobalFunction) * FUNCTION(latGeodeticToAuthalic);
LIB_EXPORT C(GlobalFunction) * FUNCTION(readDGGSJSON);



// Virtual Methods

LIB_EXPORT C(Method) * METHOD(DGGRS, areZonesNeighbors);
LIB_EXPORT C(Method) * METHOD(DGGRS, areZonesSiblings);
LIB_EXPORT C(Method) * METHOD(DGGRS, compactZones);
LIB_EXPORT C(Method) * METHOD(DGGRS, countSubZones);
LIB_EXPORT C(Method) * METHOD(DGGRS, countZoneEdges);
LIB_EXPORT C(Method) * METHOD(DGGRS, countZones);
LIB_EXPORT C(Method) * METHOD(DGGRS, doZonesOverlap);
LIB_EXPORT C(Method) * METHOD(DGGRS, doesZoneContain);
LIB_EXPORT C(Method) * METHOD(DGGRS, get64KDepth);
LIB_EXPORT C(Method) * METHOD(DGGRS, getFirstSubZone);
LIB_EXPORT C(Method) * METHOD(DGGRS, getIndexMaxDepth);
LIB_EXPORT C(Method) * METHOD(DGGRS, getLevelFromMetersPerSubZone);
LIB_EXPORT C(Method) * METHOD(DGGRS, getLevelFromPixelsAndExtent);
LIB_EXPORT C(Method) * METHOD(DGGRS, getLevelFromRefZoneArea);
LIB_EXPORT C(Method) * METHOD(DGGRS, getLevelFromScaleDenominator);
LIB_EXPORT C(Method) * METHOD(DGGRS, getMaxChildren);
LIB_EXPORT C(Method) * METHOD(DGGRS, getMaxDGGRSZoneLevel);
LIB_EXPORT C(Method) * METHOD(DGGRS, getMaxDepth);
LIB_EXPORT C(Method) * METHOD(DGGRS, getMaxNeighbors);
LIB_EXPORT C(Method) * METHOD(DGGRS, getMaxParents);
LIB_EXPORT C(Method) * METHOD(DGGRS, getMetersPerSubZoneFromLevel);
LIB_EXPORT C(Method) * METHOD(DGGRS, getRefZoneArea);
LIB_EXPORT C(Method) * METHOD(DGGRS, getRefinementRatio);
LIB_EXPORT C(Method) * METHOD(DGGRS, getScaleDenominatorFromLevel);
LIB_EXPORT C(Method) * METHOD(DGGRS, getSubZoneAtIndex);
LIB_EXPORT C(Method) * METHOD(DGGRS, getSubZoneCRSCentroids);
LIB_EXPORT C(Method) * METHOD(DGGRS, getSubZoneIndex);
LIB_EXPORT C(Method) * METHOD(DGGRS, getSubZoneWGS84Centroids);
LIB_EXPORT C(Method) * METHOD(DGGRS, getSubZones);
LIB_EXPORT C(Method) * METHOD(DGGRS, getZoneArea);
LIB_EXPORT C(Method) * METHOD(DGGRS, getZoneCRSCentroid);
LIB_EXPORT C(Method) * METHOD(DGGRS, getZoneCRSExtent);
LIB_EXPORT C(Method) * METHOD(DGGRS, getZoneCRSVertices);
LIB_EXPORT C(Method) * METHOD(DGGRS, getZoneCentroidChild);
LIB_EXPORT C(Method) * METHOD(DGGRS, getZoneCentroidParent);
LIB_EXPORT C(Method) * METHOD(DGGRS, getZoneChildren);
LIB_EXPORT C(Method) * METHOD(DGGRS, getZoneFromCRSCentroid);
LIB_EXPORT C(Method) * METHOD(DGGRS, getZoneFromTextID);
LIB_EXPORT C(Method) * METHOD(DGGRS, getZoneFromWGS84Centroid);
LIB_EXPORT C(Method) * METHOD(DGGRS, getZoneLevel);
LIB_EXPORT C(Method) * METHOD(DGGRS, getZoneNeighbors);
LIB_EXPORT C(Method) * METHOD(DGGRS, getZoneParents);
LIB_EXPORT C(Method) * METHOD(DGGRS, getZoneRefinedCRSVertices);
LIB_EXPORT C(Method) * METHOD(DGGRS, getZoneRefinedWGS84Vertices);
LIB_EXPORT C(Method) * METHOD(DGGRS, getZoneTextID);
LIB_EXPORT C(Method) * METHOD(DGGRS, getZoneWGS84Centroid);
LIB_EXPORT C(Method) * METHOD(DGGRS, getZoneWGS84Extent);
LIB_EXPORT C(Method) * METHOD(DGGRS, getZoneWGS84ExtentApproximate);
LIB_EXPORT C(Method) * METHOD(DGGRS, getZoneWGS84Vertices);
LIB_EXPORT C(Method) * METHOD(DGGRS, isZoneAncestorOf);
LIB_EXPORT C(Method) * METHOD(DGGRS, isZoneCentroidChild);
LIB_EXPORT C(Method) * METHOD(DGGRS, isZoneContainedIn);
LIB_EXPORT C(Method) * METHOD(DGGRS, isZoneDescendantOf);
LIB_EXPORT C(Method) * METHOD(DGGRS, isZoneImmediateChildOf);
LIB_EXPORT C(Method) * METHOD(DGGRS, isZoneImmediateParentOf);
LIB_EXPORT C(Method) * METHOD(DGGRS, listZones);
LIB_EXPORT C(Method) * METHOD(DGGRS, zoneHasSubZone);

LIB_EXPORT C(Method) * METHOD(GeoExtent, clear);
LIB_EXPORT C(Method) * METHOD(GeoExtent, clip);
LIB_EXPORT C(Method) * METHOD(GeoExtent, clipHandlingDateline);
LIB_EXPORT C(Method) * METHOD(GeoExtent, doUnionDL);
LIB_EXPORT C(Method) * METHOD(GeoExtent, intersects);

LIB_EXPORT C(Method) * METHOD(HEALPixProjection, forward);
LIB_EXPORT C(Method) * METHOD(HEALPixProjection, inverse);

LIB_EXPORT C(Method) * METHOD(Plane, fromPoints);

LIB_EXPORT C(Method) * METHOD(Quaternion, yawPitch);

LIB_EXPORT C(Method) * METHOD(RI5x6Projection, extent5x6FromWGS84);
LIB_EXPORT C(Method) * METHOD(RI5x6Projection, forward);
LIB_EXPORT C(Method) * METHOD(RI5x6Projection, fromIcosahedronNet);
LIB_EXPORT C(Method) * METHOD(RI5x6Projection, inverse);
LIB_EXPORT C(Method) * METHOD(RI5x6Projection, toIcosahedronNet);

LIB_EXPORT C(Method) * METHOD(Vector3D, crossProduct);
LIB_EXPORT C(Method) * METHOD(Vector3D, dotProduct);
LIB_EXPORT C(Method) * METHOD(Vector3D, multQuaternion);
LIB_EXPORT C(Method) * METHOD(Vector3D, normalize);
LIB_EXPORT C(Method) * METHOD(Vector3D, subtract);

LIB_EXPORT C(Method) * METHOD(Z7Zone, from7H);
LIB_EXPORT C(Method) * METHOD(Z7Zone, fromTextID);
LIB_EXPORT C(Method) * METHOD(Z7Zone, getParentRotationOffset);
LIB_EXPORT C(Method) * METHOD(Z7Zone, getTextID);
LIB_EXPORT C(Method) * METHOD(Z7Zone, to7H);




// Methods Function Pointers

LIB_EXPORT C(bool) (* DGGRS_areZonesNeighbors)(C(DGGRS) __this, C(DGGRSZone) a, C(DGGRSZone) b);
LIB_EXPORT C(bool) (* DGGRS_areZonesSiblings)(C(DGGRS) __this, C(DGGRSZone) a, C(DGGRSZone) b);
LIB_EXPORT C(bool) (* DGGRS_doZonesOverlap)(C(DGGRS) __this, C(DGGRSZone) a, C(DGGRSZone) b);
LIB_EXPORT C(bool) (* DGGRS_doesZoneContain)(C(DGGRS) __this, C(DGGRSZone) hayStack, C(DGGRSZone) needle);
LIB_EXPORT int (* DGGRS_get64KDepth)(C(DGGRS) __this);
LIB_EXPORT int (* DGGRS_getLevelFromMetersPerSubZone)(C(DGGRS) __this, double physicalMetersPerSubZone, int relativeDepth);
LIB_EXPORT int (* DGGRS_getLevelFromPixelsAndExtent)(C(DGGRS) __this, const C(GeoExtent) * extent, const C(Point) * pixels, int relativeDepth);
LIB_EXPORT int (* DGGRS_getLevelFromRefZoneArea)(C(DGGRS) __this, double metersSquared);
LIB_EXPORT int (* DGGRS_getLevelFromScaleDenominator)(C(DGGRS) __this, double scaleDenominator, int relativeDepth, double mmPerPixel);
LIB_EXPORT int (* DGGRS_getMaxDepth)(C(DGGRS) __this);
LIB_EXPORT double (* DGGRS_getMetersPerSubZoneFromLevel)(C(DGGRS) __this, int parentLevel, int relativeDepth);
LIB_EXPORT double (* DGGRS_getRefZoneArea)(C(DGGRS) __this, int level);
LIB_EXPORT double (* DGGRS_getScaleDenominatorFromLevel)(C(DGGRS) __this, int parentLevel, int relativeDepth, double mmPerPixel);
LIB_EXPORT C(bool) (* DGGRS_isZoneAncestorOf)(C(DGGRS) __this, C(DGGRSZone) ancestor, C(DGGRSZone) descendant, int maxDepth);
LIB_EXPORT C(bool) (* DGGRS_isZoneContainedIn)(C(DGGRS) __this, C(DGGRSZone) needle, C(DGGRSZone) hayStack);
LIB_EXPORT C(bool) (* DGGRS_isZoneDescendantOf)(C(DGGRS) __this, C(DGGRSZone) descendant, C(DGGRSZone) ancestor, int maxDepth);
LIB_EXPORT C(bool) (* DGGRS_isZoneImmediateChildOf)(C(DGGRS) __this, C(DGGRSZone) child, C(DGGRSZone) parent);
LIB_EXPORT C(bool) (* DGGRS_isZoneImmediateParentOf)(C(DGGRS) __this, C(DGGRSZone) parent, C(DGGRSZone) child);

LIB_EXPORT void (* GeoExtent_clear)(C(GeoExtent) * __this);
LIB_EXPORT C(bool) (* GeoExtent_clip)(C(GeoExtent) * __this, const C(GeoExtent) * e, const C(GeoExtent) * clipExtent);
LIB_EXPORT C(bool) (* GeoExtent_clipHandlingDateline)(C(GeoExtent) * __this, const C(GeoExtent) * e, const C(GeoExtent) * clipExtent);
LIB_EXPORT void (* GeoExtent_doUnionDL)(C(GeoExtent) * __this, const C(GeoExtent) * e);
LIB_EXPORT C(bool) (* GeoExtent_intersects)(C(GeoExtent) * __this, const C(GeoExtent) * b);


LIB_EXPORT void (* Plane_fromPoints)(C(Plane) * __this, const C(Vector3D) * v1, const C(Vector3D) * v2, const C(Vector3D) * v3);

LIB_EXPORT void (* Quaternion_yawPitch)(C(Quaternion) * __this, C(Angle) yaw, C(Angle) pitch);

LIB_EXPORT void (* RI5x6Projection_extent5x6FromWGS84)(C(RI5x6Projection) __this, const C(GeoExtent) * wgs84Extent, C(Pointd) * topLeft, C(Pointd) * bottomRight);
LIB_EXPORT C(bool) (* RI5x6Projection_fromIcosahedronNet)(const C(Pointd) * v, C(Pointd) * result);
LIB_EXPORT C(bool) (* RI5x6Projection_toIcosahedronNet)(const C(Pointd) * v, C(Pointd) * result);

LIB_EXPORT void (* Vector3D_crossProduct)(C(Vector3D) * __this, const C(Vector3D) * vector1, const C(Vector3D) * vector2);
LIB_EXPORT double (* Vector3D_dotProduct)(C(Vector3D) * __this, const C(Vector3D) * vector2);
LIB_EXPORT void (* Vector3D_multQuaternion)(C(Vector3D) * __this, const C(Vector3D) * s, const C(Quaternion) * quat);
LIB_EXPORT void (* Vector3D_normalize)(C(Vector3D) * __this, const C(Vector3D) * source);
LIB_EXPORT void (* Vector3D_subtract)(C(Vector3D) * __this, const C(Vector3D) * vector1, const C(Vector3D) * vector2);

LIB_EXPORT C(Z7Zone) (* Z7Zone_from7H)(C(I7HZone) zone);
LIB_EXPORT C(Z7Zone) (* Z7Zone_fromTextID)(constString zoneID);
LIB_EXPORT int (* Z7Zone_getParentRotationOffset)(C(I7HZone) zone);
LIB_EXPORT void (* Z7Zone_getTextID)(C(Z7Zone) __this, C(String) zoneID);
LIB_EXPORT C(I7HZone) (* Z7Zone_to7H)(C(Z7Zone) __this);



LIB_EXPORT C(Property) * PROPERTY(GeoExtent, nonNull);
LIB_EXPORT C(bool) (* GeoExtent_get_nonNull)(const C(GeoExtent) * g);

LIB_EXPORT C(Property) * PROPERTY(GeoExtent, geodeticArea);
LIB_EXPORT double (* GeoExtent_get_geodeticArea)(const C(GeoExtent) * g);

LIB_EXPORT C(Property) * PROPERTY(JSONSchema, maximum);
LIB_EXPORT double (* JSONSchema_get_maximum)(const C(JSONSchema) j);
LIB_EXPORT C(bool) (* JSONSchema_isSet_maximum)(const C(JSONSchema) j);

LIB_EXPORT C(Property) * PROPERTY(JSONSchema, exclusiveMaximum);
LIB_EXPORT double (* JSONSchema_get_exclusiveMaximum)(const C(JSONSchema) j);
LIB_EXPORT C(bool) (* JSONSchema_isSet_exclusiveMaximum)(const C(JSONSchema) j);

LIB_EXPORT C(Property) * PROPERTY(JSONSchema, minimum);
LIB_EXPORT double (* JSONSchema_get_minimum)(const C(JSONSchema) j);
LIB_EXPORT C(bool) (* JSONSchema_isSet_minimum)(const C(JSONSchema) j);

LIB_EXPORT C(Property) * PROPERTY(JSONSchema, exclusiveMinimum);
LIB_EXPORT double (* JSONSchema_get_exclusiveMinimum)(const C(JSONSchema) j);
LIB_EXPORT C(bool) (* JSONSchema_isSet_exclusiveMinimum)(const C(JSONSchema) j);

LIB_EXPORT C(Property) * PROPERTY(JSONSchema, maxItems);
LIB_EXPORT int (* JSONSchema_get_maxItems)(const C(JSONSchema) j);
LIB_EXPORT C(bool) (* JSONSchema_isSet_maxItems)(const C(JSONSchema) j);

LIB_EXPORT C(Property) * PROPERTY(JSONSchema, minItems);
LIB_EXPORT int (* JSONSchema_get_minItems)(const C(JSONSchema) j);
LIB_EXPORT C(bool) (* JSONSchema_isSet_minItems)(const C(JSONSchema) j);

LIB_EXPORT C(Property) * PROPERTY(JSONSchema, maxProperties);
LIB_EXPORT int (* JSONSchema_get_maxProperties)(const C(JSONSchema) j);
LIB_EXPORT C(bool) (* JSONSchema_isSet_maxProperties)(const C(JSONSchema) j);

LIB_EXPORT C(Property) * PROPERTY(JSONSchema, minProperties);
LIB_EXPORT int (* JSONSchema_get_minProperties)(const C(JSONSchema) j);
LIB_EXPORT C(bool) (* JSONSchema_isSet_minProperties)(const C(JSONSchema) j);

LIB_EXPORT C(Property) * PROPERTY(JSONSchema, xogcpropertySeq);
LIB_EXPORT C(bool) (* JSONSchema_isSet_xogcpropertySeq)(const C(JSONSchema) j);

LIB_EXPORT C(Property) * PROPERTY(JSONSchema, Default);
LIB_EXPORT C(bool) (* JSONSchema_isSet_Default)(const C(JSONSchema) j);

LIB_EXPORT C(Property) * PROPERTY(Vector3D, length);
LIB_EXPORT double (* Vector3D_get_length)(const C(Vector3D) * v);


// Properties




// Classes

// bitClass
LIB_EXPORT C(Class) * CO(CRS);
LIB_EXPORT C(Class) * CO(DGGRSZone);
LIB_EXPORT C(Class) * CO(GGGZone);
LIB_EXPORT C(Class) * CO(HPZone);
LIB_EXPORT C(Class) * CO(I3HZone);
LIB_EXPORT C(Class) * CO(I4RZone);
LIB_EXPORT C(Class) * CO(I7HZone);
LIB_EXPORT C(Class) * CO(I9RZone);
LIB_EXPORT C(Class) * CO(RHPZone);
LIB_EXPORT C(Class) * CO(Z7Zone);
// enumClass
LIB_EXPORT C(Class) * CO(CRSRegistry);
LIB_EXPORT C(Class) * CO(I3HNeighbor);
LIB_EXPORT C(Class) * CO(JSONSchemaType);
LIB_EXPORT C(Class) * CO(VGCRadialVertex);
// unitClass
// systemClass
// structClass
LIB_EXPORT C(Class) * CO(CRSExtent);
LIB_EXPORT C(Class) * CO(GeoExtent);
LIB_EXPORT C(Class) * CO(GeoPoint);
LIB_EXPORT C(Class) * CO(Plane);
LIB_EXPORT C(Class) * CO(Quaternion);
LIB_EXPORT C(Class) * CO(Vector3D);
// noHeadClass
// normalClass
LIB_EXPORT C(Class) * CO(BCTA3H);
LIB_EXPORT C(Class) * CO(BarycentricSphericalTriAreaProjection);
LIB_EXPORT C(Class) * CO(DGGRS);
LIB_EXPORT C(Class) * CO(DGGSJSON);
LIB_EXPORT C(Class) * CO(DGGSJSONDepth);
LIB_EXPORT C(Class) * CO(DGGSJSONDimension);
LIB_EXPORT C(Class) * CO(DGGSJSONGrid);
LIB_EXPORT C(Class) * CO(DGGSJSONShape);
LIB_EXPORT C(Class) * CO(GNOSISGlobalGrid);
LIB_EXPORT C(Class) * CO(GPP3H);
LIB_EXPORT C(Class) * CO(GoldbergPolyhedraProjection);
LIB_EXPORT C(Class) * CO(HEALPix);
LIB_EXPORT C(Class) * CO(HEALPixProjection);
LIB_EXPORT C(Class) * CO(ISEA3H);
LIB_EXPORT C(Class) * CO(ISEA4R);
LIB_EXPORT C(Class) * CO(ISEA7H);
LIB_EXPORT C(Class) * CO(ISEA7H_Z7);
LIB_EXPORT C(Class) * CO(ISEA9R);
LIB_EXPORT C(Class) * CO(ISEAProjection);
LIB_EXPORT C(Class) * CO(IVEA3H);
LIB_EXPORT C(Class) * CO(IVEA4R);
LIB_EXPORT C(Class) * CO(IVEA7H);
LIB_EXPORT C(Class) * CO(IVEA7H_Z7);
LIB_EXPORT C(Class) * CO(IVEA9R);
LIB_EXPORT C(Class) * CO(IVEAProjection);
LIB_EXPORT C(Class) * CO(JSONSchema);
LIB_EXPORT C(Class) * CO(RI5x6Projection);
LIB_EXPORT C(Class) * CO(RI7H_Z7);
LIB_EXPORT C(Class) * CO(RTEA3H);
LIB_EXPORT C(Class) * CO(RTEA4R);
LIB_EXPORT C(Class) * CO(RTEA7H);
LIB_EXPORT C(Class) * CO(RTEA7H_Z7);
LIB_EXPORT C(Class) * CO(RTEA9R);
LIB_EXPORT C(Class) * CO(RTEAProjection);
LIB_EXPORT C(Class) * CO(RhombicIcosahedral3H);
LIB_EXPORT C(Class) * CO(RhombicIcosahedral4R);
LIB_EXPORT C(Class) * CO(RhombicIcosahedral7H);
LIB_EXPORT C(Class) * CO(RhombicIcosahedral9R);
LIB_EXPORT C(Class) * CO(SliceAndDiceGreatCircleIcosahedralProjection);
LIB_EXPORT C(Class) * CO(rHEALPix);
LIB_EXPORT C(Class) * CO(rHEALPixProjection);



// Virtual Method IDs

LIB_EXPORT int M_VTBLID(DGGRS, compactZones);
LIB_EXPORT int M_VTBLID(DGGRS, countSubZones);
LIB_EXPORT int M_VTBLID(DGGRS, countZoneEdges);
LIB_EXPORT int M_VTBLID(DGGRS, countZones);
LIB_EXPORT int M_VTBLID(DGGRS, getFirstSubZone);
LIB_EXPORT int M_VTBLID(DGGRS, getIndexMaxDepth);
LIB_EXPORT int M_VTBLID(DGGRS, getMaxChildren);
LIB_EXPORT int M_VTBLID(DGGRS, getMaxDGGRSZoneLevel);
LIB_EXPORT int M_VTBLID(DGGRS, getMaxNeighbors);
LIB_EXPORT int M_VTBLID(DGGRS, getMaxParents);
LIB_EXPORT int M_VTBLID(DGGRS, getRefinementRatio);
LIB_EXPORT int M_VTBLID(DGGRS, getSubZoneAtIndex);
LIB_EXPORT int M_VTBLID(DGGRS, getSubZoneCRSCentroids);
LIB_EXPORT int M_VTBLID(DGGRS, getSubZoneIndex);
LIB_EXPORT int M_VTBLID(DGGRS, getSubZoneWGS84Centroids);
LIB_EXPORT int M_VTBLID(DGGRS, getSubZones);
LIB_EXPORT int M_VTBLID(DGGRS, getZoneArea);
LIB_EXPORT int M_VTBLID(DGGRS, getZoneCRSCentroid);
LIB_EXPORT int M_VTBLID(DGGRS, getZoneCRSExtent);
LIB_EXPORT int M_VTBLID(DGGRS, getZoneCRSVertices);
LIB_EXPORT int M_VTBLID(DGGRS, getZoneCentroidChild);
LIB_EXPORT int M_VTBLID(DGGRS, getZoneCentroidParent);
LIB_EXPORT int M_VTBLID(DGGRS, getZoneChildren);
LIB_EXPORT int M_VTBLID(DGGRS, getZoneFromCRSCentroid);
LIB_EXPORT int M_VTBLID(DGGRS, getZoneFromTextID);
LIB_EXPORT int M_VTBLID(DGGRS, getZoneFromWGS84Centroid);
LIB_EXPORT int M_VTBLID(DGGRS, getZoneLevel);
LIB_EXPORT int M_VTBLID(DGGRS, getZoneNeighbors);
LIB_EXPORT int M_VTBLID(DGGRS, getZoneParents);
LIB_EXPORT int M_VTBLID(DGGRS, getZoneRefinedCRSVertices);
LIB_EXPORT int M_VTBLID(DGGRS, getZoneRefinedWGS84Vertices);
LIB_EXPORT int M_VTBLID(DGGRS, getZoneTextID);
LIB_EXPORT int M_VTBLID(DGGRS, getZoneWGS84Centroid);
LIB_EXPORT int M_VTBLID(DGGRS, getZoneWGS84Extent);
LIB_EXPORT int M_VTBLID(DGGRS, getZoneWGS84ExtentApproximate);
LIB_EXPORT int M_VTBLID(DGGRS, getZoneWGS84Vertices);
LIB_EXPORT int M_VTBLID(DGGRS, isZoneCentroidChild);
LIB_EXPORT int M_VTBLID(DGGRS, listZones);
LIB_EXPORT int M_VTBLID(DGGRS, zoneHasSubZone);

LIB_EXPORT int M_VTBLID(HEALPixProjection, forward);
LIB_EXPORT int M_VTBLID(HEALPixProjection, inverse);

LIB_EXPORT int M_VTBLID(RI5x6Projection, forward);
LIB_EXPORT int M_VTBLID(RI5x6Projection, inverse);

#ifdef EC_STATIC
unsigned int __eCDll_Load_dggal(C(Module) * module);
unsigned int __eCDll_Unload_dggal(C(Module) * module);
#endif


// Global Functions

LIB_EXPORT C(I3HZone) (* F(i3HZoneFromI9R))(C(I9RZone) zone, char subHex);
LIB_EXPORT C(I9RZone) (* F(i9RZoneFromI3H))(C(I3HZone) zone);
LIB_EXPORT void (* F(authalicSetup))(double a, double b, double * cp /*[2][6]*/);
LIB_EXPORT void (* F(canonicalize5x6))(const C(Pointd) * _src, C(Pointd) * out);
LIB_EXPORT void (* F(compactGGGZones))(C(Array) zones, int start, int maxLevel);
LIB_EXPORT C(Angle) (* F(latAuthalicToGeodetic))(const double * cp /*[2][6]*/, C(Angle) phi);
LIB_EXPORT C(Angle) (* F(latGeodeticToAuthalic))(const double * cp /*[2][6]*/, C(Angle) phi);
LIB_EXPORT C(DGGSJSON) (* F(readDGGSJSON))(C(File) f);


LIB_EXPORT C(Module) dggal_init(C(Module) fromModule)
{
#ifdef EC_STATIC
   C(Module) module = Module_loadStatic(fromModule, DGGAL_MODULE_NAME, true, (void *)(__eCDll_Load_dggal), (void *)(__eCDll_Unload_dggal));
#else
   C(Module) module = Module_load(fromModule, DGGAL_MODULE_NAME, AccessMode_publicAccess);
#endif

#ifdef _DEBUG
   // printf("%s_init\n", "dggal");
#endif

   if(module)
   {
      // Set up all the CO(x) *, property, method, ...


      CO(BCTA3H) = eC_findClass(module, "BCTA3H");
      CO(BarycentricSphericalTriAreaProjection) = eC_findClass(module, "BarycentricSphericalTriAreaProjection");
      CO(CRS) = eC_findClass(module, "CRS");
      CO(CRSExtent) = eC_findClass(module, "CRSExtent");
      CO(CRSRegistry) = eC_findClass(module, "CRSRegistry");
      CO(DGGRS) = eC_findClass(module, "DGGRS");
      if(CO(DGGRS))
      {
         METHOD(DGGRS, areZonesNeighbors) = Class_findMethod(CO(DGGRS), "areZonesNeighbors", module);
         if(METHOD(DGGRS, areZonesNeighbors))
            DGGRS_areZonesNeighbors = (C(bool) (*)(C(DGGRS), C(DGGRSZone), C(DGGRSZone)))METHOD(DGGRS, areZonesNeighbors)->function;

         METHOD(DGGRS, areZonesSiblings) = Class_findMethod(CO(DGGRS), "areZonesSiblings", module);
         if(METHOD(DGGRS, areZonesSiblings))
            DGGRS_areZonesSiblings = (C(bool) (*)(C(DGGRS), C(DGGRSZone), C(DGGRSZone)))METHOD(DGGRS, areZonesSiblings)->function;

         METHOD(DGGRS, compactZones) = Class_findMethod(CO(DGGRS), "compactZones", module);
         if(METHOD(DGGRS, compactZones))
            M_VTBLID(DGGRS, compactZones) = METHOD(DGGRS, compactZones)->vid;

         METHOD(DGGRS, countSubZones) = Class_findMethod(CO(DGGRS), "countSubZones", module);
         if(METHOD(DGGRS, countSubZones))
            M_VTBLID(DGGRS, countSubZones) = METHOD(DGGRS, countSubZones)->vid;

         METHOD(DGGRS, countZoneEdges) = Class_findMethod(CO(DGGRS), "countZoneEdges", module);
         if(METHOD(DGGRS, countZoneEdges))
            M_VTBLID(DGGRS, countZoneEdges) = METHOD(DGGRS, countZoneEdges)->vid;

         METHOD(DGGRS, countZones) = Class_findMethod(CO(DGGRS), "countZones", module);
         if(METHOD(DGGRS, countZones))
            M_VTBLID(DGGRS, countZones) = METHOD(DGGRS, countZones)->vid;

         METHOD(DGGRS, doZonesOverlap) = Class_findMethod(CO(DGGRS), "doZonesOverlap", module);
         if(METHOD(DGGRS, doZonesOverlap))
            DGGRS_doZonesOverlap = (C(bool) (*)(C(DGGRS), C(DGGRSZone), C(DGGRSZone)))METHOD(DGGRS, doZonesOverlap)->function;

         METHOD(DGGRS, doesZoneContain) = Class_findMethod(CO(DGGRS), "doesZoneContain", module);
         if(METHOD(DGGRS, doesZoneContain))
            DGGRS_doesZoneContain = (C(bool) (*)(C(DGGRS), C(DGGRSZone), C(DGGRSZone)))METHOD(DGGRS, doesZoneContain)->function;

         METHOD(DGGRS, get64KDepth) = Class_findMethod(CO(DGGRS), "get64KDepth", module);
         if(METHOD(DGGRS, get64KDepth))
            DGGRS_get64KDepth = (int (*)(C(DGGRS)))METHOD(DGGRS, get64KDepth)->function;

         METHOD(DGGRS, getFirstSubZone) = Class_findMethod(CO(DGGRS), "getFirstSubZone", module);
         if(METHOD(DGGRS, getFirstSubZone))
            M_VTBLID(DGGRS, getFirstSubZone) = METHOD(DGGRS, getFirstSubZone)->vid;

         METHOD(DGGRS, getIndexMaxDepth) = Class_findMethod(CO(DGGRS), "getIndexMaxDepth", module);
         if(METHOD(DGGRS, getIndexMaxDepth))
            M_VTBLID(DGGRS, getIndexMaxDepth) = METHOD(DGGRS, getIndexMaxDepth)->vid;

         METHOD(DGGRS, getLevelFromMetersPerSubZone) = Class_findMethod(CO(DGGRS), "getLevelFromMetersPerSubZone", module);
         if(METHOD(DGGRS, getLevelFromMetersPerSubZone))
            DGGRS_getLevelFromMetersPerSubZone = (int (*)(C(DGGRS), double, int))METHOD(DGGRS, getLevelFromMetersPerSubZone)->function;

         METHOD(DGGRS, getLevelFromPixelsAndExtent) = Class_findMethod(CO(DGGRS), "getLevelFromPixelsAndExtent", module);
         if(METHOD(DGGRS, getLevelFromPixelsAndExtent))
            DGGRS_getLevelFromPixelsAndExtent = (int (*)(C(DGGRS), const C(GeoExtent) *, const C(Point) *, int))METHOD(DGGRS, getLevelFromPixelsAndExtent)->function;

         METHOD(DGGRS, getLevelFromRefZoneArea) = Class_findMethod(CO(DGGRS), "getLevelFromRefZoneArea", module);
         if(METHOD(DGGRS, getLevelFromRefZoneArea))
            DGGRS_getLevelFromRefZoneArea = (int (*)(C(DGGRS), double))METHOD(DGGRS, getLevelFromRefZoneArea)->function;

         METHOD(DGGRS, getLevelFromScaleDenominator) = Class_findMethod(CO(DGGRS), "getLevelFromScaleDenominator", module);
         if(METHOD(DGGRS, getLevelFromScaleDenominator))
            DGGRS_getLevelFromScaleDenominator = (int (*)(C(DGGRS), double, int, double))METHOD(DGGRS, getLevelFromScaleDenominator)->function;

         METHOD(DGGRS, getMaxChildren) = Class_findMethod(CO(DGGRS), "getMaxChildren", module);
         if(METHOD(DGGRS, getMaxChildren))
            M_VTBLID(DGGRS, getMaxChildren) = METHOD(DGGRS, getMaxChildren)->vid;

         METHOD(DGGRS, getMaxDGGRSZoneLevel) = Class_findMethod(CO(DGGRS), "getMaxDGGRSZoneLevel", module);
         if(METHOD(DGGRS, getMaxDGGRSZoneLevel))
            M_VTBLID(DGGRS, getMaxDGGRSZoneLevel) = METHOD(DGGRS, getMaxDGGRSZoneLevel)->vid;

         METHOD(DGGRS, getMaxDepth) = Class_findMethod(CO(DGGRS), "getMaxDepth", module);
         if(METHOD(DGGRS, getMaxDepth))
            DGGRS_getMaxDepth = (int (*)(C(DGGRS)))METHOD(DGGRS, getMaxDepth)->function;

         METHOD(DGGRS, getMaxNeighbors) = Class_findMethod(CO(DGGRS), "getMaxNeighbors", module);
         if(METHOD(DGGRS, getMaxNeighbors))
            M_VTBLID(DGGRS, getMaxNeighbors) = METHOD(DGGRS, getMaxNeighbors)->vid;

         METHOD(DGGRS, getMaxParents) = Class_findMethod(CO(DGGRS), "getMaxParents", module);
         if(METHOD(DGGRS, getMaxParents))
            M_VTBLID(DGGRS, getMaxParents) = METHOD(DGGRS, getMaxParents)->vid;

         METHOD(DGGRS, getMetersPerSubZoneFromLevel) = Class_findMethod(CO(DGGRS), "getMetersPerSubZoneFromLevel", module);
         if(METHOD(DGGRS, getMetersPerSubZoneFromLevel))
            DGGRS_getMetersPerSubZoneFromLevel = (double (*)(C(DGGRS), int, int))METHOD(DGGRS, getMetersPerSubZoneFromLevel)->function;

         METHOD(DGGRS, getRefZoneArea) = Class_findMethod(CO(DGGRS), "getRefZoneArea", module);
         if(METHOD(DGGRS, getRefZoneArea))
            DGGRS_getRefZoneArea = (double (*)(C(DGGRS), int))METHOD(DGGRS, getRefZoneArea)->function;

         METHOD(DGGRS, getRefinementRatio) = Class_findMethod(CO(DGGRS), "getRefinementRatio", module);
         if(METHOD(DGGRS, getRefinementRatio))
            M_VTBLID(DGGRS, getRefinementRatio) = METHOD(DGGRS, getRefinementRatio)->vid;

         METHOD(DGGRS, getScaleDenominatorFromLevel) = Class_findMethod(CO(DGGRS), "getScaleDenominatorFromLevel", module);
         if(METHOD(DGGRS, getScaleDenominatorFromLevel))
            DGGRS_getScaleDenominatorFromLevel = (double (*)(C(DGGRS), int, int, double))METHOD(DGGRS, getScaleDenominatorFromLevel)->function;

         METHOD(DGGRS, getSubZoneAtIndex) = Class_findMethod(CO(DGGRS), "getSubZoneAtIndex", module);
         if(METHOD(DGGRS, getSubZoneAtIndex))
            M_VTBLID(DGGRS, getSubZoneAtIndex) = METHOD(DGGRS, getSubZoneAtIndex)->vid;

         METHOD(DGGRS, getSubZoneCRSCentroids) = Class_findMethod(CO(DGGRS), "getSubZoneCRSCentroids", module);
         if(METHOD(DGGRS, getSubZoneCRSCentroids))
            M_VTBLID(DGGRS, getSubZoneCRSCentroids) = METHOD(DGGRS, getSubZoneCRSCentroids)->vid;

         METHOD(DGGRS, getSubZoneIndex) = Class_findMethod(CO(DGGRS), "getSubZoneIndex", module);
         if(METHOD(DGGRS, getSubZoneIndex))
            M_VTBLID(DGGRS, getSubZoneIndex) = METHOD(DGGRS, getSubZoneIndex)->vid;

         METHOD(DGGRS, getSubZoneWGS84Centroids) = Class_findMethod(CO(DGGRS), "getSubZoneWGS84Centroids", module);
         if(METHOD(DGGRS, getSubZoneWGS84Centroids))
            M_VTBLID(DGGRS, getSubZoneWGS84Centroids) = METHOD(DGGRS, getSubZoneWGS84Centroids)->vid;

         METHOD(DGGRS, getSubZones) = Class_findMethod(CO(DGGRS), "getSubZones", module);
         if(METHOD(DGGRS, getSubZones))
            M_VTBLID(DGGRS, getSubZones) = METHOD(DGGRS, getSubZones)->vid;

         METHOD(DGGRS, getZoneArea) = Class_findMethod(CO(DGGRS), "getZoneArea", module);
         if(METHOD(DGGRS, getZoneArea))
            M_VTBLID(DGGRS, getZoneArea) = METHOD(DGGRS, getZoneArea)->vid;

         METHOD(DGGRS, getZoneCRSCentroid) = Class_findMethod(CO(DGGRS), "getZoneCRSCentroid", module);
         if(METHOD(DGGRS, getZoneCRSCentroid))
            M_VTBLID(DGGRS, getZoneCRSCentroid) = METHOD(DGGRS, getZoneCRSCentroid)->vid;

         METHOD(DGGRS, getZoneCRSExtent) = Class_findMethod(CO(DGGRS), "getZoneCRSExtent", module);
         if(METHOD(DGGRS, getZoneCRSExtent))
            M_VTBLID(DGGRS, getZoneCRSExtent) = METHOD(DGGRS, getZoneCRSExtent)->vid;

         METHOD(DGGRS, getZoneCRSVertices) = Class_findMethod(CO(DGGRS), "getZoneCRSVertices", module);
         if(METHOD(DGGRS, getZoneCRSVertices))
            M_VTBLID(DGGRS, getZoneCRSVertices) = METHOD(DGGRS, getZoneCRSVertices)->vid;

         METHOD(DGGRS, getZoneCentroidChild) = Class_findMethod(CO(DGGRS), "getZoneCentroidChild", module);
         if(METHOD(DGGRS, getZoneCentroidChild))
            M_VTBLID(DGGRS, getZoneCentroidChild) = METHOD(DGGRS, getZoneCentroidChild)->vid;

         METHOD(DGGRS, getZoneCentroidParent) = Class_findMethod(CO(DGGRS), "getZoneCentroidParent", module);
         if(METHOD(DGGRS, getZoneCentroidParent))
            M_VTBLID(DGGRS, getZoneCentroidParent) = METHOD(DGGRS, getZoneCentroidParent)->vid;

         METHOD(DGGRS, getZoneChildren) = Class_findMethod(CO(DGGRS), "getZoneChildren", module);
         if(METHOD(DGGRS, getZoneChildren))
            M_VTBLID(DGGRS, getZoneChildren) = METHOD(DGGRS, getZoneChildren)->vid;

         METHOD(DGGRS, getZoneFromCRSCentroid) = Class_findMethod(CO(DGGRS), "getZoneFromCRSCentroid", module);
         if(METHOD(DGGRS, getZoneFromCRSCentroid))
            M_VTBLID(DGGRS, getZoneFromCRSCentroid) = METHOD(DGGRS, getZoneFromCRSCentroid)->vid;

         METHOD(DGGRS, getZoneFromTextID) = Class_findMethod(CO(DGGRS), "getZoneFromTextID", module);
         if(METHOD(DGGRS, getZoneFromTextID))
            M_VTBLID(DGGRS, getZoneFromTextID) = METHOD(DGGRS, getZoneFromTextID)->vid;

         METHOD(DGGRS, getZoneFromWGS84Centroid) = Class_findMethod(CO(DGGRS), "getZoneFromWGS84Centroid", module);
         if(METHOD(DGGRS, getZoneFromWGS84Centroid))
            M_VTBLID(DGGRS, getZoneFromWGS84Centroid) = METHOD(DGGRS, getZoneFromWGS84Centroid)->vid;

         METHOD(DGGRS, getZoneLevel) = Class_findMethod(CO(DGGRS), "getZoneLevel", module);
         if(METHOD(DGGRS, getZoneLevel))
            M_VTBLID(DGGRS, getZoneLevel) = METHOD(DGGRS, getZoneLevel)->vid;

         METHOD(DGGRS, getZoneNeighbors) = Class_findMethod(CO(DGGRS), "getZoneNeighbors", module);
         if(METHOD(DGGRS, getZoneNeighbors))
            M_VTBLID(DGGRS, getZoneNeighbors) = METHOD(DGGRS, getZoneNeighbors)->vid;

         METHOD(DGGRS, getZoneParents) = Class_findMethod(CO(DGGRS), "getZoneParents", module);
         if(METHOD(DGGRS, getZoneParents))
            M_VTBLID(DGGRS, getZoneParents) = METHOD(DGGRS, getZoneParents)->vid;

         METHOD(DGGRS, getZoneRefinedCRSVertices) = Class_findMethod(CO(DGGRS), "getZoneRefinedCRSVertices", module);
         if(METHOD(DGGRS, getZoneRefinedCRSVertices))
            M_VTBLID(DGGRS, getZoneRefinedCRSVertices) = METHOD(DGGRS, getZoneRefinedCRSVertices)->vid;

         METHOD(DGGRS, getZoneRefinedWGS84Vertices) = Class_findMethod(CO(DGGRS), "getZoneRefinedWGS84Vertices", module);
         if(METHOD(DGGRS, getZoneRefinedWGS84Vertices))
            M_VTBLID(DGGRS, getZoneRefinedWGS84Vertices) = METHOD(DGGRS, getZoneRefinedWGS84Vertices)->vid;

         METHOD(DGGRS, getZoneTextID) = Class_findMethod(CO(DGGRS), "getZoneTextID", module);
         if(METHOD(DGGRS, getZoneTextID))
            M_VTBLID(DGGRS, getZoneTextID) = METHOD(DGGRS, getZoneTextID)->vid;

         METHOD(DGGRS, getZoneWGS84Centroid) = Class_findMethod(CO(DGGRS), "getZoneWGS84Centroid", module);
         if(METHOD(DGGRS, getZoneWGS84Centroid))
            M_VTBLID(DGGRS, getZoneWGS84Centroid) = METHOD(DGGRS, getZoneWGS84Centroid)->vid;

         METHOD(DGGRS, getZoneWGS84Extent) = Class_findMethod(CO(DGGRS), "getZoneWGS84Extent", module);
         if(METHOD(DGGRS, getZoneWGS84Extent))
            M_VTBLID(DGGRS, getZoneWGS84Extent) = METHOD(DGGRS, getZoneWGS84Extent)->vid;

         METHOD(DGGRS, getZoneWGS84ExtentApproximate) = Class_findMethod(CO(DGGRS), "getZoneWGS84ExtentApproximate", module);
         if(METHOD(DGGRS, getZoneWGS84ExtentApproximate))
            M_VTBLID(DGGRS, getZoneWGS84ExtentApproximate) = METHOD(DGGRS, getZoneWGS84ExtentApproximate)->vid;

         METHOD(DGGRS, getZoneWGS84Vertices) = Class_findMethod(CO(DGGRS), "getZoneWGS84Vertices", module);
         if(METHOD(DGGRS, getZoneWGS84Vertices))
            M_VTBLID(DGGRS, getZoneWGS84Vertices) = METHOD(DGGRS, getZoneWGS84Vertices)->vid;

         METHOD(DGGRS, isZoneAncestorOf) = Class_findMethod(CO(DGGRS), "isZoneAncestorOf", module);
         if(METHOD(DGGRS, isZoneAncestorOf))
            DGGRS_isZoneAncestorOf = (C(bool) (*)(C(DGGRS), C(DGGRSZone), C(DGGRSZone), int))METHOD(DGGRS, isZoneAncestorOf)->function;

         METHOD(DGGRS, isZoneCentroidChild) = Class_findMethod(CO(DGGRS), "isZoneCentroidChild", module);
         if(METHOD(DGGRS, isZoneCentroidChild))
            M_VTBLID(DGGRS, isZoneCentroidChild) = METHOD(DGGRS, isZoneCentroidChild)->vid;

         METHOD(DGGRS, isZoneContainedIn) = Class_findMethod(CO(DGGRS), "isZoneContainedIn", module);
         if(METHOD(DGGRS, isZoneContainedIn))
            DGGRS_isZoneContainedIn = (C(bool) (*)(C(DGGRS), C(DGGRSZone), C(DGGRSZone)))METHOD(DGGRS, isZoneContainedIn)->function;

         METHOD(DGGRS, isZoneDescendantOf) = Class_findMethod(CO(DGGRS), "isZoneDescendantOf", module);
         if(METHOD(DGGRS, isZoneDescendantOf))
            DGGRS_isZoneDescendantOf = (C(bool) (*)(C(DGGRS), C(DGGRSZone), C(DGGRSZone), int))METHOD(DGGRS, isZoneDescendantOf)->function;

         METHOD(DGGRS, isZoneImmediateChildOf) = Class_findMethod(CO(DGGRS), "isZoneImmediateChildOf", module);
         if(METHOD(DGGRS, isZoneImmediateChildOf))
            DGGRS_isZoneImmediateChildOf = (C(bool) (*)(C(DGGRS), C(DGGRSZone), C(DGGRSZone)))METHOD(DGGRS, isZoneImmediateChildOf)->function;

         METHOD(DGGRS, isZoneImmediateParentOf) = Class_findMethod(CO(DGGRS), "isZoneImmediateParentOf", module);
         if(METHOD(DGGRS, isZoneImmediateParentOf))
            DGGRS_isZoneImmediateParentOf = (C(bool) (*)(C(DGGRS), C(DGGRSZone), C(DGGRSZone)))METHOD(DGGRS, isZoneImmediateParentOf)->function;

         METHOD(DGGRS, listZones) = Class_findMethod(CO(DGGRS), "listZones", module);
         if(METHOD(DGGRS, listZones))
            M_VTBLID(DGGRS, listZones) = METHOD(DGGRS, listZones)->vid;

         METHOD(DGGRS, zoneHasSubZone) = Class_findMethod(CO(DGGRS), "zoneHasSubZone", module);
         if(METHOD(DGGRS, zoneHasSubZone))
            M_VTBLID(DGGRS, zoneHasSubZone) = METHOD(DGGRS, zoneHasSubZone)->vid;
      }
      CO(DGGRSZone) = eC_findClass(module, "DGGRSZone");
      CO(DGGSJSON) = eC_findClass(module, "DGGSJSON");
      CO(DGGSJSONDepth) = eC_findClass(module, "DGGSJSONDepth");
      CO(DGGSJSONDimension) = eC_findClass(module, "DGGSJSONDimension");
      CO(DGGSJSONGrid) = eC_findClass(module, "DGGSJSONGrid");
      CO(DGGSJSONShape) = eC_findClass(module, "DGGSJSONShape");
      CO(GGGZone) = eC_findClass(module, "GGGZone");
      CO(GNOSISGlobalGrid) = eC_findClass(module, "GNOSISGlobalGrid");
      CO(GPP3H) = eC_findClass(module, "GPP3H");
      CO(GeoExtent) = eC_findClass(module, "GeoExtent");
      if(CO(GeoExtent))
      {
         METHOD(GeoExtent, clear) = Class_findMethod(CO(GeoExtent), "clear", module);
         if(METHOD(GeoExtent, clear))
            GeoExtent_clear = (void (*)(C(GeoExtent) *))METHOD(GeoExtent, clear)->function;

         METHOD(GeoExtent, clip) = Class_findMethod(CO(GeoExtent), "clip", module);
         if(METHOD(GeoExtent, clip))
            GeoExtent_clip = (C(bool) (*)(C(GeoExtent) *, const C(GeoExtent) *, const C(GeoExtent) *))METHOD(GeoExtent, clip)->function;

         METHOD(GeoExtent, clipHandlingDateline) = Class_findMethod(CO(GeoExtent), "clipHandlingDateline", module);
         if(METHOD(GeoExtent, clipHandlingDateline))
            GeoExtent_clipHandlingDateline = (C(bool) (*)(C(GeoExtent) *, const C(GeoExtent) *, const C(GeoExtent) *))METHOD(GeoExtent, clipHandlingDateline)->function;

         METHOD(GeoExtent, doUnionDL) = Class_findMethod(CO(GeoExtent), "doUnionDL", module);
         if(METHOD(GeoExtent, doUnionDL))
            GeoExtent_doUnionDL = (void (*)(C(GeoExtent) *, const C(GeoExtent) *))METHOD(GeoExtent, doUnionDL)->function;

         METHOD(GeoExtent, intersects) = Class_findMethod(CO(GeoExtent), "intersects", module);
         if(METHOD(GeoExtent, intersects))
            GeoExtent_intersects = (C(bool) (*)(C(GeoExtent) *, const C(GeoExtent) *))METHOD(GeoExtent, intersects)->function;

         PROPERTY(GeoExtent, nonNull) = Class_findProperty(CO(GeoExtent), "nonNull", module);
         if(PROPERTY(GeoExtent, nonNull))
            GeoExtent_get_nonNull = (void *)PROPERTY(GeoExtent, nonNull)->Get;

         PROPERTY(GeoExtent, geodeticArea) = Class_findProperty(CO(GeoExtent), "geodeticArea", module);
         if(PROPERTY(GeoExtent, geodeticArea))
            GeoExtent_get_geodeticArea = (void *)PROPERTY(GeoExtent, geodeticArea)->Get;
      }
      CO(GeoPoint) = eC_findClass(module, "GeoPoint");
      CO(GoldbergPolyhedraProjection) = eC_findClass(module, "GoldbergPolyhedraProjection");
      CO(HEALPix) = eC_findClass(module, "HEALPix");
      CO(HEALPixProjection) = eC_findClass(module, "HEALPixProjection");
      if(CO(HEALPixProjection))
      {
         METHOD(HEALPixProjection, forward) = Class_findMethod(CO(HEALPixProjection), "forward", module);
         if(METHOD(HEALPixProjection, forward))
            M_VTBLID(HEALPixProjection, forward) = METHOD(HEALPixProjection, forward)->vid;

         METHOD(HEALPixProjection, inverse) = Class_findMethod(CO(HEALPixProjection), "inverse", module);
         if(METHOD(HEALPixProjection, inverse))
            M_VTBLID(HEALPixProjection, inverse) = METHOD(HEALPixProjection, inverse)->vid;
      }
      CO(HPZone) = eC_findClass(module, "HPZone");
      CO(I3HNeighbor) = eC_findClass(module, "I3HNeighbor");
      CO(I3HZone) = eC_findClass(module, "I3HZone");
      CO(I4RZone) = eC_findClass(module, "I4RZone");
      CO(I7HZone) = eC_findClass(module, "I7HZone");
      CO(I9RZone) = eC_findClass(module, "I9RZone");
      CO(ISEA3H) = eC_findClass(module, "ISEA3H");
      CO(ISEA4R) = eC_findClass(module, "ISEA4R");
      CO(ISEA7H) = eC_findClass(module, "ISEA7H");
      CO(ISEA7H_Z7) = eC_findClass(module, "ISEA7H_Z7");
      CO(ISEA9R) = eC_findClass(module, "ISEA9R");
      CO(ISEAProjection) = eC_findClass(module, "ISEAProjection");
      CO(IVEA3H) = eC_findClass(module, "IVEA3H");
      CO(IVEA4R) = eC_findClass(module, "IVEA4R");
      CO(IVEA7H) = eC_findClass(module, "IVEA7H");
      CO(IVEA7H_Z7) = eC_findClass(module, "IVEA7H_Z7");
      CO(IVEA9R) = eC_findClass(module, "IVEA9R");
      CO(IVEAProjection) = eC_findClass(module, "IVEAProjection");
      CO(JSONSchema) = eC_findClass(module, "JSONSchema");
      if(CO(JSONSchema))
      {
         PROPERTY(JSONSchema, maximum) = Class_findProperty(CO(JSONSchema), "maximum", module);
         if(PROPERTY(JSONSchema, maximum))
         {
            JSONSchema_get_maximum = (void *)PROPERTY(JSONSchema, maximum)->Get;
            JSONSchema_isSet_maximum = (void *)PROPERTY(JSONSchema, maximum)->IsSet;
         }

         PROPERTY(JSONSchema, exclusiveMaximum) = Class_findProperty(CO(JSONSchema), "exclusiveMaximum", module);
         if(PROPERTY(JSONSchema, exclusiveMaximum))
         {
            JSONSchema_get_exclusiveMaximum = (void *)PROPERTY(JSONSchema, exclusiveMaximum)->Get;
            JSONSchema_isSet_exclusiveMaximum = (void *)PROPERTY(JSONSchema, exclusiveMaximum)->IsSet;
         }

         PROPERTY(JSONSchema, minimum) = Class_findProperty(CO(JSONSchema), "minimum", module);
         if(PROPERTY(JSONSchema, minimum))
         {
            JSONSchema_get_minimum = (void *)PROPERTY(JSONSchema, minimum)->Get;
            JSONSchema_isSet_minimum = (void *)PROPERTY(JSONSchema, minimum)->IsSet;
         }

         PROPERTY(JSONSchema, exclusiveMinimum) = Class_findProperty(CO(JSONSchema), "exclusiveMinimum", module);
         if(PROPERTY(JSONSchema, exclusiveMinimum))
         {
            JSONSchema_get_exclusiveMinimum = (void *)PROPERTY(JSONSchema, exclusiveMinimum)->Get;
            JSONSchema_isSet_exclusiveMinimum = (void *)PROPERTY(JSONSchema, exclusiveMinimum)->IsSet;
         }

         PROPERTY(JSONSchema, maxItems) = Class_findProperty(CO(JSONSchema), "maxItems", module);
         if(PROPERTY(JSONSchema, maxItems))
         {
            JSONSchema_get_maxItems = (void *)PROPERTY(JSONSchema, maxItems)->Get;
            JSONSchema_isSet_maxItems = (void *)PROPERTY(JSONSchema, maxItems)->IsSet;
         }

         PROPERTY(JSONSchema, minItems) = Class_findProperty(CO(JSONSchema), "minItems", module);
         if(PROPERTY(JSONSchema, minItems))
         {
            JSONSchema_get_minItems = (void *)PROPERTY(JSONSchema, minItems)->Get;
            JSONSchema_isSet_minItems = (void *)PROPERTY(JSONSchema, minItems)->IsSet;
         }

         PROPERTY(JSONSchema, maxProperties) = Class_findProperty(CO(JSONSchema), "maxProperties", module);
         if(PROPERTY(JSONSchema, maxProperties))
         {
            JSONSchema_get_maxProperties = (void *)PROPERTY(JSONSchema, maxProperties)->Get;
            JSONSchema_isSet_maxProperties = (void *)PROPERTY(JSONSchema, maxProperties)->IsSet;
         }

         PROPERTY(JSONSchema, minProperties) = Class_findProperty(CO(JSONSchema), "minProperties", module);
         if(PROPERTY(JSONSchema, minProperties))
         {
            JSONSchema_get_minProperties = (void *)PROPERTY(JSONSchema, minProperties)->Get;
            JSONSchema_isSet_minProperties = (void *)PROPERTY(JSONSchema, minProperties)->IsSet;
         }

         PROPERTY(JSONSchema, xogcpropertySeq) = Class_findProperty(CO(JSONSchema), "xogcpropertySeq", module);
         if(PROPERTY(JSONSchema, xogcpropertySeq))
            JSONSchema_isSet_xogcpropertySeq = (void *)PROPERTY(JSONSchema, xogcpropertySeq)->IsSet;

         PROPERTY(JSONSchema, Default) = Class_findProperty(CO(JSONSchema), "Default", module);
         if(PROPERTY(JSONSchema, Default))
            JSONSchema_isSet_Default = (void *)PROPERTY(JSONSchema, Default)->IsSet;
      }
      CO(JSONSchemaType) = eC_findClass(module, "JSONSchemaType");
      CO(Plane) = eC_findClass(module, "Plane");
      if(CO(Plane))
      {
         METHOD(Plane, fromPoints) = Class_findMethod(CO(Plane), "FromPoints", module);
         if(METHOD(Plane, fromPoints))
            Plane_fromPoints = (void (*)(C(Plane) *, const C(Vector3D) *, const C(Vector3D) *, const C(Vector3D) *))METHOD(Plane, fromPoints)->function;
      }
      CO(Quaternion) = eC_findClass(module, "Quaternion");
      if(CO(Quaternion))
      {
         METHOD(Quaternion, yawPitch) = Class_findMethod(CO(Quaternion), "YawPitch", module);
         if(METHOD(Quaternion, yawPitch))
            Quaternion_yawPitch = (void (*)(C(Quaternion) *, C(Angle), C(Angle)))METHOD(Quaternion, yawPitch)->function;
      }
      CO(RHPZone) = eC_findClass(module, "RHPZone");
      CO(RI5x6Projection) = eC_findClass(module, "RI5x6Projection");
      if(CO(RI5x6Projection))
      {
         METHOD(RI5x6Projection, extent5x6FromWGS84) = Class_findMethod(CO(RI5x6Projection), "extent5x6FromWGS84", module);
         if(METHOD(RI5x6Projection, extent5x6FromWGS84))
            RI5x6Projection_extent5x6FromWGS84 = (void (*)(C(RI5x6Projection), const C(GeoExtent) *, C(Pointd) *, C(Pointd) *))METHOD(RI5x6Projection, extent5x6FromWGS84)->function;

         METHOD(RI5x6Projection, forward) = Class_findMethod(CO(RI5x6Projection), "forward", module);
         if(METHOD(RI5x6Projection, forward))
            M_VTBLID(RI5x6Projection, forward) = METHOD(RI5x6Projection, forward)->vid;

         METHOD(RI5x6Projection, fromIcosahedronNet) = Class_findMethod(CO(RI5x6Projection), "fromIcosahedronNet", module);
         if(METHOD(RI5x6Projection, fromIcosahedronNet))
            RI5x6Projection_fromIcosahedronNet = (C(bool) (*)(const C(Pointd) *, C(Pointd) *))METHOD(RI5x6Projection, fromIcosahedronNet)->function;

         METHOD(RI5x6Projection, inverse) = Class_findMethod(CO(RI5x6Projection), "inverse", module);
         if(METHOD(RI5x6Projection, inverse))
            M_VTBLID(RI5x6Projection, inverse) = METHOD(RI5x6Projection, inverse)->vid;

         METHOD(RI5x6Projection, toIcosahedronNet) = Class_findMethod(CO(RI5x6Projection), "toIcosahedronNet", module);
         if(METHOD(RI5x6Projection, toIcosahedronNet))
            RI5x6Projection_toIcosahedronNet = (C(bool) (*)(const C(Pointd) *, C(Pointd) *))METHOD(RI5x6Projection, toIcosahedronNet)->function;
      }
      CO(RI7H_Z7) = eC_findClass(module, "RI7H_Z7");
      CO(RTEA3H) = eC_findClass(module, "RTEA3H");
      CO(RTEA4R) = eC_findClass(module, "RTEA4R");
      CO(RTEA7H) = eC_findClass(module, "RTEA7H");
      CO(RTEA7H_Z7) = eC_findClass(module, "RTEA7H_Z7");
      CO(RTEA9R) = eC_findClass(module, "RTEA9R");
      CO(RTEAProjection) = eC_findClass(module, "RTEAProjection");
      CO(RhombicIcosahedral3H) = eC_findClass(module, "RhombicIcosahedral3H");
      CO(RhombicIcosahedral4R) = eC_findClass(module, "RhombicIcosahedral4R");
      CO(RhombicIcosahedral7H) = eC_findClass(module, "RhombicIcosahedral7H");
      CO(RhombicIcosahedral9R) = eC_findClass(module, "RhombicIcosahedral9R");
      CO(SliceAndDiceGreatCircleIcosahedralProjection) = eC_findClass(module, "SliceAndDiceGreatCircleIcosahedralProjection");
      CO(VGCRadialVertex) = eC_findClass(module, "VGCRadialVertex");
      CO(Vector3D) = eC_findClass(module, "Vector3D");
      if(CO(Vector3D))
      {
         METHOD(Vector3D, crossProduct) = Class_findMethod(CO(Vector3D), "CrossProduct", module);
         if(METHOD(Vector3D, crossProduct))
            Vector3D_crossProduct = (void (*)(C(Vector3D) *, const C(Vector3D) *, const C(Vector3D) *))METHOD(Vector3D, crossProduct)->function;

         METHOD(Vector3D, dotProduct) = Class_findMethod(CO(Vector3D), "DotProduct", module);
         if(METHOD(Vector3D, dotProduct))
            Vector3D_dotProduct = (double (*)(C(Vector3D) *, const C(Vector3D) *))METHOD(Vector3D, dotProduct)->function;

         METHOD(Vector3D, multQuaternion) = Class_findMethod(CO(Vector3D), "MultQuaternion", module);
         if(METHOD(Vector3D, multQuaternion))
            Vector3D_multQuaternion = (void (*)(C(Vector3D) *, const C(Vector3D) *, const C(Quaternion) *))METHOD(Vector3D, multQuaternion)->function;

         METHOD(Vector3D, normalize) = Class_findMethod(CO(Vector3D), "Normalize", module);
         if(METHOD(Vector3D, normalize))
            Vector3D_normalize = (void (*)(C(Vector3D) *, const C(Vector3D) *))METHOD(Vector3D, normalize)->function;

         METHOD(Vector3D, subtract) = Class_findMethod(CO(Vector3D), "Subtract", module);
         if(METHOD(Vector3D, subtract))
            Vector3D_subtract = (void (*)(C(Vector3D) *, const C(Vector3D) *, const C(Vector3D) *))METHOD(Vector3D, subtract)->function;

         PROPERTY(Vector3D, length) = Class_findProperty(CO(Vector3D), "length", module);
         if(PROPERTY(Vector3D, length))
            Vector3D_get_length = (void *)PROPERTY(Vector3D, length)->Get;
      }
      CO(Z7Zone) = eC_findClass(module, "Z7Zone");
      if(CO(Z7Zone))
      {
         METHOD(Z7Zone, from7H) = Class_findMethod(CO(Z7Zone), "from7H", module);
         if(METHOD(Z7Zone, from7H))
            Z7Zone_from7H = (C(Z7Zone) (*)(C(I7HZone)))METHOD(Z7Zone, from7H)->function;

         METHOD(Z7Zone, fromTextID) = Class_findMethod(CO(Z7Zone), "fromTextID", module);
         if(METHOD(Z7Zone, fromTextID))
            Z7Zone_fromTextID = (C(Z7Zone) (*)(constString))METHOD(Z7Zone, fromTextID)->function;

         METHOD(Z7Zone, getParentRotationOffset) = Class_findMethod(CO(Z7Zone), "getParentRotationOffset", module);
         if(METHOD(Z7Zone, getParentRotationOffset))
            Z7Zone_getParentRotationOffset = (int (*)(C(I7HZone)))METHOD(Z7Zone, getParentRotationOffset)->function;

         METHOD(Z7Zone, getTextID) = Class_findMethod(CO(Z7Zone), "getTextID", module);
         if(METHOD(Z7Zone, getTextID))
            Z7Zone_getTextID = (void (*)(C(Z7Zone), C(String)))METHOD(Z7Zone, getTextID)->function;

         METHOD(Z7Zone, to7H) = Class_findMethod(CO(Z7Zone), "to7H", module);
         if(METHOD(Z7Zone, to7H))
            Z7Zone_to7H = (C(I7HZone) (*)(C(Z7Zone)))METHOD(Z7Zone, to7H)->function;
      }
      CO(rHEALPix) = eC_findClass(module, "rHEALPix");
      CO(rHEALPixProjection) = eC_findClass(module, "rHEALPixProjection");



         // Set up all the function pointers, ...

      FUNCTION(i3HZoneFromI9R) = eC_findFunction(module, "I3HZoneFromI9R");
      if(FUNCTION(i3HZoneFromI9R))
         F(i3HZoneFromI9R) = (void *)FUNCTION(i3HZoneFromI9R)->function;

      FUNCTION(i9RZoneFromI3H) = eC_findFunction(module, "I9RZoneFromI3H");
      if(FUNCTION(i9RZoneFromI3H))
         F(i9RZoneFromI3H) = (void *)FUNCTION(i9RZoneFromI3H)->function;

      FUNCTION(authalicSetup) = eC_findFunction(module, "authalicSetup");
      if(FUNCTION(authalicSetup))
         F(authalicSetup) = (void *)FUNCTION(authalicSetup)->function;

      FUNCTION(canonicalize5x6) = eC_findFunction(module, "canonicalize5x6");
      if(FUNCTION(canonicalize5x6))
         F(canonicalize5x6) = (void *)FUNCTION(canonicalize5x6)->function;

      FUNCTION(compactGGGZones) = eC_findFunction(module, "compactGGGZones");
      if(FUNCTION(compactGGGZones))
         F(compactGGGZones) = (void *)FUNCTION(compactGGGZones)->function;

      FUNCTION(latAuthalicToGeodetic) = eC_findFunction(module, "latAuthalicToGeodetic");
      if(FUNCTION(latAuthalicToGeodetic))
         F(latAuthalicToGeodetic) = (void *)FUNCTION(latAuthalicToGeodetic)->function;

      FUNCTION(latGeodeticToAuthalic) = eC_findFunction(module, "latGeodeticToAuthalic");
      if(FUNCTION(latGeodeticToAuthalic))
         F(latGeodeticToAuthalic) = (void *)FUNCTION(latGeodeticToAuthalic)->function;

      FUNCTION(readDGGSJSON) = eC_findFunction(module, "readDGGSJSON");
      if(FUNCTION(readDGGSJSON))
         F(readDGGSJSON) = (void *)FUNCTION(readDGGSJSON)->function;

   }
   else
      printf("Unable to load eC module: %s\n", DGGAL_MODULE_NAME);
   return module;
}



================================================
FILE: bindings/c/Makefile
================================================
.PHONY: all clean realclean distclean dggal_c

DGGAL_ABSPATH := $(dir $(realpath $(firstword $(MAKEFILE_LIST))))../../

ifndef EC_SDK_SRC
EC_SDK_SRC := $(DGGAL_ABSPATH)../eC
endif

export _CF_DIR = $(EC_SDK_SRC)/
include $(_CF_DIR)crossplatform.mk

# TARGETS

all: dggal_c

dggal_c:
	+$(_MAKE) -f Makefile.dggal_c
	+$(_MAKE) -f Makefile.dggal_c.static

clean:
	+$(_MAKE) -f Makefile.dggal_c clean
	+$(_MAKE) -f Makefile.dggal_c.static clean
	
realclean:
	+$(_MAKE) -f Makefile.dggal_c realclean
	+$(_MAKE) -f Makefile.dggal_c.static realclean

distclean:
	+$(_MAKE) -f Makefile.dggal_c distclean
	+$(_MAKE) -f Makefile.dggal_c.static distclean



================================================
FILE: bindings/c/Makefile.dggal_c
================================================
ifneq ($(V),1)
.SILENT:
endif

# CORE VARIABLES

BINDMODLOC := obj
BINDING_MODULE := dggal
BINDING_NAME := dggal
MODULE := $(BINDING_NAME)_c
VERSION := 0.0.6
CONFIG := release
ifndef COMPILER
COMPILER := default
endif

TARGET_TYPE = sharedlib

# FLAGS

ECFLAGS =
ifndef DEBIAN_PACKAGE
CFLAGS =
LDFLAGS =
endif
PRJ_CFLAGS =
CECFLAGS =
OFLAGS =
LIBS =

ifdef DEBUG
NOSTRIP := y
endif

CONSOLE = -mwindows

# INCLUDES

DGGAL_ABSPATH := $(dir $(realpath $(firstword $(MAKEFILE_LIST))))../../

ifndef EC_SDK_SRC
EC_SDK_SRC := $(DGGAL_ABSPATH)../eC
endif

export _CF_DIR = $(EC_SDK_SRC)/
include $(_CF_DIR)crossplatform.mk
include $(_CF_DIR)default.cf

# POST-INCLUDES VARIABLES

OBJ = obj/$(CONFIG).$(PLATFORM)$(COMPILER_SUFFIX)$(DEBUG_SUFFIX)/

RES =

TARGET = $(OBJ)$(LP)$(MODULE)$(SO)
SONAME =
ifndef SKIP_SONAME
ifdef LINUX_TARGET
TARGET = $(OBJ)$(LP)$(MODULE)$(SO).$(VERSION)
SONAME = -Wl,-soname,$(LP)$(MODULE)$(SO).0
endif
endif

_OBJECTS = $(_DEP_OBJECTS) \
	$(OBJ)$(BINDING_NAME)$(O)

OBJECTS = $(_OBJECTS)

SOURCES = $(_DEP_SOURCES) \
	$(BINDING_NAME).c

LIBS += $(SHAREDLIB) $(EXECUTABLE) $(LINKOPT)

LIBS += $(call _L,ecrt) # $(call _L,$(BINDING_MODULE))

PRJ_CFLAGS += \
	 $(if $(DEBUG), -g, -O2 -ffast-math) $(FPIC) -w -I$(EC_SDK_SRC)/bindings/c -I$(DGGAL_ABSPATH)bindings/c

ifdef C_BINDINGS_SYMBOLS_PREFIX_ENABLE
PRJ_CFLAGS += -DECPRFX=eC_
endif

OFLAGS += \
	-L$(DGGAL_ABSPATH)obj/$(PLATFORM)$(COMPILER_SUFFIX)$(DEBUG_SUFFIX)/bin \
	-L$(DGGAL_ABSPATH)obj/$(PLATFORM)$(COMPILER_SUFFIX)$(DEBUG_SUFFIX)/lib \
	-L$(EC_SDK_SRC)/obj/$(PLATFORM)$(COMPILER_SUFFIX)$(DEBUG_SUFFIX)/bin \
	-L$(EC_SDK_SRC)/obj/$(PLATFORM)$(COMPILER_SUFFIX)$(DEBUG_SUFFIX)/lib \
	-L$(BINDMODLOC)

# TARGETS

.PHONY: all
all: objdir $(TARGET);

.PHONY: objdir
objdir:
	$(call mkdir,$(OBJ))

$(SYMBOLS): | objdir
$(OBJECTS): | objdir
$(TARGET): $(SOURCES) $(OBJECTS) | objdir
	$(CC) $(OFLAGS) $(_OBJECTS) $(LIBS) -o $(TARGET) $(INSTALLNAME)
ifndef NOSTRIP
	$(STRIP) $(STRIPOPT) $(TARGET)
endif
ifdef LINUX_TARGET
ifdef LINUX_HOST
ifndef SKIP_SONAME
	$(if $(basename $(VER)),ln -sf $(LP)$(MODULE)$(SO)$(VER) $(OBJ)$(LP)$(MODULE)$(SO)$(basename $(VER)),)
	$(if $(VER),ln -sf $(LP)$(MODULE)$(SO)$(VER) $(OBJ)$(LP)$(MODULE)$(SO),)
endif
endif
endif
	$(call mkdir,$(DGGAL_ABSPATH)$(SODESTDIR))
	$(call cp,$(TARGET),$(DGGAL_ABSPATH)$(SODESTDIR))
ifndef SKIP_SONAME
ifdef LINUX_TARGET
ifdef LINUX_HOST
	$(if $(basename $(VER)),ln -sf $(LP)$(MODULE)$(SO)$(VER) $(DGGAL_ABSPATH)$(SODESTDIR)$(LP)$(MODULE)$(SO)$(basename $(VER)),)
	$(if $(VER),ln -sf $(LP)$(MODULE)$(SO)$(VER) $(DGGAL_ABSPATH)$(SODESTDIR)$(LP)$(MODULE)$(SO),)
endif
endif
endif

# OBJECT RULES

$(OBJ)$(BINDING_NAME)$(O): $(BINDING_NAME).c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,$<) -o $(call quote_path,$@)

.PHONY: cleantarget
cleantarget:
	$(call rm,$(TARGET))
ifdef LINUX_TARGET
ifdef LINUX_HOST
ifndef SKIP_SONAME
	$(call rm,$(OBJ)$(LP)$(MODULE)$(SO)$(basename $(VER)))
	$(call rm,$(OBJ)$(LP)$(MODULE)$(SO))
endif
endif
endif

.PHONY: clean
clean: cleantarget
	$(call rm,$(_OBJECTS))

.PHONY: realclean
realclean: cleantarget
	$(call rmr,$(OBJ))

.PHONY: wipeclean
wipeclean:
	$(call rmr,obj/)

.PHONY: distclean
distclean:
	$(_MAKE) -f $(_CF_DIR)Cleanfile distclean distclean_all_subdirs

$(MAKEFILE_LIST): ;
$(SOURCES): ;
$(RESOURCES): ;



================================================
FILE: bindings/c/Makefile.dggal_c.static
================================================
.PHONY: all objdir cleantarget clean realclean distclean

ifneq ($(V),1)
.SILENT:
endif

MODULE := dggal
BINDING_NAME := dggal

# CORE VARIABLES

VERSION := 0.0.6
CONFIG := static
ifndef COMPILER
COMPILER := default
endif

# C_BINDINGS_SYMBOLS_PREFIX_ENABLE := y

TARGET_TYPE = staticlib

# INCLUDES

DGGAL_ABSPATH := $(dir $(realpath $(firstword $(MAKEFILE_LIST))))../../

ifndef EC_SDK_SRC
EC_SDK_SRC := $(DGGAL_ABSPATH)../eC
endif

export _CF_DIR = $(EC_SDK_SRC)/
include $(_CF_DIR)crossplatform.mk
include $(_CF_DIR)$(COMPILER).cf

# POST-INCLUDES VARIABLES

OBJ = obj/$(CONFIG).$(PLATFORM)$(COMPILER_SUFFIX)$(DEBUG_SUFFIX)

SOURCES = $(MODULE).rs

OFLAGS =

PRJ_CFLAGS += $(if $(DEBUG), -g, -O2 -ffast-math) $(FPIC) -w -I$(EC_SDK_SRC)/bindings/c -I$(DGGAL_ABSPATH)bindings/c -DEC_STATIC

ifdef C_BINDINGS_SYMBOLS_PREFIX_ENABLE
PRJ_CFLAGS += -DECPRFX=eC_
endif

_OBJECTS = $(_DEP_OBJECTS) $(OBJ)/$(BINDING_NAME)$(O)

OBJECTS = $(_OBJECTS)

SOURCES = $(_DEP_SOURCES) $(BINDING_NAME).c

CBINDING_STATIC_LIB = $(OBJ)/lib$(BINDING_NAME)_cStatic.a

TARGET = $(CBINDING_STATIC_LIB)

all: objdir $(TARGET);

# OBJECT RULES

$(OBJ)/$(BINDING_NAME)$(O): $(BINDING_NAME).c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,$<) -o $(call quote_path,$@)

# TARGETS

objdir:
	$(call mkdir,$(OBJ))

$(SYMBOLS): | objdir
$(OBJECTS): | objdir

$(TARGET): $(SOURCES) $(OBJECTS) | objdir
	$(AR) rcs $(CBINDING_STATIC_LIB) $(_OBJECTS)
	$(call mkdir,$(DGGAL_ABSPATH)obj/$(PLATFORM)$(COMPILER_SUFFIX)$(DEBUG_SUFFIX)/lib)
	$(call cp,$(CBINDING_STATIC_LIB),$(DGGAL_ABSPATH)obj/$(PLATFORM)$(COMPILER_SUFFIX)$(DEBUG_SUFFIX)/lib)

cleantarget:
	$(call rm,$(TARGET))

clean: cleantarget
	$(call rm,_OBJECTS)
	$(call rm,$(OBJ)/lib$(BINDING_NAME)_cStatic.a)

realclean: cleantarget
	$(call rmr,$(OBJ))

distclean:
	$(_MAKE) -f $(_CF_DIR)Cleanfile distclean distclean_all_subdirs



================================================
FILE: bindings/c_fn/dggal_c.c
================================================
#ifdef DGGAL_ALLINONE
   #undef BINDINGS_SHARED
#endif

#include <dggal.h>

#ifdef DGGAL_ALLINONE
   #if defined(__WIN32__)
      #define LIB_EXPORT __attribute__((dllexport)) __attribute__ ((visibility("default")))
      #define LIB_IMPORT __attribute__((dllimport))
   #elif defined(__EMSCRIPTEN__)
      #define LIB_EXPORT EMSCRIPTEN_KEEPALIVE
      #define LIB_IMPORT
   #else
      #define LIB_EXPORT __attribute__ ((visibility("default")))
      #define LIB_IMPORT
   #endif
#endif

static Class * class_Array_DGGRSZone;

LIB_EXPORT CRSRegistry DGGAL_CRS(CRSRegistry registry, unsigned int code, int h)
{
   return CRS(registry, code, h);
}

// Dynamic Arrays

//    of GeoPoint
LIB_EXPORT int DGGAL_Array_GeoPoint_getCount(const T(Array, GeoPoint) self)
{
   return Array_get_size(self);
}

LIB_EXPORT const GeoPoint * DGGAL_Array_GeoPoint_getPointer(const T(Array, GeoPoint) self)
{
   return self ? (GeoPoint *)((struct CM(Array) *)(((byte *)self) + CO(Array)->offset))->array : null;
}

LIB_EXPORT void DGGAL_Array_GeoPoint_delete(T(Array, GeoPoint) self)
{
   deletei(self);
}

//    of Pointd
LIB_EXPORT int DGGAL_Array_Pointd_getCount(const T(Array, Pointd) self)
{
   return Array_get_size(self);
}

LIB_EXPORT const Pointd * DGGAL_Array_Pointd_getPointer(const T(Array, Pointd) self)
{
   return self ? (Pointd *)((struct CM(Array) *)(((byte *)self) + CO(Array)->offset))->array : null;
}

LIB_EXPORT void DGGAL_Array_Pointd_delete(T(Array, Pointd) self)
{
   deletei(self);
}

//    of DGGRSZone
LIB_EXPORT T(Array, DGGRSZone) DGGAL_Array_DGGRSZone_new(uint size)
{
   T(Array, DGGRSZone) array = newi(Array, DGGRSZone);
   if(array)
      Array_set_size(array, size);
   return array;
}

LIB_EXPORT int DGGAL_Array_DGGRSZone_getCount(const T(Array, DGGRSZone) self)
{
   return Array_get_size(self);
}

LIB_EXPORT DGGRSZone * DGGAL_Array_DGGRSZone_getPointer(const T(Array, DGGRSZone) self)
{
   return self ? (DGGRSZone *)((struct CM(Array) *)(((byte *)self) + CO(Array)->offset))->array : null;
}

LIB_EXPORT void DGGAL_Array_DGGRSZone_delete(T(Array, DGGRSZone) self)
{
   deletei(self);
}

// DGGAL Initialization
LIB_EXPORT Module DGGAL_init()
{
   Module mDGGAL = null;
   Application app = ecrt_init(null, true, false, 0, null);
   if(app)
   {
      mDGGAL = dggal_init(app);
      if(!mDGGAL)
         deletei(app);
      else
         class_Array_DGGRSZone = eC_findClass(app, "Array<DGGRSZone>");
   }
   return mDGGAL;
}

LIB_EXPORT void DGGAL_terminate(Module mDGGAL)
{
   if(mDGGAL)
   {
      Application app = ((struct CM(Module) *)(((byte *)mDGGAL) + CO(Module)->offset))->application;
      deletei(app);
   }
}

// DGGRS Instantiation
LIB_EXPORT DGGRS DGGAL_DGGRS_new(Module mDGGAL, const String name)
{
   DGGRS dggrs = null;
   if(name)
   {
      Class * c = eC_findClass(mDGGAL, name);
      if(c != null)
         dggrs = Instance_new(c);
   }
   return dggrs;
}

LIB_EXPORT void DGGAL_DGGRS_delete(DGGRS self)
{
   deletei(self);
}

LIB_EXPORT const char ** DGGAL_DGGRS_list(uint * count)
{
   static const char * dggrsList[] =
   {
      "GNOSISGlobalGrid",
      "ISEA4R", "ISEA9R", "ISEA3H", "ISEA7H", "ISEA7H_Z7",
      "IVEA4R", "IVEA9R", "IVEA3H", "IVEA7H", "IVEA7H_Z7",
      "RTEA4R", "RTEA9R", "RTEA3H", "RTEA7H", "RTEA7H_Z7",
      "HEALPix", "rHEALPix",
      null
   };
   if(count)
      *count = sizeof(dggrsList) / sizeof(dggrsList[0]) - 1;
   return dggrsList;
}

// DGGRS Class

// Virtual Methods
LIB_EXPORT DGGRSZone DGGAL_DGGRS_getZoneFromTextID(DGGRS self, const String zoneID)
{
   return DGGRS_getZoneFromTextID(self, zoneID);
}

LIB_EXPORT int DGGAL_DGGRS_getZoneLevel(DGGRS self, DGGRSZone zone)
{
   return DGGRS_getZoneLevel(self, zone);
}

LIB_EXPORT int DGGAL_DGGRS_countZoneEdges(DGGRS self, DGGRSZone zone)
{
   return DGGRS_countZoneEdges(self, zone);
}

LIB_EXPORT int DGGAL_DGGRS_getRefinementRatio(DGGRS self)
{
   return DGGRS_getRefinementRatio(self);
}

LIB_EXPORT int DGGAL_DGGRS_getMaxDGGRSZoneLevel(DGGRS self)
{
   return DGGRS_getMaxDGGRSZoneLevel(self);
}

LIB_EXPORT void DGGAL_DGGRS_getZoneWGS84Centroid(DGGRS self, DGGRSZone zone, GeoPoint * outCentroid)
{
   DGGRS_getZoneWGS84Centroid(self, zone, outCentroid);
}

LIB_EXPORT int DGGAL_DGGRS_getZoneWGS84Vertices(DGGRS self, DGGRSZone zone, GeoPoint * outVertices)
{
   return DGGRS_getZoneWGS84Vertices(self, zone, outVertices);
}

LIB_EXPORT double DGGAL_DGGRS_getZoneArea(DGGRS self, DGGRSZone zone)
{
   return DGGRS_getZoneArea(self, zone);
}

LIB_EXPORT uint64 DGGAL_DGGRS_countSubZones(DGGRS self, DGGRSZone zone, int depth)
{
   return DGGRS_countSubZones(self, zone, depth);
}

LIB_EXPORT void DGGAL_DGGRS_getZoneTextID(DGGRS self, DGGRSZone zone, char outId[256])
{
   DGGRS_getZoneTextID(self, zone, outId);
}

LIB_EXPORT int DGGAL_DGGRS_getZoneParents(DGGRS self, DGGRSZone zone, DGGRSZone outParents[3])
{
   return DGGRS_getZoneParents(self, zone, outParents);
}

LIB_EXPORT int DGGAL_DGGRS_getZoneChildren(DGGRS self, DGGRSZone zone, DGGRSZone outChildren[13])
{
   return DGGRS_getZoneChildren(self, zone, outChildren);
}

LIB_EXPORT int DGGAL_DGGRS_getZoneNeighbors(DGGRS self, DGGRSZone zone, DGGRSZone outNeighbors[6], int outNbTypes[6])
{
   return DGGRS_getZoneNeighbors(self, zone, outNeighbors, outNbTypes);
}

LIB_EXPORT DGGRSZone DGGAL_DGGRS_getZoneCentroidParent(DGGRS self, DGGRSZone zone)
{
   return DGGRS_getZoneCentroidParent(self, zone);
}

LIB_EXPORT DGGRSZone DGGAL_DGGRS_getZoneCentroidChild(DGGRS self, DGGRSZone zone)
{
   return DGGRS_getZoneCentroidChild(self, zone);
}

LIB_EXPORT int DGGAL_DGGRS_isZoneCentroidChild(DGGRS self, DGGRSZone zone)
{
   return DGGRS_isZoneCentroidChild(self, zone);
}

LIB_EXPORT void DGGAL_DGGRS_getZoneWGS84Extent(DGGRS self, DGGRSZone zone, GeoExtent * outExtent)
{
   return DGGRS_getZoneWGS84Extent(self, zone, outExtent);
}

LIB_EXPORT T(Array, DGGRSZone) DGGAL_DGGRS_listZones(DGGRS self, int level, const GeoExtent * bbox)
{
   return DGGRS_listZones(self, level, bbox);
}

LIB_EXPORT T(Array, GeoPoint) DGGAL_DGGRS_getZoneRefinedWGS84Vertices(DGGRS self, DGGRSZone zone, int refinement)
{
   return DGGRS_getZoneRefinedWGS84Vertices(self, zone, refinement);
}

LIB_EXPORT T(Array, DGGRSZone) DGGAL_DGGRS_getSubZones(DGGRS self, DGGRSZone zone, int depth)
{
   return DGGRS_getSubZones(self, zone, depth);
}

LIB_EXPORT DGGRSZone DGGAL_DGGRS_getZoneFromWGS84Centroid(DGGRS self, int level, const GeoPoint * point)
{
   return DGGRS_getZoneFromWGS84Centroid(self, level, point);
}

LIB_EXPORT uint64 DGGAL_DGGRS_countZones(DGGRS self, int level)
{
   return DGGRS_countZones(self, level);
}

LIB_EXPORT DGGRSZone DGGAL_DGGRS_getFirstSubZone(DGGRS self, DGGRSZone parent, int relativeDepth)
{
   return DGGRS_getFirstSubZone(self, parent, relativeDepth);
}

LIB_EXPORT int DGGAL_DGGRS_getIndexMaxDepth(DGGRS self)
{
   return DGGRS_getIndexMaxDepth(self);
}

LIB_EXPORT int DGGAL_DGGRS_getMaxChildren(DGGRS self)
{
   return DGGRS_getMaxChildren(self);
}

LIB_EXPORT int DGGAL_DGGRS_getMaxNeighbors(DGGRS self)
{
   return DGGRS_getMaxNeighbors(self);
}

LIB_EXPORT int DGGAL_DGGRS_getMaxParents(DGGRS self)
{
   return DGGRS_getMaxParents(self);
}

LIB_EXPORT DGGRSZone DGGAL_DGGRS_getSubZoneAtIndex(DGGRS self, DGGRSZone parent, int relativeDepth, int64 index)
{
   return DGGRS_getSubZoneAtIndex(self, parent, relativeDepth, index);
}

LIB_EXPORT int64 DGGAL_DGGRS_getSubZoneIndex(DGGRS self, DGGRSZone parent, DGGRSZone subZone)
{
   return DGGRS_getSubZoneIndex(self, parent, subZone);
}

LIB_EXPORT T(Array, Pointd) DGGAL_DGGRS_getSubZoneCRSCentroids(DGGRS self, DGGRSZone parent, CRS crs, int relativeDepth)
{
   return DGGRS_getSubZoneCRSCentroids(self, parent, crs, relativeDepth);
}

LIB_EXPORT T(Array, GeoPoint) DGGAL_DGGRS_getSubZoneWGS84Centroids(DGGRS self, DGGRSZone parent, int relativeDepth)
{
   return DGGRS_getSubZoneWGS84Centroids(self, parent, relativeDepth);
}

LIB_EXPORT int DGGAL_DGGRS_getZoneCRSVertices(DGGRS self, DGGRSZone zone, CRS crs, Pointd outVertices[6])
{
   return DGGRS_getZoneCRSVertices(self, zone, crs, outVertices);
}

LIB_EXPORT T(Array, Pointd) DGGAL_DGGRS_getZoneRefinedCRSVertices(DGGRS self, DGGRSZone zone, CRS crs, int refinement)
{
   return DGGRS_getZoneRefinedCRSVertices(self, zone, crs, refinement);
}

LIB_EXPORT void DGGAL_DGGRS_getZoneCRSCentroid(DGGRS self, DGGRSZone zone, CRS crs, Pointd * outCentroid)
{
   return DGGRS_getZoneCRSCentroid(self, zone, crs, outCentroid);
}

LIB_EXPORT void DGGAL_DGGRS_getZoneCRSExtent(DGGRS self, DGGRSZone zone, CRS crs, CRSExtent * outExtent)
{
   return DGGRS_getZoneCRSExtent(self, zone, crs, outExtent);
}

LIB_EXPORT void DGGAL_DGGRS_compactZones(DGGRS self, T(Array, DGGRSZone) zones)
{
   return DGGRS_compactZones(self, zones);
}

// Non-virtual methods
LIB_EXPORT int DGGAL_DGGRS_get64KDepth(DGGRS self)
{
   return DGGRS_get64KDepth(self);
}

LIB_EXPORT int DGGAL_DGGRS_getMaxDepth(DGGRS self)
{
   return DGGRS_getMaxDepth(self);
}

LIB_EXPORT int DGGAL_DGGRS_areZonesNeighbors(DGGRS self, DGGRSZone a, DGGRSZone b)
{
   return DGGRS_areZonesNeighbors(self, a, b);
}

LIB_EXPORT int DGGAL_DGGRS_areZonesSiblings(DGGRS self, DGGRSZone a, DGGRSZone b)
{
   return DGGRS_areZonesSiblings(self, a, b);
}

LIB_EXPORT int DGGAL_DGGRS_doZonesOverlap(DGGRS self, DGGRSZone a, DGGRSZone b)
{
   return DGGRS_doZonesOverlap(self, a, b);
}

LIB_EXPORT int DGGAL_DGGRS_doesZoneContain(DGGRS self, DGGRSZone hayStack, DGGRSZone needle)
{
   return DGGRS_doesZoneContain(self, hayStack, needle);
}

LIB_EXPORT int DGGAL_DGGRS_isZoneAncestorOf(DGGRS self, DGGRSZone ancestor, DGGRSZone descendant, int maxDepth)
{
   return DGGRS_isZoneAncestorOf(self, ancestor, descendant, maxDepth);
}

LIB_EXPORT int DGGAL_DGGRS_isZoneContainedIn(DGGRS self, DGGRSZone needle, DGGRSZone hayStack)
{
   return DGGRS_isZoneContainedIn(self, hayStack, needle);
}

LIB_EXPORT int DGGAL_DGGRS_isZoneDescendantOf(DGGRS self, DGGRSZone descendant, DGGRSZone ancestor, int maxDepth)
{
   return DGGRS_isZoneDescendantOf(self, ancestor, descendant, maxDepth);
}

LIB_EXPORT int DGGAL_DGGRS_isZoneImmediateChildOf(DGGRS self, DGGRSZone child, DGGRSZone parent)
{
   return DGGRS_isZoneImmediateChildOf(self, child, parent);
}

LIB_EXPORT int DGGAL_DGGRS_isZoneImmediateParentOf(DGGRS self, DGGRSZone parent, DGGRSZone child)
{
   return DGGRS_isZoneImmediateParentOf(self, child, parent);
}

LIB_EXPORT int DGGAL_DGGRS_zoneHasSubZone(DGGRS self, DGGRSZone hayStack, DGGRSZone needle)
{
   return DGGRS_zoneHasSubZone(self, hayStack, needle);
}

LIB_EXPORT int DGGAL_DGGRS_getLevelFromMetersPerSubZone(DGGRS self, double physicalMetersPerSubZone, int relativeDepth)
{
   return DGGRS_getLevelFromMetersPerSubZone(self, physicalMetersPerSubZone, relativeDepth);
}

LIB_EXPORT int DGGAL_DGGRS_getLevelFromPixelsAndExtent(DGGRS self, const GeoExtent * extent, int width, int height, int relativeDepth)
{
   Point pixels = { width, height };
   return DGGRS_getLevelFromPixelsAndExtent(self, extent, &pixels, relativeDepth);
}

LIB_EXPORT int DGGAL_DGGRS_getLevelFromRefZoneArea(DGGRS self, double metersSquared)
{
   return DGGRS_getLevelFromRefZoneArea(self, metersSquared);
}

LIB_EXPORT int DGGAL_DGGRS_getLevelFromScaleDenominator(DGGRS self, double scaleDenominator, int relativeDepth, double mmPerPixel)
{
   return DGGRS_getLevelFromScaleDenominator(self, scaleDenominator, relativeDepth, mmPerPixel);
}

LIB_EXPORT double DGGAL_DGGRS_getMetersPerSubZoneFromLevel(DGGRS self, int parentLevel, int relativeDepth)
{
   return DGGRS_getMetersPerSubZoneFromLevel(self, parentLevel, relativeDepth);
}

LIB_EXPORT double DGGAL_DGGRS_getRefZoneArea(DGGRS self, int level)
{
   return DGGRS_getRefZoneArea(self, level);
}

LIB_EXPORT double DGGAL_DGGRS_getScaleDenominatorFromLevel(DGGRS self, int parentLevel, int relativeDepth, double mmPerPixel)
{
   return DGGRS_getScaleDenominatorFromLevel(self, parentLevel, relativeDepth, mmPerPixel);
}



================================================
FILE: bindings/c_fn/dggal_c.h
================================================
#ifndef __DGGAL_C_H__
#define __DGGAL_C_H__

#include <stdint.h>

#if !defined(BINDINGS_SHARED)
#define LIB_EXPORT
#define LIB_IMPORT
#elif defined(__WIN32__)
#define LIB_EXPORT __attribute__((dllexport)) __attribute__ ((visibility("default")))
#define LIB_IMPORT __attribute__((dllimport))
#else
#define LIB_EXPORT __attribute__ ((visibility("default")))
#define LIB_IMPORT
#endif

struct DGGALModule;
typedef struct DGGALModule * DGGALModule;

// DGGAL Initialization -- Setup a single DGGAL module per application (unsafe to call multiple times)
LIB_IMPORT DGGALModule DGGAL_init();
LIB_IMPORT void DGGAL_terminate(DGGALModule mDGGAL);

// Data Types
struct DGGRS;
typedef struct DGGRS * DGGRS;
typedef uint64_t DGGRSZone;
static const uint64_t nullZone = 0xFFFFFFFFFFFFFFFFLL;

typedef char * String;
typedef const char * constString;
typedef uint64_t CRS;
enum CRSRegistry
{
   epsg = 0x0,
   ogc = 0x1
};
typedef enum CRSRegistry CRSRegistry;
LIB_IMPORT CRSRegistry DGGAL_CRS(CRSRegistry registry, unsigned int code, int h);

struct Pointd
{
   double x, y;
};
typedef struct Pointd Pointd;
struct CRSExtent
{
   CRS crs;
   Pointd tl;
   Pointd br;
};
typedef struct CRSExtent CRSExtent;
typedef double Radians;
struct GeoPoint
{
   Radians lat, lon;
};
typedef struct GeoPoint GeoPoint;
struct GeoExtent
{
   GeoPoint ll, ur;
};
typedef struct GeoExtent GeoExtent;

// Dynamic Arrays
struct Array_GeoPoint;
typedef struct Array_GeoPoint * Array_GeoPoint;
LIB_IMPORT int DGGAL_Array_GeoPoint_getCount(const Array_GeoPoint self);
LIB_IMPORT const GeoPoint * DGGAL_Array_GeoPoint_getPointer(const Array_GeoPoint self);
LIB_IMPORT void DGGAL_Array_GeoPoint_delete(Array_GeoPoint self);

struct Array_Pointd;
typedef struct Array_Pointd * Array_Pointd;
LIB_IMPORT int DGGAL_Array_Pointd_getCount(const Array_Pointd self);
LIB_IMPORT const Pointd * DGGAL_Array_Pointd_getPointer(const Array_Pointd self);
LIB_IMPORT void DGGAL_Array_Pointd_delete(Array_Pointd self);

struct Array_DGGRSZone;
typedef struct Array_DGGRSZone * Array_DGGRSZone;
LIB_IMPORT Array_DGGRSZone DGGAL_Array_DGGRSZone_new(unsigned int size);
LIB_IMPORT int DGGAL_Array_DGGRSZone_getCount(const Array_DGGRSZone self);
LIB_IMPORT DGGRSZone * DGGAL_Array_DGGRSZone_getPointer(const Array_DGGRSZone self);
LIB_IMPORT void DGGAL_Array_DGGRSZone_delete(Array_DGGRSZone self);

// DGGRS Instantiation -- Setup and re-use single instance per DGGRS (e.g., IVEA3H, HEALPix, GNOSISGlobalGrid)
LIB_IMPORT const char ** DGGAL_DGGRS_list(unsigned int * count);
LIB_IMPORT DGGRS DGGAL_DGGRS_new(DGGALModule mDGGAL, constString name);
LIB_IMPORT void DGGAL_DGGRS_delete(DGGRS self);

// DGGRS Class -- All DGGRS methods can safely be called on the same DGGRS instance from multiple threads
LIB_IMPORT DGGRSZone DGGAL_DGGRS_getZoneFromTextID(const DGGRS self, constString zoneID);
LIB_IMPORT int DGGAL_DGGRS_getZoneLevel(const DGGRS self, DGGRSZone zone);
LIB_IMPORT int DGGAL_DGGRS_countZoneEdges(const DGGRS self, DGGRSZone zone);
LIB_IMPORT int DGGAL_DGGRS_getRefinementRatio(const DGGRS self);
LIB_IMPORT int DGGAL_DGGRS_getMaxDGGRSZoneLevel(const DGGRS self);
LIB_IMPORT void DGGAL_DGGRS_getZoneWGS84Centroid(const DGGRS self, DGGRSZone zone, GeoPoint * outCentroid);
LIB_IMPORT int DGGAL_DGGRS_getZoneWGS84Vertices(const DGGRS self, DGGRSZone zone, GeoPoint outVertices[6]);
LIB_EXPORT int DGGAL_DGGRS_getZoneCRSVertices(DGGRS self, DGGRSZone zone, CRS crs, Pointd outVertices[6]);
LIB_IMPORT double DGGAL_DGGRS_getZoneArea(const DGGRS self, DGGRSZone zone);
LIB_IMPORT uint64_t DGGAL_DGGRS_countSubZones(const DGGRS self, DGGRSZone zone, int depth);
LIB_IMPORT void DGGAL_DGGRS_getZoneTextID(const DGGRS self, DGGRSZone zone, char outId[256]);
LIB_IMPORT int DGGAL_DGGRS_getZoneParents(const DGGRS self, DGGRSZone zone, DGGRSZone outParents[3]);
LIB_IMPORT int DGGAL_DGGRS_getZoneChildren(const DGGRS self, DGGRSZone zone, DGGRSZone outChildren[13]);
LIB_IMPORT int DGGAL_DGGRS_getZoneNeighbors(const DGGRS self, DGGRSZone zone, DGGRSZone outNeighbors[6], int outNbTypes[6]);
LIB_IMPORT DGGRSZone DGGAL_DGGRS_getZoneCentroidParent(const DGGRS self, DGGRSZone zone);
LIB_IMPORT DGGRSZone DGGAL_DGGRS_getZoneCentroidChild(const DGGRS self, DGGRSZone zone);
LIB_IMPORT int DGGAL_DGGRS_isZoneCentroidChild(const DGGRS self, DGGRSZone zone);
LIB_IMPORT void DGGAL_DGGRS_getZoneWGS84Extent(const DGGRS self, DGGRSZone zone, GeoExtent * outExtent);
LIB_IMPORT Array_DGGRSZone DGGAL_DGGRS_listZones(const DGGRS self, int level, const GeoExtent * bbox);
LIB_IMPORT Array_GeoPoint DGGAL_DGGRS_getZoneRefinedWGS84Vertices(const DGGRS self, DGGRSZone zone, int refinement);
LIB_IMPORT Array_DGGRSZone DGGAL_DGGRS_getSubZones(const DGGRS self, DGGRSZone zone, int depth);
LIB_IMPORT DGGRSZone DGGAL_DGGRS_getZoneFromWGS84Centroid(const DGGRS self, int level, const GeoPoint * point);
LIB_IMPORT uint64_t DGGAL_DGGRS_countZones(const DGGRS self, int level);
LIB_IMPORT DGGRSZone DGGAL_DGGRS_getFirstSubZone(const DGGRS self, DGGRSZone parent, int relativeDepth);
LIB_IMPORT int DGGAL_DGGRS_getIndexMaxDepth(const DGGRS self);
LIB_IMPORT int DGGAL_DGGRS_getMaxChildren(const DGGRS self);
LIB_IMPORT int DGGAL_DGGRS_getMaxNeighbors(const DGGRS self);
LIB_IMPORT int DGGAL_DGGRS_getMaxParents(const DGGRS self);
LIB_IMPORT DGGRSZone DGGAL_DGGRS_getSubZoneAtIndex(const DGGRS self, DGGRSZone parent, int relativeDepth, int64_t index);
LIB_IMPORT int64_t DGGAL_DGGRS_getSubZoneIndex(const DGGRS self, DGGRSZone parent, DGGRSZone subZone);
LIB_IMPORT Array_Pointd DGGAL_DGGRS_getSubZoneCRSCentroids(const DGGRS self, DGGRSZone parent, CRS crs, int relativeDepth);
LIB_IMPORT Array_GeoPoint DGGAL_DGGRS_getSubZoneWGS84Centroids(const DGGRS self, DGGRSZone parent, int relativeDepth);
LIB_IMPORT Array_Pointd DGGAL_DGGRS_getZoneRefinedCRSVertices(const DGGRS self, DGGRSZone zone, CRS crs, int refinement);
LIB_IMPORT void DGGAL_DGGRS_getZoneCRSCentroid(const DGGRS self, DGGRSZone zone, CRS crs, Pointd * outCentroid);
LIB_IMPORT void DGGAL_DGGRS_getZoneCRSExtent(const DGGRS self, DGGRSZone zone, CRS crs, CRSExtent * outExtent);
LIB_IMPORT void DGGAL_DGGRS_compactZones(const DGGRS self, Array_DGGRSZone zones);
LIB_IMPORT int DGGAL_DGGRS_get64KDepth(const DGGRS self);
LIB_IMPORT int DGGAL_DGGRS_getMaxDepth(const DGGRS self);
LIB_IMPORT int DGGAL_DGGRS_areZonesNeighbors(const DGGRS self, DGGRSZone a, DGGRSZone b);
LIB_IMPORT int DGGAL_DGGRS_areZonesSiblings(const DGGRS self, DGGRSZone a, DGGRSZone b);
LIB_IMPORT int DGGAL_DGGRS_doZonesOverlap(const DGGRS self, DGGRSZone a, DGGRSZone b);
LIB_IMPORT int DGGAL_DGGRS_doesZoneContain(const DGGRS self, DGGRSZone hayStack, DGGRSZone needle);
LIB_IMPORT int DGGAL_DGGRS_isZoneAncestorOf(const DGGRS self, DGGRSZone ancestor, DGGRSZone descendant, int maxDepth);
LIB_IMPORT int DGGAL_DGGRS_isZoneContainedIn(const DGGRS self, DGGRSZone needle, DGGRSZone hayStack);
LIB_IMPORT int DGGAL_DGGRS_isZoneDescendantOf(const DGGRS self, DGGRSZone descendant, DGGRSZone ancestor, int maxDepth);
LIB_IMPORT int DGGAL_DGGRS_isZoneImmediateChildOf(const DGGRS self, DGGRSZone child, DGGRSZone parent);
LIB_IMPORT int DGGAL_DGGRS_isZoneImmediateParentOf(const DGGRS self, DGGRSZone parent, DGGRSZone child);
LIB_IMPORT int DGGAL_DGGRS_zoneHasSubZone(const DGGRS self, DGGRSZone hayStack, DGGRSZone needle);
LIB_IMPORT int DGGAL_DGGRS_getLevelFromMetersPerSubZone(const DGGRS self, double physicalMetersPerSubZone, int relativeDepth);
LIB_IMPORT int DGGAL_DGGRS_getLevelFromPixelsAndExtent(const DGGRS self, const GeoExtent * extent, int width, int height, int relativeDepth);
LIB_IMPORT int DGGAL_DGGRS_getLevelFromRefZoneArea(const DGGRS self, double metersSquared);
LIB_IMPORT int DGGAL_DGGRS_getLevelFromScaleDenominator(const DGGRS self, double scaleDenominator, int relativeDepth, double mmPerPixel);
LIB_IMPORT double DGGAL_DGGRS_getMetersPerSubZoneFromLevel(const DGGRS self, int parentLevel, int relativeDepth);
LIB_IMPORT double DGGAL_DGGRS_getRefZoneArea(const DGGRS self, int level);
LIB_IMPORT double DGGAL_DGGRS_getScaleDenominatorFromLevel(const DGGRS self, int parentLevel, int relativeDepth, double mmPerPixel);

#endif // __DGGAL_C_H__



================================================
FILE: bindings/c_fn/Makefile
================================================
ifneq ($(V),1)
.SILENT:
endif

# CORE VARIABLES

BINDING_MODULE := dggal
BINDING_NAME := dggal
MODULE := $(BINDING_NAME)_c_fn
VERSION := 0.0.6
CONFIG := release
# CONTAINS_CXX := defined
ifndef COMPILER
COMPILER := default
endif

TARGET_TYPE = sharedlib

# FLAGS

ifndef DEBIAN_PACKAGE
CFLAGS = -std=c++17 -fno-exceptions -fno-rtti -Wcomment
LDFLAGS =
endif
PRJ_CFLAGS =
CECFLAGS =
OFLAGS = -Wl,-nostdlib
LIBS =

ifdef DEBUG
NOSTRIP := y
endif

CONSOLE = -mwindows

# INCLUDES

DGGAL_ABSPATH := $(dir $(realpath $(firstword $(MAKEFILE_LIST))))../../

ifndef EC_SDK_SRC
EC_SDK_SRC := $(DGGAL_ABSPATH)../eC
endif

export _CF_DIR = $(EC_SDK_SRC)/

include $(_CF_DIR)crossplatform.mk
include $(_CF_DIR)default.cf

# POST-INCLUDES VARIABLES

OBJ = obj/$(BINDING_NAME).$(CONFIG).$(PLATFORM)$(COMPILER_SUFFIX)$(DEBUG_SUFFIX)/

RES =

ifdef LINUX_TARGET
TARGET = $(OBJ)$(LP)$(MODULE)$(SO).$(VERSION)
SONAME = -Wl,-soname,$(LP)$(MODULE)$(SO).0
else
TARGET = $(OBJ)$(LP)$(MODULE)$(SO)
SONAME =
endif

_OBJECTS = $(_DEP_OBJECTS) \
	$(OBJ)$(BINDING_NAME)$(O)

OBJECTS = $(_OBJECTS)

SOURCES = $(_DEP_SOURCES) \
	$(BINDING_NAME)_c.c

LIBS += $(SHAREDLIB) $(EXECUTABLE) $(LINKOPT)

ifndef STATIC_LIBRARY_TARGET
LIBS += \
   $(call _L,dggal_c) \
	$(call _L,ecrt_c) \
	$(call _L,ecrt)
endif

PRJ_CFLAGS += \
	 $(if $(DEBUG), -g, -O2 -ffast-math) $(FPIC) -w -DBINDINGS_SHARED -I. #-DECPRFX=eC_

#(SPECIFIC_FLAGS)#

PRJ_CFLAGS +=  -I../c -I$(EC_SDK_SRC)/bindings/c

ifndef STATIC_LIBRARY_TARGET
OFLAGS += \
	-L$(DGGAL_ABSPATH)obj/$(PLATFORM)$(COMPILER_SUFFIX)$(DEBUG_SUFFIX)/bin \
	-L$(DGGAL_ABSPATH)obj/$(PLATFORM)$(COMPILER_SUFFIX)$(DEBUG_SUFFIX)/lib \
	-L$(EC_SDK_SRC)/obj/$(PLATFORM)$(COMPILER_SUFFIX)$(DEBUG_SUFFIX)/bin \
	-L$(EC_SDK_SRC)/obj/$(PLATFORM)$(COMPILER_SUFFIX)$(DEBUG_SUFFIX)/lib

endif

# PLATFORM-SPECIFIC OPTIONS

ifdef WINDOWS_TARGET

ifndef STATIC_LIBRARY_TARGET

OFLAGS += -static-libgcc

endif

endif

# TARGETS

.PHONY: all
all: objdir $(TARGET);

.PHONY: objdir
objdir:
	$(call mkdir,$(OBJ))

$(SYMBOLS): | objdir
$(OBJECTS): | objdir
$(TARGET): $(SOURCES) $(OBJECTS) | objdir
	$(LD) $(OFLAGS) $(_OBJECTS) $(LIBS) -o $(TARGET) $(INSTALLNAME)
ifndef NOSTRIP
	$(STRIP) $(STRIPOPT) $(TARGET)
endif
ifdef LINUX_TARGET
ifdef LINUX_HOST
	$(if $(basename $(basename $(VER))),ln -sf $(LP)$(MODULE)$(SO)$(VER) $(OBJ)$(LP)$(MODULE)$(SO)$(basename $(basename $(VER))),)
	$(if $(basename $(VER)),ln -sf $(LP)$(MODULE)$(SO)$(VER) $(OBJ)$(LP)$(MODULE)$(SO)$(basename $(VER)),)
	$(if $(VER),ln -sf $(LP)$(MODULE)$(SO)$(VER) $(OBJ)$(LP)$(MODULE)$(SO),)
endif
endif
	$(call cp,$(TARGET),$(DGGAL_ABSPATH)$(SODESTDIR))
ifdef LINUX_TARGET
ifdef LINUX_HOST
	$(if $(basename $(basename $(VER))),ln -sf $(LP)$(MODULE)$(SO)$(VER) $(DGGAL_ABSPATH)$(SODESTDIR)$(LP)$(MODULE)$(SO)$(basename $(basename $(VER))),)
	$(if $(basename $(VER)),ln -sf $(LP)$(MODULE)$(SO)$(VER) $(DGGAL_ABSPATH)$(SODESTDIR)$(LP)$(MODULE)$(SO)$(basename $(VER)),)
	$(if $(VER),ln -sf $(LP)$(MODULE)$(SO)$(VER) $(DGGAL_ABSPATH)$(SODESTDIR)$(LP)$(MODULE)$(SO),)
endif
endif

# OBJECT RULES

$(OBJ)$(BINDING_NAME)$(O): $(BINDING_NAME)_c.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,$<) -o $(call quote_path,$@)

.PHONY: cleantarget
cleantarget:
	$(call rm,$(TARGET))
ifdef LINUX_TARGET
ifdef LINUX_HOST
	$(call rm,$(OBJ)$(LP)$(MODULE)$(SO)$(basename $(VER)))
	$(call rm,$(OBJ)$(LP)$(MODULE)$(SO))
endif
endif

.PHONY: clean
clean: cleantarget
	$(call rm,$(_OBJECTS))

.PHONY: realclean
realclean: cleantarget
	$(call rmr,$(OBJ))

.PHONY: wipeclean
wipeclean:
	$(call rmr,obj/)

.PHONY: distclean
distclean:
	$(_MAKE) -f $(_CF_DIR)Cleanfile distclean distclean_all_subdirs

$(MAKEFILE_LIST): ;
$(SOURCES): ;
$(RESOURCES): ;



================================================
FILE: bindings/c_fn/Makefile.allinone
================================================
ifneq ($(V),1)
.SILENT:
endif

# CORE VARIABLES

BINDING_MODULE := dggal
BINDING_NAME := dggal
MODULE := dggal
TARGET_NAME := $(MODULE)_c_fn
VERSION := 0.0.6
CONFIG := allinone
# CONTAINS_CXX := defined
ifndef COMPILER
COMPILER := default
endif

TARGET_TYPE = sharedlib

# FLAGS

ifndef DEBIAN_PACKAGE
CFLAGS = -Wcomment
LDFLAGS =
endif
PRJ_CFLAGS =
CECFLAGS =
OFLAGS = #-Wl,-nostdlib
LIBS =

ifdef DEBUG
NOSTRIP := y
endif

CONSOLE = -mwindows

# INCLUDES

DGGALCFN_ABSPATH := $(dir $(realpath $(firstword $(MAKEFILE_LIST))))

DGGAL_ABSPATH := $(realpath $(dir $(DGGALCFN_ABSPATH))../../)/

ifndef EC_SDK_SRC
EC_SDK_SRC := $(realpath $(dir $(DGGAL_ABSPATH)/)../eC)
endif

export _CF_DIR = $(EC_SDK_SRC)/

include $(_CF_DIR)crossplatform.mk
include $(_CF_DIR)$(COMPILER).cf

# POST-INCLUDES VARIABLES

OBJ = obj/$(BINDING_NAME).$(CONFIG).$(PLATFORM)$(COMPILER_SUFFIX)$(DEBUG_SUFFIX)/

RES =

ifdef LINUX_TARGET
TARGET = $(OBJ)$(LP)$(TARGET_NAME)$(SO).$(VERSION)
SONAME = -Wl,-soname,$(LP)$(MODULE)$(SO).0
else
TARGET = $(OBJ)$(LP)$(TARGET_NAME)$(SO)
SONAME =
endif

_OBJECTS = $(_DEP_OBJECTS) \
	$(OBJ)$(BINDING_NAME)$(O)

OBJECTS = $(_OBJECTS)

SOURCES = $(_DEP_SOURCES) \
	$(BINDING_NAME)_c.c

LIBS += $(SHAREDLIB) $(EXECUTABLE) $(LINKOPT)

ifndef STATIC_LIBRARY_TARGET
LIBS += \
   $(call _L,dggal_cStatic) \
	$(call _L,ecrt_cStatic) \
	$(call _L,dggalStatic) \
	$(call _L,ecrtStatic) \
	$(call _L,m) \
	$(call _L,z)
endif

PRJ_CFLAGS += \
	 $(if $(DEBUG), -g, -O2 -ffast-math) $(FPIC) -w -DDGGAL_ALLINONE -I. #-DECPRFX=eC_

#(SPECIFIC_FLAGS)#

PRJ_CFLAGS +=  -I../c -I$(EC_SDK_SRC)/bindings/c

OFLAGS += \
	-L$(DGGAL_ABSPATH)obj/$(PLATFORM)$(COMPILER_SUFFIX)$(DEBUG_SUFFIX)/lib \
	-L$(EC_SDK_SRC)/obj/$(PLATFORM)$(COMPILER_SUFFIX)$(DEBUG_SUFFIX)/lib

# PLATFORM-SPECIFIC OPTIONS

ifdef WINDOWS_TARGET

ifndef STATIC_LIBRARY_TARGET

OFLAGS += -static-libgcc

LIBS += \
	$(call _L,winmm) \
	$(call _L,kernel32) \
	$(call _L,user32) \
	$(call _L,mpr) \
	$(call _L,advapi32) \
	$(call _L,shell32)

endif

else
ifdef LINUX_TARGET

ifndef STATIC_LIBRARY_TARGET
ifneq ($(ARCH),x32)
ifneq ($(shell uname -m),x86_64)
# $(warning ARCH: $(ARCH) -- adding -Wl,--wrap=fcntl64 to OFLAGS)
OFLAGS += \
	 -Wl,--wrap=fcntl64
endif
endif
OFLAGS +=

LIBS += \
	$(call _L,pthread) \
	$(call _L,m) \
	$(call _L,dl)

endif

else
ifdef OSX_TARGET

ifndef STATIC_LIBRARY_TARGET
OFLAGS +=

LIBS += \
	$(call _L,pthread) \
	$(call _L,m) \
	$(call _L,dl)

endif

endif
endif
endif


# TARGETS

.PHONY: all
all: objdir $(TARGET);

.PHONY: objdir
objdir:
	$(call mkdir,$(OBJ))

$(SYMBOLS): | objdir
$(OBJECTS): | objdir
$(TARGET): $(SOURCES) $(OBJECTS) | objdir
	$(LD) $(OFLAGS) $(_OBJECTS) $(LIBS) -o $(TARGET) $(INSTALLNAME)
ifndef NOSTRIP
	$(STRIP) $(STRIPOPT) $(TARGET)
endif
ifdef LINUX_TARGET
ifdef LINUX_HOST
	$(if $(basename $(VER)),ln -sf $(LP)$(TARGET_NAME)$(SO)$(VER) $(OBJ)$(LP)$(TARGET_NAME)$(SO)$(basename $(VER)),)
	$(if $(basename $(basename $(VER))),ln -sf $(LP)$(TARGET_NAME)$(SO)$(VER) $(OBJ)$(LP)$(TARGET_NAME)$(SO)$(basename $(basename $(VER))),)
	$(if $(VER),ln -sf $(LP)$(TARGET_NAME)$(SO)$(VER) $(OBJ)$(LP)$(TARGET_NAME)$(SO),)
endif
endif
	$(call cp,$(TARGET),$(DGGAL_ABSPATH)$(SODESTDIR))
ifdef LINUX_TARGET
ifdef LINUX_HOST
	$(if $(basename $(basename $(VER))),ln -sf $(LP)$(TARGET_NAME)$(SO)$(VER) $(DGGAL_ABSPATH)$(SODESTDIR)$(LP)$(TARGET_NAME)$(SO)$(basename $(basename $(VER))),)
	$(if $(basename $(VER)),ln -sf $(LP)$(TARGET_NAME)$(SO)$(VER) $(DGGAL_ABSPATH)$(SODESTDIR)$(LP)$(TARGET_NAME)$(SO)$(basename $(VER)),)
	$(if $(VER),ln -sf $(LP)$(TARGET_NAME)$(SO)$(VER) $(DGGAL_ABSPATH)$(SODESTDIR)$(LP)$(TARGET_NAME)$(SO),)
endif
endif

# OBJECT RULES


$(OBJ)$(BINDING_NAME)$(O): $(BINDING_NAME)_c.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,$<) -o $(call quote_path,$@)

.PHONY: cleantarget
cleantarget:
	$(call rm,$(TARGET))
ifdef LINUX_TARGET
ifdef LINUX_HOST
	$(call rm,$(OBJ)$(LP)$(TARGET_NAME)$(SO)$(basename $(basename $(VER))))
	$(call rm,$(OBJ)$(LP)$(TARGET_NAME)$(SO)$(basename $(VER)))
	$(call rm,$(OBJ)$(LP)$(TARGET_NAME)$(SO))
endif
endif

.PHONY: clean
clean: cleantarget
	$(call rm,$(_OBJECTS))

.PHONY: realclean
realclean: cleantarget
	$(call rmr,$(OBJ))

.PHONY: wipeclean
wipeclean:
	$(call rmr,obj/)

.PHONY: distclean
distclean:
	$(_MAKE) -f $(_CF_DIR)Cleanfile distclean distclean_all_subdirs

$(MAKEFILE_LIST): ;
$(SOURCES): ;
$(RESOURCES): ;



================================================
FILE: bindings/cpp/Makefile
================================================
.PHONY: all clean realclean distclean dggal_cpp

DGGAL_ABSPATH := $(dir $(realpath $(firstword $(MAKEFILE_LIST))))../../

ifndef EC_SDK_SRC
EC_SDK_SRC := $(DGGAL_ABSPATH)../eC
endif

export _CF_DIR = $(EC_SDK_SRC)/
include $(_CF_DIR)crossplatform.mk

# TARGETS

all: dggal_cpp

dggal_cpp:
	+$(_MAKE) -f Makefile.dggal_cpp

clean:
	+$(_MAKE) -f Makefile.dggal_cpp clean
	
realclean:
	+$(_MAKE) -f Makefile.dggal_cpp realclean

distclean:
	+$(_MAKE) -f Makefile.dggal_cpp distclean



================================================
FILE: bindings/cpp/Makefile.dggal_cpp
================================================
ifneq ($(V),1)
.SILENT:
endif

# CORE VARIABLES

BINDMODLOC := obj
BINDING_MODULE := dggal
BINDING_NAME := dggal
MODULE := $(BINDING_NAME)_cpp
VERSION := 0.0.6
CONFIG := release
# CONTAINS_CXX := defined
ifndef COMPILER
COMPILER := default
endif

TARGET_TYPE = sharedlib

# FLAGS

ifndef DEBIAN_PACKAGE
CFLAGS =
LDFLAGS =
endif
PRJ_CFLAGS =
CECFLAGS =
OFLAGS = -Wl,-nostdlib
LIBS =
CXXFLAGS += -std=c++17 -fno-exceptions -fno-rtti -Wcomment

ifdef DEBUG
NOSTRIP := y
endif

CONSOLE = -mwindows

# INCLUDES

DGGAL_ABSPATH := $(dir $(realpath $(firstword $(MAKEFILE_LIST))))../../

ifndef EC_SDK_SRC
EC_SDK_SRC := $(DGGAL_ABSPATH)../eC
endif

export _CF_DIR = $(EC_SDK_SRC)/

include $(_CF_DIR)crossplatform.mk
include $(_CF_DIR)default.cf

# POST-INCLUDES VARIABLES

OBJ = obj/$(CONFIG).$(PLATFORM)$(COMPILER_SUFFIX)$(DEBUG_SUFFIX)/

RES =

ifdef LINUX_TARGET
TARGET = $(OBJ)$(LP)$(MODULE)$(SO).$(VERSION)
SONAME = -Wl,-soname,$(LP)$(MODULE)$(SO).0
else
TARGET = $(OBJ)$(LP)$(MODULE)$(SO)
SONAME =
endif

ifndef CPP_BINDINGS_EMBEDDED_C_DISABLE
_embedded_c := 1
endif

_OBJECTS = $(_DEP_OBJECTS) \
	$(if $(_embedded_c),$(OBJ)$(BINDING_NAME).c$(O),) \
	$(OBJ)$(BINDING_NAME)$(O)

OBJECTS = $(_OBJECTS)

SOURCES = $(_DEP_SOURCES) \
	$(if $(_embedded_c),../c/$(BINDING_NAME).c,) \
	$(BINDING_NAME).cpp

LIBS += $(SHAREDLIB) $(EXECUTABLE) $(LINKOPT)

ifndef STATIC_LIBRARY_TARGET
LIBS += \
	$(call _L,ecrt) \
	$(call _L,ecrt_cpp) \
   $(if $(_embedded_c),,$(call _L,$(BINDING_NAME)_c)) # $(call _L,$(BINDING_MODULE))
endif

PRJ_CFLAGS += \
	 $(if $(DEBUG), -g, -O2 -ffast-math) $(FPIC) -w -DECPRFX=eC_ -I.

#(SPECIFIC_FLAGS)#

PRJ_CFLAGS += \
      -I../c -I$(EC_SDK_SRC)/bindings/c  -I$(EC_SDK_SRC)/bindings/cpp \

ifndef STATIC_LIBRARY_TARGET
OFLAGS += \
	-L$(DGGAL_ABSPATH)obj/$(PLATFORM)$(COMPILER_SUFFIX)$(DEBUG_SUFFIX)/bin \
	-L$(DGGAL_ABSPATH)obj/$(PLATFORM)$(COMPILER_SUFFIX)$(DEBUG_SUFFIX)/lib \
	-L$(EC_SDK_SRC)/obj/$(PLATFORM)$(COMPILER_SUFFIX)$(DEBUG_SUFFIX)/bin \
	-L$(EC_SDK_SRC)/obj/$(PLATFORM)$(COMPILER_SUFFIX)$(DEBUG_SUFFIX)/lib \
	-L$(BINDMODLOC)
endif

# TARGETS

.PHONY: all
all: objdir $(TARGET);

.PHONY: objdir
objdir:
	$(call mkdir,$(OBJ))

$(SYMBOLS): | objdir
$(OBJECTS): | objdir
$(TARGET): $(SOURCES) $(OBJECTS) | objdir
	$(LD) $(OFLAGS) $(_OBJECTS) $(LIBS) -o $(TARGET) $(INSTALLNAME)
ifndef NOSTRIP
	$(STRIP) $(STRIPOPT) $(TARGET)
endif
ifdef LINUX_TARGET
ifdef LINUX_HOST
	$(if $(basename $(VER)),ln -sf $(LP)$(MODULE)$(SO)$(VER) $(OBJ)$(LP)$(MODULE)$(SO)$(basename $(VER)),)
	$(if $(VER),ln -sf $(LP)$(MODULE)$(SO)$(VER) $(OBJ)$(LP)$(MODULE)$(SO),)
endif
endif
	$(call cp,$(TARGET),$(DGGAL_ABSPATH)$(SODESTDIR))
ifdef LINUX_TARGET
ifdef LINUX_HOST
	$(if $(basename $(VER)),ln -sf $(LP)$(MODULE)$(SO)$(VER) $(DGGAL_ABSPATH)$(SODESTDIR)$(LP)$(MODULE)$(SO)$(basename $(VER)),)
	$(if $(VER),ln -sf $(LP)$(MODULE)$(SO)$(VER) $(DGGAL_ABSPATH)$(SODESTDIR)$(LP)$(MODULE)$(SO),)
endif
endif

# OBJECT RULES


ifdef _embedded_c
$(OBJ)$(BINDING_NAME).c$(O): ../c/$(BINDING_NAME).c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,$<) -o $(call quote_path,$@)
endif

$(OBJ)$(BINDING_NAME)$(O): $(BINDING_NAME).cpp
	$(CXX) $(CXXFLAGS) $(CFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,$<) -o $(call quote_path,$@)

.PHONY: cleantarget
cleantarget:
	$(call rm,$(TARGET))
ifdef LINUX_TARGET
ifdef LINUX_HOST
	$(call rm,$(OBJ)$(LP)$(MODULE)$(SO)$(basename $(VER)))
	$(call rm,$(OBJ)$(LP)$(MODULE)$(SO))
endif
endif

.PHONY: clean
clean: cleantarget
	$(call rm,$(_OBJECTS))

.PHONY: realclean
realclean: cleantarget
	$(call rmr,$(OBJ))

.PHONY: wipeclean
wipeclean:
	$(call rmr,obj/)

.PHONY: distclean
distclean:
	$(_MAKE) -f $(_CF_DIR)Cleanfile distclean distclean_all_subdirs

$(MAKEFILE_LIST): ;
$(SOURCES): ;
$(RESOURCES): ;



================================================
FILE: bindings/js/dggal.d.ts
================================================
// dggal.d.ts

// A 64-bit unsigned zone identifier
export type DGGRSZone = bigint

// A Coordinate Reference System identifier
export type CRS = bigint;

// A geographic point in radians
export interface GeoPoint {
  lat: number
  lon: number
}

// Neighbor relationship with zone ID and adjacency type
export interface Neighbor {
  zone: DGGRSZone
  type: number
}

// A 2D point in projected CRS units
export interface Pointd {
  x: number
  y: number
}

// A geographic bounding box (WGS84)
export interface GeoExtent {
  ll: GeoPoint
  ur: GeoPoint
}

// A projected CRS bounding box
export interface CRSExtent
{
  crs: CRS
  tl: Pointd
  br: Pointd
}

export const CRSRegistry: {
  readonly epsg: 0
  readonly ogc:  1
}

export type CRSRegistry = typeof CRSRegistry[keyof typeof CRSRegistry]

// A DGGAL Discrete Global Grid Reference System
// Constructed via `const rs = dggal.createDGGRS(name)`
export class DGGRS {
  // Convert a text ID to a 64-bit zone identifier
  getZoneFromTextID(zoneID: string): DGGRSZone

  // Convert a 64-bit zone identifier back to its text ID
  getZoneTextID(zone: DGGRSZone): string

  // DGGRSZone metadata
  getZoneLevel(zone: DGGRSZone): number
  getZoneArea(zone: DGGRSZone): number
  countZoneEdges(zone: DGGRSZone): number
  countSubZones(zone: DGGRSZone, depth: number): bigint

  // Hierarchy
  getZoneParents(zone: DGGRSZone): DGGRSZone[]
  getZoneChildren(zone: DGGRSZone): DGGRSZone[]
  getZoneNeighbors(zone: DGGRSZone): Neighbor[]

  // Centroid operations
  getZoneWGS84Centroid(zone: DGGRSZone): GeoPoint
  getZoneCentroidParent(zone: DGGRSZone): DGGRSZone
  getZoneCentroidChild(zone: DGGRSZone): DGGRSZone
  isZoneCentroidChild(zone: DGGRSZone): boolean

  // Relationship queries
  areZonesNeighbors(a: DGGRSZone, b: DGGRSZone): boolean
  areZonesSiblings(a: DGGRSZone, b: DGGRSZone): boolean
  doZonesOverlap(a: DGGRSZone, b: DGGRSZone): boolean
  doesZoneContain(haystack: DGGRSZone, needle: DGGRSZone): boolean
  isZoneAncestorOf(ancestor: DGGRSZone, descendant: DGGRSZone, maxDepth: number): boolean
  isZoneContainedIn(needle: DGGRSZone, haystack: DGGRSZone): boolean
  isZoneDescendantOf(descendant: DGGRSZone, ancestor: DGGRSZone, maxDepth: number): boolean
  isZoneImmediateChildOf(child: DGGRSZone, parent: DGGRSZone): boolean
  isZoneImmediateParentOf(parent: DGGRSZone, child: DGGRSZone): boolean
  zoneHasSubZone(haystack: DGGRSZone, needle: DGGRSZone): boolean

  // Limits / metadata
  getMaxDGGRSZoneLevel(): number
  getMaxDepth(): number
  get64KDepth(): number
  getMaxChildren(): number
  getMaxParents(): number
  getMaxNeighbors(): number

  // Vertices
  getZoneCRSVertices(zone: DGGRSZone, crs: CRS): Pointd[]
  getZoneWGS84Vertices(zone: DGGRSZone): GeoPoint[]
  getZoneRefinedWGS84Vertices(zone: DGGRSZone, edgeRefinement: number): GeoPoint[]
  getZoneRefinedCRSVertices(zone: DGGRSZone, crs: CRS, edgeRefinement: number): Pointd[]

  // Sub-zone queries
  getSubZones(zone: DGGRSZone, depth: number): DGGRSZone[]

  // Refinement
  getRefinementRatio(): number

  // WGS84 extent
  getZoneWGS84Extent(zone: DGGRSZone): GeoExtent

  // Listing zones within a box
  listZones(level: number, bbox: GeoExtent): DGGRSZone[]

  // Centroid → zone
  getZoneFromWGS84Centroid(level: number, geoPoint: GeoPoint): DGGRSZone
  getZoneFromCRSCentroid(crs: CRS, pointd: Pointd): DGGRSZone

  // Global zone counts
  countZones(level: number): bigint

  // Indexed sub-zones
  getFirstSubZone(parent: DGGRSZone, relativeDepth: number): DGGRSZone
  getIndexMaxDepth(): number
  getSubZoneAtIndex(parent: DGGRSZone, relativeDepth: number, index: number): DGGRSZone
  getSubZoneIndex(parent: DGGRSZone, subZone: DGGRSZone): DGGRSZone

  // Sub-zone centroid arrays
  getSubZoneCRSCentroids(parent: DGGRSZone, crs: CRS, relativeDepth: number): Pointd[]
  getSubZoneWGS84Centroids(parent: DGGRSZone, relativeDepth: number): GeoPoint[]

  // CRS-based centroid & extent
  getZoneCRSCentroid(zone: DGGRSZone, crs: CRS): Pointd
  getZoneCRSExtent(zone: DGGRSZone, crs: CRS): CRSExtent

  // Compact & rebuild zone arrays
  compactZones(zones: DGGRSZone[]): DGGRSZone[]

  // Level / metrics conversions
  getLevelFromMetersPerSubZone(physicalMetersPerSubZone: number, relativeDepth: number): number
  getLevelFromPixelsAndExtent(extent: GeoExtent, width: number, height: number, relativeDepth: number): number
  getLevelFromRefZoneArea(refArea: number, relativeDepth: number): number
  getLevelFromScaleDenominator(scaleDenominator: number, relativeDepth: number, mmPerPixel: number): number
  getMetersPerSubZoneFromLevel(level: number, relativeDepth: number): number
  getRefZoneArea(relativeDepth: number): number
  getScaleDenominatorFromLevel(level: number, relativeDepth: number, mmPerPixel: number): number

  // Clean up native resources
  delete(): void
}

// Main entry point
// Use `const dggal = await DGGAL.init()`, then `dggal.createDGGRS()`
export class DGGAL {
  // A sentinel value indicating "no zone"
  static nullZone: DGGRSZone

  static readonly CRSRegistry: {
    readonly epsg: 0
    readonly ogc:  1
  }

  // Construct a CRS identifier
  static CRS(registry: CRSRegistry, code: number, h: boolean): CRS

  // Initialize the WASM module and return the API handle
  static init(): Promise<DGGAL>

  // Create a DGGRS instance by name
  createDGGRS(name: string): DGGRS

  // List available DGGRSs
  listDGGRS(): string[]

  // Tear down the WASM runtime
  terminate(): void
}

export default DGGAL



================================================
FILE: bindings/js/dggal.js
================================================
/*
DGGAL, the Discrete Global Grid Abstraction Library

https://dggal.org

Source: https://github.com/ecere/dggal

NPM: https://www.npmjs.com/package/dggal

BSD 3-Clause License

Copyright (c) 2014-2025, Ecere Corporation

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its
   contributors may be used to endorse or promote products derived from
   this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
import dggalFactory from './libdggal.js';

export class DGGRS {
  constructor(module, modulePtr, name) {
    this.module = module;
    const stack = this.module.stackSave();
    const namePtr = this.stackAllocString(name);
    this.dggrsPtr = this.module._DGGAL_DGGRS_new(modulePtr, namePtr);
    this.module.stackRestore(stack);
  }

  delete() {
    if (this.dggrsPtr) {
      this.module._DGGAL_DGGRS_delete(this.dggrsPtr);
      this.dggrsPtr = 0;
    }
  }

  stackAllocString(str) {
    const maxBytes = str.length * 4 + 1;
    const ptr = this.module.stackAlloc(maxBytes);
    this.module.stringToUTF8(str, ptr, maxBytes);
    return ptr;
  }

  // Basic zone lookup / text id
  getZoneFromTextID(zoneID) {
    const stack = this.module.stackSave();
    const zonePtr = this.stackAllocString(zoneID);
    const result = BigInt.asUintN(64, this.module._DGGAL_DGGRS_getZoneFromTextID(this.dggrsPtr, zonePtr));
    this.module.stackRestore(stack);
    return result;
  }

  getZoneTextID(zone) {
    const stack = this.module.stackSave();
    const buffer = this.module.stackAlloc(256);
    this.module._DGGAL_DGGRS_getZoneTextID(this.dggrsPtr, zone, buffer);
    const result = this.module.UTF8ToString(buffer);
    this.module.stackRestore(stack);
    return result;
  }

  // Zone metadata
  getZoneLevel(zone) {
    return this.module._DGGAL_DGGRS_getZoneLevel(this.dggrsPtr, zone);
  }

  getZoneArea(zone) {
    return this.module._DGGAL_DGGRS_getZoneArea(this.dggrsPtr, zone);
  }

  countZoneEdges(zone) {
    return this.module._DGGAL_DGGRS_countZoneEdges(this.dggrsPtr, zone);
  }

  countSubZones(zone, depth) {
    return BigInt.asUintN(64, this.module._DGGAL_DGGRS_countSubZones(this.dggrsPtr, zone, depth));
  }

  // Parents / children / neighbors
  getZoneParents(zone) {
    const stack = this.module.stackSave();
    const buffer = this.module.stackAlloc(3 * 8);
    this.module._DGGAL_DGGRS_getZoneParents(this.dggrsPtr, zone, buffer);
    const result = Array.from({ length: 3 }, (_, i) =>
      BigInt.asUintN(64, this.module.HEAP64[(buffer + i * 8) >> 3])
    );
    this.module.stackRestore(stack);
    return result;
  }

  getZoneChildren(zone) {
    const stack = this.module.stackSave();
    const buffer = this.module.stackAlloc(13 * 8);
    this.module._DGGAL_DGGRS_getZoneChildren(this.dggrsPtr, zone, buffer);
    const result = Array.from({ length: 13 }, (_, i) =>
      BigInt.asUintN(64, this.module.HEAP64[(buffer + i * 8) >> 3])
    );
    this.module.stackRestore(stack);
    return result;
  }

  getZoneNeighbors(zone) {
    const stack = this.module.stackSave();
    const zonesBuf = this.module.stackAlloc(6 * 8);
    const typesBuf = this.module.stackAlloc(6 * 4);
    this.module._DGGAL_DGGRS_getZoneNeighbors(this.dggrsPtr, zone, zonesBuf, typesBuf);
    const result = Array.from({ length: 6 }, (_, i) => ({
      zone: BigInt.asUintN(64, this.module.HEAP64[(zonesBuf + i * 8) >> 3]),
      type: this.module.HEAP32[(typesBuf + i * 4) >> 2],
    }));
    this.module.stackRestore(stack);
    return result;
  }

  // Centroid related
  getZoneWGS84Centroid(zone) {
    const stack = this.module.stackSave();
    const buf = this.module.stackAlloc(16); // GeoPoint { double lat; double lon; }
    this.module._DGGAL_DGGRS_getZoneWGS84Centroid(this.dggrsPtr, zone, buf);
    const lat = this.module.HEAPF64[buf >> 3];
    const lon = this.module.HEAPF64[(buf + 8) >> 3];
    this.module.stackRestore(stack);
    return { lat, lon };
  }

  getZoneCentroidParent(zone) {
    return BigInt.asUintN(64, this.module._DGGAL_DGGRS_getZoneCentroidParent(this.dggrsPtr, zone));
  }

  getZoneCentroidChild(zone) {
    return BigInt.asUintN(64, this.module._DGGAL_DGGRS_getZoneCentroidChild(this.dggrsPtr, zone));
  }

  isZoneCentroidChild(zone) {
    return this.module._DGGAL_DGGRS_isZoneCentroidChild(this.dggrsPtr, zone) !== 0;
  }

  // Relationship queries
  areZonesNeighbors(a, b) {
    return this.module._DGGAL_DGGRS_areZonesNeighbors(this.dggrsPtr, a, b) !== 0;
  }

  areZonesSiblings(a, b) {
    return this.module._DGGAL_DGGRS_areZonesSiblings(this.dggrsPtr, a, b) !== 0;
  }

  doZonesOverlap(a, b) {
    return this.module._DGGAL_DGGRS_doZonesOverlap(this.dggrsPtr, a, b) !== 0;
  }

  doesZoneContain(haystack, needle) {
    return this.module._DGGAL_DGGRS_doesZoneContain(this.dggrsPtr, haystack, needle) !== 0;
  }

  isZoneAncestorOf(ancestor, descendant, maxDepth) {
    return this.module._DGGAL_DGGRS_isZoneAncestorOf(this.dggrsPtr, ancestor, descendant, maxDepth) !== 0;
  }

  isZoneContainedIn(needle, haystack) {
    return this.module._DGGAL_DGGRS_isZoneContainedIn(this.dggrsPtr, needle, haystack) !== 0;
  }

  isZoneDescendantOf(descendant, ancestor, maxDepth) {
    return this.module._DGGAL_DGGRS_isZoneDescendantOf(this.dggrsPtr, descendant, ancestor, maxDepth) !== 0;
  }

  isZoneImmediateChildOf(child, parent) {
    return this.module._DGGAL_DGGRS_isZoneImmediateChildOf(this.dggrsPtr, child, parent) !== 0;
  }

  isZoneImmediateParentOf(parent, child) {
    return this.module._DGGAL_DGGRS_isZoneImmediateParentOf(this.dggrsPtr, parent, child) !== 0;
  }

  zoneHasSubZone(haystack, needle) {
    return this.module._DGGAL_DGGRS_zoneHasSubZone(this.dggrsPtr, haystack, needle) !== 0;
  }

  // Limits / metadata
  getMaxDGGRSZoneLevel() {
    return this.module._DGGAL_DGGRS_getMaxDGGRSZoneLevel(this.dggrsPtr);
  }

  getMaxDepth() {
    return this.module._DGGAL_DGGRS_getMaxDepth(this.dggrsPtr);
  }

  get64KDepth() {
    return this.module._DGGAL_DGGRS_get64KDepth(this.dggrsPtr);
  }

  getMaxChildren() {
    return this.module._DGGAL_DGGRS_getMaxChildren(this.dggrsPtr);
  }

  getMaxParents() {
    return this.module._DGGAL_DGGRS_getMaxParents(this.dggrsPtr);
  }

  getMaxNeighbors() {
    return this.module._DGGAL_DGGRS_getMaxNeighbors(this.dggrsPtr);
  }

  getZoneCRSVertices(zone, crs) {
    const stack = this.module.stackSave();
    const buf = this.module.stackAlloc(6 * 16); // reserve space for up to 6 Pointd structs (16 bytes each)
    const count = this.module._DGGAL_DGGRS_getZoneCRSVertices(this.dggrsPtr, zone, crs, buf);
    const verts = new Array(count);
    for (let i = 0; i < count; i++) {
      const ptr = buf + i * 16;
      verts[i] = {
        x: this.module.HEAPF64[ptr >> 3],
        y: this.module.HEAPF64[(ptr + 8) >> 3]
      };
    }
    this.module.stackRestore(stack);
    return verts;
  }

  getZoneWGS84Vertices(zone) {
    const stack = this.module.stackSave();
    const buf = this.module.stackAlloc(6 * 16);
    const count = this.module._DGGAL_DGGRS_getZoneWGS84Vertices(this.dggrsPtr, zone, buf);
    const verts = new Array(count);
    for (let i = 0; i < count; i++) {
      const ptr = buf + i * 16;
      verts[i] = {
        lat: this.module.HEAPF64[ptr >> 3],
        lon: this.module.HEAPF64[(ptr + 8) >> 3],
      };
    }
    this.module.stackRestore(stack);
    return verts;
  }

  /* ---- DGGAL-managed array wrappers ----
     These map the header's Array_* helpers to JS arrays.
     Array_GeoPoint => GeoPoint { double lat; double lon; }
     Array_Pointd   => Pointd { double x; double y; }
     Array_DGGRSZone=> uint64_t zone identifiers
  */

  // GeoPoint array (used by getZoneRefinedWGS84Vertices)
  _readArrayGeoPoint(arrPtr) {
    const count = Number(
      this.module._DGGAL_Array_GeoPoint_getCount(arrPtr)
    );
    const basePtr = this.module._DGGAL_Array_GeoPoint_getPointer(arrPtr);
    if (!basePtr || count === 0) {
      this.module._DGGAL_Array_GeoPoint_delete(arrPtr);
      return [];
    }
    const out = new Array(count);
    const bytesPerPoint = 16; // two doubles: lat, lon
    for (let i = 0; i < count; i++) {
      const gpPtr = basePtr + i * bytesPerPoint;
      const lat = this.module.HEAPF64[gpPtr >> 3];
      const lon = this.module.HEAPF64[(gpPtr + 8) >> 3];
      out[i] = { lat, lon };
    }
    this.module._DGGAL_Array_GeoPoint_delete(arrPtr);
    return out;
  }

  // Pointd array (used by getZoneRefinedCRSVertices)
  _readArrayPointd(arrPtr) {
    const count = Number(this.module._DGGAL_Array_Pointd_getCount(arrPtr));
    const basePtr = this.module._DGGAL_Array_Pointd_getPointer(arrPtr);
    if (!basePtr || count === 0) {
      this.module._DGGAL_Array_Pointd_delete(arrPtr);
      return [];
    }
    const out = new Array(count);
    const bytesPerPoint = 16; // two doubles: x, y
    for (let i = 0; i < count; i++) {
      const pPtr = basePtr + i * bytesPerPoint;
      const x = this.module.HEAPF64[pPtr >> 3];
      const y = this.module.HEAPF64[(pPtr + 8) >> 3];
      out[i] = { x, y };
    }
    this.module._DGGAL_Array_Pointd_delete(arrPtr);
    return out;
  }

  // DGGRSZone array (used by getSubZones, listZones, compactZones)
  _readArrayDGGRSZone(arrPtr) {
    const count = Number(
      this.module._DGGAL_Array_DGGRSZone_getCount(arrPtr)
    );
    const basePtr = this.module._DGGAL_Array_DGGRSZone_getPointer(arrPtr);
    if (!basePtr || count === 0) {
      this.module._DGGAL_Array_DGGRSZone_delete(arrPtr);
      return [];
    }
    const out = new Array(count);
    const bytesPerZone = 8; // DGGRSZone is 64-bit
    for (let i = 0; i < count; i++) {
      const zPtr = basePtr + i * bytesPerZone;
      const low = BigInt.asUintN(64, BigInt(this.module.HEAPU32[zPtr >> 2]));
      const high = BigInt.asUintN(64, BigInt(this.module.HEAPU32[(zPtr + 4) >> 2]));
      out[i] = (high << 32n) | low;
    }
    this.module._DGGAL_Array_DGGRSZone_delete(arrPtr);
    return out;
  }

  // ---- Methods that return DGGAL-managed arrays ----

  getZoneRefinedWGS84Vertices(zone, edgeRefinement) {
    return this._readArrayGeoPoint(this.module._DGGAL_DGGRS_getZoneRefinedWGS84Vertices(this.dggrsPtr, zone, edgeRefinement));
  }

  getZoneRefinedCRSVertices(zone, crs, edgeRefinement) {
    return this._readArrayPointd(this.module._DGGAL_DGGRS_getZoneRefinedCRSVertices(this.dggrsPtr, zone, crs, edgeRefinement));
  }

  getSubZones(zone, depth) {
    return this._readArrayDGGRSZone(this.module._DGGAL_DGGRS_getSubZones(this.dggrsPtr, zone, depth));
  }

  // Refinement
  getRefinementRatio() {
    return this.module._DGGAL_DGGRS_getRefinementRatio(this.dggrsPtr);
  }

  // WGS84 extent
  getZoneWGS84Extent(zone) {
    const stack = this.module.stackSave();
    const buf = this.module.stackAlloc(32); // GeoExtent { ll, ur }
    this.module._DGGAL_DGGRS_getZoneWGS84Extent(this.dggrsPtr, zone, buf);
    const ll_lat = this.module.HEAPF64[buf >> 3];
    const ll_lon = this.module.HEAPF64[(buf + 8) >> 3];
    const ur_lat = this.module.HEAPF64[(buf + 16) >> 3];
    const ur_lon = this.module.HEAPF64[(buf + 24) >> 3];
    this.module.stackRestore(stack);
    return {
      ll: { lat: ll_lat, lon: ll_lon },
      ur: { lat: ur_lat, lon: ur_lon },
    };
  }

  // listZones(level, bbox) → Array<DGGRSZone>
  listZones(level, bbox) {
    const stack = this.module.stackSave();
    const extentPtr = this.module.stackAlloc(32);
    this.module.HEAPF64[extentPtr >> 3] = bbox.ll.lat;
    this.module.HEAPF64[(extentPtr + 8) >> 3] = bbox.ll.lon;
    this.module.HEAPF64[(extentPtr + 16) >> 3] = bbox.ur.lat;
    this.module.HEAPF64[(extentPtr + 24) >> 3] = bbox.ur.lon;
    const arrPtr = this.module._DGGAL_DGGRS_listZones(this.dggrsPtr, level, extentPtr);
    const result = this._readArrayDGGRSZone(arrPtr);
    this.module.stackRestore(stack);
    return result;
  }

  getZoneFromWGS84Centroid(level, geoPoint) {
    const stack = this.module.stackSave();
    const buf = this.module.stackAlloc(16);        // GeoPoint { double lat; double lon; }
    this.module.HEAPF64[buf >> 3]       = geoPoint.lat;
    this.module.HEAPF64[(buf + 8) >> 3] = geoPoint.lon;
    const zone = BigInt.asUintN(64, this.module._DGGAL_DGGRS_getZoneFromWGS84Centroid(this.dggrsPtr, level, buf ));
    this.module.stackRestore(stack);
    return zone;
  }

  getZoneFromCRSCentroid(crs, pointd) {
    const stack = this.module.stackSave();
    const buf = this.module.stackAlloc(16);        // Pointd { double x; double y; }
    this.module.HEAPF64[buf >> 3]       = pointd.x;
    this.module.HEAPF64[(buf + 8) >> 3] = pointd.y;
    const zone = BigInt.asUintN(64, this.module._DGGAL_DGGRS_getZoneFromCRSCentroid(this.dggrsPtr, crs, buf));
    this.module.stackRestore(stack);
    return zone;
  }

  countZones(level) {
    return BigInt.asUintN(64, this.module._DGGAL_DGGRS_countZones(this.dggrsPtr, level));
  }

  // First / indexed sub-zones
  getFirstSubZone(parent, relativeDepth) {
    return BigInt.asUintN(64, this.module._DGGAL_DGGRS_getFirstSubZone(this.dggrsPtr, parent, relativeDepth)
    );
  }

  getIndexMaxDepth() {
    return this.module._DGGAL_DGGRS_getIndexMaxDepth(this.dggrsPtr);
  }

  getSubZoneAtIndex(parent, relativeDepth, index) {
    return BigInt.asUintN(64, this.module._DGGAL_DGGRS_getSubZoneAtIndex(this.dggrsPtr, parent, relativeDepth, index));
  }

  getSubZoneIndex(parent, subZone) {
    return BigInt.asUintN(64, this.module._DGGAL_DGGRS_getSubZoneIndex(this.dggrsPtr, parent, subZone));
  }

  // Sub-zone centroid arrays
  getSubZoneCRSCentroids(parent, crs, relativeDepth) {
    return this._readArrayPointd(this.module._DGGAL_DGGRS_getSubZoneCRSCentroids(this.dggrsPtr, parent, crs, relativeDepth));
  }

  getSubZoneWGS84Centroids(parent, relativeDepth) {
    return this._readArrayGeoPoint(this.module._DGGAL_DGGRS_getSubZoneWGS84Centroids(this.dggrsPtr, parent, relativeDepth));
  }

  // CRS-based centroid & extent
  getZoneCRSCentroid(zone, crs) {
    const stack = this.module.stackSave();
    const buf = this.module.stackAlloc(16);
    this.module._DGGAL_DGGRS_getZoneCRSCentroid(this.dggrsPtr, zone, crs, buf);
    const x = this.module.HEAPF64[buf >> 3];
    const y = this.module.HEAPF64[(buf + 8) >> 3];
    this.module.stackRestore(stack);
    return { x, y };
  }

  getZoneCRSExtent(zone, crs) {
    const stack = this.module.stackSave();
    const buf = this.module.stackAlloc(40); // CRS + Pointd tl + Pointd br
    this.module._DGGAL_DGGRS_getZoneCRSExtent(this.dggrsPtr, zone, crs, buf);
    const crsOut = BigInt.asUintN(64, this.module.HEAP64[buf >> 3]);
    const tlx = this.module.HEAPF64[(buf + 8) >> 3];
    const tly = this.module.HEAPF64[(buf + 16) >> 3];
    const brx = this.module.HEAPF64[(buf + 24) >> 3];
    const bry = this.module.HEAPF64[(buf + 32) >> 3];
    this.module.stackRestore(stack);
    return {
      crs: crsOut,
      tl: { x: tlx, y: tly },
      br: { x: brx, y: bry },
    };
  }

  compactZones(zones) {
    const arrPtr = this.module._DGGAL_Array_DGGRSZone_new(zones.length);
    const basePtr = this.module._DGGAL_Array_DGGRSZone_getPointer(arrPtr);

    for (let i = 0; i < zones.length; i++) {
      const z = zones[i];
      this.module.HEAPU32[(basePtr + i * 8    ) >> 2] = Number(z & 0xFFFFFFFFn);
      this.module.HEAPU32[(basePtr + i * 8 + 4) >> 2] = Number(z >> 32n);
    }
    this.module._DGGAL_DGGRS_compactZones(this.dggrsPtr, arrPtr);
    return this._readArrayDGGRSZone(arrPtr);
  }

  // Level / metrics conversions
  getLevelFromMetersPerSubZone(physicalMetersPerSubZone, relativeDepth) {
    return this.module._DGGAL_DGGRS_getLevelFromMetersPerSubZone(this.dggrsPtr, physicalMetersPerSubZone, relativeDepth);
  }

  getLevelFromPixelsAndExtent(extent, width, height, relativeDepth) {
    const stack = this.module.stackSave();
    const buf = this.module.stackAlloc(32);
    // write WGS84 extent: ll.lat, ll.lon, ur.lat, ur.lon
    this.module.HEAPF64[buf >> 3] = extent.ll.lat;
    this.module.HEAPF64[(buf + 8) >> 3] = extent.ll.lon;
    this.module.HEAPF64[(buf + 16) >> 3] = extent.ur.lat;
    this.module.HEAPF64[(buf + 24) >> 3] = extent.ur.lon;
    const result = this.module._DGGAL_DGGRS_getLevelFromPixelsAndExtent(this.dggrsPtr, buf, width, height, relativeDepth );
    this.module.stackRestore(stack);
    return result;
  }

  getLevelFromRefZoneArea(refArea, relativeDepth) {
    return this.module._DGGAL_DGGRS_getLevelFromRefZoneArea(this.dggrsPtr, refArea, relativeDepth);
  }

  getLevelFromScaleDenominator(scaleDenominator, relativeDepth, mmPerPixel) {
    return this.module._DGGAL_DGGRS_getLevelFromScaleDenominator(this.dggrsPtr, scaleDenominator, relativeDepth, mmPerPixel);
  }

  getMetersPerSubZoneFromLevel(level, relativeDepth, mmPerPixel) {
    return this.module._DGGAL_DGGRS_getMetersPerSubZoneFromLevel(this.dggrsPtr, level, relativeDepth, mmPerPixel);
  }

  getRefZoneArea(relativeDepth) {
    return this.module._DGGAL_DGGRS_getRefZoneArea(this.dggrsPtr, relativeDepth);
  }

  getScaleDenominatorFromLevel(level, relativeDepth) {
    return this.module._DGGAL_DGGRS_getScaleDenominatorFromLevel(this.dggrsPtr, level, relativeDepth);
  }
}

// DGGAL module wrapper

export class DGGAL {
  static nullZone = 0xFFFFFFFFFFFFFFFFn;
  static CRSRegistry = { epsg: 0, ogc: 1 };

  static CRS(registry, code, h) {
    return BigInt.asUintN(64, this.module._DGGAL_CRS(registry, code, h));
  }

  constructor(module, modulePtr) {
    this.module = module;
    this.modulePtr = modulePtr;
  }

  static async init() {
    const module = await dggalFactory();
    const modulePtr = module._DGGAL_init();
    return new DGGAL(module, modulePtr);
  }

  terminate() {
    this.module._DGGAL_terminate(this.modulePtr);
  }

  createDGGRS(name) {
    return new DGGRS(this.module, this.modulePtr, name);
  }

  listDGGRS() {
    const PTR_SIZE = this.module.HEAPU32.BYTES_PER_ELEMENT;
    const PTR_TYPE = PTR_SIZE === 4 ? 'i32' : 'i64';
    const result = [];
    const listPtr = this.module._DGGAL_DGGRS_list(0);
    let offset = 0;
    while (true) {
      const strPtr = this.module.getValue(listPtr + offset, PTR_TYPE);
      if (strPtr === 0) break;
      const str = this.module.UTF8ToString(strPtr);
      result.push(str);
      offset += PTR_SIZE;
    }
    return result;
  }
}

export default DGGAL;



================================================
FILE: bindings/py/__init__.py
================================================
import os
import sys

# Work-around for lack of R(UN)PATH on Windows
script_dir = os.path.dirname(os.path.abspath(__file__))

if sys.platform.startswith('win'):
   original_path = os.environ.get('PATH', '')
   ecrtLibPath = os.path.join(script_dir, '..', 'ecrt', 'lib')
   dggalLibPath = os.path.join(script_dir, 'bin')
   new_path = dggalLibPath + os.pathsep + ecrtLibPath + os.pathsep + original_path
   os.environ['PATH'] = new_path
   if hasattr(os, 'add_dll_directory'):
      os.add_dll_directory(ecrtLibPath)
      os.add_dll_directory(dggalLibPath)

# The EC_LIB_PATH is not needed if _pydggal is linked with -Wl,--no-as-needed -ldggal
#else:
#   os.environ['EC_LIB_PATH'] = os.path.join(script_dir, 'lib', 'lib') # Including lib prefix

from .dggal import *

if sys.platform.startswith('win'):
   os.environ['PATH'] = original_path



================================================
FILE: bindings/py/build_dggal.py
================================================
import sys
import os
import platform
from distutils.util import get_platform;
from os import path
from cffi import FFI
from distutils.sysconfig import get_config_var
# pkg_resources is deprecated in setuptools >= 81
# import pkg_resources
try:
    from importlib.metadata import distribution # Python 3.8+
except ImportError:
    from importlib_metadata import distribution # Fallback for older Python (<3.8)

owd = os.getcwd()

if path.isfile('cffi-dggal.h'):
   bindings_py_dir = '.'
else:
   bindings_py_dir = path.join('bindings', 'py')
   if not path.isfile(bindings_py_dir):
      bindings_py_dir = path.join(owd, 'dggal', 'bindings', 'py')

dnf = path.dirname(__file__)
dir = path.abspath(path.dirname(__file__))

cpath = os.path.normpath(path.join(dnf, '..', 'c'))

incdir = cpath

if path.isdir(cpath) != True:
   print('error: unable to find path to C bindings!')
if path.isfile(path.join(bindings_py_dir, 'cffi-dggal.h')) != True:
   print('Cannot find cffi-dggal.h in', bindings_py_dir)

sysdir = 'win32' if sys.platform == 'win32' else ('apple' if sys.platform == 'darwin' else 'linux')
syslibdir = 'bin' if sys.platform == 'win32' else 'lib'
libdir = path.join(bindings_py_dir, '..', '..', 'obj', sysdir, syslibdir)

if dnf != '':
   os.chdir(dir)

sys.path.append(bindings_py_dir)

ext = '.so' if get_config_var('EXT_SUFFIX') is None else get_config_var('EXT_SUFFIX')

try:
   # pkg_resources is deprecated in setuptools >= 81
   # ecdev_location = os.path.join(pkg_resources.get_distribution("ecdev").location, 'ecdev')
   ecdev_location = os.path.join(distribution("ecdev").locate_file(""), "ecdev")
   ecrt_bindings_py_dir = os.path.join(ecdev_location, 'include')
   incdir_ecrt = os.path.join(ecdev_location, 'include')
   ecrt_location = os.path.join(ecdev_location, syslibdir)
except:
   try:
      ec_sdk_src = os.getenv('EC_SDK_SRC')
      ecrt_bindings_py_dir = os.path.join(ec_sdk_src, 'bindings', 'py')
      ecrt_location = os.path.join(ec_sdk_src, 'obj', sysdir, syslibdir)
      incdir_ecrt = os.path.join(ec_sdk_src, 'bindings', 'c')
   except:
      ecrt_bindings_py_dir = os.path.join(bindings_py_dir, '..', '..', '..', 'eC', 'bindings', 'py')
      ecrt_location = os.path.join(bindings_py_dir, '..', '..', '..', 'eC', 'obj', sysdir, syslibdir)
      incdir_ecrt = os.path.join(bindings_py_dir, '..', '..', '..', 'eC', 'bindings', 'c')
# ecrt_location = os.path.join(pkg_resources.get_distribution("ecrt").location, 'ecrt', '.lib')

ffi_ecrt = FFI()
ffi_ecrt.cdef(open(path.join(ecrt_bindings_py_dir, 'cffi-ecrt.h')).read())

if sys.platform == 'darwin':
   extra_link_args = ["-Wl,-rpath,@loader_path/ecrt/lib" ]
else:
   extra_link_args = ["-Wl,-rpath,$ORIGIN/lib:$ORIGIN/ecrt/lib"]

if sys.platform == 'win32':
   extra_link_args.append('-Wl,--export-all-symbols')
   extra_link_args.append('-static-libgcc')
else:
   extra_link_args.append('-Wl,--export-dynamic')

ffi_ecrt.set_source('_pyecrt',
               '#include "ecrt.h"',
               sources=[],
               define_macros=[('BINDINGS_SHARED', None), ('ECRT_EXPORT', None)],
               extra_compile_args=['-DECPRFX=eC_', '-DMS_WIN64', '-Wl,--export-dynamic', '-O2'],
               include_dirs=[ecrt_bindings_py_dir],
               libraries=[],
               # _py* CFFI packages are currently being packaged outside of the main extension directory
               extra_link_args=extra_link_args,
               library_dirs=[libdir],
               py_limited_api=False)

ffi_dggal = FFI()
ffi_dggal.include(ffi_ecrt)
ffi_dggal.cdef(open(path.join(bindings_py_dir, 'cffi-dggal.h')).read())
PY_BINDINGS_EMBEDDED_C_DISABLE = os.getenv('PY_BINDINGS_EMBEDDED_C_DISABLE')
_embedded_c = True # False if PY_BINDINGS_EMBEDDED_C_DISABLE == '' else True

srcs = []
if _embedded_c == True:
   srcs.append(path.join(cpath, 'dggal.c'))

libs = []

libs.append('ecrt')
#libs.append('dggal') # Adding dggal here doesn't seem to work with -Wl,--no-as-needed to force dependency ensuring dlopen() will find DGGAL using RPATH
if _embedded_c == False:
   libs.append('dggal_c')

# _py* CFFI packages are currently being packaged outside of the main extension directory
if sys.platform == 'darwin':
   extra_link_args = ['-ldggal',"-Wl,-rpath,@loader_path/dggal/lib","-Wl,-rpath,@loader_path/ecrt/lib", '-O2']
else:
   extra_link_args = ['-Wl,--no-as-needed','-ldggal',"-Wl,-rpath,$ORIGIN/lib:$ORIGIN/../../ecrt/lib:$ORIGIN/dggal/lib:$ORIGIN/ecrt/lib", '-DMS_WIN64', '-O2']

if sys.platform == 'win32':
   extra_link_args.append('-Wl,--export-all-symbols')
elif sys.platform != 'darwin':
   extra_link_args.append('-Wl,--export-dynamic')

ffi_dggal.set_source('_pydggal',
               '#include "dggal.h"',
               sources=srcs,
               define_macros=[('BINDINGS_SHARED', None), ('DGGAL_EXPORT', None)],
               extra_compile_args=['-std=gnu11', '-DECPRFX=eC_', '-DMS_WIN64', '-O2'], #--export-dynamic' ]
               include_dirs=[bindings_py_dir, incdir, incdir_ecrt, ecrt_bindings_py_dir],
               libraries=libs,
               extra_link_args=extra_link_args,
               library_dirs=[libdir, ecrt_location],
               py_limited_api=False)
if __name__ == '__main__':
   V = os.getenv('V')
   v = True if V == '1' or V == 'y' else False

   ffi_dggal.compile(verbose=v,tmpdir='.',debug=False) # True)

if dnf != '':
   os.chdir(owd)



================================================
FILE: bindings/py/cffi-dggal.h
================================================
typedef uint64 eC_CRS;
struct eC_CRSExtent
{
   eC_CRS crs;
   eC_Pointd tl;
   eC_Pointd br;
};

struct eC_GeoPoint
{
   eC_Angle lat;
   eC_Angle lon;
};
struct eC_Vector3D
{
   double x;
   double y;
   double z;
};
typedef eC_Instance eC_RI5x6Projection;
typedef eC_RI5x6Projection eC_BarycentricSphericalTriAreaProjection;
typedef struct eC_CRSExtent eC_CRSExtent;
typedef eC_Instance eC_DGGRS;
typedef uint64 eC_DGGRSZone;
typedef eC_Instance eC_DGGSJSON;
typedef eC_Instance eC_DGGSJSONGrid;
typedef eC_Instance eC_DGGSJSONShape;
typedef struct eC_GeoExtent eC_GeoExtent;
typedef struct eC_GeoPoint eC_GeoPoint;
typedef eC_Instance eC_HEALPixProjection;
typedef uint64 eC_I3HZone;
typedef uint64 eC_I7HZone;
typedef uint64 eC_I9RZone;
typedef eC_Instance eC_JSONSchema;
typedef int eC_JSONSchemaType;
enum
{
   JSONSchemaType_unset = 0x0,
   JSONSchemaType_array = 0x1,
   JSONSchemaType_boolean = 0x2,
   JSONSchemaType_integer = 0x3,
   JSONSchemaType_null = 0x4,
   JSONSchemaType_number = 0x5,
   JSONSchemaType_object = 0x6,
   JSONSchemaType_string = 0x7
};

typedef struct eC_Plane eC_Plane;
typedef struct eC_Quaternion eC_Quaternion;
typedef eC_DGGRS eC_RhombicIcosahedral7H;
typedef eC_RhombicIcosahedral7H eC_RI7H_Z7;
typedef eC_DGGRS eC_RhombicIcosahedral3H;
typedef eC_DGGRS eC_RhombicIcosahedral4R;
typedef eC_DGGRS eC_RhombicIcosahedral9R;
typedef eC_RI5x6Projection eC_SliceAndDiceGreatCircleIcosahedralProjection;
typedef struct eC_Vector3D eC_Vector3D;
typedef uint64 eC_Z7Zone;
#define AUTH_ORDER 6

static const uint64 nullZone;

static const double wgs84InvFlattening;

static const eC_Distance wgs84Minor;

typedef eC_RhombicIcosahedral3H eC_BCTA3H;
typedef int eC_CRSRegistry;
enum
{
   CRSRegistry_epsg = 0x0,
   CRSRegistry_ogc = 0x1
};

typedef eC_Instance eC_DGGSJSONDepth;
typedef eC_Instance eC_DGGSJSONDimension;
typedef uint64 eC_GGGZone;
typedef eC_DGGRS eC_GNOSISGlobalGrid;
typedef eC_RhombicIcosahedral3H eC_GPP3H;
typedef eC_BarycentricSphericalTriAreaProjection eC_GoldbergPolyhedraProjection;
typedef eC_DGGRS eC_HEALPix;
typedef uint64 eC_HPZone;
typedef int eC_I3HNeighbor;
enum
{
   I3HNeighbor_top = 0x0,
   I3HNeighbor_bottom = 0x1,
   I3HNeighbor_left = 0x2,
   I3HNeighbor_right = 0x3,
   I3HNeighbor_topLeft = 0x4,
   I3HNeighbor_topRight = 0x5,
   I3HNeighbor_bottomLeft = 0x6,
   I3HNeighbor_bottomRight = 0x7
};

typedef uint64 eC_I4RZone;
typedef eC_RhombicIcosahedral3H eC_ISEA3H;
typedef eC_RhombicIcosahedral4R eC_ISEA4R;
typedef eC_RhombicIcosahedral7H eC_ISEA7H;
typedef eC_RI7H_Z7 eC_ISEA7H_Z7;
typedef eC_RhombicIcosahedral9R eC_ISEA9R;
typedef eC_SliceAndDiceGreatCircleIcosahedralProjection eC_ISEAProjection;
typedef eC_RhombicIcosahedral3H eC_IVEA3H;
typedef eC_RhombicIcosahedral4R eC_IVEA4R;
typedef eC_RhombicIcosahedral7H eC_IVEA7H;
typedef eC_RI7H_Z7 eC_IVEA7H_Z7;
typedef eC_RhombicIcosahedral9R eC_IVEA9R;
typedef eC_SliceAndDiceGreatCircleIcosahedralProjection eC_IVEAProjection;
typedef uint64 eC_RHPZone;
typedef eC_RhombicIcosahedral3H eC_RTEA3H;
typedef eC_RhombicIcosahedral4R eC_RTEA4R;
typedef eC_RhombicIcosahedral7H eC_RTEA7H;
typedef eC_RI7H_Z7 eC_RTEA7H_Z7;
typedef eC_RhombicIcosahedral9R eC_RTEA9R;
typedef eC_SliceAndDiceGreatCircleIcosahedralProjection eC_RTEAProjection;
typedef int eC_VGCRadialVertex;
enum
{
   VGCRadialVertex_isea = 0x0,
   VGCRadialVertex_ivea = 0x1,
   VGCRadialVertex_rtea = 0x2
};

typedef eC_DGGRS eC_rHEALPix;
typedef eC_HEALPixProjection eC_rHEALPixProjection;
typedef eC_Array template_Array_JSONSchema;
typedef eC_Map template_Map_String_JSONSchema;
typedef eC_Array template_Array_String;
typedef eC_Array template_Array_FieldValue;
typedef eC_Array template_Array_double;
typedef eC_Map template_Map_String_int;
typedef eC_Array template_Array_DGGSJSONDepth;
typedef eC_Map template_Map_String_template_Array_DGGSJSONDepth;
typedef eC_Array template_Array_DGGSJSONDimension;
typedef eC_Array template_Array_int;
typedef eC_Array template_Array_DGGRSZone;
typedef eC_Array template_Array_GeoPoint;
typedef eC_Array template_Array_Pointd;
#define CRS_registry_SHIFT                               0
#define CRS_registry_MASK                                0x3FFFFFFF
#define CRS_crsID_SHIFT                                  30
#define CRS_crsID_MASK                                   0x3FFFFFFFC0000000LL
#define CRS_h_SHIFT                                      62
#define CRS_h_MASK                                       0x4000000000000000LL


extern eC_bool (* DGGRS_areZonesNeighbors)(eC_DGGRS __this, eC_DGGRSZone a, eC_DGGRSZone b);

extern eC_bool (* DGGRS_areZonesSiblings)(eC_DGGRS __this, eC_DGGRSZone a, eC_DGGRSZone b);

extern int DGGRS_compactZones_vTblID;
void DGGRS_compactZones(eC_DGGRS __i, eC_Array zones);
extern eC_Method * method_DGGRS_compactZones;

extern int DGGRS_countSubZones_vTblID;
uint64 DGGRS_countSubZones(eC_DGGRS __i, eC_DGGRSZone zone, int depth);
extern eC_Method * method_DGGRS_countSubZones;

extern int DGGRS_countZoneEdges_vTblID;
int DGGRS_countZoneEdges(eC_DGGRS __i, eC_DGGRSZone zone);
extern eC_Method * method_DGGRS_countZoneEdges;

extern int DGGRS_countZones_vTblID;
uint64 DGGRS_countZones(eC_DGGRS __i, int level);
extern eC_Method * method_DGGRS_countZones;

extern eC_bool (* DGGRS_doZonesOverlap)(eC_DGGRS __this, eC_DGGRSZone a, eC_DGGRSZone b);

extern eC_bool (* DGGRS_doesZoneContain)(eC_DGGRS __this, eC_DGGRSZone hayStack, eC_DGGRSZone needle);

extern int (* DGGRS_get64KDepth)(eC_DGGRS __this);

extern int DGGRS_getFirstSubZone_vTblID;
eC_DGGRSZone DGGRS_getFirstSubZone(eC_DGGRS __i, eC_DGGRSZone zone, int relativeDepth);
extern eC_Method * method_DGGRS_getFirstSubZone;

extern int DGGRS_getIndexMaxDepth_vTblID;
int DGGRS_getIndexMaxDepth(eC_DGGRS __i);
extern eC_Method * method_DGGRS_getIndexMaxDepth;

extern int (* DGGRS_getLevelFromMetersPerSubZone)(eC_DGGRS __this, double physicalMetersPerSubZone, int relativeDepth);

extern int (* DGGRS_getLevelFromPixelsAndExtent)(eC_DGGRS __this, const eC_GeoExtent * extent, const eC_Point * pixels, int relativeDepth);

extern int (* DGGRS_getLevelFromRefZoneArea)(eC_DGGRS __this, double metersSquared);

extern int (* DGGRS_getLevelFromScaleDenominator)(eC_DGGRS __this, double scaleDenominator, int relativeDepth, double mmPerPixel);

extern int DGGRS_getMaxChildren_vTblID;
int DGGRS_getMaxChildren(eC_DGGRS __i);
extern eC_Method * method_DGGRS_getMaxChildren;

extern int DGGRS_getMaxDGGRSZoneLevel_vTblID;
int DGGRS_getMaxDGGRSZoneLevel(eC_DGGRS __i);
extern eC_Method * method_DGGRS_getMaxDGGRSZoneLevel;

extern int (* DGGRS_getMaxDepth)(eC_DGGRS __this);

extern int DGGRS_getMaxNeighbors_vTblID;
int DGGRS_getMaxNeighbors(eC_DGGRS __i);
extern eC_Method * method_DGGRS_getMaxNeighbors;

extern int DGGRS_getMaxParents_vTblID;
int DGGRS_getMaxParents(eC_DGGRS __i);
extern eC_Method * method_DGGRS_getMaxParents;

extern double (* DGGRS_getMetersPerSubZoneFromLevel)(eC_DGGRS __this, int parentLevel, int relativeDepth);

extern double (* DGGRS_getRefZoneArea)(eC_DGGRS __this, int level);

extern int DGGRS_getRefinementRatio_vTblID;
int DGGRS_getRefinementRatio(eC_DGGRS __i);
extern eC_Method * method_DGGRS_getRefinementRatio;

extern double (* DGGRS_getScaleDenominatorFromLevel)(eC_DGGRS __this, int parentLevel, int relativeDepth, double mmPerPixel);

extern int DGGRS_getSubZoneAtIndex_vTblID;
eC_DGGRSZone DGGRS_getSubZoneAtIndex(eC_DGGRS __i, eC_DGGRSZone parent, int relativeDepth, int64 index);
extern eC_Method * method_DGGRS_getSubZoneAtIndex;

extern int DGGRS_getSubZoneCRSCentroids_vTblID;
eC_Array DGGRS_getSubZoneCRSCentroids(eC_DGGRS __i, eC_DGGRSZone parent, eC_CRS crs, int relativeDepth);
extern eC_Method * method_DGGRS_getSubZoneCRSCentroids;

extern int DGGRS_getSubZoneIndex_vTblID;
int64 DGGRS_getSubZoneIndex(eC_DGGRS __i, eC_DGGRSZone parent, eC_DGGRSZone subZone);
extern eC_Method * method_DGGRS_getSubZoneIndex;

extern int DGGRS_getSubZoneWGS84Centroids_vTblID;
eC_Array DGGRS_getSubZoneWGS84Centroids(eC_DGGRS __i, eC_DGGRSZone parent, int relativeDepth);
extern eC_Method * method_DGGRS_getSubZoneWGS84Centroids;

extern int DGGRS_getSubZones_vTblID;
eC_Array DGGRS_getSubZones(eC_DGGRS __i, eC_DGGRSZone parent, int relativeDepth);
extern eC_Method * method_DGGRS_getSubZones;

extern int DGGRS_getZoneArea_vTblID;
double DGGRS_getZoneArea(eC_DGGRS __i, eC_DGGRSZone zone);
extern eC_Method * method_DGGRS_getZoneArea;

extern int DGGRS_getZoneCRSCentroid_vTblID;
void DGGRS_getZoneCRSCentroid(eC_DGGRS __i, eC_DGGRSZone zone, eC_CRS crs, eC_Pointd * centroid);
extern eC_Method * method_DGGRS_getZoneCRSCentroid;

extern int DGGRS_getZoneCRSExtent_vTblID;
void DGGRS_getZoneCRSExtent(eC_DGGRS __i, eC_DGGRSZone zone, eC_CRS crs, eC_CRSExtent * extent);
extern eC_Method * method_DGGRS_getZoneCRSExtent;

extern int DGGRS_getZoneCRSVertices_vTblID;
int DGGRS_getZoneCRSVertices(eC_DGGRS __i, eC_DGGRSZone zone, eC_CRS crs, eC_Pointd * vertices);
extern eC_Method * method_DGGRS_getZoneCRSVertices;

extern int DGGRS_getZoneCentroidChild_vTblID;
eC_DGGRSZone DGGRS_getZoneCentroidChild(eC_DGGRS __i, eC_DGGRSZone zone);
extern eC_Method * method_DGGRS_getZoneCentroidChild;

extern int DGGRS_getZoneCentroidParent_vTblID;
eC_DGGRSZone DGGRS_getZoneCentroidParent(eC_DGGRS __i, eC_DGGRSZone zone);
extern eC_Method * method_DGGRS_getZoneCentroidParent;

extern int DGGRS_getZoneChildren_vTblID;
int DGGRS_getZoneChildren(eC_DGGRS __i, eC_DGGRSZone zone, eC_DGGRSZone * children);
extern eC_Method * method_DGGRS_getZoneChildren;

extern int DGGRS_getZoneFromCRSCentroid_vTblID;
eC_DGGRSZone DGGRS_getZoneFromCRSCentroid(eC_DGGRS __i, int level, eC_CRS crs, const eC_Pointd * centroid);
extern eC_Method * method_DGGRS_getZoneFromCRSCentroid;

extern int DGGRS_getZoneFromTextID_vTblID;
eC_DGGRSZone DGGRS_getZoneFromTextID(eC_DGGRS __i, constString zoneID);
extern eC_Method * method_DGGRS_getZoneFromTextID;

extern int DGGRS_getZoneFromWGS84Centroid_vTblID;
eC_DGGRSZone DGGRS_getZoneFromWGS84Centroid(eC_DGGRS __i, int level, const eC_GeoPoint * centroid);
extern eC_Method * method_DGGRS_getZoneFromWGS84Centroid;

extern int DGGRS_getZoneLevel_vTblID;
int DGGRS_getZoneLevel(eC_DGGRS __i, eC_DGGRSZone zone);
extern eC_Method * method_DGGRS_getZoneLevel;

extern int DGGRS_getZoneNeighbors_vTblID;
int DGGRS_getZoneNeighbors(eC_DGGRS __i, eC_DGGRSZone zone, eC_DGGRSZone * neighbors, int * nbType);
extern eC_Method * method_DGGRS_getZoneNeighbors;

extern int DGGRS_getZoneParents_vTblID;
int DGGRS_getZoneParents(eC_DGGRS __i, eC_DGGRSZone zone, eC_DGGRSZone * parents);
extern eC_Method * method_DGGRS_getZoneParents;

extern int DGGRS_getZoneRefinedCRSVertices_vTblID;
eC_Array DGGRS_getZoneRefinedCRSVertices(eC_DGGRS __i, eC_DGGRSZone zone, eC_CRS crs, int edgeRefinement);
extern eC_Method * method_DGGRS_getZoneRefinedCRSVertices;

extern int DGGRS_getZoneRefinedWGS84Vertices_vTblID;
eC_Array DGGRS_getZoneRefinedWGS84Vertices(eC_DGGRS __i, eC_DGGRSZone zone, int edgeRefinement);
extern eC_Method * method_DGGRS_getZoneRefinedWGS84Vertices;

extern int DGGRS_getZoneTextID_vTblID;
void DGGRS_getZoneTextID(eC_DGGRS __i, eC_DGGRSZone zone, eC_String zoneID);
extern eC_Method * method_DGGRS_getZoneTextID;

extern int DGGRS_getZoneWGS84Centroid_vTblID;
void DGGRS_getZoneWGS84Centroid(eC_DGGRS __i, eC_DGGRSZone zone, eC_GeoPoint * centroid);
extern eC_Method * method_DGGRS_getZoneWGS84Centroid;

extern int DGGRS_getZoneWGS84Extent_vTblID;
void DGGRS_getZoneWGS84Extent(eC_DGGRS __i, eC_DGGRSZone zone, eC_GeoExtent * extent);
extern eC_Method * method_DGGRS_getZoneWGS84Extent;

extern int DGGRS_getZoneWGS84ExtentApproximate_vTblID;
void DGGRS_getZoneWGS84ExtentApproximate(eC_DGGRS __i, eC_DGGRSZone zone, eC_GeoExtent * extent);
extern eC_Method * method_DGGRS_getZoneWGS84ExtentApproximate;

extern int DGGRS_getZoneWGS84Vertices_vTblID;
int DGGRS_getZoneWGS84Vertices(eC_DGGRS __i, eC_DGGRSZone zone, eC_GeoPoint * vertices);
extern eC_Method * method_DGGRS_getZoneWGS84Vertices;

extern eC_bool (* DGGRS_isZoneAncestorOf)(eC_DGGRS __this, eC_DGGRSZone ancestor, eC_DGGRSZone descendant, int maxDepth);

extern int DGGRS_isZoneCentroidChild_vTblID;
eC_bool DGGRS_isZoneCentroidChild(eC_DGGRS __i, eC_DGGRSZone zone);
extern eC_Method * method_DGGRS_isZoneCentroidChild;

extern eC_bool (* DGGRS_isZoneContainedIn)(eC_DGGRS __this, eC_DGGRSZone needle, eC_DGGRSZone hayStack);

extern eC_bool (* DGGRS_isZoneDescendantOf)(eC_DGGRS __this, eC_DGGRSZone descendant, eC_DGGRSZone ancestor, int maxDepth);

extern eC_bool (* DGGRS_isZoneImmediateChildOf)(eC_DGGRS __this, eC_DGGRSZone child, eC_DGGRSZone parent);

extern eC_bool (* DGGRS_isZoneImmediateParentOf)(eC_DGGRS __this, eC_DGGRSZone parent, eC_DGGRSZone child);

extern int DGGRS_listZones_vTblID;
eC_Array DGGRS_listZones(eC_DGGRS __i, int level, const eC_GeoExtent * bbox);
extern eC_Method * method_DGGRS_listZones;

extern int DGGRS_zoneHasSubZone_vTblID;
eC_bool DGGRS_zoneHasSubZone(eC_DGGRS __i, eC_DGGRSZone hayStack, eC_DGGRSZone needle);
extern eC_Method * method_DGGRS_zoneHasSubZone;

#define DGGRSZONE_level_SHIFT                            59
#define DGGRSZONE_level_MASK                             0xF800000000000000LL
#define DGGRSZONE_row_SHIFT                              30
#define DGGRSZONE_row_MASK                               0x7FFFFFFC0000000LL
#define DGGRSZONE_col_SHIFT                              0
#define DGGRSZONE_col_MASK                               0x3FFFFFFF


struct class_members_DGGSJSON
{
   eC_String dggrs;
   eC_String zoneId;
   eC_Array depths;
   eC_String representedValue;
   eC_JSONSchema schema;
   eC_Array dimensions;
   eC_Map values;
};
struct class_members_DGGSJSONDepth
{
   int depth;
   eC_DGGSJSONShape shape;
   eC_Array data;
};
struct class_members_DGGSJSONDimension
{
   eC_String name;
   eC_Array interval;
   eC_DGGSJSONGrid grid;
   eC_String definition;
   eC_String unit;
   eC_String unitLang;
};
struct class_members_DGGSJSONGrid
{
   int cellsCount;
   double resolution;
   eC_Array coordinates;
   eC_Array boundsCoordinates;
   eC_Array relativeBounds;
   eC_FieldValue firstCoordinate;
};
struct class_members_DGGSJSONShape
{
   int count;
   int subZones;
   eC_Map dimensions;
};
#define GGGZONE_level_SHIFT                              59
#define GGGZONE_level_MASK                               0xF800000000000000LL
#define GGGZONE_row_SHIFT                                30
#define GGGZONE_row_MASK                                 0x7FFFFFFC0000000LL
#define GGGZONE_col_SHIFT                                0
#define GGGZONE_col_MASK                                 0x3FFFFFFF


struct eC_GeoExtent
{
   eC_GeoPoint ll;
   eC_GeoPoint ur;
};
extern void (* GeoExtent_clear)(eC_GeoExtent * __this);

extern eC_bool (* GeoExtent_clip)(eC_GeoExtent * __this, const eC_GeoExtent * e, const eC_GeoExtent * clipExtent);

extern eC_bool (* GeoExtent_clipHandlingDateline)(eC_GeoExtent * __this, const eC_GeoExtent * e, const eC_GeoExtent * clipExtent);

extern void (* GeoExtent_doUnionDL)(eC_GeoExtent * __this, const eC_GeoExtent * e);

extern eC_bool (* GeoExtent_intersects)(eC_GeoExtent * __this, const eC_GeoExtent * b);

extern eC_Property * property_GeoExtent_nonNull;
extern eC_bool (* GeoExtent_get_nonNull)(const eC_GeoExtent * g);

extern eC_Property * property_GeoExtent_geodeticArea;
extern double (* GeoExtent_get_geodeticArea)(const eC_GeoExtent * g);

extern int HEALPixProjection_forward_vTblID;
eC_bool HEALPixProjection_forward(eC_HEALPixProjection __i, const eC_GeoPoint * p, eC_Pointd * v);
extern eC_Method * method_HEALPixProjection_forward;

extern int HEALPixProjection_inverse_vTblID;
eC_bool HEALPixProjection_inverse(eC_HEALPixProjection __i, const eC_Pointd * v, eC_GeoPoint * result, eC_bool oddGrid);
extern eC_Method * method_HEALPixProjection_inverse;

#define HPZONE_level_SHIFT                               56
#define HPZONE_level_MASK                                0x1F00000000000000LL
#define HPZONE_rootRhombus_SHIFT                         52
#define HPZONE_rootRhombus_MASK                          0xF0000000000000LL
#define HPZONE_subIndex_SHIFT                            0
#define HPZONE_subIndex_MASK                             0xFFFFFFFFFFFFFLL


#define I3HZONE_levelI9R_SHIFT                           57
#define I3HZONE_levelI9R_MASK                            0x3E00000000000000LL
#define I3HZONE_rootRhombus_SHIFT                        53
#define I3HZONE_rootRhombus_MASK                         0x1E0000000000000LL
#define I3HZONE_rhombusIX_SHIFT                          2
#define I3HZONE_rhombusIX_MASK                           0x1FFFFFFFFFFFFCLL
#define I3HZONE_subHex_SHIFT                             0
#define I3HZONE_subHex_MASK                              0x3


#define I4RZONE_level_SHIFT                              59
#define I4RZONE_level_MASK                               0xF800000000000000LL
#define I4RZONE_row_SHIFT                                30
#define I4RZONE_row_MASK                                 0x7FFFFFFC0000000LL
#define I4RZONE_col_SHIFT                                0
#define I4RZONE_col_MASK                                 0x3FFFFFFF


#define I7HZONE_levelI49R_SHIFT                          58
#define I7HZONE_levelI49R_MASK                           0x3C00000000000000LL
#define I7HZONE_rootRhombus_SHIFT                        54
#define I7HZONE_rootRhombus_MASK                         0x3C0000000000000LL
#define I7HZONE_rhombusIX_SHIFT                          3
#define I7HZONE_rhombusIX_MASK                           0x3FFFFFFFFFFFF8LL
#define I7HZONE_subHex_SHIFT                             0
#define I7HZONE_subHex_MASK                              0x7


#define I9RZONE_level_SHIFT                              59
#define I9RZONE_level_MASK                               0xF800000000000000LL
#define I9RZONE_row_SHIFT                                30
#define I9RZONE_row_MASK                                 0x7FFFFFFC0000000LL
#define I9RZONE_col_SHIFT                                0
#define I9RZONE_col_MASK                                 0x3FFFFFFF


struct class_members_JSONSchema
{
   eC_String schema;
   eC_String id;
   eC_String title;
   eC_String comment;
   eC_String description;
   eC_FieldValue Default;
   eC_bool readOnly;
   eC_bool writeOnly;
   eC_Array examples;
   eC_Array multipleOf;
   eC_JSONSchemaType type;
   eC_Array Enum;
   eC_String format;
   eC_String contentMediaType;
   double maximum;
   double exclusiveMaximum;
   double minimum;
   double exclusiveMinimum;
   eC_String pattern;
   eC_JSONSchema items;
   int maxItems;
   int minItems;
   eC_bool uniqueItems;
   eC_String contains;
   int maxProperties;
   int minProperties;
   eC_Array required;
   eC_JSONSchema additionalProperties;
   eC_Map definitions;
   eC_Map properties;
   eC_Map patternProperties;
   eC_Map dependencies;
   eC_String propertyNames;
   eC_String contentEncoding;
   eC_JSONSchema If;
   eC_JSONSchema Then;
   eC_JSONSchema Else;
   eC_Array allOf;
   eC_Array anyOf;
   eC_Array oneOf;
   eC_JSONSchema Not;
   eC_String xogcrole;
   int xogcpropertySeq;
};
extern eC_Property * property_JSONSchema_maximum;
extern double (* JSONSchema_get_maximum)(const eC_JSONSchema j);
extern eC_bool (* JSONSchema_isSet_maximum)(const eC_JSONSchema j);

extern eC_Property * property_JSONSchema_exclusiveMaximum;
extern double (* JSONSchema_get_exclusiveMaximum)(const eC_JSONSchema j);
extern eC_bool (* JSONSchema_isSet_exclusiveMaximum)(const eC_JSONSchema j);

extern eC_Property * property_JSONSchema_minimum;
extern double (* JSONSchema_get_minimum)(const eC_JSONSchema j);
extern eC_bool (* JSONSchema_isSet_minimum)(const eC_JSONSchema j);

extern eC_Property * property_JSONSchema_exclusiveMinimum;
extern double (* JSONSchema_get_exclusiveMinimum)(const eC_JSONSchema j);
extern eC_bool (* JSONSchema_isSet_exclusiveMinimum)(const eC_JSONSchema j);

extern eC_Property * property_JSONSchema_maxItems;
extern int (* JSONSchema_get_maxItems)(const eC_JSONSchema j);
extern eC_bool (* JSONSchema_isSet_maxItems)(const eC_JSONSchema j);

extern eC_Property * property_JSONSchema_minItems;
extern int (* JSONSchema_get_minItems)(const eC_JSONSchema j);
extern eC_bool (* JSONSchema_isSet_minItems)(const eC_JSONSchema j);

extern eC_Property * property_JSONSchema_maxProperties;
extern int (* JSONSchema_get_maxProperties)(const eC_JSONSchema j);
extern eC_bool (* JSONSchema_isSet_maxProperties)(const eC_JSONSchema j);

extern eC_Property * property_JSONSchema_minProperties;
extern int (* JSONSchema_get_minProperties)(const eC_JSONSchema j);
extern eC_bool (* JSONSchema_isSet_minProperties)(const eC_JSONSchema j);

extern eC_Property * property_JSONSchema_xogcpropertySeq;
extern eC_bool (* JSONSchema_isSet_xogcpropertySeq)(const eC_JSONSchema j);

extern eC_Property * property_JSONSchema_Default;
extern eC_bool (* JSONSchema_isSet_Default)(const eC_JSONSchema j);

struct eC_Plane
{
   union
   {
      struct
      {
         double a;
         double b;
         double c;
      };
      eC_Vector3D normal;
   };
   double d;
};
extern void (* Plane_fromPoints)(eC_Plane * __this, const eC_Vector3D * v1, const eC_Vector3D * v2, const eC_Vector3D * v3);

struct eC_Quaternion
{
   double w;
   double x;
   double y;
   double z;
};
extern void (* Quaternion_yawPitch)(eC_Quaternion * __this, eC_Angle yaw, eC_Angle pitch);

#define RHPZONE_level_SHIFT                              59
#define RHPZONE_level_MASK                               0xF800000000000000LL
#define RHPZONE_row_SHIFT                                30
#define RHPZONE_row_MASK                                 0x7FFFFFFC0000000LL
#define RHPZONE_col_SHIFT                                0
#define RHPZONE_col_MASK                                 0x3FFFFFFF


extern void (* RI5x6Projection_extent5x6FromWGS84)(eC_RI5x6Projection __this, const eC_GeoExtent * wgs84Extent, eC_Pointd * topLeft, eC_Pointd * bottomRight);

extern int RI5x6Projection_forward_vTblID;
eC_bool RI5x6Projection_forward(eC_RI5x6Projection __i, const eC_GeoPoint * p, eC_Pointd * v);
extern eC_Method * method_RI5x6Projection_forward;

extern eC_bool (* RI5x6Projection_fromIcosahedronNet)(const eC_Pointd * v, eC_Pointd * result);

extern int RI5x6Projection_inverse_vTblID;
eC_bool RI5x6Projection_inverse(eC_RI5x6Projection __i, const eC_Pointd * _v, eC_GeoPoint * result, eC_bool oddGrid);
extern eC_Method * method_RI5x6Projection_inverse;

extern eC_bool (* RI5x6Projection_toIcosahedronNet)(const eC_Pointd * v, eC_Pointd * result);

extern void (* Vector3D_crossProduct)(eC_Vector3D * __this, const eC_Vector3D * vector1, const eC_Vector3D * vector2);

extern double (* Vector3D_dotProduct)(eC_Vector3D * __this, const eC_Vector3D * vector2);

extern void (* Vector3D_multQuaternion)(eC_Vector3D * __this, const eC_Vector3D * s, const eC_Quaternion * quat);

extern void (* Vector3D_normalize)(eC_Vector3D * __this, const eC_Vector3D * source);

extern void (* Vector3D_subtract)(eC_Vector3D * __this, const eC_Vector3D * vector1, const eC_Vector3D * vector2);

extern eC_Property * property_Vector3D_length;
extern double (* Vector3D_get_length)(const eC_Vector3D * v);

#define Z7ZONE_rootPentagon_SHIFT                        60
#define Z7ZONE_rootPentagon_MASK                         0xF000000000000000LL
#define Z7ZONE_ancestry_SHIFT                            0
#define Z7ZONE_ancestry_MASK                             0xFFFFFFFFFFFFFFFLL


extern eC_Z7Zone (* Z7Zone_from7H)(eC_I7HZone zone);

extern eC_Z7Zone (* Z7Zone_fromTextID)(constString zoneID);

extern int (* Z7Zone_getParentRotationOffset)(eC_I7HZone zone);

extern void (* Z7Zone_getTextID)(eC_Z7Zone __this, eC_String zoneID);

extern eC_I7HZone (* Z7Zone_to7H)(eC_Z7Zone __this);

extern eC_I3HZone (* eC_i3HZoneFromI9R)(eC_I9RZone zone, char subHex);
extern eC_I9RZone (* eC_i9RZoneFromI3H)(eC_I3HZone zone);
// NOTE: These functions break on older CFFI
extern void (* eC_authalicSetup)(double a, double b, double * cp /*[2][6]*/);
extern void (* eC_canonicalize5x6)(const eC_Pointd * _src, eC_Pointd * out);
extern void (* eC_compactGGGZones)(eC_Array zones, int start, int maxLevel);
extern eC_Angle (* eC_latAuthalicToGeodetic)(const double * cp /*[2][6]*/, eC_Angle phi);
extern eC_Angle (* eC_latGeodeticToAuthalic)(const double * cp /*[2][6]*/, eC_Angle phi);
extern eC_DGGSJSON (* eC_readDGGSJSON)(eC_File f);
extern eC_Class * class_BCTA3H;
extern eC_Class * class_BarycentricSphericalTriAreaProjection;
extern eC_Class * class_CRS;
extern eC_Class * class_CRSExtent;
extern eC_Class * class_CRSRegistry;
extern eC_Class * class_DGGRS;
extern eC_Class * class_DGGRSZone;
extern eC_Class * class_DGGSJSON;
extern eC_Class * class_DGGSJSONDepth;
extern eC_Class * class_DGGSJSONDimension;
extern eC_Class * class_DGGSJSONGrid;
extern eC_Class * class_DGGSJSONShape;
extern eC_Class * class_GGGZone;
extern eC_Class * class_GNOSISGlobalGrid;
extern eC_Class * class_GPP3H;
extern eC_Class * class_GeoExtent;
extern eC_Class * class_GeoPoint;
extern eC_Class * class_GoldbergPolyhedraProjection;
extern eC_Class * class_HEALPix;
extern eC_Class * class_HEALPixProjection;
extern eC_Class * class_HPZone;
extern eC_Class * class_I3HNeighbor;
extern eC_Class * class_I3HZone;
extern eC_Class * class_I4RZone;
extern eC_Class * class_I7HZone;
extern eC_Class * class_I9RZone;
extern eC_Class * class_ISEA3H;
extern eC_Class * class_ISEA4R;
extern eC_Class * class_ISEA7H;
extern eC_Class * class_ISEA7H_Z7;
extern eC_Class * class_ISEA9R;
extern eC_Class * class_ISEAProjection;
extern eC_Class * class_IVEA3H;
extern eC_Class * class_IVEA4R;
extern eC_Class * class_IVEA7H;
extern eC_Class * class_IVEA7H_Z7;
extern eC_Class * class_IVEA9R;
extern eC_Class * class_IVEAProjection;
extern eC_Class * class_JSONSchema;
extern eC_Class * class_JSONSchemaType;
extern eC_Class * class_Plane;
extern eC_Class * class_Quaternion;
extern eC_Class * class_RHPZone;
extern eC_Class * class_RI5x6Projection;
extern eC_Class * class_RI7H_Z7;
extern eC_Class * class_RTEA3H;
extern eC_Class * class_RTEA4R;
extern eC_Class * class_RTEA7H;
extern eC_Class * class_RTEA7H_Z7;
extern eC_Class * class_RTEA9R;
extern eC_Class * class_RTEAProjection;
extern eC_Class * class_RhombicIcosahedral3H;
extern eC_Class * class_RhombicIcosahedral4R;
extern eC_Class * class_RhombicIcosahedral7H;
extern eC_Class * class_RhombicIcosahedral9R;
extern eC_Class * class_SliceAndDiceGreatCircleIcosahedralProjection;
extern eC_Class * class_VGCRadialVertex;
extern eC_Class * class_Vector3D;
extern eC_Class * class_Z7Zone;
extern eC_Class * class_rHEALPix;
extern eC_Class * class_rHEALPixProjection;

extern eC_Module dggal_init(eC_Module fromModule);




================================================
FILE: bindings/rust/dggal.rs
================================================
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
//#![allow(unused_variables)]

extern crate ecrt_sys;

extern crate ecrt;

use ecrt::define_bitclass;
use ecrt::Application;
use ecrt::File;
use ecrt::nullVTbl;
use ecrt::nullInst;
use ecrt::nullPtr;
use ecrt::Array;
use ecrt::Map;
use ecrt::FieldValue;
use ecrt::ConstString;
use ecrt::Instance;
use ecrt::TTAU64;
use ecrt::delegate_ttau64_and_default;

extern crate dggal_sys;

use std::ffi::CString;
use std::ffi::CStr;
use std::ffi::c_void;
use std::slice;
use std::mem;
use std::f64::consts::PI;
use std::ops::Deref;
/////

pub type GeoPoint = dggal_sys::GeoPoint;
pub type GeoExtent = dggal_sys::GeoExtent;
pub type DGGRSZone = dggal_sys::DGGRSZone;

pub const nullZone : DGGRSZone = 0xFFFFFFFFFFFFFFFFu64;

pub const wholeWorld: GeoExtent = GeoExtent {
   ll: GeoPoint { lat: -90.0 * PI / 180.0, lon : -180.0 * PI / 180.0 },
   ur: GeoPoint { lat:  90.0 * PI / 180.0, lon :  180.0 * PI / 180.0 }
};

define_bitclass! { CRS, dggal_sys::CRS,
    registry => { set: set_registry, is_bool: false, type: dggal_sys::CRSRegistry, prim_type: u32, mask: dggal_sys::CRS_registry_MASK, shift: dggal_sys::CRS_registry_SHIFT },
    crsID =>    { set: set_crsID,    is_bool: false, type: u32,                    prim_type: u32, mask: dggal_sys::CRS_crsID_MASK,    shift: dggal_sys::CRS_crsID_SHIFT },
    h =>        { set: set_h,        is_bool: true,  type: bool,                   prim_type: u32, mask: dggal_sys::CRS_h_MASK,        shift: dggal_sys::CRS_h_SHIFT }
}

#[macro_export] macro_rules! CRS {
   ($registry:expr, $crsID:expr $(, $h:expr)?) => {
      {
         let mut instance = CRS(0);
         instance.set_registry($registry);
         instance.set_crsID($crsID);
         $(instance.set_h($h);)?
         instance
      }
   };
}

pub const epsg : dggal_sys::CRSRegistry = dggal_sys::CRSRegistry_CRSRegistry_epsg;
pub const ogc  : dggal_sys::CRSRegistry = dggal_sys::CRSRegistry_CRSRegistry_ogc;

pub struct DGGRS {
   imp: dggal_sys::DGGRS,
   mDGGAL: ecrt_sys::Module
}

pub struct DGGAL {
   mDGGAL: ecrt_sys::Module
}

impl DGGAL {
   pub fn new(app: &Application) -> DGGAL
   {
      unsafe {
         DGGAL { mDGGAL: dggal_sys::dggal_init(app.app) }
      }
   }
}

impl DGGRS {
   pub fn new(dggal: &DGGAL, name: &str) -> Result<Self, String>
   {
      let dggrsName = CString::new(name).unwrap();
      unsafe {
         let c = ecrt_sys::__eCNameSpace__eC__types__eSystem_FindClass(dggal.mDGGAL, dggrsName.as_ptr());
         if c != nullVTbl as * mut ecrt_sys::Class {
            Ok(DGGRS { imp: ecrt_sys::__eCNameSpace__eC__types__eInstance_New(c) as dggal_sys::DGGRS, mDGGAL: dggal.mDGGAL })
         }
         else {
            Err(format!("Failure to instantiate DGGRS {name}"))
         }
      }
   }

   // TODO: Could we use rust function-generating macros?

   // These are the virtual methods:
   pub fn getZoneFromTextID(&self, zoneID: &str) -> dggal_sys::DGGRSZone
   {
      let mut zone = nullZone;
      unsafe
      {
         let c = dggal_sys::class_DGGRS;
         let vTbl = if self.imp != nullInst && (*self.imp)._vTbl != nullVTbl { (*self.imp)._vTbl } else { (*c)._vTbl };
         let cMethod: usize = std::mem::transmute(*vTbl.add(dggal_sys::DGGRS_getZoneFromTextID_vTblID as usize));
         if cMethod != 0usize {
            let method : unsafe extern "C" fn(dggrs: dggal_sys::DGGRS, zoneID: * const i8) -> dggal_sys::DGGRSZone = std::mem::transmute(cMethod);
            let csZoneID = CString::new(zoneID).unwrap();
            zone = method(self.imp, csZoneID.as_ptr());
         }
      }
      zone
   }

   pub fn getZoneLevel(&self, zone: dggal_sys::DGGRSZone) -> i32
   {
      let mut level = -1;
      unsafe
      {
         let c = dggal_sys::class_DGGRS;
         let vTbl = if self.imp != nullInst && (*self.imp)._vTbl != nullVTbl { (*self.imp)._vTbl } else { (*c)._vTbl };
         let cMethod: usize = std::mem::transmute(*vTbl.add(dggal_sys::DGGRS_getZoneLevel_vTblID as usize));
         if cMethod != 0usize {
            let method : unsafe extern "C" fn(dggrs: dggal_sys::DGGRS, zone: dggal_sys::DGGRSZone) -> i32 = std::mem::transmute(cMethod);
            level = method(self.imp, zone);
         }
      }
      level
   }

   pub fn countZoneEdges(&self, zone: dggal_sys::DGGRSZone) -> i32
   {
      let mut level = -1;
      unsafe
      {
         let c = dggal_sys::class_DGGRS;
         let vTbl = if self.imp != nullInst && (*self.imp)._vTbl != nullVTbl { (*self.imp)._vTbl } else { (*c)._vTbl };
         let cMethod: usize = std::mem::transmute(*vTbl.add(dggal_sys::DGGRS_countZoneEdges_vTblID as usize));
         if cMethod != 0usize {
            let method : unsafe extern "C" fn(dggrs: dggal_sys::DGGRS, zone: dggal_sys::DGGRSZone) -> i32 = std::mem::transmute(cMethod);
            level = method(self.imp, zone);
         }
      }
      level
   }

   pub fn getRefinementRatio(&self) -> i32
   {
      let mut depth = -1;
      unsafe
      {
         let c = dggal_sys::class_DGGRS;
         let vTbl = if self.imp != nullInst && (*self.imp)._vTbl != nullVTbl { (*self.imp)._vTbl } else { (*c)._vTbl };
         let cMethod: usize = std::mem::transmute(*vTbl.add(dggal_sys::DGGRS_getRefinementRatio_vTblID as usize));
         if cMethod != 0usize {
            let method : unsafe extern "C" fn(dggrs: dggal_sys::DGGRS) -> i32 = std::mem::transmute(cMethod);
            depth = method(self.imp,);
         }
      }
      depth
   }

   pub fn getMaxDGGRSZoneLevel(&self) -> i32
   {
      let mut depth = -1;
      unsafe
      {
         let c = dggal_sys::class_DGGRS;
         let vTbl = if self.imp != nullInst && (*self.imp)._vTbl != nullVTbl { (*self.imp)._vTbl } else { (*c)._vTbl };
         let cMethod: usize = std::mem::transmute(*vTbl.add(dggal_sys::DGGRS_getMaxDGGRSZoneLevel_vTblID as usize));
         if cMethod != 0usize {
            let method : unsafe extern "C" fn(dggrs: dggal_sys::DGGRS) -> i32 = std::mem::transmute(cMethod);
            depth = method(self.imp,);
         }
      }
      depth
   }

   pub fn getZoneWGS84Centroid(&self, zone: dggal_sys::DGGRSZone) -> dggal_sys::GeoPoint
   {
      let mut centroid = dggal_sys::GeoPoint { lat: 0.0, lon: 0.0 };
      unsafe
      {
         let c = dggal_sys::class_DGGRS;
         let vTbl = if self.imp != nullInst && (*self.imp)._vTbl != nullVTbl { (*self.imp)._vTbl } else { (*c)._vTbl };
         let cMethod: usize = std::mem::transmute(*vTbl.add(dggal_sys::DGGRS_getZoneWGS84Centroid_vTblID as usize));
         if cMethod != std::mem::transmute(0usize) {
            let method : unsafe extern "C" fn(dggrs: dggal_sys::DGGRS, zone: dggal_sys::DGGRSZone, centroid: *mut dggal_sys::GeoPoint) = std::mem::transmute(cMethod);
            method(self.imp, zone, std::ptr::from_mut(&mut centroid));
         }
      }
      centroid
   }

   pub fn getZoneWGS84Vertices(&self, zone: dggal_sys::DGGRSZone) -> Vec<dggal_sys::GeoPoint>
   {
      let vertices: Vec<dggal_sys::GeoPoint>;
      unsafe
      {
         let c = dggal_sys::class_DGGRS;
         let vTbl = if self.imp != nullInst && (*self.imp)._vTbl != nullVTbl { (*self.imp)._vTbl } else { (*c)._vTbl };
         let mut v: [dggal_sys::GeoPoint; 6] = [dggal_sys::GeoPoint { lat: 0.0, lon: 0.0 }; 6]; // REVIEW: Any way to avoid this initialization?
         let cMethod: usize = std::mem::transmute(*vTbl.add(dggal_sys::DGGRS_getZoneWGS84Vertices_vTblID as usize));
         let mut n: i32 = 0;
         if cMethod != std::mem::transmute(0usize) {
            let method : unsafe extern "C" fn(dggrs: dggal_sys::DGGRS, zone: dggal_sys::DGGRSZone, vertices: *mut dggal_sys::GeoPoint) -> i32 = std::mem::transmute(cMethod);
            n = method(self.imp, zone, std::ptr::from_mut(&mut v[0]));
         }
         vertices = slice::from_raw_parts(&v[0], n as usize).to_vec();
      }
      vertices
   }

   pub fn getZoneArea(&self, zone: dggal_sys::DGGRSZone) -> f64
   {
      let mut area = 0.0;
      unsafe
      {
         let c = dggal_sys::class_DGGRS;
         let vTbl = if self.imp != nullInst && (*self.imp)._vTbl != nullVTbl { (*self.imp)._vTbl } else { (*c)._vTbl };
         let cMethod: usize = std::mem::transmute(*vTbl.add(dggal_sys::DGGRS_getZoneArea_vTblID as usize));
         if cMethod != std::mem::transmute(0usize) {
            let method : unsafe extern "C" fn(dggrs: dggal_sys::DGGRS, zone: dggal_sys::DGGRSZone) -> f64 = std::mem::transmute(cMethod);
            area = method(self.imp, zone);
         }
      }
      area
   }

   pub fn countSubZones(&self, zone: dggal_sys::DGGRSZone, depth: i32) -> u64
   {
      let mut count = 0;
      unsafe
      {
         let c = dggal_sys::class_DGGRS;
         let vTbl = if self.imp != nullInst && (*self.imp)._vTbl != nullVTbl { (*self.imp)._vTbl } else { (*c)._vTbl };
         let cMethod: usize = std::mem::transmute(*vTbl.add(dggal_sys::DGGRS_countSubZones_vTblID as usize));
         if cMethod != std::mem::transmute(0usize) {
            let method : unsafe extern "C" fn(dggrs: dggal_sys::DGGRS, zone: dggal_sys::DGGRSZone, depth: i32) -> u64 = std::mem::transmute(cMethod);
            count = method(self.imp, zone, depth);
         }
      }
      count
   }

   pub fn getZoneTextID(&self, zone: dggal_sys::DGGRSZone) -> String
   {
      let id: String;
      unsafe
      {
         let c = dggal_sys::class_DGGRS;
         let vTbl = if self.imp != nullInst && (*self.imp)._vTbl != nullVTbl { (*self.imp)._vTbl } else { (*c)._vTbl };
         let mut zoneID = [0i8; 256]; // REVIEW: Any way to avoid this initialization?
         let cMethod: usize = std::mem::transmute(*vTbl.add(dggal_sys::DGGRS_getZoneTextID_vTblID as usize));
         if cMethod != std::mem::transmute(0usize) {
            let method : unsafe extern "C" fn(dggrs: dggal_sys::DGGRS, zone: dggal_sys::DGGRSZone, zoneID: *mut i8) = std::mem::transmute(cMethod);
            method(self.imp, zone, std::ptr::from_mut(&mut zoneID[0]));
         }
         id = CStr::from_ptr(zoneID.as_ptr()).to_str().unwrap().to_string();
      }
      id
   }

   pub fn getZoneParents(&self, zone: dggal_sys::DGGRSZone) -> Vec<dggal_sys::DGGRSZone>
   {
      let mut n: i32 = 0;
      let parents: Vec<dggal_sys::DGGRSZone>;
      unsafe
      {
         let c = dggal_sys::class_DGGRS;
         let vTbl = if self.imp != nullInst && (*self.imp)._vTbl != nullVTbl { (*self.imp)._vTbl } else { (*c)._vTbl };
         let mut p = [nullZone; 3]; // REVIEW: Any way to avoid this initialization?
         let cMethod: usize = std::mem::transmute(*vTbl.add(dggal_sys::DGGRS_getZoneParents_vTblID as usize));
         if cMethod != std::mem::transmute(0usize) {
            let method : unsafe extern "C" fn(dggrs: dggal_sys::DGGRS, zone: dggal_sys::DGGRSZone, parents: *mut dggal_sys::DGGRSZone) -> i32 = std::mem::transmute(cMethod);
            n = method(self.imp, zone, std::ptr::from_mut(&mut p[0]));
         }
         parents = slice::from_raw_parts(&p[0], n as usize).to_vec();
      }
      parents
   }

   pub fn getZoneChildren(&self, zone: dggal_sys::DGGRSZone) -> Vec<dggal_sys::DGGRSZone>
   {
      let mut n: i32 = 0;
      let children: Vec<dggal_sys::DGGRSZone>;
      unsafe
      {
         let c = dggal_sys::class_DGGRS;
         let vTbl = if self.imp != nullInst && (*self.imp)._vTbl != nullVTbl { (*self.imp)._vTbl } else { (*c)._vTbl };
         let mut ch = [nullZone; 13]; // REVIEW: Any way to avoid this initialization?
         let cMethod: usize = std::mem::transmute(*vTbl.add(dggal_sys::DGGRS_getZoneChildren_vTblID as usize));
         if cMethod != std::mem::transmute(0usize) {
            let method : unsafe extern "C" fn(dggrs: dggal_sys::DGGRS, zone: dggal_sys::DGGRSZone, children: *mut dggal_sys::DGGRSZone) -> i32 = std::mem::transmute(cMethod);
            n = method(self.imp, zone, std::ptr::from_mut(&mut ch[0]));
         }
         children = slice::from_raw_parts(&ch[0], n as usize).to_vec();
      }
      children
   }

   pub fn getZoneNeighbors(&self, zone: dggal_sys::DGGRSZone, nbTypes: &mut [i32; 6]) -> Vec<dggal_sys::DGGRSZone>
   {
      let mut n: i32 = 0;
      let neighbors: Vec<dggal_sys::DGGRSZone>;
      unsafe
      {
         let c = dggal_sys::class_DGGRS;
         let vTbl = if self.imp != nullInst && (*self.imp)._vTbl != nullVTbl { (*self.imp)._vTbl } else { (*c)._vTbl };
         let mut nb = [nullZone; 6]; // REVIEW: Any way to avoid this initialization?
         let cMethod: usize = std::mem::transmute(*vTbl.add(dggal_sys::DGGRS_getZoneNeighbors_vTblID as usize));
         if cMethod != std::mem::transmute(0usize) {
            let method : unsafe extern "C" fn(dggrs: dggal_sys::DGGRS, zone: dggal_sys::DGGRSZone, neighbors: *mut dggal_sys::DGGRSZone, nbTypes: *mut i32) -> i32 = std::mem::transmute(cMethod);
            n = method(self.imp, zone, std::ptr::from_mut(&mut nb[0]), std::ptr::from_mut(&mut nbTypes[0]));
         }
         neighbors = slice::from_raw_parts(&nb[0], n as usize).to_vec();
      }
      neighbors
   }

   pub fn getZoneCentroidParent(&self, zone: dggal_sys::DGGRSZone) -> dggal_sys::DGGRSZone
   {
      let mut centroidParent: dggal_sys::DGGRSZone = nullZone;
      unsafe
      {
         let c = dggal_sys::class_DGGRS;
         let vTbl = if self.imp != nullInst && (*self.imp)._vTbl != nullVTbl { (*self.imp)._vTbl } else { (*c)._vTbl };
         let cMethod: usize = std::mem::transmute(*vTbl.add(dggal_sys::DGGRS_getZoneCentroidParent_vTblID as usize));
         if cMethod != std::mem::transmute(0usize) {
            let method : unsafe extern "C" fn(dggrs: dggal_sys::DGGRS, zone: dggal_sys::DGGRSZone) -> dggal_sys::DGGRSZone = std::mem::transmute(cMethod);
            centroidParent = method(self.imp, zone);
         }
      }
      centroidParent
   }

   pub fn getZoneCentroidChild(&self, zone: dggal_sys::DGGRSZone) -> dggal_sys::DGGRSZone
   {
      let mut centroidChild: dggal_sys::DGGRSZone = nullZone;
      unsafe
      {
         let c = dggal_sys::class_DGGRS;
         let vTbl = if self.imp != nullInst && (*self.imp)._vTbl != nullVTbl { (*self.imp)._vTbl } else { (*c)._vTbl };
         let cMethod: usize = std::mem::transmute(*vTbl.add(dggal_sys::DGGRS_getZoneCentroidChild_vTblID as usize));
         if cMethod != std::mem::transmute(0usize) {
            let method : unsafe extern "C" fn(dggrs: dggal_sys::DGGRS, zone: dggal_sys::DGGRSZone) -> dggal_sys::DGGRSZone = std::mem::transmute(cMethod);
            centroidChild = method(self.imp, zone);
         }
      }
      centroidChild
   }

   pub fn isZoneCentroidChild(&self, zone: dggal_sys::DGGRSZone) -> bool
   {
      let mut result: bool = false;
      unsafe
      {
         let c = dggal_sys::class_DGGRS;
         let vTbl = if self.imp != nullInst && (*self.imp)._vTbl != nullVTbl { (*self.imp)._vTbl } else { (*c)._vTbl };
         let cMethod: usize = std::mem::transmute(*vTbl.add(dggal_sys::DGGRS_isZoneCentroidChild_vTblID as usize));
         if cMethod != std::mem::transmute(0usize) {
            let method : unsafe extern "C" fn(dggrs: dggal_sys::DGGRS, zone: dggal_sys::DGGRSZone) -> u32 = std::mem::transmute(cMethod);
            result = method(self.imp, zone) != 0;
         }
      }
      result
   }

   pub fn getZoneWGS84Extent(&self, zone: dggal_sys::DGGRSZone) -> dggal_sys::GeoExtent
   {
      let mut extent: dggal_sys::GeoExtent = dggal_sys::GeoExtent {    // REVIEW: Any way to avoid this initialization?
         ll: dggal_sys::GeoPoint { lat: 0.0, lon: 0.0 },
         ur: dggal_sys::GeoPoint { lat: 0.0, lon: 0.0 } };
      unsafe
      {
         let c = dggal_sys::class_DGGRS;
         let vTbl = if self.imp != nullInst && (*self.imp)._vTbl != nullVTbl { (*self.imp)._vTbl } else { (*c)._vTbl };
         let cMethod: usize = std::mem::transmute(*vTbl.add(dggal_sys::DGGRS_getZoneWGS84Extent_vTblID as usize));
         if cMethod != std::mem::transmute(0usize) {
            let method : unsafe extern "C" fn(dggrs: dggal_sys::DGGRS, zone: dggal_sys::DGGRSZone, extent: *mut dggal_sys::GeoExtent) = std::mem::transmute(cMethod);
            method(self.imp, zone, std::ptr::from_mut(&mut extent));
         }
      }
      extent
   }

   pub fn listZones(&self, level: i32, bbox: &dggal_sys::GeoExtent) -> Vec<dggal_sys::DGGRSZone>
   {
      let zones: Vec<dggal_sys::DGGRSZone>;
      unsafe
      {
         let c = dggal_sys::class_DGGRS;
         let vTbl = if self.imp != nullInst && (*self.imp)._vTbl != nullVTbl { (*self.imp)._vTbl } else { (*c)._vTbl };
         let cMethod: usize = std::mem::transmute(*vTbl.add(dggal_sys::DGGRS_listZones_vTblID as usize));
         let mut n: usize = 0;
         let mut a: *const dggal_sys::DGGRSZone = nullPtr as *const dggal_sys::DGGRSZone;

         if cMethod != std::mem::transmute(0usize) {
            let method : unsafe extern "C" fn(dggrs: dggal_sys::DGGRS, level: i32, bbox: *const dggal_sys::GeoExtent) -> dggal_sys::template_Array_DGGRSZone = std::mem::transmute(cMethod);
            let az: dggal_sys::template_Array_DGGRSZone = method(self.imp, level, bbox);
            if az != nullInst {
               let am: *const ecrt_sys::class_members_Array = ((az as *const i8).wrapping_add((*ecrt_sys::class_Array).offset as usize)) as *const ecrt_sys::class_members_Array;
               n = (*am).count as usize;
               a = (*am).array;
            }
         }
         zones = slice::from_raw_parts(a, n).to_vec();
      }
      zones
   }

   pub fn getZoneRefinedWGS84Vertices(&self, zone: dggal_sys::DGGRSZone, refinement: i32) -> Vec<dggal_sys::GeoPoint>
   {
      let vertices: Vec<dggal_sys::GeoPoint>;
      unsafe
      {
         let c = dggal_sys::class_DGGRS;
         let vTbl = if self.imp != nullInst && (*self.imp)._vTbl != nullVTbl { (*self.imp)._vTbl } else { (*c)._vTbl };
         let mut n: usize = 0;
         let mut a: *const dggal_sys::GeoPoint = nullPtr as *const dggal_sys::GeoPoint;

         let cMethod: usize = std::mem::transmute(*vTbl.add(dggal_sys::DGGRS_getZoneRefinedWGS84Vertices_vTblID as usize));
         if cMethod != std::mem::transmute(0usize) {
            let method : unsafe extern "C" fn(dggrs: dggal_sys::DGGRS, zone: dggal_sys::DGGRSZone, refinement: i32) -> dggal_sys::template_Array_GeoPoint = std::mem::transmute(cMethod);
            let ap: dggal_sys::template_Array_GeoPoint = method(self.imp, zone, refinement);
            if ap != nullInst {
               let am: *const ecrt_sys::class_members_Array = ((ap as *const i8).wrapping_add((*ecrt_sys::class_Array).offset as usize)) as *const ecrt_sys::class_members_Array;
               n = (*am).count as usize;
               a = (*am).array as *const dggal_sys::GeoPoint;
            }
         }
         vertices = slice::from_raw_parts(a, n).to_vec();
      }
      vertices
   }

   pub fn getSubZones(&self, parent: dggal_sys::DGGRSZone, relativeDepth: i32) -> Vec<dggal_sys::DGGRSZone>
   {
      let zones: Vec<dggal_sys::DGGRSZone>;
      unsafe
      {
         let c = dggal_sys::class_DGGRS;
         let vTbl = if self.imp != nullInst && (*self.imp)._vTbl != nullVTbl { (*self.imp)._vTbl } else { (*c)._vTbl };
         let cMethod: usize = std::mem::transmute(*vTbl.add(dggal_sys::DGGRS_getSubZones_vTblID as usize));
         let mut n: usize = 0;
         let mut a: *const dggal_sys::DGGRSZone = nullPtr as *const dggal_sys::DGGRSZone;

         if cMethod != std::mem::transmute(0usize) {
            let method : unsafe extern "C" fn(dggrs: dggal_sys::DGGRS, parent: dggal_sys::DGGRSZone, relativeDepth: i32) -> dggal_sys::template_Array_DGGRSZone = std::mem::transmute(cMethod);
            let az: dggal_sys::template_Array_DGGRSZone = method(self.imp, parent, relativeDepth);
            if az != nullInst {
               let am: *const ecrt_sys::class_members_Array = ((az as *const i8).wrapping_add((*ecrt_sys::class_Array).offset as usize)) as *const ecrt_sys::class_members_Array;
               n = (*am).count as usize;
               a = (*am).array;
            }
         }
         zones = slice::from_raw_parts(a, n).to_vec();
      }
      zones
   }

   pub fn getZoneFromWGS84Centroid(&self, level: i32, centroid: &dggal_sys::GeoPoint) -> dggal_sys::DGGRSZone
   {
      let mut zone = nullZone;
      unsafe
      {
         let c = dggal_sys::class_DGGRS;
         let vTbl = if self.imp != nullInst && (*self.imp)._vTbl != nullVTbl { (*self.imp)._vTbl } else { (*c)._vTbl };
         let cMethod: usize = std::mem::transmute(*vTbl.add(dggal_sys::DGGRS_getZoneFromWGS84Centroid_vTblID as usize));
         if cMethod != 0usize {
            let method : unsafe extern "C" fn(dggrs: dggal_sys::DGGRS, level: i32, centroid: * const dggal_sys::GeoPoint) -> dggal_sys::DGGRSZone = std::mem::transmute(cMethod);
            zone = method(self.imp, level, centroid);
         }
      }
      zone
   }

   pub fn getZoneFromCRSCentroid(&self, level: i32, crs: CRS, centroid: &ecrt_sys::Pointd) -> dggal_sys::DGGRSZone
   {
      let mut zone = nullZone;
      unsafe
      {
         let c = dggal_sys::class_DGGRS;
         let vTbl = if self.imp != nullInst && (*self.imp)._vTbl != nullVTbl { (*self.imp)._vTbl } else { (*c)._vTbl };
         let cMethod: usize = std::mem::transmute(*vTbl.add(dggal_sys::DGGRS_getZoneFromCRSCentroid_vTblID as usize));
         if cMethod != 0usize {
            let method : unsafe extern "C" fn(dggrs: dggal_sys::DGGRS, level: i32, crs: dggal_sys::CRS, centroid: * const ecrt_sys::Pointd) -> dggal_sys::DGGRSZone = std::mem::transmute(cMethod);
            zone = method(self.imp, level, *crs, centroid);
         }
      }
      zone
   }

   pub fn countZones(&self, level: i32) -> u64
   {
      let mut count = 0;
      unsafe
      {
         let c = dggal_sys::class_DGGRS;
         let vTbl = if self.imp != nullInst && (*self.imp)._vTbl != nullVTbl { (*self.imp)._vTbl } else { (*c)._vTbl };
         let cMethod: usize = std::mem::transmute(*vTbl.add(dggal_sys::DGGRS_countZones_vTblID as usize));
         if cMethod != std::mem::transmute(0usize) {
            let method : unsafe extern "C" fn(dggrs: dggal_sys::DGGRS, level: i32) -> u64 = std::mem::transmute(cMethod);
            count = method(self.imp, level);
         }
      }
      count
   }

   pub fn getFirstSubZone(&self, parent: dggal_sys::DGGRSZone, relativeDepth: i32) -> dggal_sys::DGGRSZone
   {
      let mut zone = nullZone;
      unsafe
      {
         let c = dggal_sys::class_DGGRS;
         let vTbl = if self.imp != nullInst && (*self.imp)._vTbl != nullVTbl { (*self.imp)._vTbl } else { (*c)._vTbl };
         let cMethod: usize = std::mem::transmute(*vTbl.add(dggal_sys::DGGRS_getFirstSubZone_vTblID as usize));
         if cMethod != 0usize {
            let method : unsafe extern "C" fn(dggrs: dggal_sys::DGGRS, parent: dggal_sys::DGGRSZone, relativeDepth: i32) -> dggal_sys::DGGRSZone = std::mem::transmute(cMethod);
            zone = method(self.imp, parent, relativeDepth);
         }
      }
      zone
   }

   pub fn getIndexMaxDepth(&self) -> i32
   {
      let mut maxDepth = 0;
      unsafe
      {
         let c = dggal_sys::class_DGGRS;
         let vTbl = if self.imp != nullInst && (*self.imp)._vTbl != nullVTbl { (*self.imp)._vTbl } else { (*c)._vTbl };
         let cMethod: usize = std::mem::transmute(*vTbl.add(dggal_sys::DGGRS_getIndexMaxDepth_vTblID as usize));
         if cMethod != std::mem::transmute(0usize) {
            let method : unsafe extern "C" fn(dggrs: dggal_sys::DGGRS) -> i32 = std::mem::transmute(cMethod);
            maxDepth = method(self.imp);
         }
      }
      maxDepth
   }

   pub fn getMaxChildren(&self) -> i32
   {
      let mut maxChildren = 0;
      unsafe
      {
         let c = dggal_sys::class_DGGRS;
         let vTbl = if self.imp != nullInst && (*self.imp)._vTbl != nullVTbl { (*self.imp)._vTbl } else { (*c)._vTbl };
         let cMethod: usize = std::mem::transmute(*vTbl.add(dggal_sys::DGGRS_getMaxChildren_vTblID as usize));
         if cMethod != std::mem::transmute(0usize) {
            let method : unsafe extern "C" fn(dggrs: dggal_sys::DGGRS) -> i32 = std::mem::transmute(cMethod);
            maxChildren = method(self.imp);
         }
      }
      maxChildren
   }

   pub fn getMaxNeighbors(&self) -> i32
   {
      let mut maxNeighbors = 0;
      unsafe
      {
         let c = dggal_sys::class_DGGRS;
         let vTbl = if self.imp != nullInst && (*self.imp)._vTbl != nullVTbl { (*self.imp)._vTbl } else { (*c)._vTbl };
         let cMethod: usize = std::mem::transmute(*vTbl.add(dggal_sys::DGGRS_getMaxNeighbors_vTblID as usize));
         if cMethod != std::mem::transmute(0usize) {
            let method : unsafe extern "C" fn(dggrs: dggal_sys::DGGRS) -> i32 = std::mem::transmute(cMethod);
            maxNeighbors = method(self.imp);
         }
      }
      maxNeighbors
   }

   pub fn getMaxParents(&self) -> i32
   {
      let mut maxParents = 0;
      unsafe
      {
         let c = dggal_sys::class_DGGRS;
         let vTbl = if self.imp != nullInst && (*self.imp)._vTbl != nullVTbl { (*self.imp)._vTbl } else { (*c)._vTbl };
         let cMethod: usize = std::mem::transmute(*vTbl.add(dggal_sys::DGGRS_getMaxParents_vTblID as usize));
         if cMethod != std::mem::transmute(0usize) {
            let method : unsafe extern "C" fn(dggrs: dggal_sys::DGGRS) -> i32 = std::mem::transmute(cMethod);
            maxParents = method(self.imp);
         }
      }
      maxParents
   }

   pub fn getSubZoneAtIndex(&self, parent: dggal_sys::DGGRSZone, index: i64) -> dggal_sys::DGGRSZone
   {
      let mut zone = nullZone;
      unsafe
      {
         let c = dggal_sys::class_DGGRS;
         let vTbl = if self.imp != nullInst && (*self.imp)._vTbl != nullVTbl { (*self.imp)._vTbl } else { (*c)._vTbl };
         let cMethod: usize = std::mem::transmute(*vTbl.add(dggal_sys::DGGRS_getSubZoneAtIndex_vTblID as usize));
         if cMethod != 0usize {
            let method : unsafe extern "C" fn(dggrs: dggal_sys::DGGRS, parent: dggal_sys::DGGRSZone, index: i64) -> dggal_sys::DGGRSZone = std::mem::transmute(cMethod);
            zone = method(self.imp, parent, index);
         }
      }
      zone
   }

   pub fn getSubZoneIndex(&self, parent: dggal_sys::DGGRSZone, subZone: dggal_sys::DGGRSZone) -> i64
   {
      let mut index = -1;
      unsafe
      {
         let c = dggal_sys::class_DGGRS;
         let vTbl = if self.imp != nullInst && (*self.imp)._vTbl != nullVTbl { (*self.imp)._vTbl } else { (*c)._vTbl };
         let cMethod: usize = std::mem::transmute(*vTbl.add(dggal_sys::DGGRS_getSubZoneIndex_vTblID as usize));
         if cMethod != 0usize {
            let method : unsafe extern "C" fn(dggrs: dggal_sys::DGGRS, parent: dggal_sys::DGGRSZone, subZone: dggal_sys::DGGRSZone) -> i64 = std::mem::transmute(cMethod);
            index = method(self.imp, parent, subZone);
         }
      }
      index
   }

   pub fn getSubZoneCRSCentroids(&self, parent: dggal_sys::DGGRSZone, crs: CRS, relativeDepth: i32) -> Vec<ecrt_sys::Pointd>
   {
      let centroids: Vec<ecrt_sys::Pointd>;
      unsafe
      {
         let c = dggal_sys::class_DGGRS;
         let vTbl = if self.imp != nullInst && (*self.imp)._vTbl != nullVTbl { (*self.imp)._vTbl } else { (*c)._vTbl };
         let mut n: usize = 0;
         let mut a: *const ecrt_sys::Pointd = nullPtr as *const ecrt_sys::Pointd;

         let cMethod: usize = std::mem::transmute(*vTbl.add(dggal_sys::DGGRS_getSubZoneCRSCentroids_vTblID as usize));
         if cMethod != std::mem::transmute(0usize) {
            let method : unsafe extern "C" fn(dggrs: dggal_sys::DGGRS, parent: dggal_sys::DGGRSZone, crs: dggal_sys::CRS, relativeDepth: i32) -> dggal_sys::template_Array_Pointd = std::mem::transmute(cMethod);
            let ap: dggal_sys::template_Array_Pointd = method(self.imp, parent, *crs, relativeDepth);
            if ap != nullInst {
               let am: *const ecrt_sys::class_members_Array = ((ap as *const i8).wrapping_add((*ecrt_sys::class_Array).offset as usize)) as *const ecrt_sys::class_members_Array;
               n = (*am).count as usize;
               a = (*am).array as *const ecrt_sys::Pointd;
            }
         }
         centroids = slice::from_raw_parts(a, n).to_vec();
      }
      centroids
   }

   pub fn getSubZoneWGS84Centroids(&self, parent: dggal_sys::DGGRSZone, relativeDepth: i32) -> Vec<dggal_sys::GeoPoint>
   {
      let centroids: Vec<dggal_sys::GeoPoint>;
      unsafe
      {
         let c = dggal_sys::class_DGGRS;
         let vTbl = if self.imp != nullInst && (*self.imp)._vTbl != nullVTbl { (*self.imp)._vTbl } else { (*c)._vTbl };
         let mut n: usize = 0;
         let mut a: *const dggal_sys::GeoPoint = nullPtr as *const dggal_sys::GeoPoint;

         let cMethod: usize = std::mem::transmute(*vTbl.add(dggal_sys::DGGRS_getSubZoneWGS84Centroids_vTblID as usize));
         if cMethod != std::mem::transmute(0usize) {
            let method : unsafe extern "C" fn(dggrs: dggal_sys::DGGRS, parent: dggal_sys::DGGRSZone, relativeDepth: i32) -> dggal_sys::template_Array_GeoPoint = std::mem::transmute(cMethod);
            let ap: dggal_sys::template_Array_GeoPoint = method(self.imp, parent, relativeDepth);
            if ap != nullInst {
               let am: *const ecrt_sys::class_members_Array = ((ap as *const i8).wrapping_add((*ecrt_sys::class_Array).offset as usize)) as *const ecrt_sys::class_members_Array;
               n = (*am).count as usize;
               a = (*am).array as *const dggal_sys::GeoPoint;
            }
         }
         centroids = slice::from_raw_parts(a, n).to_vec();
      }
      centroids
   }

   pub fn getZoneCRSVertices(&self, zone: dggal_sys::DGGRSZone, crs: CRS) -> Vec<ecrt_sys::Pointd>
   {
      let vertices: Vec<ecrt_sys::Pointd>;
      unsafe
      {
         let c = dggal_sys::class_DGGRS;
         let vTbl = if self.imp != nullInst && (*self.imp)._vTbl != nullVTbl { (*self.imp)._vTbl } else { (*c)._vTbl };
         let mut v: [ecrt_sys::Pointd; 6] = [ecrt_sys::Pointd { x: 0.0, y: 0.0 }; 6]; // REVIEW: Any way to avoid this initialization?
         let cMethod: usize = std::mem::transmute(*vTbl.add(dggal_sys::DGGRS_getZoneCRSVertices_vTblID as usize));
         let mut n: i32 = 0;
         if cMethod != std::mem::transmute(0usize) {
            let method : unsafe extern "C" fn(dggrs: dggal_sys::DGGRS, zone: dggal_sys::DGGRSZone, crs: dggal_sys::CRS, vertices: *mut ecrt_sys::Pointd) -> i32 = std::mem::transmute(cMethod);
            n = method(self.imp, zone, *crs, std::ptr::from_mut(&mut v[0]));
         }
         vertices = slice::from_raw_parts(&v[0], n as usize).to_vec();
      }
      vertices
   }

   pub fn getZoneRefinedCRSVertices(&self, zone: dggal_sys::DGGRSZone, crs: CRS, refinement: i32) -> Vec<ecrt_sys::Pointd>
   {
      let vertices: Vec<ecrt_sys::Pointd>;
      unsafe
      {
         let c = dggal_sys::class_DGGRS;
         let vTbl = if self.imp != nullInst && (*self.imp)._vTbl != nullVTbl { (*self.imp)._vTbl } else { (*c)._vTbl };
         let mut n: usize = 0;
         let mut a: *const ecrt_sys::Pointd = nullPtr as *const ecrt_sys::Pointd;

         let cMethod: usize = std::mem::transmute(*vTbl.add(dggal_sys::DGGRS_getZoneRefinedCRSVertices_vTblID as usize));
         if cMethod != std::mem::transmute(0usize) {
            let method : unsafe extern "C" fn(dggrs: dggal_sys::DGGRS, zone: dggal_sys::DGGRSZone, crs: dggal_sys::CRS, refinement: i32) -> dggal_sys::template_Array_GeoPoint = std::mem::transmute(cMethod);
            let ap: dggal_sys::template_Array_GeoPoint = method(self.imp, zone, *crs, refinement);
            if ap != nullInst {
               let am: *const ecrt_sys::class_members_Array = ((ap as *const i8).wrapping_add((*ecrt_sys::class_Array).offset as usize)) as *const ecrt_sys::class_members_Array;
               n = (*am).count as usize;
               a = (*am).array as *const ecrt_sys::Pointd;
            }
         }
         vertices = slice::from_raw_parts(a, n).to_vec();
      }
      vertices
   }

   pub fn getZoneCRSCentroid(&self, zone: dggal_sys::DGGRSZone, crs: CRS) -> ecrt_sys::Pointd
   {
      let mut centroid = ecrt_sys::Pointd { x: 0.0, y: 0.0 };
      unsafe
      {
         let c = dggal_sys::class_DGGRS;
         let vTbl = if self.imp != nullInst && (*self.imp)._vTbl != nullVTbl { (*self.imp)._vTbl } else { (*c)._vTbl };
         let cMethod: usize = std::mem::transmute(*vTbl.add(dggal_sys::DGGRS_getZoneCRSCentroid_vTblID as usize));
         if cMethod != std::mem::transmute(0usize) {
            let method : unsafe extern "C" fn(dggrs: dggal_sys::DGGRS, zone: dggal_sys::DGGRSZone, crs: dggal_sys::CRS, centroid: *mut ecrt_sys::Pointd) = std::mem::transmute(cMethod);
            method(self.imp, zone, *crs, std::ptr::from_mut(&mut centroid));
         }
      }
      centroid
   }

   pub fn getZoneCRSExtent(&self, zone: dggal_sys::DGGRSZone, crs: CRS) -> dggal_sys::CRSExtent
   {
      let mut extent: dggal_sys::CRSExtent = dggal_sys::CRSExtent {    // REVIEW: Any way to avoid this initialization?
         tl: ecrt_sys::Pointd { x: 0.0, y: 0.0 },
         br: ecrt_sys::Pointd { x: 0.0, y: 0.0 },
         crs: 0 };
      unsafe
      {
         let c = dggal_sys::class_DGGRS;
         let vTbl = if self.imp != nullInst && (*self.imp)._vTbl != nullVTbl { (*self.imp)._vTbl } else { (*c)._vTbl };
         let cMethod: usize = std::mem::transmute(*vTbl.add(dggal_sys::DGGRS_getZoneCRSExtent_vTblID as usize));
         if cMethod != std::mem::transmute(0usize) {
            let method : unsafe extern "C" fn(dggrs: dggal_sys::DGGRS, zone: dggal_sys::DGGRSZone, crs: dggal_sys::CRS, extent: *mut dggal_sys::CRSExtent) = std::mem::transmute(cMethod);
            method(self.imp, zone, *crs, std::ptr::from_mut(&mut extent));
         }
      }
      extent
   }

   pub fn compactZones(&self, zones: &mut Vec<dggal_sys::DGGRSZone>)
   {
      unsafe
      {
         let c = dggal_sys::class_DGGRS;
         let vTbl = if self.imp != nullInst && (*self.imp)._vTbl != nullVTbl { (*self.imp)._vTbl } else { (*c)._vTbl };
         let cMethod: usize = std::mem::transmute(*vTbl.add(dggal_sys::DGGRS_compactZones_vTblID as usize));
         if cMethod != std::mem::transmute(0usize) {
            let mut n: usize = zones.len();
            if n != 0 {
               let method : unsafe extern "C" fn(dggrs: dggal_sys::DGGRS, zones: dggal_sys::template_Array_DGGRSZone) = std::mem::transmute(cMethod);
               let ac = ecrt_sys::__eCNameSpace__eC__types__eSystem_FindClass(self.mDGGAL, "Array<DGGRSZone>\0".as_ptr() as *const i8);
               let az: dggal_sys::template_Array_DGGRSZone = ecrt_sys::__eCNameSpace__eC__types__eInstance_New(ac) as dggal_sys::template_Array_DGGRSZone;
               let am: *const ecrt_sys::class_members_Array;
               let mut a: *mut dggal_sys::DGGRSZone;

               ecrt_sys::Array_set_size.unwrap()(az, n as u32);
               am = ((az as *const i8).wrapping_add((*ecrt_sys::class_Array).offset as usize)) as *const ecrt_sys::class_members_Array;
               a = (*am).array as *mut dggal_sys::DGGRSZone;
               ecrt_sys::memcpy(a as *mut c_void, zones.as_ptr() as *const c_void, (mem::size_of::<dggal_sys::DGGRSZone>() * n) as std::os::raw::c_ulong);
               method(self.imp, az);

               n = (*am).count as usize;
               a = (*am).array;

               zones.reserve(n);
               zones.set_len(n);
               ecrt_sys::memcpy(zones.as_ptr() as *mut c_void, a as *const c_void, (mem::size_of::<dggal_sys::DGGRSZone>() * n) as std::os::raw::c_ulong);

               ecrt_sys::__eCNameSpace__eC__types__eInstance_DecRef(az);
            }
         }
      }
   }

   pub fn zoneHasSubZone(&self, hayStack: dggal_sys::DGGRSZone, needle: dggal_sys::DGGRSZone) -> bool
   {
      let mut result: bool = false;
      unsafe
      {
         let c = dggal_sys::class_DGGRS;
         let vTbl = if self.imp != nullInst && (*self.imp)._vTbl != nullVTbl { (*self.imp)._vTbl } else { (*c)._vTbl };
         let cMethod: usize = std::mem::transmute(*vTbl.add(dggal_sys::DGGRS_zoneHasSubZone_vTblID as usize));
         if cMethod != std::mem::transmute(0usize) {
            let method : unsafe extern "C" fn(dggrs: dggal_sys::DGGRS, hayStack: dggal_sys::DGGRSZone, needle: dggal_sys::DGGRSZone) -> u32 = std::mem::transmute(cMethod);
            result = method(self.imp, hayStack, needle) != 0;
         }
      }
      result
   }

   // These methods are NOT virtual:
   pub fn get64KDepth(&self) -> i32
   {
      let mut depth = -1;
      unsafe
      {
         if self.imp != nullInst {
            depth = dggal_sys::DGGRS_get64KDepth.unwrap()(self.imp);
         }
      }
      depth
   }

   pub fn getMaxDepth(&self) -> i32
   {
      let mut depth = -1;
      unsafe
      {
         if self.imp != nullInst {
            depth = dggal_sys::DGGRS_getMaxDepth.unwrap()(self.imp);
         }
      }
      depth
   }

   pub fn areZonesNeighbors(&self, a: dggal_sys::DGGRSZone, b: dggal_sys::DGGRSZone) -> bool
   {
      let mut result: bool = false;
      unsafe
      {
         if self.imp != nullInst {
            result = dggal_sys::DGGRS_areZonesNeighbors.unwrap()(self.imp, a, b) != 0;
         }
      }
      result
   }

   pub fn areZonesSiblings(&self, a: dggal_sys::DGGRSZone, b: dggal_sys::DGGRSZone) -> bool
   {
      let mut result: bool = false;
      unsafe
      {
         if self.imp != nullInst {
            result = dggal_sys::DGGRS_areZonesSiblings.unwrap()(self.imp, a, b) != 0;
         }
      }
      result
   }

   pub fn doZonesOverlap(&self, a: dggal_sys::DGGRSZone, b: dggal_sys::DGGRSZone) -> bool
   {
      let mut result: bool = false;
      unsafe
      {
         if self.imp != nullInst {
            result = dggal_sys::DGGRS_doZonesOverlap.unwrap()(self.imp, a, b) != 0;
         }
      }
      result
   }

   pub fn doesZoneContain(&self, hayStack: dggal_sys::DGGRSZone, needle: dggal_sys::DGGRSZone) -> bool
   {
      let mut result: bool = false;
      unsafe
      {
         if self.imp != nullInst {
            result = dggal_sys::DGGRS_doesZoneContain.unwrap()(self.imp, hayStack, needle) != 0;
         }
      }
      result
   }

   pub fn isZoneAncestorOf(&self, ancestor: dggal_sys::DGGRSZone, descendant: dggal_sys::DGGRSZone, maxDepth: i32) -> bool
   {
      let mut result: bool = false;
      unsafe
      {
         if self.imp != nullInst {
            result = dggal_sys::DGGRS_isZoneAncestorOf.unwrap()(self.imp, ancestor, descendant, maxDepth) != 0;
         }
      }
      result
   }

   pub fn isZoneContainedIn(&self, needle: dggal_sys::DGGRSZone, hayStack: dggal_sys::DGGRSZone) -> bool
   {
      let mut result: bool = false;
      unsafe
      {
         if self.imp != nullInst {
            result = dggal_sys::DGGRS_isZoneContainedIn.unwrap()(self.imp, needle, hayStack) != 0;
         }
      }
      result
   }

   pub fn isZoneDescendantOf(&self, descendant: dggal_sys::DGGRSZone, ancestor: dggal_sys::DGGRSZone, maxDepth: i32) -> bool
   {
      let mut result: bool = false;
      unsafe
      {
         if self.imp != nullInst {
            result = dggal_sys::DGGRS_isZoneDescendantOf.unwrap()(self.imp, descendant, ancestor, maxDepth) != 0;
         }
      }
      result
   }

   pub fn isZoneImmediateChildOf(&self, child: dggal_sys::DGGRSZone, parent: dggal_sys::DGGRSZone) -> bool
   {
      let mut result: bool = false;
      unsafe
      {
         if self.imp != nullInst {
            result = dggal_sys::DGGRS_isZoneImmediateChildOf.unwrap()(self.imp, child, parent) != 0;
         }
      }
      result
   }

   pub fn isZoneImmediateParentOf(&self, parent: dggal_sys::DGGRSZone, child: dggal_sys::DGGRSZone) -> bool
   {
      let mut result: bool = false;
      unsafe
      {
         if self.imp != nullInst {
            result = dggal_sys::DGGRS_isZoneImmediateParentOf.unwrap()(self.imp, parent, child) != 0;
         }
      }
      result
   }

   pub fn getLevelFromMetersPerSubZone(&self, physicalMetersPerSubZone: f64, relativeDepth: i32) -> i32
   {
      let mut result: i32 = 0;
      unsafe
      {
         if self.imp != nullInst {
            result = dggal_sys::DGGRS_getLevelFromMetersPerSubZone.unwrap()(self.imp, physicalMetersPerSubZone, relativeDepth);
         }
      }
      result
   }

   pub fn getLevelFromPixelsAndExtent(&self, extent: &dggal_sys::GeoExtent, pixels: &ecrt_sys::Point, relativeDepth: i32) -> i32
   {
      let mut result: i32 = 0;
      unsafe
      {
         if self.imp != nullInst {
            result = dggal_sys::DGGRS_getLevelFromPixelsAndExtent.unwrap()(self.imp, extent, pixels, relativeDepth);
         }
      }
      result
   }

   pub fn getLevelFromRefZoneArea(&self, metersSquared: f64) -> i32
   {
      let mut result: i32 = 0;
      unsafe
      {
         if self.imp != nullInst {
            result = dggal_sys::DGGRS_getLevelFromRefZoneArea.unwrap()(self.imp, metersSquared);
         }
      }
      result
   }

   pub fn getLevelFromScaleDenominator(&self, scaleDenominator: f64, relativeDepth: i32, mmPerPixel: f64) -> i32
   {
      let mut result: i32 = 0;
      unsafe
      {
         if self.imp != nullInst {
            result = dggal_sys::DGGRS_getLevelFromScaleDenominator.unwrap()(self.imp, scaleDenominator, relativeDepth, mmPerPixel);
         }
      }
      result
   }

   pub fn getMetersPerSubZoneFromLevel(&self, parentLevel: i32, relativeDepth: i32) -> f64
   {
      let mut result: f64 = 0.0;
      unsafe
      {
         if self.imp != nullInst {
            result = dggal_sys::DGGRS_getMetersPerSubZoneFromLevel.unwrap()(self.imp, parentLevel, relativeDepth);
         }
      }
      result
   }

   pub fn getRefZoneArea(&self, level: i32) -> f64
   {
      let mut result: f64 = 0.0;
      unsafe
      {
         if self.imp != nullInst {
            result = dggal_sys::DGGRS_getRefZoneArea.unwrap()(self.imp, level);
         }
      }
      result
   }

   pub fn getScaleDenominatorFromLevel(&self, parentLevel: i32, relativeDepth: i32, mmPerPixel: f64) -> f64
   {
      let mut result: f64 = 0.0;
      unsafe
      {
         if self.imp != nullInst {
            result = dggal_sys::DGGRS_getScaleDenominatorFromLevel.unwrap()(self.imp, parentLevel, relativeDepth, mmPerPixel);
         }
      }
      result
   }
}
impl Drop for DGGRS {
   fn drop(&mut self)
   {
      unsafe {
         ecrt_sys::__eCNameSpace__eC__types__eInstance_DecRef(self.imp as ecrt_sys::Instance);
      }
   }
}

unsafe impl Sync for DGGRS {

}

#[repr(transparent)]
pub struct DGGSJSONDepth(pub Instance);
delegate_ttau64_and_default!(DGGSJSONDepth);

impl DGGSJSONDepth
{
   pub fn data(&self) -> Array<FieldValue>
   {
      let mut data = Array::<FieldValue>::new(nullInst);
      if self.0.0 != nullInst {
         unsafe {
            let members: *const dggal_sys::class_members_DGGSJSONDepth = ((self.0.0 as *const i8).wrapping_add((*dggal_sys::class_DGGSJSONDepth).offset as usize)) as *const dggal_sys::class_members_DGGSJSONDepth;
            data.array = (*members).data;
         }
      }
      data
   }
}

#[repr(transparent)]
pub struct DGGSJSON(pub Instance);
delegate_ttau64_and_default!(DGGSJSON);

impl DGGSJSON {
   pub fn dggrs(&self) -> ConstString
   {
      let mut dggrs: ConstString = Default::default();
      if self.0.0 != nullInst {
         unsafe {
            let members: *const dggal_sys::class_members_DGGSJSON = ((self.0.0 as *const i8).wrapping_add((*dggal_sys::class_DGGSJSON).offset as usize)) as *const dggal_sys::class_members_DGGSJSON;
            dggrs = ConstString((*members).dggrs);
         }
      }
      dggrs
   }

   pub fn zoneId(&self) -> ConstString
   {
      let mut zoneId: ConstString = Default::default();
      if self.0.0 != nullInst {
         unsafe {
            let members: *const dggal_sys::class_members_DGGSJSON = ((self.0.0 as *const i8).wrapping_add((*dggal_sys::class_DGGSJSON).offset as usize)) as *const dggal_sys::class_members_DGGSJSON;
            zoneId = ConstString((*members).zoneId);
         }
      }
      zoneId
   }

   pub fn depths(&self) -> Array<i32>
   {
      let mut depths = Array::<i32>::new(nullInst);
      if self.0.0 != nullInst {
         unsafe {
            let members: *const dggal_sys::class_members_DGGSJSON = ((self.0.0 as *const i8).wrapping_add((*dggal_sys::class_DGGSJSON).offset as usize)) as *const dggal_sys::class_members_DGGSJSON;
            depths.array = (*members).depths;
         }
      }
      depths
   }

   pub fn values(&self) -> Map<ecrt::String, ArrayOfDGGSJSONDepth>
   {
      let mut values = Map::<ecrt::String, ArrayOfDGGSJSONDepth>::new(nullInst);
      if self.0.0 != nullInst {
         unsafe {
            let members: *const dggal_sys::class_members_DGGSJSON = ((self.0.0 as *const i8).wrapping_add((*dggal_sys::class_DGGSJSON).offset as usize)) as *const dggal_sys::class_members_DGGSJSON;
            values.map = (*members).values;
         }
      }
      values
   }
}

pub type ArrayOfDGGSJSONDepth = Instance;

pub fn readDGGSJSON(f: &File) -> Result<DGGSJSON, &str>
{
   let mut result: Result<DGGSJSON, &str> = Err("Failure to load DGGS-JSON");
   unsafe
   {
      if f.file != nullInst {
         let r: dggal_sys::DGGSJSON = dggal_sys::fnptr_readDGGSJSON.unwrap()(f.file);
         if r != nullInst {
            result = Ok(DGGSJSON(Instance(r)))
         }
      }
   }
   result
}



================================================
FILE: bindings/rust/Makefile
================================================
.PHONY: all clean realclean distclean dggal-sys dggal

DGGAL_ABSPATH := $(dir $(realpath $(firstword $(MAKEFILE_LIST))))../../

ifndef EC_SDK_SRC
EC_SDK_SRC := $(DGGAL_ABSPATH)../eC
endif

export _CF_DIR = $(EC_SDK_SRC)/
include $(_CF_DIR)crossplatform.mk

# TARGETS

all: dggal-sys dggal

dggal-sys:
	+$(_MAKE) -f Makefile.dggal-sys

dggal: dggal-sys
	+$(_MAKE) -f Makefile.dggal

clean:
	+$(_MAKE) -f Makefile.dggal-sys clean
	+$(_MAKE) -f Makefile.dggal clean
	
realclean:
	+$(_MAKE) -f Makefile.dggal-sys realclean
	+$(_MAKE) -f Makefile.dggal realclean

distclean:
	+$(_MAKE) -f Makefile.dggal-sys distclean
	+$(_MAKE) -f Makefile.dggal distclean



================================================
FILE: bindings/rust/Makefile.dggal
================================================
.PHONY: all objdir cleantarget clean realclean distclean

ifneq ($(V),1)
.SILENT:
endif

MODULE := dggal

# CORE VARIABLES

VERSION := 0.0.6
CONFIG := release
ifndef COMPILER
COMPILER := default
endif

TARGET_TYPE = sharedlib

# INCLUDES

DGGAL_ABSPATH := $(dir $(realpath $(firstword $(MAKEFILE_LIST))))../../

ifndef EC_SDK_SRC
EC_SDK_SRC := $(DGGAL_ABSPATH)../eC
endif

export _CF_DIR = $(EC_SDK_SRC)/
include $(_CF_DIR)crossplatform.mk
include $(_CF_DIR)default.cf

# POST-INCLUDES VARIABLES

OBJ = obj/$(PLATFORM)$(COMPILER_SUFFIX)

TARGET = $(OBJ)/lib$(MODULE).rlib

SOURCES = $(MODULE).rs

LIBS +=

OFLAGS =

OFLAGS += \
	-L obj/$(PLATFORM)$(COMPILER_SUFFIX)$(DEBUG_SUFFIX) \
	-L $(EC_SDK_SRC)/bindings/rust \
	-L $(EC_SDK_SRC)/obj/$(PLATFORM)$(COMPILER_SUFFIX)$(DEBUG_SUFFIX)/lib

PRJ_CFLAGS += $(if $(DEBUG), -g, -O2 -ffast-math) -w

RUSTFLAGS =

ifdef C_BINDINGS_SYMBOLS_PREFIX_ENABLE
PRJ_CFLAGS += -DECPRFX=eC_
endif

SOURCES = $(_DEP_SOURCES) $(MODULE).rs

all: objdir $(TARGET);

# OBJECT RULES


# TARGETS

objdir:
	$(call mkdir,$(OBJ))

$(SYMBOLS): | objdir
$(OBJECTS): | objdir

$(TARGET): $(SOURCES) $(OBJECTS) | objdir
	rustc --crate-type lib $(RUSTFLAGS) $(MODULE).rs $(OFLAGS) $(LIBS) -o $(TARGET)
	$(call mkdir,$(DGGAL_ABSPATH)obj/$(PLATFORM)/lib)
	$(call cp,$(TARGET),$(DGGAL_ABSPATH)obj/$(PLATFORM)/lib)

cleantarget:
	$(call rm,$(TARGET))

clean: cleantarget
	$(call rm,_OBJECTS)

realclean: cleantarget
	$(call rmr,$(OBJ))

distclean:
	$(_MAKE) -f $(_CF_DIR)Cleanfile distclean distclean_all_subdirs



================================================
FILE: bindings/rust/Makefile.dggal-sys
================================================
.PHONY: all objdir cleantarget clean realclean distclean

ifneq ($(V),1)
.SILENT:
endif

MODULE := dggal_sys
BINDING_NAME := dggal

# CORE VARIABLES

VERSION := 0.0.6
CONFIG := release
ifndef COMPILER
COMPILER := default
endif

# C_BINDINGS_SYMBOLS_PREFIX_ENABLE := y

TARGET_TYPE = sharedlib

# INCLUDES

DGGAL_ABSPATH := $(dir $(realpath $(firstword $(MAKEFILE_LIST))))../../

ifndef EC_SDK_SRC
EC_SDK_SRC := $(DGGAL_ABSPATH)../eC
endif

export _CF_DIR = $(EC_SDK_SRC)/
include $(_CF_DIR)crossplatform.mk
include $(_CF_DIR)default.cf

# POST-INCLUDES VARIABLES

OBJ = obj/$(PLATFORM)$(COMPILER_SUFFIX)

TARGET = $(OBJ)/lib$(MODULE).rlib

SOURCES = $(MODULE).rs

LIBS += \
   $(call _L,dggal_cStatic) \
	$(call _L,dggalStatic)

#	-Clink-arg=$(OBJ)/$(BINDING_NAME)$(O)

OFLAGS =

OFLAGS += \
	-L obj/$(PLATFORM)$(COMPILER_SUFFIX)$(DEBUG_SUFFIX) \
	-L $(DGGAL_ABSPATH)obj/$(PLATFORM)$(COMPILER_SUFFIX)$(DEBUG_SUFFIX)/lib \
	-L $(EC_SDK_SRC)/obj/$(PLATFORM)$(COMPILER_SUFFIX)$(DEBUG_SUFFIX)/lib

RUSTFLAGS = --edition 2021 -Anon_snake_case -Anon_upper_case_globals -Anon_camel_case_types -Aimproper_ctypes

_OBJECTS = $(_DEP_OBJECTS) $(OBJ)/$(BINDING_NAME)$(O)

OBJECTS = $(_OBJECTS)

SOURCES = $(_DEP_SOURCES) $(BINDING_NAME)_cffi.rs

CBINDING_STATIC_LIB = $(DGGAL_ABSPATH)obj/$(PLATFORM)$(COMPILER_SUFFIX)$(DEBUG_SUFFIX)/lib/libdggal_cStatic.a

all: objdir $(TARGET);

# TARGETS

objdir:
	$(call mkdir,$(OBJ))

$(SYMBOLS): | objdir
$(OBJECTS): | objdir

$(TARGET): $(SOURCES) $(OBJECTS) $(CBINDING_STATIC_LIB) | objdir
	rustc --crate-type lib --crate-name dggal_sys $(RUSTFLAGS) $(BINDING_NAME)_cffi.rs $(OFLAGS) $(LIBS) -o $(TARGET)
	$(call mkdir,$(DGGAL_ABSPATH)obj/$(PLATFORM)/lib)
	$(call cp,$(TARGET),$(DGGAL_ABSPATH)obj/$(PLATFORM)/lib)

cleantarget:
	$(call rm,$(TARGET))

clean: cleantarget
	$(call rm,_OBJECTS)

realclean: cleantarget
	$(call rmr,$(OBJ))

distclean:
	$(_MAKE) -f $(_CF_DIR)Cleanfile distclean distclean_all_subdirs



================================================
FILE: bindings_examples/c/info.c
================================================
#include <dggal.h>

// parameterized templates in C! (for options map)
typedef Map T(Map, String, constString);
typedef MapIterator T(MapIterator, String, constString);

// For looking up internationalized strings
#define MODULE_NAME "info"

static int zoneInfo(DGGRS dggrs, DGGRSZone zone, T(Map, String, constString) options)
{
   int level = DGGRS_getZoneLevel(dggrs, zone);
   int nEdges = DGGRS_countZoneEdges(dggrs, zone);
   GeoPoint centroid;
   GeoExtent extent;
   GeoPoint vertices[6];
   int nVertices = DGGRS_getZoneWGS84Vertices(dggrs, zone, vertices);
   char zoneID[256];
   double area = DGGRS_getZoneArea(dggrs, zone), areaKM2 = area / 1000000;
   int depth = DGGRS_get64KDepth(dggrs);
   DGGRSZone parents[3], neighbors[6], children[13];
   int nParents = DGGRS_getZoneParents(dggrs, zone, parents);
   int nbTypes[6];
   int nNeighbors = DGGRS_getZoneNeighbors(dggrs, zone, neighbors, nbTypes);
   int nChildren = DGGRS_getZoneChildren(dggrs, zone, children);
   DGGRSZone centroidParent = DGGRS_getZoneCentroidParent(dggrs, zone);
   DGGRSZone centroidChild = DGGRS_getZoneCentroidChild(dggrs, zone);
   bool isCentroidChild = DGGRS_isZoneCentroidChild(dggrs, zone);
   int i;
   const String crs = "EPSG:4326";
   int64 nSubZones;
   constString depthOption = null;
   if(options)
   {
      T(MapIterator, String, constString) it = { options };
      if(Iterator_index((Iterator *)&it, TAp((void *)"depth"), false))
         depthOption = pTA(const char, Iterator_getData((Iterator *)&it));
   }

   if(depthOption)
   {
      int maxDepth = DGGRS_getMaxDepth(dggrs);
      _onGetDataFromString(CO(int), &depth, depthOption);
      if(depth > maxDepth)
      {
         printLn(CO(String), $("Invalid depth (maximum: "), CO(int), maxDepth, ")", null);
         return 1;
      }
   }

   nSubZones = DGGRS_countSubZones(dggrs, zone, depth);

   DGGRS_getZoneWGS84Centroid(dggrs, zone, &centroid);
   DGGRS_getZoneWGS84Extent(dggrs, zone, &extent);
   DGGRS_getZoneTextID(dggrs, zone, zoneID);

   printLn(CO(String), $("Textual Zone ID: "), CO(String), zoneID, null);
   printx(CO(String), $("64-bit integer ID: "), CO(uint64), &zone, CO(String), " (", null);

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wformat" // FORMAT64HEX contains runtime checks for platform
   printf(FORMAT64HEX, zone);
#pragma GCC diagnostic pop
   printLn(CO(String), ")", null);
   printLn(CO(String), "", null);
   printLn(
      CO(String), $("Level "),
      CO(int), &level,
      CO(String), $(" zone ("),
      CO(int), &nEdges,
      CO(String), $(" edges"),
      CO(String), isCentroidChild ? $(", centroid child)") : ")", null);
   printLn(CO(double), &area, CO(String), " m² (", CO(double), &areaKM2, CO(String), " km²)", null);
   printLn(CO(int64), &nSubZones, CO(String), $(" sub-zones at depth "), CO(int), &depth, null);
   printLn(CO(String), $("WGS84 Centroid (lat, lon): "), CO(Degrees), &centroid.lat, CO(String), ", ", CO(Degrees), &centroid.lon, null);
   printLn(
      CO(String), $("WGS84 Extent (lat, lon): { "),
      CO(Degrees), &extent.ll.lat, CO(String), ", ",
      CO(Degrees), &extent.ll.lon, CO(String), " }, { ",
      CO(Degrees), &extent.ur.lat, CO(String), ", ",
      CO(Degrees), &extent.ur.lon, CO(String), " }", null);

   printLn(CO(String), "", null);
   if(nParents)
   {
      printLn(CO(String), $("Parent"), CO(String), nParents > 1 ? "s" : "", CO(String), " (", CO(int), &nParents, CO(String), "):", null);
      for(i = 0; i < nParents; i++)
      {
         char pID[256];
         DGGRS_getZoneTextID(dggrs, parents[i], pID);
         printx(CO(String), "   ", CO(String), pID, null);
         if(centroidParent == parents[i])
            printx(CO(String), $(" (centroid child)"), null);
         printLn(CO(String), "", null);
      }
   }
   else
      printLn(CO(String), $("No parent"), null);

   printLn(CO(String), "", null);
   printLn(CO(String), $("Children ("), CO(int), &nChildren, CO(String), "):", null);
   for(i = 0; i < nChildren; i++)
   {
      char cID[256];
      DGGRS_getZoneTextID(dggrs, children[i], cID);
      printx(CO(String), "   ", CO(String), cID, null);
      if(centroidChild == children[i])
         printx(CO(String), $(" (centroid)"), null);
      printLn(CO(String), "", null);
   }

   printLn(CO(String), "", null);
   printLn(CO(String), $("Neighbors ("), CO(int), &nNeighbors, CO(String), "):", null);
   for(i = 0; i < nNeighbors; i++)
   {
      char nID[256];
      DGGRS_getZoneTextID(dggrs, neighbors[i], nID);
      printLn(CO(String), $("   (direction "), CO(int), &nbTypes[i], CO(String), "): ", CO(String), nID, null);
   }

   printLn(CO(String), "", null);
   printLn(CO(String), "[", CO(String), crs, CO(String), $("] Vertices ("), CO(int), &nVertices, CO(String), "):", null);

   for(i = 0; i < nVertices; i++)
      printLn(CO(String), "   ", CO(Degrees), &vertices[i].lat, CO(String), ", ", CO(Degrees), &vertices[i].lon, null);
   return 0;
}

static int dggrsInfo(DGGRS dggrs, T(Map, String, constString) options)
{
   int depth64k = DGGRS_get64KDepth(dggrs);
   int ratio = DGGRS_getRefinementRatio(dggrs);
   int maxLevel = DGGRS_getMaxDGGRSZoneLevel(dggrs);

   printLn(CO(String), $("Refinement Ratio: "), CO(int), &ratio, null);
   printLn(CO(String), $("Maximum level for 64-bit global identifiers (DGGAL DGGRSZone): "), CO(int), &maxLevel, null);
   printLn(CO(String), $("Default ~64K sub-zones relative depth: "), CO(int), &depth64k, null);
   return 0;
}

int displayInfo(DGGRS dggrs, DGGRSZone zone, T(Map, String, constString) options)
{
   if(zone != nullZone)
      return zoneInfo(dggrs, zone, options);
   else
      return dggrsInfo(dggrs, options);
}

Class * class_Map_String_constString;

int main(int argc, char * argv[])
{
   Application app = ecrt_init(null, true, false, argc, argv);
   Module mDGGAL = dggal_init(app);
   int exitCode = 0;
   bool showSyntax = false;
   const char * dggrsName = null;
   int a = 1;
   constString zoneID = null;
   T(Map, String, constString) options;

   class_Map_String_constString = eC_findClass(app, "Map<String, const String>");
   options = newi(Map, String, constString);

        if(!strcmpi(argv[0], "i3h") || !strcmpi(argv[0], "isea3h")) dggrsName = "ISEA3H";
   else if(!strcmpi(argv[0], "i9r") || !strcmpi(argv[0], "isea9r")) dggrsName = "ISEA9R";
   else if(!strcmpi(argv[0], "i7h") || !strcmpi(argv[0], "isea7h")) dggrsName = "ISEA7H";
   else if(!strcmpi(argv[0], "iz7") || !strcmpi(argv[0], "isea7h_z7")) dggrsName = "ISEA7H_Z7";
   else if(!strcmpi(argv[0], "i4r") || !strcmpi(argv[0], "isea4r")) dggrsName = "ISEA4R";

   else if(!strcmpi(argv[0], "r3h") || !strcmpi(argv[0], "rtea3h")) dggrsName = "RTEA3H";
   else if(!strcmpi(argv[0], "r9r") || !strcmpi(argv[0], "rtea9r")) dggrsName = "RTEA9R";
   else if(!strcmpi(argv[0], "r7h") || !strcmpi(argv[0], "rtea7h")) dggrsName = "RTEA7H";
   else if(!strcmpi(argv[0], "rz7") || !strcmpi(argv[0], "rtea7h_z7")) dggrsName = "RTEA7H_Z7";
   else if(!strcmpi(argv[0], "r4r") || !strcmpi(argv[0], "rtea4r")) dggrsName = "RTEA4R";

   else if(!strcmpi(argv[0], "v3h") || !strcmpi(argv[0], "ivea3h")) dggrsName = "IVEA3H";
   else if(!strcmpi(argv[0], "v9r") || !strcmpi(argv[0], "ivea9r")) dggrsName = "IVEA9R";
   else if(!strcmpi(argv[0], "v7h") || !strcmpi(argv[0], "ivea7h")) dggrsName = "IVEA7H";
   else if(!strcmpi(argv[0], "vz7") || !strcmpi(argv[0], "ivea7h_z7")) dggrsName = "IVEA7H_Z7";
   else if(!strcmpi(argv[0], "v4r") || !strcmpi(argv[0], "ivea4r")) dggrsName = "IVEA4R";

   else if(!strcmpi(argv[0], "ggg") || !strcmpi(argv[0], "gnosis")) dggrsName = "GNOSISGlobalGrid";

   else if(!strcmpi(argv[0], "rhp") || !strcmpi(argv[0], "rHEALPix")) dggrsName = "rHEALPix";
   else if(!strcmpi(argv[0], "hpx") || !strcmpi(argv[0], "HEALPix")) dggrsName = "HEALPix";

   if(!dggrsName && argc > 1)
   {
           if(!strcmpi(argv[1], "isea3h")) dggrsName = "ISEA3H";
      else if(!strcmpi(argv[1], "isea9r")) dggrsName = "ISEA9R";
      else if(!strcmpi(argv[1], "isea7h")) dggrsName = "ISEA7H";
      else if(!strcmpi(argv[1], "isea7h_z7")) dggrsName = "ISEA7H_Z7";
      else if(!strcmpi(argv[1], "isea4r")) dggrsName = "ISEA4R";

      else if(!strcmpi(argv[1], "rtea3h")) dggrsName = "RTEA3H";
      else if(!strcmpi(argv[1], "rtea9r")) dggrsName = "RTEA9R";
      else if(!strcmpi(argv[1], "rtea7h")) dggrsName = "RTEA7H";
      else if(!strcmpi(argv[1], "rtea7h_z7")) dggrsName = "RTEA7H_Z7";
      else if(!strcmpi(argv[1], "rtea4r")) dggrsName = "RTEA4R";

      else if(!strcmpi(argv[1], "ivea3h")) dggrsName = "IVEA3H";
      else if(!strcmpi(argv[1], "ivea9r")) dggrsName = "IVEA9R";
      else if(!strcmpi(argv[1], "ivea7h")) dggrsName = "IVEA7H";
      else if(!strcmpi(argv[1], "ivea7h_z7")) dggrsName = "IVEA7H_Z7";
      else if(!strcmpi(argv[1], "ivea4r")) dggrsName = "IVEA4R";

      else if(!strcmpi(argv[1], "gnosis")) dggrsName = "GNOSISGlobalGrid";

      else if(!strcmpi(argv[1], "rHEALPix")) dggrsName = "rHEALPix";
      else if(!strcmpi(argv[1], "HEALPix")) dggrsName = "HEALPix";
      a++;
   }

   if(argc > a)
      zoneID = argv[a++];

   while(a < argc)
   {
      const char * key = argv[a++];
      if(key[0] == '-' && a < argc)
      {
         const char * value = argv[a++];
         T(MapIterator, String, constString) it = { options };
         Iterator_index((Iterator *)&it, TAp((void *)(key+1)), true);
         Iterator_setData((Iterator *)&it, TAp((void *)value));
      }
      else
         exitCode = 1, showSyntax = true;
   }

   if(dggrsName && !exitCode)
   {
      DGGRS dggrs = Instance_new(eC_findClass(mDGGAL, dggrsName));
      DGGRSZone zone = nullZone;

      printLn(CO(String), $("DGGRS: https://maps.gnosis.earth/ogcapi/dggrs/"), CO(String), dggrsName, null);

      if(zoneID)
         zone = DGGRS_getZoneFromTextID(dggrs, zoneID);

      displayInfo(dggrs, zone, options);

      deletei(dggrs);
   }
   else
      showSyntax = true, exitCode = 1;

   deletei(options);

   if(showSyntax)
      printLn(CO(String),
         $("Syntax:\n"
         "   info <dggrs> [zone] [options]\n"
         "where dggrs is one of gnosis, isea(4r/9r/3h/7h/7h_z7), ivea(4r/9r/3h/7h/7h_z7), rtea(4r/9r/3h/7h/7h_z7), healpix, rhealpix\n"), null);
   deletei(app);
   return exitCode;
}



================================================
FILE: bindings_examples/c/info.epj
================================================
{
   "Version" : 0.2,
   "ModuleName" : "info",
   "Options" : {
      "Warnings" : "All",
      "IncludeDirs" : [
         "../../bindings/c"
      ],
      "TargetType" : "Executable",
      "TargetFileName" : "info",
      "Libraries" : [
         "ecrt"
      ],
      "LibraryDirs" : [
         "../../obj/release.$(PLATFORM)$(COMPILER_SUFFIX)"
      ],
      "Console" : true
   },
   "Configurations" : [
      {
         "Name" : "Debug",
         "Options" : {
            "Debug" : true,
            "Optimization" : "None",
            "PreprocessorDefinitions" : [
               "_DEBUG"
            ],
            "FastMath" : false
         }
      },
      {
         "Name" : "Release",
         "Options" : {
            "Debug" : false,
            "Optimization" : "Speed",
            "FastMath" : true
         }
      },
      {
         "Name" : "Static",
         "Options" : {
            "Optimization" : "Speed",
            "PreprocessorDefinitions" : [
               "EC_STATIC"
            ],
            "Libraries" : [
               "ecrtStatic"
            ],
            "LibraryDirs" : [
               "../../obj/static.$(PLATFORM)$(COMPILER_SUFFIX)"
            ],
            "FastMath" : true
         },
         "Platforms" : [
            {
               "Name" : "linux",
               "Options" : {
                  "Libraries" : [
                     "dggalStatic",
                     "X11",
                     "Xext",
                     "Xrender",
                     "m",
                     "dl",
                     "pthread",
                     "curses",
                     "z"
                  ]
               }
            },
            {
               "Name" : "win32",
               "Options" : {
                  "Libraries" : [
                     "kernel32",
                     "gdi32",
                     "user32",
                     "winmm",
                     "mpr",
                     "imm32",
                     "z",
                     "dggalStatic"
                  ]
               }
            }
         ]
      }
   ],
   "Files" : [
      {
         "Folder" : "bindings",
         "Files" : [
            "../../bindings/c/ecrt.c",
            "../../bindings/c/ecrt.h",
            "../../bindings/c/dggal.c",
            "../../bindings/c/dggal.h"
         ]
      },
      "info.c"
   ],
   "ResourcesPath" : "",
   "Resources" : [

   ]
}



================================================
FILE: bindings_examples/c/Makefile
================================================
.PHONY: all objdir cleantarget clean realclean distclean

# CORE VARIABLES

MODULE := info
VERSION :=
CONFIG := release
ifndef COMPILER
COMPILER := default
endif

TARGET_TYPE = executable

# FLAGS

ECFLAGS =
ifndef DEBIAN_PACKAGE
CFLAGS =
LDFLAGS =
endif
PRJ_CFLAGS =
CECFLAGS =
OFLAGS =
LIBS =

ifdef DEBUG
NOSTRIP := y
endif

CONSOLE = -mconsole

# INCLUDES

DGGAL_ABSPATH := $(dir $(realpath $(firstword $(MAKEFILE_LIST))))../../

ifndef EC_SDK_SRC
EC_SDK_SRC := $(DGGAL_ABSPATH)../eC
endif

_CF_DIR = $(EC_SDK_SRC)/
include $(_CF_DIR)crossplatform.mk
include $(_CF_DIR)default.cf
ifndef WINDOWS_HOST
export LD_LIBRARY_PATH := $(LD_LIBRARY_PATH):$(DGGAL_ABSPATH)obj/$(CONFIG).$(HOST_PLATFORM)$(COMPILER_SUFFIX)$(DEBUG_SUFFIX)/
else
export PATH := $(PATH);$(DGGAL_ABSPATH)obj/$(CONFIG).$(HOST_PLATFORM)$(COMPILER_SUFFIX)$(DEBUG_SUFFIX)/
endif

# POST-INCLUDES VARIABLES

OBJ = obj/$(CONFIG).$(PLATFORM)$(COMPILER_SUFFIX)$(DEBUG_SUFFIX)/

RES =

TARGET_NAME := info

TARGET = obj/$(CONFIG).$(PLATFORM)$(COMPILER_SUFFIX)$(DEBUG_SUFFIX)/$(TARGET_NAME)$(OUT)

_OBJECTS = \
	$(OBJ)ecrt$(O) \
	$(OBJ)dggal$(O) \
	$(OBJ)info$(O)

OBJECTS = $(_OBJECTS)

SOURCES = \
	$(EC_SDK_SRC)/bindings/c/ecrt.c \
	../../bindings/c/dggal.c \
	info.c

RESOURCES =

ifdef USE_RESOURCES_EAR
RESOURCES_EAR =
else
RESOURCES_EAR = $(RESOURCES)
endif

LIBS += $(SHAREDLIB) $(EXECUTABLE) $(LINKOPT)

LIBS += $(call _L,ecrt)

PRJ_CFLAGS += \
	 $(if $(DEBUG), -g, -O2 -ffast-math) $(FPIC) -Wall -DREPOSITORY_VERSION="\"$(REPOSITORY_VER)\"" \
			 -I../../bindings/c -I$(EC_SDK_SRC)/bindings/c

ECFLAGS += -module $(MODULE)
CECFLAGS += -cpp $(_CPP)

OFLAGS += \
	 -L$(call quote_path,../../obj/release.$(PLATFORM)$(COMPILER_SUFFIX)) \
	 -L$(call quote_path,../../obj/$(PLATFORM)$(COMPILER_SUFFIX)/lib) \
	 -L$(call quote_path,$(EC_SDK_SRC)/obj/$(PLATFORM)$(COMPILER_SUFFIX)/lib) \
	 -L$(call quote_path,../../obj/$(PLATFORM)$(COMPILER_SUFFIX)/bin) \
	 -L$(call quote_path,$(EC_SDK_SRC)/obj/$(PLATFORM)$(COMPILER_SUFFIX)/bin)

# TARGETS

all: objdir $(TARGET)

objdir:
	$(if $(wildcard $(OBJ)),,$(call mkdir,$(OBJ)))

$(SYMBOLS): | objdir
$(OBJECTS): | objdir
$(TARGET): $(SOURCES) $(RESOURCES_EAR) $(SYMBOLS) $(OBJECTS) | objdir
	@$(call rm,$(OBJ)objects.lst)
	@$(call touch,$(OBJ)objects.lst)
	$(call addtolistfile,$(_OBJECTS),$(OBJ)objects.lst)
	$(LD) $(OFLAGS) @$(OBJ)objects.lst $(LIBS) -o $(TARGET) $(INSTALLNAME) $(SONAME)
ifndef NOSTRIP
	$(STRIP) $(STRIPOPT) $(TARGET)
endif
ifdef LINUX_TARGET
ifdef LINUX_HOST
	$(if $(basename $(VER)),ln -sf $(LP)$(MODULE)$(SO)$(VER) $(OBJ)$(LP)$(MODULE)$(SO)$(basename $(VER)),)
	$(if $(VER),ln -sf $(LP)$(MODULE)$(SO)$(VER) $(OBJ)$(LP)$(MODULE)$(SO),)
endif
endif

# SYMBOL RULES

# C OBJECT RULES

# OBJECT RULES

$(OBJ)ecrt$(O): $(EC_SDK_SRC)/bindings/c/ecrt.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,$(EC_SDK_SRC)/bindings/c/ecrt.c) -o $(call quote_path,$@)

$(OBJ)dggal$(O): ../../bindings/c/dggal.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,../../bindings/c/dggal.c) -o $(call quote_path,$@)

$(OBJ)info$(O): info.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,info.c) -o $(call quote_path,$@)

cleantarget:
	$(call rm,$(OBJ)objects.lst)
	$(call rm,$(TARGET))
ifdef LINUX_TARGET
ifdef LINUX_HOST
	$(call rm,$(OBJ)$(LP)$(MODULE)$(SO)$(basename $(VER)))
	$(call rm,$(OBJ)$(LP)$(MODULE)$(SO))
endif
endif

clean: cleantarget
	$(call rm,$(_OBJECTS))

realclean: cleantarget
	$(call rmr,$(OBJ))

distclean: cleantarget
	$(call rmr,obj/)
	$(call rmr,.configs/)
	$(call rm,*.ews)
	$(call rm,*.Makefile)



================================================
FILE: bindings_examples/c/Makefile.static
================================================
.PHONY: all objdir cleantarget clean realclean distclean

# CORE VARIABLES

MODULE := info
VERSION :=
CONFIG := static
ifndef COMPILER
COMPILER := default
endif

TARGET_TYPE = executable

# FLAGS

ECFLAGS =
ifndef DEBIAN_PACKAGE
CFLAGS =
LDFLAGS =
endif
PRJ_CFLAGS =
CECFLAGS =
OFLAGS =
LIBS =

ifdef DEBUG
NOSTRIP := y
endif

CONSOLE = -mconsole

# INCLUDES

DGGAL_ABSPATH := $(dir $(realpath $(firstword $(MAKEFILE_LIST))))../../

ifndef EC_SDK_SRC
EC_SDK_SRC := $(DGGAL_ABSPATH)../eC
endif

_CF_DIR = $(EC_SDK_SRC)/
include $(_CF_DIR)crossplatform.mk
include $(_CF_DIR)default.cf
ifndef WINDOWS_HOST
export LD_LIBRARY_PATH := $(LD_LIBRARY_PATH):$(DGGAL_ABSPATH)obj/$(CONFIG).$(HOST_PLATFORM)$(COMPILER_SUFFIX)$(DEBUG_SUFFIX)/
else
export PATH := $(PATH);$(DGGAL_ABSPATH)obj/$(CONFIG).$(HOST_PLATFORM)$(COMPILER_SUFFIX)$(DEBUG_SUFFIX)/
endif

# POST-INCLUDES VARIABLES

OBJ = obj/$(CONFIG).$(PLATFORM)$(COMPILER_SUFFIX)$(DEBUG_SUFFIX)/

RES =

TARGET_NAME := info

TARGET = obj/$(CONFIG).$(PLATFORM)$(COMPILER_SUFFIX)$(DEBUG_SUFFIX)/$(TARGET_NAME)$(OUT)

_OBJECTS = \
	$(OBJ)ecrt$(O) \
	$(OBJ)dggal$(O) \
	$(OBJ)info$(O)

OBJECTS = $(_OBJECTS)

SOURCES = \
	$(EC_SDK_SRC)/bindings/c/ecrt.c \
	../../bindings/c/dggal.c \
	info.c

RESOURCES =

ifdef USE_RESOURCES_EAR
RESOURCES_EAR =
else
RESOURCES_EAR = $(RESOURCES)
endif

LIBS += $(SHAREDLIB) $(EXECUTABLE) $(LINKOPT)

ifndef STATIC_LIBRARY_TARGET
LIBS += \
	$(call _L,ecrtStatic)
endif

PRJ_CFLAGS += \
	 $(if $(DEBUG), -g, -O2 -ffast-math) $(FPIC) -Wall -DREPOSITORY_VERSION="\"$(REPOSITORY_VER)\"" \
			 -DEC_STATIC \
			 -I../../bindings/c -I$(EC_SDK_SRC)/bindings/c

ECFLAGS += -module $(MODULE)
# PLATFORM-SPECIFIC OPTIONS

ifdef WINDOWS_TARGET

ifndef STATIC_LIBRARY_TARGET
LIBS += \
	$(call _L,kernel32) \
	$(call _L,user32) \
	$(call _L,winmm) \
	$(call _L,mpr) \
	$(call _L,z) \
	$(call _L,dggalStatic)
endif

else
ifdef LINUX_TARGET

ifndef STATIC_LIBRARY_TARGET
LIBS += \
	$(call _L,dggalStatic) \
	$(call _L,m) \
	$(call _L,dl) \
	$(call _L,pthread) \
	$(call _L,z)
endif

endif
endif

CECFLAGS += -cpp $(_CPP)

ifndef STATIC_LIBRARY_TARGET
OFLAGS += \
	 -L$(call quote_path,../../obj/static.$(PLATFORM)$(COMPILER_SUFFIX)) \
	 -L$(call quote_path,$(EC_SDK_SRC)/obj/$(PLATFORM)$(COMPILER_SUFFIX)/lib)
endif

# TARGETS

all: objdir $(TARGET)

objdir:
	$(if $(wildcard $(OBJ)),,$(call mkdir,$(OBJ)))

$(SYMBOLS): | objdir
$(OBJECTS): | objdir
$(TARGET): $(SOURCES) $(RESOURCES_EAR) $(SYMBOLS) $(OBJECTS) | objdir
	@$(call rm,$(OBJ)objects.lst)
	@$(call touch,$(OBJ)objects.lst)
	$(call addtolistfile,$(_OBJECTS),$(OBJ)objects.lst)
ifndef STATIC_LIBRARY_TARGET
	$(LD) $(OFLAGS) @$(OBJ)objects.lst $(LIBS) -o $(TARGET) $(INSTALLNAME) $(SONAME)
ifndef NOSTRIP
	$(STRIP) $(STRIPOPT) $(TARGET)
endif
else
ifdef WINDOWS_HOST
	$(AR) rcs $(TARGET) @$(OBJ)objects.lst $(LIBS)
else
	$(AR) rcs $(TARGET) $(OBJECTS) $(LIBS)
endif
endif
ifdef SHARED_LIBRARY_TARGET
ifdef LINUX_TARGET
ifdef LINUX_HOST
	$(if $(basename $(VER)),ln -sf $(LP)$(MODULE)$(SO)$(VER) $(OBJ)$(LP)$(MODULE)$(SO)$(basename $(VER)),)
	$(if $(VER),ln -sf $(LP)$(MODULE)$(SO)$(VER) $(OBJ)$(LP)$(MODULE)$(SO),)
endif
endif
endif

# SYMBOL RULES

# C OBJECT RULES

# OBJECT RULES

$(OBJ)ecrt$(O): $(EC_SDK_SRC)/bindings/c/ecrt.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,$(EC_SDK_SRC)/bindings/c/ecrt.c) -o $(call quote_path,$@)

$(OBJ)dggal$(O): ../../bindings/c/dggal.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,../../bindings/c/dggal.c) -o $(call quote_path,$@)

$(OBJ)info$(O): info.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,info.c) -o $(call quote_path,$@)

cleantarget:
	$(call rm,$(OBJ)objects.lst)
	$(call rm,$(TARGET))
ifdef SHARED_LIBRARY_TARGET
ifdef LINUX_TARGET
ifdef LINUX_HOST
	$(call rm,$(OBJ)$(LP)$(MODULE)$(SO)$(basename $(VER)))
	$(call rm,$(OBJ)$(LP)$(MODULE)$(SO))
endif
endif
endif

clean: cleantarget
	$(call rm,$(_OBJECTS))

realclean: cleantarget
	$(call rmr,$(OBJ))

distclean: cleantarget
	$(call rmr,obj/)
	$(call rmr,.configs/)
	$(call rm,*.ews)
	$(call rm,*.Makefile)



================================================
FILE: bindings_examples/c_fn/info.c
================================================
#include "dggal_c.h"

#include <stdio.h>
#include <stdint.h>
#include <stdbool.h>
#include <inttypes.h>
#include <stdlib.h>
#include <string.h>

#define Pi 3.1415926535897932384626433832795028841971

#define strcmpi strcasecmp

static int zoneInfo(DGGRS dggrs, DGGRSZone zone, int depthOption)
{
   int level = DGGAL_DGGRS_getZoneLevel(dggrs, zone);
   int nEdges = DGGAL_DGGRS_countZoneEdges(dggrs, zone);
   GeoPoint centroid;
   GeoExtent extent;
   GeoPoint vertices[6];
   int nVertices = DGGAL_DGGRS_getZoneWGS84Vertices(dggrs, zone, vertices);
   char zoneID[256];
   double area = DGGAL_DGGRS_getZoneArea(dggrs, zone), areaKM2 = area / 1000000;
   int depth = DGGAL_DGGRS_get64KDepth(dggrs);
   DGGRSZone parents[3], neighbors[6], children[13];
   int nParents = DGGAL_DGGRS_getZoneParents(dggrs, zone, parents);
   int nbTypes[6];
   int nNeighbors = DGGAL_DGGRS_getZoneNeighbors(dggrs, zone, neighbors, nbTypes);
   int nChildren = DGGAL_DGGRS_getZoneChildren(dggrs, zone, children);
   DGGRSZone centroidParent = DGGAL_DGGRS_getZoneCentroidParent(dggrs, zone);
   DGGRSZone centroidChild = DGGAL_DGGRS_getZoneCentroidChild(dggrs, zone);
   int isCentroidChild = DGGAL_DGGRS_isZoneCentroidChild(dggrs, zone);
   int i;
   constString crs = "EPSG:4326";
   int64_t nSubZones;

   if(depthOption != -1)
   {
      int maxDepth = DGGAL_DGGRS_getMaxDepth(dggrs);
      depth = depthOption;
      if(depth > maxDepth)
      {
         printf("Invalid depth (maximum: %d)\n", maxDepth);
         return 1;
      }
   }

   nSubZones = DGGAL_DGGRS_countSubZones(dggrs, zone, depth);

   DGGAL_DGGRS_getZoneWGS84Centroid(dggrs, zone, &centroid);
   DGGAL_DGGRS_getZoneWGS84Extent(dggrs, zone, &extent);
   DGGAL_DGGRS_getZoneTextID(dggrs, zone, zoneID);

   printf("Textual Zone ID: %s\n", zoneID);
   printf("64-bit integer ID: " "%" PRId64 " (" "0x%" PRIx64 ")\n", zone, zone);
   printf("Level %d zone (%d edges%s)\n", level, nEdges, isCentroidChild ? ", centroid child" : "");
   printf("%f m² (%f km²)\n", area, areaKM2);
   printf("%" PRId64 " sub-zones at depth %d\n", nSubZones, depth);
   printf("WGS84 Centroid (lat, lon): %f, %f\n", centroid.lat * 180 / Pi, centroid.lon * 180 / Pi);
   printf("WGS84 Extent (lat, lon): { %f, %f }, { %f, %f }\n",
      extent.ll.lat * 180 / Pi, extent.ll.lon * 180 / Pi,
      extent.ur.lat * 180 / Pi, extent.ur.lon * 180 / Pi);

   printf("\n");
   if(nParents)
   {
      printf("Parent%s (%d):\n", nParents > 1 ? "s" : "", nParents);
      for(i = 0; i < nParents; i++)
      {
         char pID[256];
         DGGAL_DGGRS_getZoneTextID(dggrs, parents[i], pID);
         printf("   %s", pID);
         if(centroidParent == parents[i])
            printf(" (centroid child)");
         printf("\n");
      }
   }
   else
      printf("No parent\n");

   printf("\n");
   printf("Children (%d):\n", nChildren);
   for(i = 0; i < nChildren; i++)
   {
      char cID[256];
      DGGAL_DGGRS_getZoneTextID(dggrs, children[i], cID);
      printf("   %s", cID);
      if(centroidChild == children[i])
         printf(" (centroid)");
      printf("\n");
   }

   printf("\nNeighbors (%d)\n", nNeighbors);
   for(i = 0; i < nNeighbors; i++)
   {
      char nID[256];
      DGGAL_DGGRS_getZoneTextID(dggrs, neighbors[i], nID);
      printf("   (direction %d): %s\n", nbTypes[i], nID);
   }

   printf("\n[%s] Vertices (%d):\n", crs, nVertices);

   for(i = 0; i < nVertices; i++)
      printf("   %f, %f\n", vertices[i].lat * 180 / Pi, vertices[i].lon * 180 / Pi);
   return 0;
}

static int dggrsInfo(DGGRS dggrs)
{
   int depth64k = DGGAL_DGGRS_get64KDepth(dggrs);
   int ratio = DGGAL_DGGRS_getRefinementRatio(dggrs);
   int maxLevel = DGGAL_DGGRS_getMaxDGGRSZoneLevel(dggrs);

   printf("Refinement Ratio: %d\n", ratio);
   printf("Maximum level for 64-bit global identifiers (DGGAL DGGRSZone): %d\n", maxLevel);
   printf("Default ~64K sub-zones relative depth: %d\n", depth64k);
   return 0;
}

int displayInfo(DGGRS dggrs, DGGRSZone zone, int depthOption)
{
   if(zone != nullZone)
      return zoneInfo(dggrs, zone, depthOption);
   else
      return dggrsInfo(dggrs);
}

int main(int argc, char * argv[])
{
   DGGALModule dggal = DGGAL_init();
   int exitCode = 0;
   int showSyntax = false;
   const char * dggrsName = NULL;
   int a = 1;
   constString zoneID = NULL;
   int depthOption = -1;

        if(!strcmpi(argv[0], "i3h") || !strcmpi(argv[0], "isea3h")) dggrsName = "ISEA3H";
   else if(!strcmpi(argv[0], "i9r") || !strcmpi(argv[0], "isea9r")) dggrsName = "ISEA9R";
   else if(!strcmpi(argv[0], "i4r") || !strcmpi(argv[0], "isea4r")) dggrsName = "ISEA4R";
   else if(!strcmpi(argv[0], "i7h") || !strcmpi(argv[0], "isea7h")) dggrsName = "ISEA7H";
   else if(!strcmpi(argv[0], "iz7") || !strcmpi(argv[0], "isea7h_z7")) dggrsName = "ISEA7H_Z7";

   else if(!strcmpi(argv[0], "r3h") || !strcmpi(argv[0], "rtea3h")) dggrsName = "RTEA3H";
   else if(!strcmpi(argv[0], "r9r") || !strcmpi(argv[0], "rtea9r")) dggrsName = "RTEA9R";
   else if(!strcmpi(argv[0], "r4r") || !strcmpi(argv[0], "rtea4r")) dggrsName = "RTEA4R";
   else if(!strcmpi(argv[0], "r7h") || !strcmpi(argv[0], "rtea7h")) dggrsName = "RTEA7H";
   else if(!strcmpi(argv[0], "rz7") || !strcmpi(argv[0], "rtea7h_z7")) dggrsName = "RTEA7H_Z7";

   else if(!strcmpi(argv[0], "v3h") || !strcmpi(argv[0], "ivea3h")) dggrsName = "IVEA3H";
   else if(!strcmpi(argv[0], "v9r") || !strcmpi(argv[0], "ivea9r")) dggrsName = "IVEA9R";
   else if(!strcmpi(argv[0], "v4r") || !strcmpi(argv[0], "ivea4r")) dggrsName = "IVEA4R";
   else if(!strcmpi(argv[0], "v7h") || !strcmpi(argv[0], "ivea7h")) dggrsName = "IVEA7H";
   else if(!strcmpi(argv[0], "vz7") || !strcmpi(argv[0], "ivea7h_z7")) dggrsName = "IVEA7H_Z7";

   else if(!strcmpi(argv[0], "ggg") || !strcmpi(argv[0], "gnosis")) dggrsName = "GNOSISGlobalGrid";

   else if(!strcmpi(argv[0], "rhp") || !strcmpi(argv[0], "rHEALPix")) dggrsName = "rHEALPix";
   else if(!strcmpi(argv[0], "hpx") || !strcmpi(argv[0], "HEALPix")) dggrsName = "HEALPix";

   if(!dggrsName && argc > 1)
   {
           if(!strcmpi(argv[1], "isea3h")) dggrsName = "ISEA3H";
      else if(!strcmpi(argv[1], "isea9r")) dggrsName = "ISEA9R";
      else if(!strcmpi(argv[1], "isea4r")) dggrsName = "ISEA4R";
      else if(!strcmpi(argv[1], "isea7h_z7")) dggrsName = "ISEA7H_Z7";

      else if(!strcmpi(argv[1], "rtea3h")) dggrsName = "RTEA3H";
      else if(!strcmpi(argv[1], "rtea9r")) dggrsName = "RTEA9R";
      else if(!strcmpi(argv[1], "rtea4r")) dggrsName = "RTEA4R";
      else if(!strcmpi(argv[1], "rtea7h")) dggrsName = "RTEA7H";
      else if(!strcmpi(argv[1], "rtea7h_z7")) dggrsName = "RTEA7H_Z7";

      else if(!strcmpi(argv[1], "ivea3h")) dggrsName = "IVEA3H";
      else if(!strcmpi(argv[1], "ivea9r")) dggrsName = "IVEA9R";
      else if(!strcmpi(argv[1], "ivea4r")) dggrsName = "IVEA4R";
      else if(!strcmpi(argv[1], "ivea7h")) dggrsName = "IVEA7H";
      else if(!strcmpi(argv[1], "ivea7h_z7")) dggrsName = "IVEA7H_Z7";

      else if(!strcmpi(argv[1], "gnosis")) dggrsName = "GNOSISGlobalGrid";

      else if(!strcmpi(argv[1], "rHEALPix")) dggrsName = "rHEALPix";
      else if(!strcmpi(argv[1], "HEALPix")) dggrsName = "HEALPix";
      a++;
   }

   if(argc > a)
      zoneID = argv[a++];

   while(a < argc)
   {
      const char * key = argv[a++];
      if(key[0] == '-' && a < argc)
      {
         const char * value = argv[a++];
         if(!strcmpi(key + 1, "depth"))
            depthOption = strtol(value, NULL, 10);
      }
      else
         exitCode = 1, showSyntax = true;
   }

   if(dggrsName && !exitCode)
   {
      DGGRS dggrs = DGGAL_DGGRS_new(dggal, dggrsName);
      DGGRSZone zone = nullZone;

      #if 0
      uint nDGGRS;
      const char ** dggrsList = DGGAL_DGGRS_list(&nDGGRS);
      {
         int i;

         printf("Available DGGRSs:\n");
         for(i = 0; i < nDGGRS; i++)
            printf("   %s\n", dggrsList[i]);
      }
      #endif

      printf("DGGRS: https://maps.gnosis.earth/ogcapi/dggrs/%s\n", dggrsName);

      if(zoneID)
         zone = DGGAL_DGGRS_getZoneFromTextID(dggrs, zoneID);

      displayInfo(dggrs, zone, depthOption);

      // Compacted Zones Test
      #if 0
      DGGRS isea4r = DGGAL_DGGRS_new(dggal, "ISEA4R");
      const char * zoneIDs[] = { "B5-0", "B5-1", "B5-2", "B5-3" };
      unsigned int count = sizeof(zoneIDs) / sizeof(zoneIDs[0]);
      Array_DGGRSZone a = DGGAL_Array_DGGRSZone_new(count);
      DGGRSZone * zones = DGGAL_Array_DGGRSZone_getPointer(a);
      int i;

      for(i = 0; i < count; i++)
         zones[i] = DGGAL_DGGRS_getZoneFromTextID(isea4r, zoneIDs[i]);

      DGGAL_DGGRS_compactZones(isea4r, a);
      zones = DGGAL_Array_DGGRSZone_getPointer(a);
      count = DGGAL_Array_DGGRSZone_getCount(a);

      printf("Compacted zones\n");
      for(i = 0; i < count; i++)
      {
         char id[256];
         DGGAL_DGGRS_getZoneTextID(isea4r, zones[i], id);
         printf("   %s\n", id);
      }
      DGGAL_Array_DGGRSZone_delete(a);
      DGGAL_DGGRS_delete(isea4r);
      #endif

      DGGAL_DGGRS_delete(dggrs);
   }
   else
      showSyntax = true, exitCode = 1;

   if(showSyntax)
      printf(
         "Syntax:\n"
         "   info <dggrs> [zone] [options]\n"
         "where dggrs is one of gnosis, isea(4r/9r/3h/7h/7h_z7), ivea(4r/9r/3h/7h/7h_z7), rtea(4r/9r/3h/7h/7h_z7), healpix, rhealpix\n");

   DGGAL_terminate(dggal);
   return exitCode;
}



================================================
FILE: bindings_examples/c_fn/Makefile
================================================
.PHONY: all objdir cleantarget clean realclean distclean

# CORE VARIABLES

MODULE := info
VERSION :=
CONFIG := release
ifndef COMPILER
COMPILER := default
endif

TARGET_TYPE = executable

# FLAGS

ECFLAGS =
ifndef DEBIAN_PACKAGE
CFLAGS =
LDFLAGS =
endif
PRJ_CFLAGS =
CECFLAGS =
OFLAGS =
LIBS =

ifdef DEBUG
NOSTRIP := y
endif

CONSOLE = -mconsole

# INCLUDES

DGGAL_ABSPATH := $(dir $(realpath $(firstword $(MAKEFILE_LIST))))../../

ifndef EC_SDK_SRC
EC_SDK_SRC := $(DGGAL_ABSPATH)../eC
endif

_CF_DIR = $(EC_SDK_SRC)/
include $(_CF_DIR)crossplatform.mk
include $(_CF_DIR)default.cf
ifndef WINDOWS_HOST
export LD_LIBRARY_PATH := $(LD_LIBRARY_PATH):$(DGGAL_ABSPATH)obj/$(CONFIG).$(HOST_PLATFORM)$(COMPILER_SUFFIX)$(DEBUG_SUFFIX)/
else
export PATH := $(PATH);$(DGGAL_ABSPATH)obj/$(CONFIG).$(HOST_PLATFORM)$(COMPILER_SUFFIX)$(DEBUG_SUFFIX)/
endif

# POST-INCLUDES VARIABLES

OBJ = obj/$(CONFIG).$(PLATFORM)$(COMPILER_SUFFIX)$(DEBUG_SUFFIX)/

RES =

TARGET_NAME := info

TARGET = obj/$(CONFIG).$(PLATFORM)$(COMPILER_SUFFIX)$(DEBUG_SUFFIX)/$(TARGET_NAME)$(OUT)

_OBJECTS = \
	$(OBJ)info$(O)

OBJECTS = $(_OBJECTS)

SOURCES = \
	info.c

RESOURCES =

ifdef USE_RESOURCES_EAR
RESOURCES_EAR =
else
RESOURCES_EAR = $(RESOURCES)
endif

LIBS += $(SHAREDLIB) $(EXECUTABLE) $(LINKOPT)

LIBS += \
	$(call _L,dggal_c_fn)

PRJ_CFLAGS += \
	 $(if $(DEBUG), -g, -O2 -ffast-math) $(FPIC) -Wall -DREPOSITORY_VERSION="\"$(REPOSITORY_VER)\"" \
			 -I../../bindings/c_fn

ECFLAGS += -module $(MODULE)
CECFLAGS += -cpp $(_CPP)

# OFLAGS += -L../../bindings/c_fn/obj/dggal.allinone.$(PLATFORM)

OFLAGS += \
	 -L$(call quote_path,../../obj/release.$(PLATFORM)$(COMPILER_SUFFIX)) \
	 -L$(call quote_path,../../obj/$(PLATFORM)$(COMPILER_SUFFIX)/lib) \
	 -L$(call quote_path,$(EC_SDK_SRC)/obj/$(PLATFORM)$(COMPILER_SUFFIX)/lib) \
	 -L$(call quote_path,../../obj/$(PLATFORM)$(COMPILER_SUFFIX)/bin) \
	 -L$(call quote_path,$(EC_SDK_SRC)/obj/$(PLATFORM)$(COMPILER_SUFFIX)/bin)

# TARGETS

all: objdir $(TARGET)

objdir:
	$(if $(wildcard $(OBJ)),,$(call mkdir,$(OBJ)))

$(SYMBOLS): | objdir
$(OBJECTS): | objdir
$(TARGET): $(SOURCES) $(RESOURCES_EAR) $(SYMBOLS) $(OBJECTS) | objdir
	@$(call rm,$(OBJ)objects.lst)
	@$(call touch,$(OBJ)objects.lst)
	$(call addtolistfile,$(_OBJECTS),$(OBJ)objects.lst)
	$(LD) $(OFLAGS) @$(OBJ)objects.lst $(LIBS) -o $(TARGET) $(INSTALLNAME) $(SONAME)
ifndef NOSTRIP
	$(STRIP) $(STRIPOPT) $(TARGET)
endif
ifdef LINUX_TARGET
ifdef LINUX_HOST
	$(if $(basename $(VER)),ln -sf $(LP)$(MODULE)$(SO)$(VER) $(OBJ)$(LP)$(MODULE)$(SO)$(basename $(VER)),)
	$(if $(VER),ln -sf $(LP)$(MODULE)$(SO)$(VER) $(OBJ)$(LP)$(MODULE)$(SO),)
endif
endif

# SYMBOL RULES

# C OBJECT RULES

# OBJECT RULES

$(OBJ)info$(O): info.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,info.c) -o $(call quote_path,$@)

cleantarget:
	$(call rm,$(OBJ)objects.lst)
	$(call rm,$(TARGET))
ifdef LINUX_TARGET
ifdef LINUX_HOST
	$(call rm,$(OBJ)$(LP)$(MODULE)$(SO)$(basename $(VER)))
	$(call rm,$(OBJ)$(LP)$(MODULE)$(SO))
endif
endif

clean: cleantarget
	$(call rm,$(_OBJECTS))

realclean: cleantarget
	$(call rmr,$(OBJ))

distclean: cleantarget
	$(call rmr,obj/)
	$(call rmr,.configs/)
	$(call rm,*.ews)
	$(call rm,*.Makefile)



================================================
FILE: bindings_examples/cpp/info.cpp
================================================
#include <dggal.hpp>

// For looking up internationalized strings
#define MODULE_NAME "info"

static int zoneInfo(DGGRS & dggrs, DGGRSZone zone, TMap<constString, constString> & options)
{
   int level = dggrs.getZoneLevel(zone);
   int nEdges = dggrs.countZoneEdges(zone);
   GeoPoint centroid;
   GeoExtent extent;
   GeoPoint vertices[6];
   int nVertices = dggrs.getZoneWGS84Vertices(zone, vertices);
   char zoneID[256];
   double area = dggrs.getZoneArea(zone), areaKM2 = area / 1000000;
   int depth = dggrs.get64KDepth();
   DGGRSZone parents[3], neighbors[6], children[13];
   int nParents = dggrs.getZoneParents(zone, parents);
   int nbTypes[6];
   int nNeighbors = dggrs.getZoneNeighbors(zone, neighbors, nbTypes);
   int nChildren = dggrs.getZoneChildren(zone, children);
   DGGRSZone centroidParent = dggrs.getZoneCentroidParent(zone);
   DGGRSZone centroidChild = dggrs.getZoneCentroidChild(zone);
   bool isCentroidChild = dggrs.isZoneCentroidChild(zone);
   int i;
   constString crs = "EPSG:4326";
   int64 nSubZones;
   constString depthOption = null;

   TMapIterator<constString, constString> it;
   it.map = options;
   if(it.index("depth", false))
      depthOption = it.value;

   if(depthOption)
   {
      int maxDepth = dggrs.getMaxDepth();
      _onGetDataFromString(CO(int), &depth, depthOption);
      if(depth > maxDepth)
      {
         printLn($("Invalid depth (maximum: "), maxDepth, ")");
         return 1;
      }
   }

   nSubZones = dggrs.countSubZones(zone, depth);

   dggrs.getZoneWGS84Centroid(zone, centroid);
   dggrs.getZoneWGS84Extent(zone, extent);
   dggrs.getZoneTextID(zone, zoneID);

   printLn($("Textual Zone ID: "), zoneID);
   printx($("64-bit integer ID: "), (uint64)zone, " ("); // FIXME: It would be nice not needing this cast

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wformat" // FORMAT64HEX contains runtime checks for platform
   printf(FORMAT64HEX, zone);
#pragma GCC diagnostic pop
   printLn(")");
   printLn("");
   printLn($("Level "), level, $(" zone ("), nEdges, $(" edges"),
      isCentroidChild ? $(", centroid child)") : ")");
   printLn(area, " m² (", areaKM2, " km²)");
   printLn(nSubZones, $(" sub-zones at depth "), depth);
   printLn($("WGS84 Centroid (lat, lon): "), centroid.lat, ", ", centroid.lon);
   printLn($("WGS84 Extent (lat, lon): { "),
      // FIXME: It would be nice not needing this GeoPoint cast
      ((GeoPoint)extent.ll).lat, ", ", ((GeoPoint)extent.ll).lon, " }, { ",
      ((GeoPoint)extent.ur).lat, ", ", ((GeoPoint)extent.ur).lon, " }");

   printLn("");
   if(nParents)
   {
      printLn($("Parent"), nParents > 1 ? "s" : "", " (", nParents, "):");
      for(i = 0; i < nParents; i++)
      {
         char pID[256];
         dggrs.getZoneTextID(parents[i], pID);
         printx("   ", pID);
         if(centroidParent == parents[i])
            printx($(" (centroid child)"));
         printLn("");
      }
   }
   else
      printLn($("No parent"));

   printLn("");
   printLn($("Children ("), nChildren, "):");
   for(i = 0; i < nChildren; i++)
   {
      char cID[256];
      dggrs.getZoneTextID(children[i], cID);
      printx("   ", cID);
      if(centroidChild == children[i])
         printx($(" (centroid)"));
      printLn("");
   }

   printLn("");
   printLn($("Neighbors ("), nNeighbors, "):");
   for(i = 0; i < nNeighbors; i++)
   {
      char nID[256];
      dggrs.getZoneTextID(neighbors[i], nID);
      printLn($("   (direction "), nbTypes[i], "): ", nID);
   }

   printLn("");
   printLn("[", crs, $("] Vertices ("), nVertices, "):");

   for(i = 0; i < nVertices; i++)
      printLn("   ", vertices[i].lat, ", ", vertices[i].lon);

   return 0;
}

static int dggrsInfo(DGGRS & dggrs, TMap<constString, constString> & options)
{
   int depth64k = dggrs.get64KDepth();
   int ratio = dggrs.getRefinementRatio();
   int maxLevel = dggrs.getMaxDGGRSZoneLevel();

   printLn($("Refinement Ratio: "), ratio);
   printLn($("Maximum level for 64-bit global identifiers (DGGAL DGGRSZone): "), maxLevel);
   printLn($("Default ~64K sub-zones relative depth: "), depth64k);
   return 0;
}

int displayInfo(DGGRS & dggrs, DGGRSZone zone, TMap<constString, constString> & options)
{
   if(zone != nullZone)
      return zoneInfo(dggrs, zone, options);
   else
      return dggrsInfo(dggrs, options);
}

class DGGALInfoApp : Application
{
public:
   eC_Module mDGGAL;

   DGGALInfoApp() : Application(ecrt_init(null, true, false, null, null))
   {
      mDGGAL = dggal_init(__thisModule);
      dggal_cpp_init(Module(__thisModule));
   }
};

int main(int argc, char * argv[])
{
   int exitCode = 0;
   DGGALInfoApp app;

   bool showSyntax = false;
   const char * dggrsName = null;
   int a = 1;
   constString zoneID = null;

   TMap<constString, constString> options;

        if(!strcmpi(argv[0], "i3h") || !strcmpi(argv[0], "isea3h")) dggrsName = "ISEA3H";
   else if(!strcmpi(argv[0], "i9r") || !strcmpi(argv[0], "isea9r")) dggrsName = "ISEA9R";
   else if(!strcmpi(argv[0], "i7h") || !strcmpi(argv[0], "isea7h")) dggrsName = "ISEA7H";
   else if(!strcmpi(argv[0], "iz7") || !strcmpi(argv[0], "isea7h_z7")) dggrsName = "ISEA7H_Z7";
   else if(!strcmpi(argv[0], "i4r") || !strcmpi(argv[0], "isea4r")) dggrsName = "ISEA4R";

   else if(!strcmpi(argv[0], "r3h") || !strcmpi(argv[0], "rtea3h")) dggrsName = "RTEA3H";
   else if(!strcmpi(argv[0], "r9r") || !strcmpi(argv[0], "rtea9r")) dggrsName = "RTEA9R";
   else if(!strcmpi(argv[0], "r7h") || !strcmpi(argv[0], "rtea7h")) dggrsName = "RTEA7H";
   else if(!strcmpi(argv[0], "iz7") || !strcmpi(argv[0], "rtea7h_z7")) dggrsName = "RTEA7H_Z7";
   else if(!strcmpi(argv[0], "r4r") || !strcmpi(argv[0], "rtea4r")) dggrsName = "RTEA4R";

   else if(!strcmpi(argv[0], "v3h") || !strcmpi(argv[0], "ivea3h")) dggrsName = "IVEA3H";
   else if(!strcmpi(argv[0], "v9r") || !strcmpi(argv[0], "ivea9r")) dggrsName = "IVEA9R";
   else if(!strcmpi(argv[0], "v7h") || !strcmpi(argv[0], "ivea7h")) dggrsName = "IVEA7H";
   else if(!strcmpi(argv[0], "vz7") || !strcmpi(argv[0], "ivea7h_z7")) dggrsName = "IVEA7H_Z7";
   else if(!strcmpi(argv[0], "v4r") || !strcmpi(argv[0], "ivea4r")) dggrsName = "IVEA4R";

   else if(!strcmpi(argv[0], "ggg") || !strcmpi(argv[0], "gnosis")) dggrsName = "GNOSISGlobalGrid";

   else if(!strcmpi(argv[0], "rhp") || !strcmpi(argv[0], "rHEALPix")) dggrsName = "rHEALPix";
   else if(!strcmpi(argv[0], "hpx") || !strcmpi(argv[0], "HEALPix")) dggrsName = "HEALPix";


   if(!dggrsName && argc > 1)
   {
           if(!strcmpi(argv[1], "isea3h")) dggrsName = "ISEA3H";
      else if(!strcmpi(argv[1], "isea9r")) dggrsName = "ISEA9R";
      else if(!strcmpi(argv[1], "isea7h")) dggrsName = "ISEA7H";
      else if(!strcmpi(argv[1], "isea7h_z7")) dggrsName = "ISEA7H_Z7";
      else if(!strcmpi(argv[1], "isea4r")) dggrsName = "ISEA4R";

      else if(!strcmpi(argv[1], "rtea3h")) dggrsName = "RTEA3H";
      else if(!strcmpi(argv[1], "rtea9r")) dggrsName = "RTEA9R";
      else if(!strcmpi(argv[1], "rtea7h")) dggrsName = "RTEA7H";
      else if(!strcmpi(argv[1], "rtea7h_z7")) dggrsName = "RTEA7H_Z7";
      else if(!strcmpi(argv[1], "rtea4r")) dggrsName = "RTEA4R";

      else if(!strcmpi(argv[1], "ivea3h")) dggrsName = "IVEA3H";
      else if(!strcmpi(argv[1], "ivea9r")) dggrsName = "IVEA9R";
      else if(!strcmpi(argv[1], "ivea7h")) dggrsName = "IVEA7H";
      else if(!strcmpi(argv[1], "ivea7h_z7")) dggrsName = "IVEA7H_Z7";
      else if(!strcmpi(argv[1], "ivea4r")) dggrsName = "IVEA4R";

      else if(!strcmpi(argv[1], "gnosis")) dggrsName = "GNOSISGlobalGrid";

      else if(!strcmpi(argv[1], "rHEALPix")) dggrsName = "rHEALPix";
      else if(!strcmpi(argv[1], "HEALPix")) dggrsName = "HEALPix";
      a++;
   }

   if(argc > a)
      zoneID = argv[a++];

   while(a < argc)
   {
      const char * key = argv[a++];
      if(key[0] == '-' && a < argc)
      {
         const char * value = argv[a++];
         TMapIterator<constString, constString> it;
         it.map = options;
         it.index(key + 1, true);
         it.value = (char *)value;
      }
      else
         exitCode = 1, showSyntax = true;
   }

   if(dggrsName && !exitCode)
   {
      DGGRS * dggrs = new DGGRS((eC_Instance)newi(eC_findClass(app.mDGGAL, dggrsName)));
      DGGRSZone zone = nullZone;

      printLn($("DGGRS: https://maps.gnosis.earth/ogcapi/dggrs/"), dggrsName);

      if(zoneID)
         zone = dggrs->getZoneFromTextID(zoneID);

      displayInfo(*dggrs, zone, options);
      delete dggrs;
   }
   else
      showSyntax = true, exitCode = 1;

   if(showSyntax)
      printLn($("Syntax:\n"
         "   info <dggrs> [zone] [options]\n"
         "where dggrs is one of gnosis, isea(4r/9r/3h/7h/7h_z7), ivea(4r/9r/3h/7h/7h_z7), rtea(4r/9r/3h/7h/7h_z7), healpix, rhealpix\n"));
   return exitCode;
}



================================================
FILE: bindings_examples/cpp/info.epj
================================================
{
   "Version" : 0.2,
   "ModuleName" : "info",
   "Options" : {
      "Warnings" : "All",
      "IncludeDirs" : [
         "../../bindings/c",
         "../../bindings/cpp"
      ],
      "TargetType" : "Executable",
      "TargetFileName" : "info",
      "Libraries" : [
         "ecere"
      ],
      "LibraryDirs" : [
         "../../obj/release.$(PLATFORM)$(COMPILER_SUFFIX)"
      ],
      "Console" : true
   },
   "Configurations" : [
      {
         "Name" : "Debug",
         "Options" : {
            "Debug" : true,
            "Optimization" : "None",
            "PreprocessorDefinitions" : [
               "_DEBUG"
            ],
            "FastMath" : false
         }
      },
      {
         "Name" : "Release",
         "Options" : {
            "Debug" : false,
            "Optimization" : "Speed",
            "FastMath" : true
         }
      },
      {
         "Name" : "Static",
         "Options" : {
            "Optimization" : "Speed",
            "PreprocessorDefinitions" : [
               "ECERE_STATIC"
            ],
            "Libraries" : [
               "ecereVanilla"
            ],
            "LibraryDirs" : [
               "../../obj/static.$(PLATFORM)$(COMPILER_SUFFIX)"
            ],
            "FastMath" : true
         },
         "Platforms" : [
            {
               "Name" : "linux",
               "Options" : {
                  "Libraries" : [
                     "dggalStatic",
                     "X11",
                     "Xext",
                     "Xrender",
                     "m",
                     "dl",
                     "pthread",
                     "curses",
                     "z"
                  ]
               }
            },
            {
               "Name" : "win32",
               "Options" : {
                  "Libraries" : [
                     "kernel32",
                     "gdi32",
                     "user32",
                     "winmm",
                     "mpr",
                     "imm32",
                     "z",
                     "dggalStatic"
                  ]
               }
            }
         ]
      }
   ],
   "Files" : [
      {
         "Folder" : "bindings",
         "Files" : [
            {
               "Folder" : "cpp",
               "Files" : [
                  "../../bindings/cpp/dggal.cpp",
                  "../../bindings/cpp/dggal.hpp",
                  "../../bindings/cpp/eC.cpp",
                  "../../bindings/cpp/eC.hpp",
                  "../../bindings/cpp/ecere.cpp",
                  "../../bindings/cpp/ecere.hpp"
               ]
            },
            {
               "Folder" : "c",
               "Files" : [
                  "../../bindings/c/dggal.c",
                  "../../bindings/c/dggal.h",
                  "../../bindings/c/eC.c",
                  "../../bindings/c/eC.h",
                  "../../bindings/c/ecere.c",
                  "../../bindings/c/ecere.h"
               ],
               "Options" : {
                  "PreprocessorDefinitions" : [
                     "ECPRFX=eC_"
                  ]
               }
            }
         ]
      },
      "info.cpp"
   ],
   "ResourcesPath" : "",
   "Resources" : [

   ]
}



================================================
FILE: bindings_examples/cpp/Makefile
================================================
.PHONY: all objdir cleantarget clean realclean distclean

# CORE VARIABLES

MODULE := info
VERSION :=
CONFIG := release
CONTAINS_CXX := defined
ifndef COMPILER
COMPILER := default
endif

TARGET_TYPE = executable

# FLAGS

ECFLAGS =
ifndef DEBIAN_PACKAGE
CFLAGS =
LDFLAGS =
endif
PRJ_CFLAGS =
CECFLAGS =
OFLAGS =
LIBS =

ifdef DEBUG
NOSTRIP := y
endif

CONSOLE = -mconsole

# INCLUDES

DGGAL_ABSPATH := $(dir $(realpath $(firstword $(MAKEFILE_LIST))))../../

ifndef EC_SDK_SRC
EC_SDK_SRC := $(DGGAL_ABSPATH)../eC
endif

_CF_DIR = $(EC_SDK_SRC)/
include $(_CF_DIR)crossplatform.mk
include $(_CF_DIR)default.cf
ifndef WINDOWS_HOST
export LD_LIBRARY_PATH := $(LD_LIBRARY_PATH):$(DGGAL_ABSPATH)obj/$(CONFIG).$(HOST_PLATFORM)$(COMPILER_SUFFIX)$(DEBUG_SUFFIX)/
else
export PATH := $(PATH);$(DGGAL_ABSPATH)obj/$(CONFIG).$(HOST_PLATFORM)$(COMPILER_SUFFIX)$(DEBUG_SUFFIX)/
endif

# POST-INCLUDES VARIABLES

OBJ = obj/$(CONFIG).$(PLATFORM)$(COMPILER_SUFFIX)$(DEBUG_SUFFIX)/

RES =

TARGET_NAME := info

TARGET = obj/$(CONFIG).$(PLATFORM)$(COMPILER_SUFFIX)$(DEBUG_SUFFIX)/$(TARGET_NAME)$(OUT)

_OBJECTS = \
	$(OBJ)dggal.cpp$(O) \
	$(OBJ)ecrt.cpp$(O) \
	$(OBJ)dggal$(O) \
	$(OBJ)ecrt$(O) \
	$(OBJ)info$(O)

OBJECTS = $(_OBJECTS)

SOURCES = \
	../../bindings/cpp/dggal.cpp \
	$(EC_SDK_SRC)/bindings/cpp/ecrt.cpp \
	../../bindings/c/dggal.c \
	$(EC_SDK_SRC)/bindings/c/ecrt.c \
	info.cpp

RESOURCES =

ifdef USE_RESOURCES_EAR
RESOURCES_EAR =
else
RESOURCES_EAR = $(RESOURCES)
endif

LIBS += $(SHAREDLIB) $(EXECUTABLE) $(LINKOPT)

ifndef STATIC_LIBRARY_TARGET
LIBS += \
	$(call _L,ecrt)
endif

PRJ_CFLAGS += \
	 $(if $(DEBUG), -g, -O2 -ffast-math) $(FPIC) -Wall -DREPOSITORY_VERSION="\"$(REPOSITORY_VER)\"" \
			 -I../../bindings/c \
			 -I../../bindings/cpp \
			 -I$(EC_SDK_SRC)/bindings/c \
			 -I$(EC_SDK_SRC)/bindings/cpp

CUSTOM1_PRJ_CFLAGS = \
			 -DECPRFX=eC_ \
	 $(PRJ_CFLAGS)

ECFLAGS += -module $(MODULE)
CECFLAGS += -cpp $(_CPP)

OFLAGS += \
	-L$(call quote_path,../../obj/release.$(PLATFORM)$(COMPILER_SUFFIX)) \
	-L$(call quote_path,$(EC_SDK_SRC)/obj/$(PLATFORM)$(COMPILER_SUFFIX)/lib) \
	-L$(call quote_path,$(EC_SDK_SRC)/obj/$(PLATFORM)$(COMPILER_SUFFIX)/bin)

CXXFLAGS += -std=c++17

# TARGETS

all: objdir $(TARGET)

objdir:
	$(if $(wildcard $(OBJ)),,$(call mkdir,$(OBJ)))

$(SYMBOLS): | objdir
$(OBJECTS): | objdir
$(TARGET): $(SOURCES) $(RESOURCES_EAR) $(SYMBOLS) $(OBJECTS) | objdir
	@$(call rm,$(OBJ)objects.lst)
	@$(call touch,$(OBJ)objects.lst)
	$(call addtolistfile,$(_OBJECTS),$(OBJ)objects.lst)
	$(LD) $(OFLAGS) @$(OBJ)objects.lst $(LIBS) -o $(TARGET) $(INSTALLNAME) $(SONAME)
ifndef NOSTRIP
	$(STRIP) $(STRIPOPT) $(TARGET)
endif
ifdef LINUX_TARGET
ifdef LINUX_HOST
	$(if $(basename $(VER)),ln -sf $(LP)$(MODULE)$(SO)$(VER) $(OBJ)$(LP)$(MODULE)$(SO)$(basename $(VER)),)
	$(if $(VER),ln -sf $(LP)$(MODULE)$(SO)$(VER) $(OBJ)$(LP)$(MODULE)$(SO),)
endif
endif

# SYMBOL RULES

# C OBJECT RULES

# OBJECT RULES

$(OBJ)dggal.cpp$(O): ../../bindings/cpp/dggal.cpp
	$(CXX) $(CXXFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,../../bindings/cpp/dggal.cpp) -o $(call quote_path,$@)

$(OBJ)ecrt.cpp$(O): $(EC_SDK_SRC)/bindings/cpp/ecrt.cpp
	$(CXX) $(CXXFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,$(EC_SDK_SRC)/bindings/cpp/ecrt.cpp) -o $(call quote_path,$@)

$(OBJ)dggal$(O): ../../bindings/c/dggal.c
	$(CC) $(CFLAGS) $(CUSTOM1_PRJ_CFLAGS) -c $(call quote_path,../../bindings/c/dggal.c) -o $(call quote_path,$@)

$(OBJ)ecrt$(O): $(EC_SDK_SRC)/bindings/c/ecrt.c
	$(CC) $(CFLAGS) $(CUSTOM1_PRJ_CFLAGS) -c $(call quote_path,$(EC_SDK_SRC)/bindings/c/ecrt.c) -o $(call quote_path,$@)

$(OBJ)info$(O): info.cpp
	$(CXX) $(CXXFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,info.cpp) -o $(call quote_path,$@)

cleantarget:
	$(call rm,$(OBJ)objects.lst)
	$(call rm,$(TARGET))
ifdef SHARED_LIBRARY_TARGET
ifdef LINUX_TARGET
ifdef LINUX_HOST
	$(call rm,$(OBJ)$(LP)$(MODULE)$(SO)$(basename $(VER)))
	$(call rm,$(OBJ)$(LP)$(MODULE)$(SO))
endif
endif
endif

clean: cleantarget
	$(call rm,$(_OBJECTS))

realclean: cleantarget
	$(call rmr,$(OBJ))

distclean: cleantarget
	$(call rmr,obj/)
	$(call rmr,.configs/)
	$(call rm,*.ews)
	$(call rm,*.Makefile)



================================================
FILE: bindings_examples/cpp/Makefile.static
================================================
.PHONY: all objdir cleantarget clean realclean distclean

# CORE VARIABLES

MODULE := info
VERSION :=
CONFIG := static
CONTAINS_CXX := defined
ifndef COMPILER
COMPILER := default
endif

TARGET_TYPE = executable

# FLAGS

ECFLAGS =
ifndef DEBIAN_PACKAGE
CFLAGS =
LDFLAGS =
endif
PRJ_CFLAGS =
CECFLAGS =
OFLAGS =
LIBS =

ifdef DEBUG
NOSTRIP := y
endif

CONSOLE = -mconsole

# INCLUDES

DGGAL_ABSPATH := $(dir $(realpath $(firstword $(MAKEFILE_LIST))))../../

ifndef EC_SDK_SRC
EC_SDK_SRC := $(DGGAL_ABSPATH)../eC
endif

_CF_DIR = $(EC_SDK_SRC)/
include $(_CF_DIR)crossplatform.mk
include $(_CF_DIR)default.cf
ifndef WINDOWS_HOST
export LD_LIBRARY_PATH := $(LD_LIBRARY_PATH):$(DGGAL_ABSPATH)obj/$(CONFIG).$(HOST_PLATFORM)$(COMPILER_SUFFIX)$(DEBUG_SUFFIX)/
else
export PATH := $(PATH);$(DGGAL_ABSPATH)obj/$(CONFIG).$(HOST_PLATFORM)$(COMPILER_SUFFIX)$(DEBUG_SUFFIX)/
endif

# POST-INCLUDES VARIABLES

OBJ = obj/$(CONFIG).$(PLATFORM)$(COMPILER_SUFFIX)$(DEBUG_SUFFIX)/

RES =

TARGET_NAME := info

TARGET = obj/$(CONFIG).$(PLATFORM)$(COMPILER_SUFFIX)$(DEBUG_SUFFIX)/$(TARGET_NAME)$(OUT)

_OBJECTS = \
	$(OBJ)dggal.cpp$(O) \
	$(OBJ)ecrt.cpp$(O) \
	$(OBJ)dggal$(O) \
	$(OBJ)ecrt$(O) \
	$(OBJ)info$(O)

OBJECTS = $(_OBJECTS)

SOURCES = \
	../../bindings/cpp/dggal.cpp \
	$(EC_SDK_SRC)/bindings/cpp/ecrt.cpp \
	../../bindings/c/dggal.c \
	$(EC_SDK_SRC)/bindings/c/ecrt.c \
	info.cpp

RESOURCES =

ifdef USE_RESOURCES_EAR
RESOURCES_EAR =
else
RESOURCES_EAR = $(RESOURCES)
endif

LIBS += $(SHAREDLIB) $(EXECUTABLE) $(LINKOPT)

ifndef STATIC_LIBRARY_TARGET
LIBS += \
	$(call _L,ecrtStatic)
endif

PRJ_CFLAGS += \
	 $(if $(DEBUG), -g, -O2 -ffast-math) $(FPIC) -Wall -DREPOSITORY_VERSION="\"$(REPOSITORY_VER)\"" \
			 -DEC_STATIC \
			 -I../../bindings/c \
			 -I../../bindings/cpp \
			 -I$(EC_SDK_SRC)/bindings/c \
			 -I$(EC_SDK_SRC)/bindings/cpp

CUSTOM1_PRJ_CFLAGS = \
			 -DECPRFX=eC_ \
	 $(PRJ_CFLAGS)

ECFLAGS += -module $(MODULE)
# PLATFORM-SPECIFIC OPTIONS

ifdef WINDOWS_TARGET

ifndef STATIC_LIBRARY_TARGET
LIBS += \
	$(call _L,kernel32) \
	$(call _L,user32) \
	$(call _L,winmm) \
	$(call _L,mpr) \
	$(call _L,z) \
	$(call _L,dggalStatic)
endif

else
ifdef LINUX_TARGET

LIBS += \
	$(call _L,dggalStatic) \
	$(call _L,m) \
	$(call _L,dl) \
	$(call _L,pthread) \
	$(call _L,z)

endif
endif

CECFLAGS += -cpp $(_CPP)

OFLAGS += \
	-L$(call quote_path,../../obj/static.$(PLATFORM)$(COMPILER_SUFFIX)) \
	-L$(call quote_path,../../obj/release.$(PLATFORM)$(COMPILER_SUFFIX)) \
	-L$(call quote_path,$(EC_SDK_SRC)/obj/$(PLATFORM)$(COMPILER_SUFFIX)/lib) \
	-L$(call quote_path,$(EC_SDK_SRC)/obj/$(PLATFORM)$(COMPILER_SUFFIX)/bin)

CXXFLAGS += -std=c++17

# TARGETS

all: objdir $(TARGET)

objdir:
	$(if $(wildcard $(OBJ)),,$(call mkdir,$(OBJ)))

$(SYMBOLS): | objdir
$(OBJECTS): | objdir
$(TARGET): $(SOURCES) $(RESOURCES_EAR) $(SYMBOLS) $(OBJECTS) | objdir
	@$(call rm,$(OBJ)objects.lst)
	@$(call touch,$(OBJ)objects.lst)
	$(call addtolistfile,$(_OBJECTS),$(OBJ)objects.lst)
	$(LD) $(OFLAGS) @$(OBJ)objects.lst $(LIBS) -o $(TARGET) $(INSTALLNAME) $(SONAME)
ifndef NOSTRIP
	$(STRIP) $(STRIPOPT) $(TARGET)
endif

# SYMBOL RULES

# C OBJECT RULES

# OBJECT RULES

$(OBJ)dggal.cpp$(O): ../../bindings/cpp/dggal.cpp
	$(CXX) $(CXXFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,../../bindings/cpp/dggal.cpp) -o $(call quote_path,$@)

$(OBJ)ecrt.cpp$(O): $(EC_SDK_SRC)/bindings/cpp/ecrt.cpp
	$(CXX) $(CXXFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,$(EC_SDK_SRC)/bindings/cpp/ecrt.cpp) -o $(call quote_path,$@)

$(OBJ)dggal$(O): ../../bindings/c/dggal.c
	$(CC) $(CFLAGS) $(CUSTOM1_PRJ_CFLAGS) -c $(call quote_path,../../bindings/c/dggal.c) -o $(call quote_path,$@)

$(OBJ)ecrt$(O): $(EC_SDK_SRC)/bindings/c/ecrt.c
	$(CC) $(CFLAGS) $(CUSTOM1_PRJ_CFLAGS) -c $(call quote_path,$(EC_SDK_SRC)/bindings/c/ecrt.c) -o $(call quote_path,$@)

$(OBJ)info$(O): info.cpp
	$(CXX) $(CXXFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,info.cpp) -o $(call quote_path,$@)

cleantarget:
	$(call rm,$(OBJ)objects.lst)
	$(call rm,$(TARGET))

clean: cleantarget
	$(call rm,$(_OBJECTS))

realclean: cleantarget
	$(call rmr,$(OBJ))

distclean: cleantarget
	$(call rmr,obj/)
	$(call rmr,.configs/)
	$(call rm,*.ews)
	$(call rm,*.Makefile)



================================================
FILE: bindings_examples/js/dggalExample.js
================================================
import { DGGAL } from './dggal.js';

let dggal;
const initPromise = DGGAL.init();

document.addEventListener('DOMContentLoaded', () => {
  // Utility to log messages to the consoleLog textarea
  function addToLog(message) {
    console.log(message);
    const logArea = document.getElementById('consoleLog');
    if (logArea) {
      logArea.value += message + '\n';
      logArea.scrollTop = logArea.scrollHeight;
    }
  }

  // Clear the log output
  function clearLog() {
    const logArea = document.getElementById('consoleLog');
    if (logArea) {
      logArea.value = '';
    }
  }

  // Expose clearLog globally for the Clear button
  window.clearLog = clearLog;

  // Main form handler
  window.processForm = async function () {
    try {
      // Ensure WASM module is initialized
      dggal = await initPromise;

      const nameInput = document.getElementById('name');
      const idInput = document.getElementById('id');

      if (!nameInput || !idInput) {
        addToLog('Error: Missing input elements.');
        return;
      }

      const dggrsName = nameInput.value.trim();
      const zoneID = idInput.value.trim();

      if (!dggrsName || !zoneID) {
        addToLog('Error: Both DGGRS Name and Zone ID are required.');
        return;
      }

      // Create DGGRS instance and process zone
      const dggrs = dggal.createDGGRS(dggrsName);
      const zone = dggrs.getZoneFromTextID(zoneID);

      if(zone == DGGAL.nullZone)
         addToLog('Invalid zone identifier');
      else
      {
         const centroid = dggrs.getZoneWGS84Centroid(zone);

         addToLog(`Centroid: { latitude: ${centroid.lat * 180 / Math.PI}, longitude: ${centroid.lon * 180 / Math.PI} }`);

         // Get refined vertices and print them
         const vertices = dggrs.getZoneRefinedWGS84Vertices(zone, 0);

         if (!Array.isArray(vertices)) {
           addToLog('Error: getZoneRefinedWGS84Vertices did not return an array.');
         } else {
           addToLog(`Refined vertices (count: ${vertices.length}):`);
           vertices.forEach((v, i) => {
             const latDeg = v.lat * 180 / Math.PI;
             const lonDeg = v.lon * 180 / Math.PI;
             addToLog(`  ${i}: { latitude: ${latDeg}, longitude: ${lonDeg} }`);
           });
         }
      }

      // Clean up
      dggrs.delete();
    } catch (err) {
      console.error(err);
      addToLog(`Error: ${err.message}`);
    }
  };

  // Optional: clear log on page load
  clearLog();
});

window.addEventListener('pagehide', (event) => {
  if (!event.persisted && dggal) {
    dggal.terminate();
    dggal = null;
  }
});

document.getElementById('userForm').addEventListener('submit', function(event) {
  event.preventDefault();
  processForm();
});



================================================
FILE: bindings_examples/js/dggalExample2.js
================================================
// dggalExample2.js
import { DGGAL } from './dggal.js';

let dggal;
const initPromise = DGGAL.init();

// Create OpenLayers map using global ol (assumes ol.css and ol.js are included in HTML before this module)
document.addEventListener('DOMContentLoaded', () => {
  if (!window.ol) {
    const logArea = document.getElementById('consoleLog');
    const msg = 'OpenLayers not found. Include ol.js and ol.css in your HTML before this module.';
    console.error(msg);
    if (logArea) logArea.value += msg + '\n';
    return;
  }

  const ol = window.ol;
  const vectorSource = new ol.source.Vector();

  const vectorLayer = new ol.layer.Vector({
    source: vectorSource,
    style: feature => {
      const t = feature.get('type');
      if (t === 'polygon') {
        return new ol.style.Style({
          stroke: new ol.style.Stroke({ color: 'rgba(0,120,255,0.9)', width: 2 }),
          fill: new ol.style.Fill({ color: 'rgba(0,120,255,0.15)' })
        });
      } else if (t === 'centroid') {
        return new ol.style.Style({
          image: new ol.style.Circle({
            radius: 6,
            fill: new ol.style.Fill({ color: '#ff5722' }),
            stroke: new ol.style.Stroke({ color: '#fff', width: 2 })
          }),
          text: new ol.style.Text({ text: feature.get('label') || '', offsetY: -14, fill: new ol.style.Fill({ color: '#222' }) })
        });
      }
      return null;
    }
  });

  const map = new ol.Map({
    target: 'map',
    layers: [
      new ol.layer.Tile({ source: new ol.source.OSM() }),
      vectorLayer
    ],
    view: new ol.View({ center: ol.proj.fromLonLat([0, 0]), zoom: 2 })
  });

  window.__dggal_map = map;
  window.__dggal_vectorSource = vectorSource;
});

// Utility logging helpers
function addToLog(message) {
  console.log(message);
  const logArea = document.getElementById('consoleLog');
  if (logArea) {
    logArea.value += message + '\n';
    logArea.scrollTop = logArea.scrollHeight;
  }
}

function clearLog() {
  const logArea = document.getElementById('consoleLog');
  if (logArea) {
    logArea.value = '';
  }
}
window.clearLog = clearLog;

// Main form handler (kept intact, hardened slightly)
document.addEventListener('DOMContentLoaded', () => {
 (async () => {
  dggal = await initPromise;

  populateDGGRSDropdown('IVEA7H_Z7');

  window.processForm = async function () {
    try {
      // ensure map is initialized
      if (!window.__dggal_map) {
        addToLog('Map not initialized');
        return;
      }

      const nameInput = document.getElementById('name');
      const idInput = document.getElementById('id');

      if (!nameInput || !idInput) {
        addToLog('Error: Missing input elements.');
        return;
      }

      const dggrsName = nameInput.value.trim();
      const zoneID = idInput.value.trim();

      if (!dggrsName || !zoneID) {
        addToLog('Error: Both DGGRS Name and Zone ID are required.');
        return;
      }

      const dggrs = dggal.createDGGRS(dggrsName);

      const zone = dggrs.getZoneFromTextID(zoneID);

      let vertices, latDeg, lonDeg;

      if (zone === DGGAL.nullZone) {
        addToLog('Invalid zone identifier');
        dggrs.delete();
        return;
      } else {
        const centroid = dggrs.getZoneWGS84Centroid(zone);
        latDeg = centroid.lat * 180 / Math.PI;
        lonDeg = centroid.lon * 180 / Math.PI;
        addToLog(`Centroid: latitude: ${latDeg}, longitude: ${lonDeg}`);

        vertices = dggrs.getZoneRefinedWGS84Vertices(zone, 0);
      }

      // Clear previous features
      const vectorSrc = window.__dggal_vectorSource;
      if (!vectorSrc) {
        addToLog('Map not initialized yet');
        dggrs.delete();
        return;
      }
      vectorSrc.clear();

      // Convert vertices to [lon, lat] degrees and ensure ring is closed
      const coordsDeg = (Array.isArray(vertices) ? vertices : []).map(v => [v.lon * 180 / Math.PI, v.lat * 180 / Math.PI]);
      if (coordsDeg.length > 0) {
        const first = coordsDeg[0];
        const last = coordsDeg[coordsDeg.length - 1];
        if (first[0] !== last[0] || first[1] !== last[1]) coordsDeg.push([first[0], first[1]]);
      } else {
        addToLog('No vertices returned for zone');
        dggrs.delete();
        return;
      }

      const ol = window.ol;
      const polygonCoords = [coordsDeg.map(c => ol.proj.fromLonLat(c))];
      const polygonFeature = new ol.Feature({
        geometry: new ol.geom.Polygon(polygonCoords),
        type: 'polygon'
      });
      vectorSrc.addFeature(polygonFeature);

      const centroidPoint = ol.proj.fromLonLat([lonDeg, latDeg]);
      const centroidFeature = new ol.Feature({
        geometry: new ol.geom.Point(centroidPoint),
        type: 'centroid',
        label: `Centroid (${latDeg.toFixed(6)}, ${lonDeg.toFixed(6)})`
      });
      vectorSrc.addFeature(centroidFeature);

      window.__dggal_map.getView().fit(polygonFeature.getGeometry().getExtent(), { padding: [40, 40, 40, 40], maxZoom: 18, duration: 300 });

      dggrs.delete();
    } catch (err) {
      console.error(err);
      addToLog(`Error: ${err && err.message ? err.message : err}`);
    }
  };

  // Optional: clear log on page load
  clearLog();
 })();
});

window.addEventListener('pagehide', (event) => {
  if (!event.persisted && dggal) {
    dggal.terminate();
    dggal = null;
  }
});

document.getElementById('userForm').addEventListener('submit', function(event) {
  event.preventDefault();
  processForm();
});

function populateDGGRSDropdown(defaultValue = null) {
  const select = document.getElementById('name');
  select.innerHTML = '';

  const names = dggal.listDGGRS();

  for (const name of names) {
    const option = document.createElement('option');
    option.value = name;
    option.textContent = name;
    if (name === defaultValue) {
      option.selected = true;
    }
    select.appendChild(option);
  }
  if (!defaultValue) {
    const placeholder = document.createElement('option');
    placeholder.textContent = 'Select a DGGRS...';
    placeholder.disabled = true;
    placeholder.selected = true;
    select.appendChild(placeholder);
  }
}



================================================
FILE: bindings_examples/js/index.html
================================================
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DGGAL in the browser</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ol@10.6.1/ol.css" />
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 50px auto;
            padding: 20px;
            background-color: #f5f5f5;
        }

        .form-container {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        h1 {
            color: #333;
            margin-bottom: 30px;
            text-align: center;
        }

        .form-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: #555;
        }

        input[type="text"] {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 16px;
            box-sizing: border-box;
            transition: border-color 0.3s;
        }

        input[type="text"]:focus {
            outline: none;
            border-color: #007bff;
        }

        .dropdown-arrow {
            position: absolute;
            right: 12px;
            top: 50%;
            transform: translateY(-50%);
            cursor: pointer;
            color: #666;
            font-size: 14px;
            user-select: none;
        }

        .dropdown-menu {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 2px solid #ddd;
            border-top: none;
            border-radius: 0 0 5px 5px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
        }

        .dropdown-item {
            padding: 10px 12px;
            cursor: pointer;
            border-bottom: 1px solid #eee;
            transition: background-color 0.2s;
        }

        .dropdown-item:hover {
            background-color: #f8f9fa;
        }

        .dropdown-item:last-child {
            border-bottom: none;
        }

        button {
            background-color: #007bff;
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 6px;
            font-size: 16px;
            cursor: pointer;
            transition: background-color 0.3s;
            margin-top: 10px;
        }

        button:hover {
            background-color: #0056b3;
        }

        .log-container {
            margin-top: 30px;
        }

        .log-header {
            font-weight: bold;
            color: #333;
            margin-bottom: 10px;
        }

        #consoleLog {
            width: 100%;
            height: 200px;
            padding: 15px;
            border: 2px solid #ddd;
            border-radius: 6px;
            background-color: #f8f9fa;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            resize: vertical;
            box-sizing: border-box;
            white-space: pre-wrap;
            overflow-y: auto;
        }

        .clear-btn {
            background-color: #dc3545;
            margin-top: 10px;
            padding: 8px 16px;
            font-size: 14px;
        }

        .clear-btn:hover {
            background-color: #c82333;
        }
    </style>
</head>

<body>
    <div class="form-container">
        <h1>DGGAL in the browser</h1>
        <form id="userForm">
            <div class="form-group">
                <label for="name">DGGRS Name:</label>
                <select id="name" name="name">
                <!-- Options will be populated dynamically -->
               </select>
            </div>
            <div class="form-group">
                <label for="id">Zone ID:</label>
                <input type="text" id="id" name="id" placeholder="Enter your ID" value="0234">
            </div>
            <button type="button" onclick="processForm()">Query</button>
        </form>
        <div class="log-container">
            <div class="log-header">Output:</div>
            <textarea id="consoleLog" readonly placeholder=""></textarea>
            <button type="button" class="clear-btn" onclick="clearLog()">Clear Log</button>
        </div>
    </div>

    <div id="map" style="width:100%;height:400px;margin-top:20px;border-radius:8px;overflow:hidden;"></div>
    <script src="https://cdn.jsdelivr.net/npm/ol@10.6.1/dist/ol.js"></script>
    <script type="module" src="./dggalExample2.js"></script>
</body>

</html>



================================================
FILE: bindings_examples/js/indexSimple.html
================================================
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DGGAL in the browser</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 50px auto;
            padding: 20px;
            background-color: #f5f5f5;
        }

        .form-container {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        h1 {
            color: #333;
            margin-bottom: 30px;
            text-align: center;
        }

        .form-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: #555;
        }

        input[type="text"] {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 16px;
            box-sizing: border-box;
            transition: border-color 0.3s;
        }

        input[type="text"]:focus {
            outline: none;
            border-color: #007bff;
        }

        .dropdown-arrow {
            position: absolute;
            right: 12px;
            top: 50%;
            transform: translateY(-50%);
            cursor: pointer;
            color: #666;
            font-size: 14px;
            user-select: none;
        }

        .dropdown-menu {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 2px solid #ddd;
            border-top: none;
            border-radius: 0 0 5px 5px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
        }

        .dropdown-item {
            padding: 10px 12px;
            cursor: pointer;
            border-bottom: 1px solid #eee;
            transition: background-color 0.2s;
        }

        .dropdown-item:hover {
            background-color: #f8f9fa;
        }

        .dropdown-item:last-child {
            border-bottom: none;
        }

        button {
            background-color: #007bff;
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 6px;
            font-size: 16px;
            cursor: pointer;
            transition: background-color 0.3s;
            margin-top: 10px;
        }

        button:hover {
            background-color: #0056b3;
        }

        .log-container {
            margin-top: 30px;
        }

        .log-header {
            font-weight: bold;
            color: #333;
            margin-bottom: 10px;
        }

        #consoleLog {
            width: 100%;
            height: 200px;
            padding: 15px;
            border: 2px solid #ddd;
            border-radius: 6px;
            background-color: #f8f9fa;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            resize: vertical;
            box-sizing: border-box;
            white-space: pre-wrap;
            overflow-y: auto;
        }

        .clear-btn {
            background-color: #dc3545;
            margin-top: 10px;
            padding: 8px 16px;
            font-size: 14px;
        }

        .clear-btn:hover {
            background-color: #c82333;
        }
    </style>
</head>

<body>
    <div class="form-container">
        <h1>DGGAL in the browser</h1>
        <form id="userForm">
            <div class="form-group">
                <label for="name">DGGRS Name:</label>
                <select id="name" name="name">
                 <option value="GNOSISGlobalGrid">GNOSISGlobalGrid</option>
                 <option value="ISEA4R">ISEA4R</option>
                 <option value="ISEA9R">ISEA9R</option>
                 <option value="ISEA3H">ISEA3H</option>
                 <option value="ISEA7H">ISEA7H</option>
                 <option value="ISEA7H_Z7">ISEA7H_Z7</option>
                 <option value="IVEA4R">IVEA4R</option>
                 <option value="IVEA9R">IVEA9R</option>
                 <option value="IVEA3H">IVEA3H</option>
                 <option value="IVEA7H">IVEA7H</option>
                 <option value="IVEA7H_Z7" selected>IVEA7H_Z7</option>
                 <option value="RTEA4R">RTEA4R</option>
                 <option value="RTEA9R">RTEA9R</option>
                 <option value="RTEA3H">RTEA3H</option>
                 <option value="RTEA7H">RTEA7H</option>
                 <option value="RTEA7H_Z7">RTEA7H_Z7</option>
                 <option value="rHEALPix">rHEALPix</option>
                 <option value="HEALPix">HEALPix</option>
               </select>
            </div>
            <div class="form-group">
                <label for="id">Zone ID:</label>
                <input type="text" id="id" name="id" placeholder="Enter your ID" value="0234">
            </div>
            <button type="button" onclick="processForm()">Query</button>
        </form>
        <div class="log-container">
            <div class="log-header">Output:</div>
            <textarea id="consoleLog" readonly placeholder=""></textarea>
            <button type="button" class="clear-btn" onclick="clearLog()">Clear Log</button>
        </div>
    </div>
    <script type="module" src="./dggalExample.js"></script>
</body>

</html>



================================================
FILE: bindings_examples/py/authalic.py
================================================
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from dggal import *

app = Application(appGlobals=globals())
pydggal_setup(app)

cp = authalicSetup(wgs84Major, wgs84Minor)

lat = Degrees(45.0)

authalic = latGeodeticToAuthalic(cp, lat)

geodetic = latAuthalicToGeodetic(cp, authalic)

print("Authalic latitude:", Degrees(authalic))

print("Geodetic latitude:", Degrees(geodetic))



================================================
FILE: bindings_examples/py/geom.py
================================================
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from dggal import *

app = Application(appGlobals=globals())
pydggal_setup(app)

def generateZoneFeature(dggrs, zone, crs, id, centroids: bool, fc: bool, properties):
   t = "   " if fc else ""

   zoneID = dggrs.getZoneTextID(zone)

   printLn('{')
   printLn(t, '   "type" : "Feature",')
   printx (t, '   "id" : ')
   if id:
      printx(id)
   else:
      printx(f'"{zoneID}"')
   printLn(',')

   generateZoneGeometry(dggrs, zone, crs, id, centroids, fc)

   printLn(',')

   printLn(t, '   "properties" : {')
   printx (t, '     "zoneID" : "')
   printx(zoneID)
   printx('"')
   if properties:
      for key, v in properties.items():
         printx(',\n', t, '     "', key, '" : ', v)

   printLn('')
   printLn(t, '   }')
   printx(t, '}')

def generateZoneGeometry(dggrs, zone, crs, id, centroids: bool, fc: bool):
   t = "   " if fc else ""

   printLn(t, '   "geometry" : {');
   printLn(t, '      "type" : "', 'Point' if centroids else 'Polygon', '",')
   printx (t, '      "coordinates" : [')

   if not crs or crs == CRS(ogc, 84) or crs == CRS(epsg, 4326):
      if centroids:
         centroid = dggrs.getZoneWGS84Centroid(zone)
         printx(" ", centroid.lon, ", ", centroid.lat)
      else:
         vertices = dggrs.getZoneRefinedWGS84Vertices(zone, 0)
         if vertices:
            count = vertices.count

            printLn("")
            printx(t, "         [ ")
            for i in range(count):
               printx(", " if i else "", "[", vertices[i].lon, ", ", vertices[i].lat, "]")
            printx(", " if count else "", "[", vertices[0].lon, ", ", vertices[0].lat, "]")
            printLn(" ]")
         printx(t, "     ")
   else:
      if centroids:
         centroid = dggrs.getZoneCRSCentroid(zone, crs)
         printx(" ", centroid.x, ", ", centroid.y);
      else:
         vertices = dggrs.getZoneRefinedCRSVertices(zone, crs, 0)
         if vertices:
            count = vertices.count

            printLn("")
            printLn(t, "         [ ")

            for i in range(count):
               printx(", " if i else "", "[", vertices[i].x, ", ", vertices[i].y, "]")
            printx(", " if count else "", "[", vertices[0].x, ", ", vertices[0].y, "]")
            printLn(" ]")
         printx(t, "     ")
   printLn(" ]")
   printx(t, "   }")

def generateGeometry(dggrs, zone, options):
   if zone != nullZone:
      centroids = options.get('centroids') if options else None
      crsOption = options.get('crs') if options else None
      crs = 0

      if crsOption:
         if crsOption == "5x6":    crs = CRS(ogc, 153456)
         elif crsOption == "isea": crs = CRS(ogc, 1534)

      generateZoneFeature(dggrs, zone, crs, 0, centroids, False, None)
      printLn("")
      return 0
   else:
      printLn("geom command requires a zone")
   return 1

if __name__ == "__main__":
   dggrs = ISEA3H()

   # TODO: Parse arguments

   options = { }
   #options['crs'] = 'isea'

   zoneID = 'A4-0-A'
   zone = dggrs.getZoneFromTextID(zoneID)

   generateGeometry(dggrs, zone, options)



================================================
FILE: bindings_examples/py/info.py
================================================
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from dggal import *

app = Application(appGlobals=globals())
pydggal_setup(app)

def zoneInfo(dggrs, zone):
   centroid = GeoPoint()
   centroid = dggrs.getZoneWGS84Centroid(zone)
   area = dggrs.getZoneArea(zone)
   areaKM2 = area / 1000000
   level = dggrs.getZoneLevel(zone)
   zoneID = dggrs.getZoneTextID(zone)
   nEdges = dggrs.countZoneEdges(zone)
   depth = dggrs.get64KDepth()
   parents = dggrs.getZoneParents(zone)
   children = dggrs.getZoneChildren(zone)
   nbTypes = Array("<int>")
   neighbors = dggrs.getZoneNeighbors(zone, nbTypes)
   centroidParent = dggrs.getZoneCentroidParent(zone)
   centroidChild = dggrs.getZoneCentroidChild(zone)
   isCentroidChild = dggrs.isZoneCentroidChild(zone)

   nSubZones = dggrs.countSubZones(zone, depth)
   printLn("Zone ID: ", zoneID)
   printLn("Level ", level, " zone (", nEdges, " edges", ", centroid child)" if isCentroidChild else ")")
   printLn(nSubZones, " sub-zones at depth ", depth)
   printLn("WGS84 Centroid (lat, lon): ", centroid);
   printLn(area, " m² (", areaKM2, " km²)")

   printLn("")
   if parents.count:
      printLn("Parent", "s" if parents.count > 1 else "", " (", parents.count, "):")
      for p in parents:
         pID = dggrs.getZoneTextID(p)
         printx("   ", pID)
         if centroidParent == p:
            printx(" (centroid child)")
         printLn("");
   else:
      printLn("No parent")

   printLn("");
   printLn("Children (", children.count, "):")
   for ch in children:
      cID = dggrs.getZoneTextID(ch)
      printx("   ", cID)
      if centroidChild == ch:
         printx(" (centroid)")
      printLn("")

   printLn("")
   printLn("Neighbors (", neighbors.count, "):")
   i = 0
   for nb in neighbors:
      nID = dggrs.getZoneTextID(nb)
      printLn("   (direction ", nbTypes[i], "): ", nID)
      i += 1

def zoneGeometry(dggrs, zone):
   v = dggrs.getZoneRefinedWGS84Vertices(zone, 0)
   return v

dggrs = ISEA3H()

zoneID = "A4-0-A"
zone = dggrs.getZoneFromTextID(zoneID)

zoneInfo(dggrs, zone)
printLn("")

geom = zoneGeometry(dggrs, dggrs.getZoneFromTextID(zoneID))
printLn("Refined geometry vertices for ", zoneID, " (lon, lat):")
for v in geom:
   printLn("   [", v.lon, ", ", v.lat, "]")

subZones = dggrs.getSubZones(zone, 3)
print(subZones.getCount(), "sub-zones at depth 3:")

for z in subZones:
   printLn("   - ", dggrs.getZoneTextID(z))

depth = dggrs.get64KDepth()
index = 100
subZone = dggrs.getSubZoneAtIndex(zone, depth, index)
printLn("Sub-zone at depth ", depth, " index ", index, " is ", dggrs.getZoneTextID(subZone))

verts = dggrs.getZoneWGS84Vertices(zone)
for v in verts:
   printLn(v)
   printLn("   [", v.lon, ", ", v.lat, "]")

verts = dggrs.getZoneCRSVertices(zone, 0)
for v in verts:
   printLn(v)
   printLn("   [", v.x, ", ", v.y, "]")



================================================
FILE: bindings_examples/py/list.py
================================================
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from dggal import *

app = Application(appGlobals=globals())
pydggal_setup(app)

def parseBBox(options, bbox):
   result = True
   bboxOption = options.get('bbox') if options else None
   if bboxOption:
      s = bboxOption
      tokens = tokenizeWith(s, 4, ",", False)
      result = False
      if len(tokens) == 4:
         try:
            a = float(tokens[0])
            b = float(tokens[1])
            c = float(tokens[2])
            d = float(tokens[3])
            if a < 90 and a > -90:
               bbox.ll = (a, b)
               bbox.ur = (c, d)
               result = True
            else:
               result = False
         except ValueError:
            result = False
      if result == False:
         printLn("Invalid bounding box specified")
   return result

def listZones(dggrs, level, options = None):
   exitCode = 0
   centroids = options.get('centroids') if options is not None else None
   compact = options.get('compact') if options is not None else None
   bbox = wholeWorld

   if not parseBBox(options, bbox):
      exitCode = 1

   if compact is not None and centroids is not None:
      exitCode = 1;
      printLn("Cannot return compact list of zones as centroids")

   if level == -1:
      level = 0

   if not exitCode:
      i = 0
      zones = dggrs.listZones(level, bbox)

      if compact is not None:
         dggrs.compactZones(zones)

      printx("[");
      if zones is not None:
         for z in zones:
            printx(", " if i > 0 else " ")
            if centroids is not None:
               centroid = dggrs.getZoneWGS84Centroid(z)
               printx("[ ", centroid.lat, ", ", centroid.lon, " ]")
            else:
               zoneID = dggrs.getZoneTextID(z)
               printx("\"", zoneID, "\"")
            i += 1
      printLn(" ]")
   return 0

dggrs = ISEA3H()
# dggrs = GNOSISGlobalGrid()

# TODO: Parse arguments

level = 0
options = { }
options['bbox'] = '30,40,50,60'

listZones(dggrs, level, options)



================================================
FILE: bindings_examples/py/togeo.py
================================================
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from dggal import *
from geom import *

def convertToGeoJSON(inputFile, options):
   exitCode = 1
   f = fileOpen(inputFile, FileOpenMode.read)
   if f:
      dggsJSON = readDGGSJSON(f)
      if dggsJSON:
         dggrsClass = None

         dggrsID = getLastDirectory(dggsJSON.dggrs)

         # We could use globals()['GNOSISGlobalGrid'] to be more generic, but here we limit to DGGRSs we know
         if   not strnicmp(dggrsID, "GNOSIS", 6): dggrsClass = GNOSISGlobalGrid
         elif not strnicmp(dggrsID, "ISEA4R", 6): dggrsClass = ISEA4R
         elif not strnicmp(dggrsID, "ISEA9R", 6): dggrsClass = ISEA9R
         elif not strnicmp(dggrsID, "ISEA3H", 6): dggrsClass = ISEA3H
         elif not strnicmp(dggrsID, "ISEA7H_Z7", 9): dggrsClass = ISEA7H_Z7
         elif not strnicmp(dggrsID, "ISEA7H", 6): dggrsClass = ISEA7H
         elif not strnicmp(dggrsID, "IVEA4R", 6): dggrsClass = IVEA4R
         elif not strnicmp(dggrsID, "IVEA9R", 6): dggrsClass = IVEA9R
         elif not strnicmp(dggrsID, "IVEA3H", 6): dggrsClass = IVEA3H
         elif not strnicmp(dggrsID, "IVEA7H_Z7", 9): dggrsClass = IVEA7H_Z7
         elif not strnicmp(dggrsID, "IVEA7H", 6): dggrsClass = IVEA7H
         elif not strnicmp(dggrsID, "RTEA4R", 6): dggrsClass = RTEA4R
         elif not strnicmp(dggrsID, "RTEA9R", 6): dggrsClass = RTEA9R
         elif not strnicmp(dggrsID, "RTEA3H", 6): dggrsClass = RTEA3H
         elif not strnicmp(dggrsID, "RTEA7H_Z7", 9): dggrsClass = RTEA7H_Z7
         elif not strnicmp(dggrsID, "RTEA7H", 6): dggrsClass = RTEA7H
         elif not strnicmp(dggrsID, "HEALPix", 7): dggrsClass = HEALPix
         elif not strnicmp(dggrsID, "rHEALPix", 8): dggrsClass = rHEALPix

         if dggrsClass:
            zoneID = dggsJSON.zoneId
            dggrs = dggrsClass()
            zone = dggrs.getZoneFromTextID(zoneID)

            if zone != nullZone:
               if dggsJSON.depths:
                  maxDepth = -1

                  for d in range(dggsJSON.depths.count):
                     depth = dggsJSON.depths[d]
                     if depth > maxDepth:
                        maxDepth = depth
                        break;
                  if d < dggsJSON.depths.count:
                     depth = maxDepth
                     subZones = dggrs.getSubZones(zone, depth)
                     centroids = options.get('centroids') if options else None
                     crsOption = options.get('crs') if options else None
                     crs = 0

                     if crsOption:
                        if   crsOption == "5x6":  crs = CRS(ogc, 153456)
                        elif crsOption == "isea": crs = CRS(ogc, 1534)

                     if subZones:
                        i = 0

                        printLn("{")
                        printLn("   \"type\": \"FeatureCollection\",")
                        printx ("   \"features\": [ ")

                        for z in subZones:
                           props = { }
                           printx(", " if i else "   ")

                           # NOTE: We should eventually try to support __iter__ on containers
                           #       for key, depths in dggsJSON.values.items():
                           it = MapIterator(map = dggsJSON.values)
                           while it.next():
                              key = it.key
                              depths = it.value
                              if key and depths and depths.count > d:
                                 djDepth = depths[d]
                                 data = djDepth.data
                                 props[key] = data[i]

                           generateZoneFeature(dggrs, z, crs, i + 1, centroids, True, props)
                           i += 1
                        printLn(" ]")
                        printLn("}")
            else:
               printLn("Invalid zone ID: ", zoneID)
         else:
            printLn("Failure to recognize DGGRS")
      else:
         printLn("Failure to parse DGGS-JSON file ", inputFile)
   else:
      printLn("Failure to open file ", inputFile)
   return exitCode

# TODO: Parse arguments

#input = "A4-0-A.json"
input = "gebco-Z7-023-d6.json"
options = { }
#options['crs'] = 'isea'

convertToGeoJSON(input, options)



================================================
FILE: bindings_examples/py/togeo_json.py
================================================
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# This alternate implementation of the functions in geom.py and togeo.py converts
# a DGGS-JSON JSON dictionary to a GeoJSON JSON dictionary
# (instead of using DGGAL::readDGGSJSON() and printing to standard output)

from dggal import *

def generateZoneGeometry(dggrs, zone, crs, id, centroids: bool, fc: bool):
   coordinates = []
   if not crs or crs == CRS(ogc, 84) or crs == CRS(epsg, 4326):
      if centroids:
         centroid = dggrs.getZoneWGS84Centroid(zone, centroid)
         coordinates.append(centroid.lon.value)
         coordinates.append(centroid.lat.value)
      else:
         vertices = dggrs.getZoneRefinedWGS84Vertices(zone, 0)
         if vertices:
            contour = [ ]
            for v in vertices:
               contour.append([ v.lon.value, v.lat.value])
            contour.append([vertices[0].lon.value, vertices[0].lat.value])
            coordinates.append(contour)
   else:
      if centroids:
         centroid = dggrs.getZoneCRSCentroid(zone, crs, centroid)
         coordinates.append(centroid.x)
         coordinates.append(centroid.y)
      else:
         vertices = dggrs.getZoneRefinedCRSVertices(zone, crs, 0)
         if vertices:
            count = vertices.count
            contour = [ ]
            for v in vertices:
               contour.append([v.x, v.y])
            contour.append([vertices[0].x, vertices[0].y])
            coordinates.append(contour)
   geometry = {
      'type': 'Point' if centroids else 'Polygon',
      'coordinates': coordinates
   }
   return geometry

def generateZoneFeature(dggrs, zone, crs, id, centroids: bool, fc: bool, props):
   zoneID = dggrs.getZoneTextID(zone)

   properties = {
      'zoneID': f'{zoneID}'
   }
   if props:
      for key, v in props.items():
         properties[key] = v

   features = {
      'type': 'Feature',
      'id': id if id is not None else zoneID,
      'geometry': generateZoneGeometry(dggrs, zone, crs, id, centroids, fc),
      'properties': properties
   }
   return features

def dggsJSON2GeoJSON(dggsJSON, crs: CRS = None, centroids: bool = False):
   result = None
   if dggsJSON is not None:
         dggrsClass = None
         dggrsID = getLastDirectory(dggsJSON['dggrs'])

         # We could use globals()['GNOSISGlobalGrid'] to be more generic, but here we limit to DGGRSs we know
         if   not strnicmp(dggrsID, "GNOSIS", 6): dggrsClass = GNOSISGlobalGrid
         elif not strnicmp(dggrsID, "ISEA4R", 6): dggrsClass = ISEA4R
         elif not strnicmp(dggrsID, "ISEA9R", 6): dggrsClass = ISEA9R
         elif not strnicmp(dggrsID, "ISEA3H", 6): dggrsClass = ISEA3H
         elif not strnicmp(dggrsID, "ISEA7H", 6): dggrsClass = ISEA7H
         elif not strnicmp(dggrsID, "IVEA4R", 6): dggrsClass = IVEA4R
         elif not strnicmp(dggrsID, "IVEA9R", 6): dggrsClass = IVEA9R
         elif not strnicmp(dggrsID, "IVEA3H", 6): dggrsClass = IVEA3H
         elif not strnicmp(dggrsID, "IVEA7H", 6): dggrsClass = IVEA7H
         elif not strnicmp(dggrsID, "RTEA4R", 6): dggrsClass = RTEA4R
         elif not strnicmp(dggrsID, "RTEA9R", 6): dggrsClass = RTEA9R
         elif not strnicmp(dggrsID, "RTEA3H", 6): dggrsClass = RTEA3H
         elif not strnicmp(dggrsID, "RTEA7H", 6): dggrsClass = RTEA7H
         elif not strnicmp(dggrsID, "HEALPix", 7): dggrsClass = HEALPix
         elif not strnicmp(dggrsID, "rHEALPix", 8): dggrsClass = rHEALPix

         if dggrsClass:
            zoneID = dggsJSON['zoneId']
            dggrs = dggrsClass()
            zone = dggrs.getZoneFromTextID(zoneID)

            if zone != nullZone:
                depths = dggsJSON['depths']
                if depths:
                  maxDepth = -1

                  for d in range(len(depths)):
                     depth = depths[d]
                     if depth > maxDepth:
                        maxDepth = depth
                        break;
                  if d < len(depths):
                     depth = maxDepth
                     subZones = dggrs.getSubZones(zone, depth)
                     if subZones:
                        i = 0
                        values = dggsJSON['values']
                        features = [ ]
                        for z in subZones:
                           props = { }

                           # NOTE: We should eventually try to support __iter__ on containers
                           #       for key, depths in dggsJSON.values.items():
                           for key, vDepths in values.items():
                              if key and vDepths and len(vDepths) > d:
                                 djDepth = vDepths[d]
                                 data = djDepth['data']
                                 props[key] = data[i]

                           features.append(generateZoneFeature(dggrs, z, crs, i + 1, centroids, True, props))
                           i += 1
                        result = {
                           'type': 'FeatureCollection',
                           'features': features
                        }
   return result



================================================
FILE: bindings_examples/py/togeo_text.py
================================================
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from dggal import *

# This alternate implementation of the functions in geom.py and togeo.py converts
# a DGGS-JSON JSON dictionary to a GeoJSON JSON text string
# (instead of using DGGAL::readDGGSJSON() and printing to standard output)

def generateZoneFeature(dggrs, zone, crs, id, centroids: bool, fc: bool, properties):
   t = "   " if fc else ""

   zoneID = dggrs.getZoneTextID(zone)

   features = '{\n'
   features = features + t + '   "type" : "Feature",\n'
   features = features + t + '   "id" : '
   if id:
      features = features + f'"{id}"'
   else:
      features = features + zoneID
   features = features + ',\n'
   features = features + generateZoneGeometry(dggrs, zone, crs, id, centroids, fc)
   features = features + ',\n'
   features = features + t + '   "properties" : {\n'
   features = features + t + f'     "zoneID" : "{zoneID}"'
   if properties:
      for key, v in properties.items():
         features = features + ',\n' + t + f'     "{key}" : {v}'

   features = features + '\n'
   features = features + t + '   }\n'
   features = features + t + '}'
   return features

def generateZoneGeometry(dggrs, zone, crs, id, centroids: bool, fc: bool):
   t = "   " if fc else ""

   geometry = t + '   "geometry" : {\n'
   geometry = geometry + t + '      "type" : "' + ('Point' if centroids else 'Polygon') + '",\n'
   geometry = geometry + t + '      "coordinates" : [\n'

   if not crs or crs == CRS(ogc, 84) or crs == CRS(epsg, 4326):
      if centroids:
         centroid = dggrs.getZoneWGS84Centroid(zone, centroid)
         geometry = geometry + " " + f"{centroid.lon}, {centroid.lat}"
      else:
         vertices = dggrs.getZoneRefinedWGS84Vertices(zone, 0)
         if vertices:
            count = vertices.count

            geometry = geometry + "\n"
            geometry = geometry + t + "         [ "
            for i in range(count):
               geometry = geometry + (", " if i else "") + f"[{vertices[i].lon}, {vertices[i].lat}]"
            geometry = geometry + (", " if i else "") + f"[{vertices[0].lon}, {vertices[0].lat}]"
            geometry = geometry + " ]\n"
         geometry = geometry + t + "     "
   else:
      if centroids:
         centroid = dggrs.getZoneCRSCentroid(zone, crs, centroid)
         geometry = geometry + f" {centroid.x}, {centroid.y}"
      else:
         vertices = dggrs.getZoneRefinedCRSVertices(zone, crs, 0)
         if vertices:
            count = vertices.count

            geometry = geometry + "\n"
            geometry = geometry + t + "         [ \n"

            for i in range(count):
               geometry = geometry + (", " if i else "") + f"[{vertices[i].x}, {vertices[i].y}]"
            geometry = geometry + (", " if i else "") + f"[{vertices[0].x}, {vertices[0].y}]"
            geometry = geometry + " ]\n"
         geometry = geometry + t + "     "
   geometry = geometry + " ]\n"
   geometry = geometry + t + "   }"
   return geometry

def dggsJSON2GeoJSON(dggsJSON, crs: CRS = None, centroids: bool = False):
   result = None
   if dggsJSON is not None:
         dggrsClass = None
         dggrsID = getLastDirectory(dggsJSON['dggrs'])

         # We could use globals()['GNOSISGlobalGrid'] to be more generic, but here we limit to DGGRSs we know
         if   not strnicmp(dggrsID, "GNOSIS", 6): dggrsClass = GNOSISGlobalGrid
         elif not strnicmp(dggrsID, "ISEA4R", 6): dggrsClass = ISEA4R
         elif not strnicmp(dggrsID, "ISEA9R", 6): dggrsClass = ISEA9R
         elif not strnicmp(dggrsID, "ISEA3H", 6): dggrsClass = ISEA3H
         elif not strnicmp(dggrsID, "ISEA7H", 6): dggrsClass = ISEA7H
         elif not strnicmp(dggrsID, "IVEA4R", 6): dggrsClass = IVEA4R
         elif not strnicmp(dggrsID, "IVEA9R", 6): dggrsClass = IVEA9R
         elif not strnicmp(dggrsID, "IVEA3H", 6): dggrsClass = IVEA3H
         elif not strnicmp(dggrsID, "IVEA7H", 6): dggrsClass = IVEA7H
         elif not strnicmp(dggrsID, "RTEA4R", 6): dggrsClass = RTEA4R
         elif not strnicmp(dggrsID, "RTEA9R", 6): dggrsClass = RTEA9R
         elif not strnicmp(dggrsID, "RTEA3H", 6): dggrsClass = RTEA3H
         elif not strnicmp(dggrsID, "RTEA7H", 6): dggrsClass = RTEA7H
         elif not strnicmp(dggrsID, "HEALPix", 7): dggrsClass = HEALPix
         elif not strnicmp(dggrsID, "rHEALPix", 8): dggrsClass = rHEALPix

         if dggrsClass:
            zoneID = dggsJSON['zoneId']
            dggrs = dggrsClass()
            zone = dggrs.getZoneFromTextID(zoneID)

            if zone != nullZone:
                depths = dggsJSON['depths']
                if depths:
                  maxDepth = -1

                  for d in range(len(depths)):
                     depth = depths[d]
                     if depth > maxDepth:
                        maxDepth = depth
                        break;
                  if d < len(depths):
                     depth = maxDepth
                     subZones = dggrs.getSubZones(zone, depth)
                     if subZones:
                        i = 0
                        collection = "{\n"
                        collection = collection + "   \"type\": \"FeatureCollection\",\n"
                        collection = collection + "   \"features\": [ "

                        values = dggsJSON['values']
                        for z in subZones:
                           props = { }
                           collection = collection + (", " if i else "   ")

                           # NOTE: We should eventually try to support __iter__ on containers
                           #       for key, depths in dggsJSON.values.items():
                           for key, vDepths in values.items():
                              if key and vDepths and len(vDepths) > d:
                                 djDepth = vDepths[d]
                                 data = djDepth['data']
                                 props[key] = data[i]

                           collection = collection + generateZoneFeature(dggrs, z, crs, i + 1, centroids, True, props)
                           i += 1
                        collection = collection + " ]\n"
                        collection = collection + "}\n"
                        result = collection
   return result



================================================
FILE: bindings_examples/rust/geom.rs
================================================
#[cfg(feature = "geom_cmd")]
use std::env;

#[cfg(feature = "geom_cmd")]
use std::process::exit;

use std::collections::HashMap;
use std::f64::consts::PI;
use std::ffi::CStr;

extern crate ecrt;

#[cfg(feature = "geom_cmd")]
use ecrt::Application;

use ecrt::FieldValue;
use ecrt::FieldTypeEx;
use ecrt::FieldType;

extern crate dggal;

#[cfg(feature = "geom_cmd")]
use dggal::DGGAL;

#[cfg(feature = "geom_cmd")]
use dggal::nullZone;

use dggal::DGGRS;
use dggal::DGGRSZone;

use dggal::CRS;
use dggal::ogc;
use dggal::epsg;

pub fn resolve_crs_string(crs_option: Option<&&str>) -> CRS
{
   let mut crs = CRS(0);
   if crs_option.is_some() {
      let str = crs_option.unwrap();
      // NOTE: Currently re-using the same CRS identifiers regardless of actual projection for 5x6 and icosahedron net space
           if str.eq_ignore_ascii_case("5x6" )       { crs = CRS!(ogc, 153456); }
      else if str.eq_ignore_ascii_case("ico") ||
              str.eq_ignore_ascii_case("isea") ||
              str.eq_ignore_ascii_case("ivea") ||
              str.eq_ignore_ascii_case("rtea")       { crs = CRS!(ogc, 1534); }
      else if str.eq_ignore_ascii_case("OGC:CRS84")  { crs = CRS!(ogc, 84); }
      else if str.eq_ignore_ascii_case("EPSG:4326")  { crs = CRS!(epsg, 4326); }
      else if str.eq_ignore_ascii_case("rhp") ||
              str.eq_ignore_ascii_case("hpx") ||
              str.eq_ignore_ascii_case("hlp")        { crs = CRS!(ogc, 99999); }
   }
   return crs;
}

pub fn generate_zone_feature(dggrs: &DGGRS, zone : DGGRSZone, crs: CRS, id: u64, centroids: bool, fc: bool, properties: Option<&HashMap<String, FieldValue>>)
{
   let t = if fc { "   " } else { "" };
   let zone_id = dggrs.getZoneTextID(zone);

   println!("{{");
   println!("{t}   \"type\" : \"Feature\",");
   print!("{t}   \"id\" : ");
   if id != 0 {
      print!("{id}");
   }
   else {
      print!("\"{zone_id}\"");
   }
   println!(",");

   generate_zone_geometry(dggrs, zone, crs, centroids, fc);

   println!(",");

   println!("{t}   \"properties\" : {{");
   print!("{t}     \"zone_id\" : \"");
   print!("{zone_id}");
   print!("\"");
   if properties.is_some() {
      for (key, v) in properties.unwrap() {
         print!(",\n{t}     \"{key}\" : ");
         unsafe
         {
            match FieldTypeEx(v.type_).type_() {
               FieldType::Real    => print!("{}", v.__bindgen_anon_1.r),
               FieldType::Text    => print!("{}", CStr::from_ptr(v.__bindgen_anon_1.s).to_str().unwrap()),
               FieldType::Integer => print!("{}", v.__bindgen_anon_1.i),
               _ => todo!()
            }
         }
      }
   }

   println!("");
   println!("{t}   }}");
   print!("{t}}}");
}

pub fn generate_zone_geometry(dggrs: &DGGRS, zone: DGGRSZone, crs: CRS, centroids: bool, fc: bool)
{
   let t = if fc { "   " } else { "" };

   println!("{t}   \"geometry\" : {{");
   println!("{t}      \"type\" : \"{}\",", if centroids { "Point" } else { "Polygon" });
   print!("{t}      \"coordinates\" : [");

   if crs == 0 || crs == CRS!(ogc, 84) || crs == CRS!(epsg, 4326) {
      if centroids {
         let centroid = dggrs.getZoneWGS84Centroid(zone);
         print!(" {}, {}", centroid.lon * 180.0 / PI, centroid.lat * 180.0 / PI);
      }
      else {
         let vertices = dggrs.getZoneRefinedWGS84Vertices(zone, 0);
         let count = vertices.len();
         if count != 0 {
            println!("");
            print!("{t}         [ ");
            for i in 0..count {
               print!("{}[{}, {}]", if i != 0 { ", " } else { "" }, vertices[i].lon * 180.0 / PI, vertices[i].lat * 180.0 / PI);
            }
            print!("{}[{}, {}]", if count != 0  { ", " } else { "" }, vertices[0].lon * 180.0 / PI, vertices[0].lat * 180.0 / PI);
            println!(" ]");
         }
         print!("{t}     ");
      }
   }
   else {
      if centroids {
         let centroid = dggrs.getZoneCRSCentroid(zone, crs);
         print!(" {}, {}", centroid.x, centroid.y);
      }
      else {
         let vertices = dggrs.getZoneRefinedCRSVertices(zone, crs, 0);
         let count = vertices.len();
         if count != 0 {

            println!("");
            println!("{t}         [ ");

            for i in 0..count {
               print!("{}[{}, {}]", if i != 0  { ", " } else { "" }, vertices[i].x, vertices[i].y);
            }
            print!("{}[{}, {}]", if count != 0  { ", " } else { "" }, vertices[0].x, vertices[0].y);
            println!(" ]");
         }
         print!("{t}     ");
      }
   }
   println!(" ]");
   print!("{t}   }}");
}

#[cfg(feature = "geom_cmd")]
pub fn generate_geometry(dggrs: &DGGRS, zone: DGGRSZone, options: &HashMap::<&str, &str>) -> i32
{
   if zone != nullZone {
      let centroids = options.get("centroids");
      let crs = resolve_crs_string(options.get("crs"));
      generate_zone_feature(dggrs, zone, crs, 0, centroids.is_some(), false, None);
      println!("");
      return 0;
   }
   else {
      println!("geom command requires a zone");
   }
   return 1;
}

#[cfg(feature = "geom_cmd")]
fn main()
{
   let args: Vec<String> = env::args().collect();
   let argc = args.len();
   let my_app = Application::new(&args);
   let dggal = DGGAL::new(&my_app);
   let mut exit_code: i32 = 0;
   let mut show_syntax = false;
   let mut dggrs_name = "";
   let mut a : usize = 1;
   let arg0: &str = &args[0];
   let mut options = HashMap::<&str, &str>::new();
   let mut zone_id: &str = "";
   let mut zone: DGGRSZone = nullZone;

        if arg0.eq_ignore_ascii_case("i4r") { dggrs_name = &"ISEA4R"; }
   else if arg0.eq_ignore_ascii_case("i9r") { dggrs_name = &"ISEA9R"; }
   else if arg0.eq_ignore_ascii_case("i3h") { dggrs_name = &"ISEA3H"; }
   else if arg0.eq_ignore_ascii_case("i7h") { dggrs_name = &"ISEA7H"; }
   else if arg0.eq_ignore_ascii_case("iz7") { dggrs_name = &"ISEA7H_Z7"; }
   else if arg0.eq_ignore_ascii_case("v4r") { dggrs_name = &"IVEA4R"; }
   else if arg0.eq_ignore_ascii_case("v9r") { dggrs_name = &"IVEA9R"; }
   else if arg0.eq_ignore_ascii_case("v3h") { dggrs_name = &"IVEA3H"; }
   else if arg0.eq_ignore_ascii_case("v7h") { dggrs_name = &"IVEA7H"; }
   else if arg0.eq_ignore_ascii_case("vz7") { dggrs_name = &"IVEA7H_Z7"; }
   else if arg0.eq_ignore_ascii_case("r4r") { dggrs_name = &"RTEA4R"; }
   else if arg0.eq_ignore_ascii_case("r9r") { dggrs_name = &"RTEA9R"; }
   else if arg0.eq_ignore_ascii_case("r3h") { dggrs_name = &"RTEA3H"; }
   else if arg0.eq_ignore_ascii_case("r7h") { dggrs_name = &"RTEA7H"; }
   else if arg0.eq_ignore_ascii_case("rz7") { dggrs_name = &"RTEA7H_Z7"; }
   else if arg0.eq_ignore_ascii_case("rhp") { dggrs_name = &"rHEALPix"; }
   else if arg0.eq_ignore_ascii_case("hpx") { dggrs_name = &"HEALPix"; }
   else if arg0.eq_ignore_ascii_case("ggg") { dggrs_name = &"GNOSISGlobalGrid"; }

   if dggrs_name == "" && argc > 1 {
      let arg1: &str = &args[1];
           if arg1.eq_ignore_ascii_case("isea4r") { dggrs_name = &"ISEA4R"; }
      else if arg1.eq_ignore_ascii_case("isea9r") { dggrs_name = &"ISEA9R"; }
      else if arg1.eq_ignore_ascii_case("isea3h") { dggrs_name = &"ISEA3H"; }
      else if arg1.eq_ignore_ascii_case("isea7h") { dggrs_name = &"ISEA7H"; }
      else if arg1.eq_ignore_ascii_case("isea7h_z7") { dggrs_name = &"ISEA7H_Z7"; }
      else if arg1.eq_ignore_ascii_case("ivea4r") { dggrs_name = &"IVEA4R"; }
      else if arg1.eq_ignore_ascii_case("ivea9r") { dggrs_name = &"IVEA9R"; }
      else if arg1.eq_ignore_ascii_case("ivea3h") { dggrs_name = &"IVEA3H"; }
      else if arg1.eq_ignore_ascii_case("ivea7h") { dggrs_name = &"IVEA7H"; }
      else if arg1.eq_ignore_ascii_case("ivea7h_z7") { dggrs_name = &"IVEA7H_Z7"; }
      else if arg1.eq_ignore_ascii_case("rtea4r") { dggrs_name = &"RTEA4R"; }
      else if arg1.eq_ignore_ascii_case("rtea9r") { dggrs_name = &"RTEA9R"; }
      else if arg1.eq_ignore_ascii_case("rtea3h") { dggrs_name = &"RTEA3H"; }
      else if arg1.eq_ignore_ascii_case("rtea7h") { dggrs_name = &"RTEA7H"; }
      else if arg1.eq_ignore_ascii_case("rtea7h_z7") { dggrs_name = &"RTEA7H_Z7"; }
      else if arg1.eq_ignore_ascii_case("rHEALPIx") { dggrs_name = &"rHEALPix"; }
      else if arg1.eq_ignore_ascii_case("HEALPIx") { dggrs_name = &"HEALPix"; }
      else if arg1.eq_ignore_ascii_case("gnosis") { dggrs_name = &"GNOSISGlobalGrid"; }
      a += 1;
   }

   if argc > a {
      zone_id = &args[a];
      a+=1;
   }

   while a < argc {
      let key = &args[a];
      a+=1;
      if key.as_bytes()[0] == '-' as u8 {
         let k = &key[1..];
         if k == "crs" {
            if a < argc {
               options.insert(k, &args[a]);
               a+=1;
            }
            else {
               exit_code = 1;
               show_syntax = true;
            }
         }
         else {
            options.insert(k, "");
         }
      }
      else
      {
         exit_code = 1;
         show_syntax = true;
      }
   }

   if dggrs_name != "" && exit_code == 0 {
      let dggrs: DGGRS = DGGRS::new(&dggal, dggrs_name).expect("Unknown DGGRS");

      // println!("DGGRS: https://maps.gnosis.earth/ogcapi/dggrs/{dggrs_name}");

      if zone_id != "" {
         zone = dggrs.getZoneFromTextID(zone_id);
         if zone == nullZone
         {
            println!("Invalid {dggrs_name} zone identifier: {zone_id}");
            exit_code = 1;
         }
      }

      if exit_code == 0 {
         generate_geometry(&dggrs, zone, &options);
      }
   }
   else {
      show_syntax = true;
      exit_code = 1;
   }

   if show_syntax {
      println!("Syntax:");
      println!("   geom <dggrs> <zone> [options]");
      println!("where dggrs is one of gnosis, isea(4r/9r/3h/7h/7h_z7), ivea(4r/9r/3h/7h/7h_z7), rtea(4r/9r/3h/7h/7h_z7), HEALPix, rHEALPix");
   }

   exit(exit_code)
}



================================================
FILE: bindings_examples/rust/info.rs
================================================
extern crate ecrt;

#[cfg(feature = "info_cmd")]
use ecrt::Application;

extern crate dggal;

#[cfg(feature = "info_cmd")]
use dggal::DGGAL;

#[cfg(feature = "info_cmd")]
use std::env;

#[cfg(feature = "info_cmd")]
use std::process::exit;

use dggal::DGGRS;
use dggal::DGGRSZone;
use dggal::GeoExtent;
use dggal::GeoPoint;
use dggal::nullZone;

use std::collections::HashMap;
use std::f64::consts::PI;

pub fn zone_info(dggrs: DGGRS, zone: DGGRSZone, options: HashMap<&str, &str>) -> i32
{
   let level = dggrs.getZoneLevel(zone);
   let n_edges = dggrs.countZoneEdges(zone);
   let centroid = dggrs.getZoneWGS84Centroid(zone);
   let extent: GeoExtent = dggrs.getZoneWGS84Extent(zone);
   let vertices: Vec<GeoPoint> = dggrs.getZoneWGS84Vertices(zone);
   let zone_id: String = dggrs.getZoneTextID(zone);
   let area: f64 = dggrs.getZoneArea(zone);
   let area_km2: f64 = area / 1000000.0;
   let mut depth: i32 = dggrs.get64KDepth();
   let parents = dggrs.getZoneParents(zone);
   let mut nb_types: [i32; 6] = [0; 6];
   let neighbors = dggrs.getZoneNeighbors(zone, &mut nb_types);
   let children = dggrs.getZoneChildren(zone);
   let centroid_parent: DGGRSZone = dggrs.getZoneCentroidParent(zone);
   let centroid_child: DGGRSZone = dggrs.getZoneCentroidChild(zone);
   let is_centroid_child = dggrs.isZoneCentroidChild(zone);
   let crs = &"EPSG:4326";
   let depth_option = options.get(&"depth");

   if depth_option != None
   {
      let max_depth: i32 = dggrs.getMaxDepth();
      depth = depth_option.unwrap().parse::<i32>().unwrap();
      if depth > max_depth
      {
         println!("Invalid depth (maximum: {max_depth})");
         return 1;
      }
   }

   let n_sub_zones: u64 = dggrs.countSubZones(zone, depth);

   println!("Textual Zone ID: {zone_id}");
   println!("64-bit integer ID: {zone} (0x{zone:X})");
   println!("");
   println!("Level {level} zone ({n_edges} edges{0})", if is_centroid_child { ", centroid child" } else { "" });
   println!("{area} m² ({area_km2} km²)");
   println!("{n_sub_zones} sub-zones at depth {depth}");

   println!("WGS84 Centroid (lat, lon): {0}, {1}",
      centroid.lat * 180.0 / PI, centroid.lon * 180.0 / PI);
   println!("WGS84 Extent (lat, lon): {{ {0}, {1} }}, {{ {2}, {3} }}",
      extent.ll.lat * 180.0 / PI, extent.ll.lon * 180.0 / PI,
      extent.ur.lat * 180.0 / PI, extent.ur.lon * 180.0 / PI);
   println!("");

   let n_parents = parents.len();
   if n_parents != 0
   {
      println!("Parent{0} ({n_parents}):", if n_parents > 1 { "s" } else { "" });
      for p in parents
      {
         let p_id = dggrs.getZoneTextID(p);
         print!("   {p_id}");
         if centroid_parent == p {
            print!(" (centroid child)");
         }
         println!("");
      }
   }
   else {
      println!("No parent");
   }
   println!("");

   println!("Children ({0}):", children.len());
   for c in children
   {
      let c_id = dggrs.getZoneTextID(c);
      print!("   {c_id}");
      if centroid_child == c {
         print!(" (centroid)");
      }
      println!("");
   }
   println!("");

   println!("Neighbors ({0}):", neighbors.len());

   let mut i: usize = 0;
   for n in neighbors
   {
      let n_id = dggrs.getZoneTextID(n);
      let nt = nb_types[i];
      println!("   (direction {nt}): {n_id}");
      i += 1;
   }
   println!("");
   println!("[{crs}] Vertices ({0}):", vertices.len());

   for v in vertices
   {
      let lat = v.lat * 180.0 / PI;
      let lon = v.lon * 180.0 / PI;
      println!("   {lat}, {lon}");
   }

   0 // No error
}

pub fn dggrs_info(dggrs: DGGRS, _options: HashMap<&str, &str>) -> i32
{
   let depth64k = dggrs.get64KDepth();
   let ratio = dggrs.getRefinementRatio();
   let max_level = dggrs.getMaxDGGRSZoneLevel();

   println!("Refinement Ratio: {ratio}");
   println!("Maximum level for 64-bit global identifiers (DGGAL DGGRSZone): {max_level}");
   println!("Default ~64K sub-zones relative depth: {depth64k}");
   0 // No error
}

pub fn display_info(dggrs: DGGRS, zone: DGGRSZone, options: HashMap<&str, &str>) -> i32
{
   if zone != nullZone {
      zone_info(dggrs, zone, options)
   } else {
      dggrs_info(dggrs, options)
   }
}

#[cfg(feature = "info_cmd")]
fn main()
{
   let args: Vec<String> = env::args().collect();
   let argc = args.len();
   let my_app = Application::new(&args);
   let dggal = DGGAL::new(&my_app);
   let mut exit_code: i32 = 0;
   let mut show_syntax = false;
   let mut dggrs_name = "";
   let mut a : usize = 1;
   let mut zone_id: &str = "";
   let arg0: &str = &args[0];
   let mut options = HashMap::<&str, &str>::new();

        if arg0.eq_ignore_ascii_case("i4r") { dggrs_name = &"ISEA4R"; }
   else if arg0.eq_ignore_ascii_case("i9r") { dggrs_name = &"ISEA9R"; }
   else if arg0.eq_ignore_ascii_case("i3h") { dggrs_name = &"ISEA3H"; }
   else if arg0.eq_ignore_ascii_case("i7h") { dggrs_name = &"ISEA7H"; }
   else if arg0.eq_ignore_ascii_case("iz7") { dggrs_name = &"ISEA7H_Z7"; }
   else if arg0.eq_ignore_ascii_case("v4r") { dggrs_name = &"IVEA4R"; }
   else if arg0.eq_ignore_ascii_case("v9r") { dggrs_name = &"IVEA9R"; }
   else if arg0.eq_ignore_ascii_case("v3h") { dggrs_name = &"IVEA3H"; }
   else if arg0.eq_ignore_ascii_case("v7h") { dggrs_name = &"IVEA7H"; }
   else if arg0.eq_ignore_ascii_case("vz7") { dggrs_name = &"IVEA7H_Z7"; }
   else if arg0.eq_ignore_ascii_case("r4r") { dggrs_name = &"RTEA4R"; }
   else if arg0.eq_ignore_ascii_case("r9r") { dggrs_name = &"RTEA9R"; }
   else if arg0.eq_ignore_ascii_case("r3h") { dggrs_name = &"RTEA3H"; }
   else if arg0.eq_ignore_ascii_case("r7h") { dggrs_name = &"RTEA7H"; }
   else if arg0.eq_ignore_ascii_case("rz7") { dggrs_name = &"RTEA7H_Z7"; }
   else if arg0.eq_ignore_ascii_case("rhp") { dggrs_name = &"rHEALPix"; }
   else if arg0.eq_ignore_ascii_case("hpx") { dggrs_name = &"HEALPix"; }
   else if arg0.eq_ignore_ascii_case("ggg") { dggrs_name = &"GNOSISGlobalGrid"; }

   if dggrs_name == "" && argc > 1 {
      let arg1: &str = &args[1];
           if arg1.eq_ignore_ascii_case("isea4r") { dggrs_name = &"ISEA4R"; }
      else if arg1.eq_ignore_ascii_case("isea9r") { dggrs_name = &"ISEA9R"; }
      else if arg1.eq_ignore_ascii_case("isea3h") { dggrs_name = &"ISEA3H"; }
      else if arg1.eq_ignore_ascii_case("isea7h") { dggrs_name = &"ISEA7H"; }
      else if arg1.eq_ignore_ascii_case("isea7h_z7") { dggrs_name = &"ISEA7H_Z7"; }
      else if arg1.eq_ignore_ascii_case("ivea4r") { dggrs_name = &"IVEA4R"; }
      else if arg1.eq_ignore_ascii_case("ivea9r") { dggrs_name = &"IVEA9R"; }
      else if arg1.eq_ignore_ascii_case("ivea3h") { dggrs_name = &"IVEA3H"; }
      else if arg1.eq_ignore_ascii_case("ivea7h") { dggrs_name = &"IVEA7H"; }
      else if arg1.eq_ignore_ascii_case("ivea7h_z7") { dggrs_name = &"IVEA7H_Z7"; }
      else if arg1.eq_ignore_ascii_case("rtea4r") { dggrs_name = &"RTEA4R"; }
      else if arg1.eq_ignore_ascii_case("rtea9r") { dggrs_name = &"RTEA9R"; }
      else if arg1.eq_ignore_ascii_case("rtea3h") { dggrs_name = &"RTEA3H"; }
      else if arg1.eq_ignore_ascii_case("rtea7h") { dggrs_name = &"RTEA7H"; }
      else if arg1.eq_ignore_ascii_case("rtea7h_z7") { dggrs_name = &"RTEA7H_Z7"; }
      else if arg1.eq_ignore_ascii_case("rHEALPIx") { dggrs_name = &"rHEALPix"; }
      else if arg1.eq_ignore_ascii_case("HEALPIx") { dggrs_name = &"HEALPix"; }
      else if arg1.eq_ignore_ascii_case("gnosis") { dggrs_name = &"GNOSISGlobalGrid"; }
      a += 1;
   }

   if argc > a {
      zone_id = &args[a];
      a+=1;
   }

   while a < argc
   {
      let key = &args[a];
      a+=1;
      if key.as_bytes()[0] == '-' as u8 && a < argc
      {
         options.insert(&key[1..], &args[a]);
         a+=1;
      }
      else
      {
         exit_code = 1;
         show_syntax = true;
      }
   }

   if dggrs_name != "" && exit_code == 0
   {
      let dggrs: DGGRS = DGGRS::new(&dggal, dggrs_name).expect("Unknown DGGRS");
      let mut zone = nullZone;

      println!("DGGRS: https://maps.gnosis.earth/ogcapi/dggrs/{dggrs_name}");

      if zone_id != "" {
         zone = dggrs.getZoneFromTextID(zone_id);
         if zone == nullZone
         {
            println!("Invalid {dggrs_name} zone identifier: {zone_id}");
            exit_code = 1;
         }
      }

      if exit_code == 0 {
         display_info(dggrs, zone, options);
      }
   }
   else
   {
      show_syntax = true;
      exit_code = 1;
   }

   if show_syntax {
      println!("Syntax:");
      println!("   info <dggrs> [zone] [options]");
      println!("where dggrs is one of gnosis, isea(4r/9r/3h/7h/7h_z7), ivea(4r/9r/3h/7h/7h_z7), rtea(4r/9r/3h/7h/7h_z7), HEALPix, rHEALPix");
   }

   exit(exit_code)
}



================================================
FILE: bindings_examples/rust/list.rs
================================================
extern crate ecrt;

use ecrt::Application;
use ecrt::tokenizeWith;

extern crate dggal;

use dggal::DGGAL;
use dggal::DGGRS;
// use dggal::DGGRSZone;
//use dggal::nullZone;
use dggal::GeoExtent;
use dggal::GeoPoint;
use dggal::wholeWorld;

use std::collections::HashMap;
use std::env;
use std::process::exit;
use std::f64::consts::PI;

fn parse_bbox(options: &HashMap<&str, &str>, bbox: &mut GeoExtent) -> bool
{
   let mut result = true;
   let bbox_option = options.get(&"bbox");
   if bbox_option != None {
      let s = bbox_option.unwrap();
      // NOTE: tokenizeWith() will eventually be moved to ecrt crate
      let tokens: Vec<String> = tokenizeWith::<4>(s, ",", false);
      result = false;
      if tokens.len() == 4 {
         let a = tokens[0].parse::<f64>();
         let b = tokens[1].parse::<f64>();
         let c = tokens[2].parse::<f64>();
         let d = tokens[3].parse::<f64>();
         if a.is_ok() && b.is_ok() && c.is_ok() && d.is_ok() {
            let af = a.unwrap();
            let bf = b.unwrap();
            let cf = c.unwrap();
            let df = d.unwrap();
            if af < 90.0 && af > -90.0 {
               bbox.ll = GeoPoint { lat: af * PI / 180.0, lon: bf * PI / 180.0 };
               bbox.ur = GeoPoint { lat: cf * PI / 180.0, lon: df * PI / 180.0 };
               result = true;
            }
            else {
               result = false;
            }
         }
         else {
            result = false;
         }
      }
      if result == false {
         println!("Invalid bounding box specified");
      }
   }
   return result;
}

fn list_zones(dggrs: DGGRS, mut level: i32, options: &HashMap<&str, &str>) -> i32
{
   let mut exit_code = 0;
   let centroids = options.get(&"centroids");
   let compact = options.get(&"compact");
   let mut bbox = wholeWorld;

   if !parse_bbox(options, &mut bbox) {
      exit_code = 1
   }

   if compact != None && centroids != None {
      exit_code = 1;
      println!("Cannot return compact list of zones as centroids")
   }

   if level == -1 {
      level = 0;
   }

   if exit_code == 0 {
      let mut i = 0;
      let mut zones = dggrs.listZones(level, &bbox);

      if compact != None {
         dggrs.compactZones(&mut zones);
      }

      print!("[");
      for z in zones {
         print!("{}", if i > 0 { ", " } else { " " });
         if centroids != None {
            let centroid = dggrs.getZoneWGS84Centroid(z);
            print!("[ {}, {} ]", centroid.lat * 180.0 / PI, centroid.lon * 180.0 / PI);
         }
         else {
            let zone_id = dggrs.getZoneTextID(z);
            print!("\"{zone_id}\"");
         }
         i += 1;
      }
      println!(" ]");
   }
   return exit_code;
}

fn main()
{
   let args: Vec<String> = env::args().collect();
   let argc = args.len();
   let my_app = Application::new(&args);
   let dggal = DGGAL::new(&my_app);
   let mut exit_code: i32 = 0;
   let mut show_syntax = false;
   let mut dggrs_name = "";
   let mut a : usize = 1;
   let mut level: i32 = -1;
   let arg0: &str = &args[0];
   let mut options = HashMap::<&str, &str>::new();

        if arg0.eq_ignore_ascii_case("i4r") { dggrs_name = &"ISEA4R"; }
   else if arg0.eq_ignore_ascii_case("i9r") { dggrs_name = &"ISEA9R"; }
   else if arg0.eq_ignore_ascii_case("i3h") { dggrs_name = &"ISEA3H"; }
   else if arg0.eq_ignore_ascii_case("i7h") { dggrs_name = &"ISEA7H"; }
   else if arg0.eq_ignore_ascii_case("iz7") { dggrs_name = &"ISEA7H_Z7"; }
   else if arg0.eq_ignore_ascii_case("v4r") { dggrs_name = &"IVEA4R"; }
   else if arg0.eq_ignore_ascii_case("v9r") { dggrs_name = &"IVEA9R"; }
   else if arg0.eq_ignore_ascii_case("v3h") { dggrs_name = &"IVEA3H"; }
   else if arg0.eq_ignore_ascii_case("v7h") { dggrs_name = &"IVEA7H"; }
   else if arg0.eq_ignore_ascii_case("vz7") { dggrs_name = &"IVEA7H_Z7"; }
   else if arg0.eq_ignore_ascii_case("r4r") { dggrs_name = &"RTEA4R"; }
   else if arg0.eq_ignore_ascii_case("r9r") { dggrs_name = &"RTEA9R"; }
   else if arg0.eq_ignore_ascii_case("r3h") { dggrs_name = &"RTEA3H"; }
   else if arg0.eq_ignore_ascii_case("r7h") { dggrs_name = &"RTEA7H"; }
   else if arg0.eq_ignore_ascii_case("rz7") { dggrs_name = &"RTEA7H_Z7"; }
   else if arg0.eq_ignore_ascii_case("rhp") { dggrs_name = &"rHEALPix"; }
   else if arg0.eq_ignore_ascii_case("hpx") { dggrs_name = &"HEALPix"; }
   else if arg0.eq_ignore_ascii_case("ggg") { dggrs_name = &"GNOSISGlobalGrid"; }

   if dggrs_name == "" && argc > 1 {
      let arg1: &str = &args[1];
           if arg1.eq_ignore_ascii_case("isea4r") { dggrs_name = &"ISEA4R"; }
      else if arg1.eq_ignore_ascii_case("isea9r") { dggrs_name = &"ISEA9R"; }
      else if arg1.eq_ignore_ascii_case("isea3h") { dggrs_name = &"ISEA3H"; }
      else if arg1.eq_ignore_ascii_case("isea7h") { dggrs_name = &"ISEA7H"; }
      else if arg1.eq_ignore_ascii_case("isea7h_z7") { dggrs_name = &"ISEA7H_Z7"; }
      else if arg1.eq_ignore_ascii_case("ivea4r") { dggrs_name = &"IVEA4R"; }
      else if arg1.eq_ignore_ascii_case("ivea9r") { dggrs_name = &"IVEA9R"; }
      else if arg1.eq_ignore_ascii_case("ivea3h") { dggrs_name = &"IVEA3H"; }
      else if arg1.eq_ignore_ascii_case("ivea7h") { dggrs_name = &"IVEA7H"; }
      else if arg1.eq_ignore_ascii_case("ivea7h_z7") { dggrs_name = &"IVEA7H_Z7"; }
      else if arg1.eq_ignore_ascii_case("rtea4r") { dggrs_name = &"RTEA4R"; }
      else if arg1.eq_ignore_ascii_case("rtea9r") { dggrs_name = &"RTEA9R"; }
      else if arg1.eq_ignore_ascii_case("rtea3h") { dggrs_name = &"RTEA3H"; }
      else if arg1.eq_ignore_ascii_case("rtea7h") { dggrs_name = &"RTEA7H"; }
      else if arg1.eq_ignore_ascii_case("rtea7h_z7") { dggrs_name = &"RTEA7H_Z7"; }
      else if arg1.eq_ignore_ascii_case("rHEALPIx") { dggrs_name = &"rHEALPix"; }
      else if arg1.eq_ignore_ascii_case("HEALPIx") { dggrs_name = &"HEALPix"; }
      else if arg1.eq_ignore_ascii_case("gnosis") { dggrs_name = &"GNOSISGlobalGrid"; }
      a += 1;
   }

   if argc > a {
      level = args[a].parse::<i32>().unwrap();
      a+=1;
   }

   while a < argc {
      let key = &args[a];
      a+=1;
      if key.as_bytes()[0] == '-' as u8 {
         let k = &key[1..];
         if k == "bbox" {
            if a < argc {
               options.insert(k, &args[a]);
               a+=1;
            }
            else {
               exit_code = 1;
               show_syntax = true;
            }
         }
         else {
            options.insert(k, "");
         }
      }
      else
      {
         exit_code = 1;
         show_syntax = true;
      }
   }

   if dggrs_name != "" && exit_code == 0 {
      let dggrs: DGGRS = DGGRS::new(&dggal, dggrs_name).expect("Unknown DGGRS");

      println!("DGGRS: https://maps.gnosis.earth/ogcapi/dggrs/{dggrs_name}");

      if exit_code == 0 {
         list_zones(dggrs, level, &options);
      }
   }
   else {
      show_syntax = true;
      exit_code = 1;
   }

   if show_syntax {
      println!("Syntax:");
      println!("   list <dggrs> [level [options]]");
      println!("where dggrs is one of gnosis, isea(4r/9r/3h/7h/7h_z7), ivea(4r/9r/3h/7h/7h_z7), rtea(4r/9r/3h/7h/7h_z7), HEALPix, rHEALPix");
   }

   exit(exit_code)
}



================================================
FILE: bindings_examples/rust/Makefile
================================================
ifneq ($(V),1)
.SILENT:
endif

MODULE := info

# CORE VARIABLES

VERSION :=
CONFIG := release
ifndef COMPILER
COMPILER := default
endif

TARGET_TYPE = executable

# INCLUDES

DGGAL_ABSPATH := $(dir $(realpath $(firstword $(MAKEFILE_LIST))))../../

ifndef EC_SDK_SRC
EC_SDK_SRC := $(DGGAL_ABSPATH)../eC
endif

_CF_DIR = $(EC_SDK_SRC)/
include $(_CF_DIR)crossplatform.mk
include $(_CF_DIR)default.cf

# POST-INCLUDES VARIABLES

OBJ = obj/$(PLATFORM)$(COMPILER_SUFFIX)

TARGET = $(OBJ)/$(MODULE)

SOURCES = info.rs

OFLAGS =

OFLAGS += \
	-L$(DGGAL_ABSPATH)obj/$(PLATFORM)$(COMPILER_SUFFIX)$(DEBUG_SUFFIX)/lib \
	-L$(EC_SDK_SRC)/obj/$(PLATFORM)$(COMPILER_SUFFIX)$(DEBUG_SUFFIX)/lib \
	-L$(DGGAL_ABSPATH)obj/$(PLATFORM)$(COMPILER_SUFFIX)$(DEBUG_SUFFIX)/bin \
	-L$(EC_SDK_SRC)/obj/$(PLATFORM)$(COMPILER_SUFFIX)$(DEBUG_SUFFIX)/bin \
	-L$(DGGAL_ABSPATH)obj/static.$(PLATFORM)$(COMPILER_SUFFIX)$(DEBUG_SUFFIX)

# TARGETS

.PHONY: all
all: objdir $(TARGET);

.PHONY: objdir
objdir:
	$(call mkdir,$(OBJ))

$(SYMBOLS): | objdir
$(OBJECTS): | objdir
$(TARGET): $(SOURCES) $(OBJECTS) | objdir
	rustc --edition 2021 --cfg 'feature="info_cmd"' $(OFLAGS) $(SOURCES) $(LIBS) -o $(TARGET)

.PHONY: cleantarget
cleantarget:
	$(call rm,$(TARGET))

.PHONY: clean
clean: cleantarget

.PHONY: realclean
realclean: cleantarget
	$(call rmr,$(OBJ))

.PHONY: distclean
distclean:
	$(_MAKE) -f $(_CF_DIR)Cleanfile distclean distclean_all_subdirs



================================================
FILE: bindings_examples/rust/Makefile.geom
================================================
ifneq ($(V),1)
.SILENT:
endif

MODULE := geom

# CORE VARIABLES

VERSION :=
CONFIG := release
ifndef COMPILER
COMPILER := default
endif

TARGET_TYPE = executable

# INCLUDES

DGGAL_ABSPATH := $(dir $(realpath $(firstword $(MAKEFILE_LIST))))../../

ifndef EC_SDK_SRC
EC_SDK_SRC := $(DGGAL_ABSPATH)../eC
endif

_CF_DIR = $(EC_SDK_SRC)/
include $(_CF_DIR)crossplatform.mk
include $(_CF_DIR)default.cf

# POST-INCLUDES VARIABLES

OBJ = obj/$(PLATFORM)$(COMPILER_SUFFIX)

TARGET = $(OBJ)/$(MODULE)

SOURCES = geom.rs

OFLAGS =

OFLAGS += \
	-L$(DGGAL_ABSPATH)obj/$(PLATFORM)$(COMPILER_SUFFIX)$(DEBUG_SUFFIX)/lib \
	-L$(EC_SDK_SRC)/obj/$(PLATFORM)$(COMPILER_SUFFIX)$(DEBUG_SUFFIX)/lib \
	-L$(DGGAL_ABSPATH)obj/$(PLATFORM)$(COMPILER_SUFFIX)$(DEBUG_SUFFIX)/bin \
	-L$(EC_SDK_SRC)/obj/$(PLATFORM)$(COMPILER_SUFFIX)$(DEBUG_SUFFIX)/bin \
	-L$(DGGAL_ABSPATH)obj/static.$(PLATFORM)$(COMPILER_SUFFIX)$(DEBUG_SUFFIX)

# TARGETS

.PHONY: all
all: objdir $(TARGET);

.PHONY: objdir
objdir:
	$(call mkdir,$(OBJ))

$(SYMBOLS): | objdir
$(OBJECTS): | objdir
$(TARGET): $(SOURCES) $(OBJECTS) | objdir
	rustc --edition 2021 --cfg 'feature="geom_cmd"' $(OFLAGS) $(SOURCES) $(LIBS) -o $(TARGET)

.PHONY: cleantarget
cleantarget:
	$(call rm,$(TARGET))

.PHONY: clean
clean: cleantarget

.PHONY: realclean
realclean: cleantarget
	$(call rmr,$(OBJ))

.PHONY: distclean
distclean:
	$(_MAKE) -f $(_CF_DIR)Cleanfile distclean distclean_all_subdirs



================================================
FILE: bindings_examples/rust/Makefile.list
================================================
ifneq ($(V),1)
.SILENT:
endif

MODULE := list

# CORE VARIABLES

VERSION :=
CONFIG := release
ifndef COMPILER
COMPILER := default
endif

TARGET_TYPE = executable

# INCLUDES

DGGAL_ABSPATH := $(dir $(realpath $(firstword $(MAKEFILE_LIST))))../../

ifndef EC_SDK_SRC
EC_SDK_SRC := $(DGGAL_ABSPATH)../eC
endif

_CF_DIR = $(EC_SDK_SRC)/
include $(_CF_DIR)crossplatform.mk
include $(_CF_DIR)default.cf

# POST-INCLUDES VARIABLES

OBJ = obj/$(PLATFORM)$(COMPILER_SUFFIX)

TARGET = $(OBJ)/$(MODULE)

SOURCES = list.rs

OFLAGS =

OFLAGS += \
	-L$(DGGAL_ABSPATH)obj/$(PLATFORM)$(COMPILER_SUFFIX)$(DEBUG_SUFFIX)/lib \
	-L$(EC_SDK_SRC)/obj/$(PLATFORM)$(COMPILER_SUFFIX)$(DEBUG_SUFFIX)/lib \
	-L$(DGGAL_ABSPATH)obj/$(PLATFORM)$(COMPILER_SUFFIX)$(DEBUG_SUFFIX)/bin \
	-L$(EC_SDK_SRC)/obj/$(PLATFORM)$(COMPILER_SUFFIX)$(DEBUG_SUFFIX)/bin \
	-L$(DGGAL_ABSPATH)obj/static.$(PLATFORM)$(COMPILER_SUFFIX)$(DEBUG_SUFFIX)

# TARGETS

.PHONY: all
all: objdir $(TARGET);

.PHONY: objdir
objdir:
	$(call mkdir,$(OBJ))

$(SYMBOLS): | objdir
$(OBJECTS): | objdir
$(TARGET): $(SOURCES) $(OBJECTS) | objdir
	rustc --edition 2021 $(OFLAGS) $(SOURCES) $(LIBS) -o $(TARGET)

.PHONY: cleantarget
cleantarget:
	$(call rm,$(TARGET))

.PHONY: clean
clean: cleantarget

.PHONY: realclean
realclean: cleantarget
	$(call rmr,$(OBJ))

.PHONY: distclean
distclean:
	$(_MAKE) -f $(_CF_DIR)Cleanfile distclean distclean_all_subdirs



================================================
FILE: bindings_examples/rust/Makefile.togeo
================================================
ifneq ($(V),1)
.SILENT:
endif

MODULE := togeo

# CORE VARIABLES

VERSION :=
CONFIG := release
ifndef COMPILER
COMPILER := default
endif

TARGET_TYPE = executable

# INCLUDES

DGGAL_ABSPATH := $(dir $(realpath $(firstword $(MAKEFILE_LIST))))../../

ifndef EC_SDK_SRC
EC_SDK_SRC := $(DGGAL_ABSPATH)../eC
endif

_CF_DIR = $(EC_SDK_SRC)/
include $(_CF_DIR)crossplatform.mk
include $(_CF_DIR)default.cf

# POST-INCLUDES VARIABLES

OBJ = obj/$(PLATFORM)$(COMPILER_SUFFIX)

TARGET = $(OBJ)/$(MODULE)

SOURCES = togeo.rs

OFLAGS = -g

OFLAGS += \
	-L$(DGGAL_ABSPATH)obj/$(PLATFORM)$(COMPILER_SUFFIX)$(DEBUG_SUFFIX)/lib \
	-L$(EC_SDK_SRC)/obj/$(PLATFORM)$(COMPILER_SUFFIX)$(DEBUG_SUFFIX)/lib \
	-L$(DGGAL_ABSPATH)obj/$(PLATFORM)$(COMPILER_SUFFIX)$(DEBUG_SUFFIX)/bin \
	-L$(EC_SDK_SRC)/obj/$(PLATFORM)$(COMPILER_SUFFIX)$(DEBUG_SUFFIX)/bin \
	-L$(DGGAL_ABSPATH)obj/static.$(PLATFORM)$(COMPILER_SUFFIX)$(DEBUG_SUFFIX)

# TARGETS

.PHONY: all
all: objdir $(TARGET);

.PHONY: objdir
objdir:
	$(call mkdir,$(OBJ))

$(SYMBOLS): | objdir
$(OBJECTS): | objdir
$(TARGET): $(SOURCES) $(OBJECTS) | objdir
	rustc --edition 2021 --cfg 'feature="togeo_cmd"'  $(OFLAGS) $(SOURCES) $(LIBS) -o $(TARGET)

.PHONY: cleantarget
cleantarget:
	$(call rm,$(TARGET))

.PHONY: clean
clean: cleantarget

.PHONY: realclean
realclean: cleantarget
	$(call rmr,$(OBJ))

.PHONY: distclean
distclean:
	$(_MAKE) -f $(_CF_DIR)Cleanfile distclean distclean_all_subdirs



================================================
FILE: bindings_examples/rust/Makefile.zone
================================================
ifneq ($(V),1)
.SILENT:
endif

MODULE := zone

# CORE VARIABLES

VERSION :=
CONFIG := release
ifndef COMPILER
COMPILER := default
endif

TARGET_TYPE = executable

# INCLUDES

DGGAL_ABSPATH := $(dir $(realpath $(firstword $(MAKEFILE_LIST))))../../

ifndef EC_SDK_SRC
EC_SDK_SRC := $(DGGAL_ABSPATH)../eC
endif

_CF_DIR = $(EC_SDK_SRC)/
include $(_CF_DIR)crossplatform.mk
include $(_CF_DIR)default.cf

# POST-INCLUDES VARIABLES

OBJ = obj/$(PLATFORM)$(COMPILER_SUFFIX)

TARGET = $(OBJ)/$(MODULE)

SOURCES = zone.rs # info.rs -- dependency

OFLAGS =

OFLAGS += \
	-L$(DGGAL_ABSPATH)obj/$(PLATFORM)$(COMPILER_SUFFIX)$(DEBUG_SUFFIX)/lib \
	-L$(EC_SDK_SRC)/obj/$(PLATFORM)$(COMPILER_SUFFIX)$(DEBUG_SUFFIX)/lib \
	-L$(DGGAL_ABSPATH)obj/$(PLATFORM)$(COMPILER_SUFFIX)$(DEBUG_SUFFIX)/bin \
	-L$(EC_SDK_SRC)/obj/$(PLATFORM)$(COMPILER_SUFFIX)$(DEBUG_SUFFIX)/bin \
	-L$(DGGAL_ABSPATH)obj/static.$(PLATFORM)$(COMPILER_SUFFIX)$(DEBUG_SUFFIX)

# TARGETS

.PHONY: all
all: objdir $(TARGET);

.PHONY: objdir
objdir:
	$(call mkdir,$(OBJ))

$(SYMBOLS): | objdir
$(OBJECTS): | objdir
$(TARGET): $(SOURCES) $(OBJECTS) | objdir
	rustc --edition 2021 --cfg 'feature="zone_cmd"' $(OFLAGS) $(SOURCES) $(LIBS) -o $(TARGET)

.PHONY: cleantarget
cleantarget:
	$(call rm,$(TARGET))

.PHONY: clean
clean: cleantarget

.PHONY: realclean
realclean: cleantarget
	$(call rmr,$(OBJ))

.PHONY: distclean
distclean:
	$(_MAKE) -f $(_CF_DIR)Cleanfile distclean distclean_all_subdirs



================================================
FILE: bindings_examples/rust/togeo.rs
================================================
use std::collections::HashMap;
use std::env;
use std::process::exit;

extern crate ecrt;

use ecrt::Application;
use ecrt::FieldValue;
use ecrt::File;
use ecrt::FileOpenMode;
use ecrt::getLastDirectory;
use ecrt::MapIterator;
use ecrt::Array;
use ecrt::nullInst;

extern crate dggal;

use dggal::DGGAL;
use dggal::DGGRS;
use dggal::DGGRSZone;
use dggal::nullZone;
use dggal::CRS;
use dggal::DGGSJSON;
use dggal::DGGSJSONDepth;
use dggal::ArrayOfDGGSJSONDepth;
use dggal::readDGGSJSON;

mod geom;

use geom::resolve_crs_string;
use geom::generate_zone_feature;

fn convert_to_geojson(dggal: &DGGAL, input_file: &str, options: &HashMap::<&str, &str>) -> i32
{
   let mut exit_code = 1;
   let fr = File::open(input_file, FileOpenMode::Read);
   if fr.is_ok() {
      let f = fr.unwrap();
      let dggs_json_option = readDGGSJSON(&f);
      if dggs_json_option.is_ok() {
         let dggs_json: DGGSJSON = dggs_json_option.unwrap();

         let dggrs_uri = dggs_json.dggrs().string();

         let mut dggrs_id = getLastDirectory(&dggrs_uri);

         dggrs_id.truncate(dggrs_id.len().max(1) - 1);

         let dggrs_result = DGGRS::new(&dggal, &dggrs_id);

         if dggrs_result.is_ok() {
            let dggrs = dggrs_result.unwrap();
            let zone_id = dggs_json.zoneId().string();
            let zone = dggrs.getZoneFromTextID(&zone_id);

            if zone != nullZone {
               let depths = dggs_json.depths();
               if depths.array != nullInst {
                  let mut max_depth = -1;
                  let mut d_index: i32 = -1;

                  for d in 0..depths.count() {
                     // NOTE: Unfortunately we can't implement the Index trait which would support [ ]
                     //       due to internal representations not always matching type of array and Index trait
                     //       requiring references (not an issue in Python with __setitem__ and __getitem__)
                     let depth = depths.getElement(d);
                     if depth > max_depth {
                        max_depth = depth;
                        d_index = d as i32;
                        break;
                     }
                  }
                  if max_depth != -1 {
                     let depth = max_depth;
                     let sub_zones: Vec<DGGRSZone> = dggrs.getSubZones(zone, depth);
                     let centroids = options.get("centroids");
                     let crs: CRS = resolve_crs_string(options.get("crs"));

                     if sub_zones.len() != 0 {
                        let mut i: i32 = 0;

                        println!("{{");
                        println!("   \"type\": \"FeatureCollection\",");
                        print! ("   \"features\": [ ");

                        for z in sub_zones {
                           let mut props = HashMap::<String, FieldValue>::new();

                           print!("{}", if i != 0 { ", " } else { "   " });

                           let mut it = MapIterator!(<ecrt::String, ArrayOfDGGSJSONDepth> dggs_json.values());

                           while it.next() {
                              let key: ecrt::String = it.key();
                              let v_depths = Array::<DGGSJSONDepth>::new(*it.value());
                              if !key.is_null() && v_depths.array != nullInst && v_depths.count() > d_index {
                                 let dj_depth = v_depths.getElement(d_index);
                                 let data: Array<FieldValue> = dj_depth.data();
                                 let v: FieldValue = data.getElement(i);
                                 props.insert(key.string(), v);
                              }
                           }
                           generate_zone_feature(&dggrs, z, crs, (i + 1) as u64, centroids.is_some(), true, Some(&props));
                           i += 1;
                        }
                        println!(" ]");
                        println!("}}");

                        exit_code = 0;
                     }
                  }
               }
            } else {
               println!("Invalid zone ID: {zone_id}")
            }
         } else {
            println!("Failure to recognize DGGRS {dggrs_id}")
         }
      } else {
         println!("Failure to parse DGGS-JSON file {input_file}")
      }
   } else {
      println!("Failure to open file {input_file}")
   }
   exit_code
}

fn main()
{
   let args: Vec<String> = env::args().collect();
   let argc = args.len();
   let my_app = Application::new(&args);
   let dggal = DGGAL::new(&my_app);
   let mut exit_code: i32 = 0;
   let mut show_syntax = false;
   let mut a : usize = 1;
   let mut options = HashMap::<&str, &str>::new();
   let mut input: &str = "";

   if argc > a {
      input = &args[a];
      a+=1;
   }

   while a < argc {
      let key = &args[a];
      a+=1;
      if key.as_bytes()[0] == '-' as u8 {
         let k = &key[1..];
         if k == "crs" {
            if a < argc {
               options.insert(k, &args[a]);
               a+=1;
            }
            else {
               exit_code = 1;
               show_syntax = true;
            }
         }
         else {
            options.insert(k, "");
         }
      }
      else
      {
         exit_code = 1;
         show_syntax = true;
      }
   }

   if exit_code == 0 {
      if input == "" {
         println!("Missing input DGGS-JSON file");
         exit_code = 1;
      }

      if exit_code == 0 {
         convert_to_geojson(&dggal, input, &options);
      }
   }
   else {
      show_syntax = true;
      exit_code = 1;
   }

   if show_syntax {
      println!("Syntax:");
      println!("   togeo <DGGS-JSON file> [options]");
   }

   exit(exit_code)
}



================================================
FILE: bindings_examples/rust/zone.rs
================================================
use std::collections::HashMap;
use std::env;
use std::process::exit;

extern crate ecrt;

use ecrt::Application;
use ecrt::Pointd;
use ecrt::tokenizeWith;

extern crate dggal;

use dggal::DGGAL;
use dggal::DGGRS;
use dggal::DGGRSZone;
use dggal::nullZone;
use dggal::CRS;
use dggal::epsg;

mod info;

use info::display_info;

fn query_zone(dggrs: DGGRS, coordinates: &str, mut level: i32, options: HashMap<&str, &str>) -> i32
{
   let mut exit_code: i32 = 1;
   let coords: Vec<String> = tokenizeWith::<2>(coordinates, ",", false);
   let n = coords.len();
   if n == 2 {
      let lat = coords[0].parse::<f64>();
      let lon = coords[1].parse::<f64>();
      if lat.is_ok() && lon.is_ok() {
         let f_lat = lat.unwrap();
         let f_lon = lon.unwrap();
         if f_lat < 90.0 && f_lat > -90.0 {
            if level == -1 {
               level = 0;
            }
            let zone: DGGRSZone = dggrs.getZoneFromCRSCentroid(level,
               CRS!(epsg, 4326), &Pointd { x: f_lat, y: f_lon });
            if zone != nullZone {
               display_info(dggrs, zone, options);
               exit_code = 0;
            }
            else {
               println!("Could not identify zone from coordinates");
            }
         }
      }
   }

   if exit_code != 0 {
      if coordinates != "" {
         println!("Invalid coordinates for zone query");
      } else {
         println!("Missing coordinates for zone query");
      }
   }
   return exit_code;
}

fn main()
{
   let args: Vec<String> = env::args().collect();
   let argc = args.len();
   let my_app = Application::new(&args);
   let dggal = DGGAL::new(&my_app);
   let mut exit_code: i32 = 0;
   let mut show_syntax = false;
   let mut dggrs_name = "";
   let mut a : usize = 1;
   let arg0: &str = &args[0];
   let mut options = HashMap::<&str, &str>::new();
   let mut coordinates: &str = "";
   let mut level: i32 = -1;

        if arg0.eq_ignore_ascii_case("i4r") { dggrs_name = &"ISEA4R"; }
   else if arg0.eq_ignore_ascii_case("i9r") { dggrs_name = &"ISEA9R"; }
   else if arg0.eq_ignore_ascii_case("i3h") { dggrs_name = &"ISEA3H"; }
   else if arg0.eq_ignore_ascii_case("i7h") { dggrs_name = &"ISEA7H"; }
   else if arg0.eq_ignore_ascii_case("iz7") { dggrs_name = &"ISEA7H_Z7"; }
   else if arg0.eq_ignore_ascii_case("v4r") { dggrs_name = &"IVEA4R"; }
   else if arg0.eq_ignore_ascii_case("v9r") { dggrs_name = &"IVEA9R"; }
   else if arg0.eq_ignore_ascii_case("v3h") { dggrs_name = &"IVEA3H"; }
   else if arg0.eq_ignore_ascii_case("v7h") { dggrs_name = &"IVEA7H"; }
   else if arg0.eq_ignore_ascii_case("vz7") { dggrs_name = &"IVEA7H_Z7"; }
   else if arg0.eq_ignore_ascii_case("r4r") { dggrs_name = &"RTEA4R"; }
   else if arg0.eq_ignore_ascii_case("r9r") { dggrs_name = &"RTEA9R"; }
   else if arg0.eq_ignore_ascii_case("r3h") { dggrs_name = &"RTEA3H"; }
   else if arg0.eq_ignore_ascii_case("r7h") { dggrs_name = &"RTEA7H"; }
   else if arg0.eq_ignore_ascii_case("rz7") { dggrs_name = &"RTEA7H_Z7"; }
   else if arg0.eq_ignore_ascii_case("rhp") { dggrs_name = &"rHEALPix"; }
   else if arg0.eq_ignore_ascii_case("hpx") { dggrs_name = &"HEALPix"; }
   else if arg0.eq_ignore_ascii_case("ggg") { dggrs_name = &"GNOSISGlobalGrid"; }

   if dggrs_name == "" && argc > 1 {
      let arg1: &str = &args[1];
           if arg1.eq_ignore_ascii_case("isea4r") { dggrs_name = &"ISEA4R"; }
      else if arg1.eq_ignore_ascii_case("isea9r") { dggrs_name = &"ISEA9R"; }
      else if arg1.eq_ignore_ascii_case("isea3h") { dggrs_name = &"ISEA3H"; }
      else if arg1.eq_ignore_ascii_case("isea7h") { dggrs_name = &"ISEA7H"; }
      else if arg1.eq_ignore_ascii_case("isea7h_z7") { dggrs_name = &"ISEA7H_Z7"; }
      else if arg1.eq_ignore_ascii_case("ivea4r") { dggrs_name = &"IVEA4R"; }
      else if arg1.eq_ignore_ascii_case("ivea9r") { dggrs_name = &"IVEA9R"; }
      else if arg1.eq_ignore_ascii_case("ivea3h") { dggrs_name = &"IVEA3H"; }
      else if arg1.eq_ignore_ascii_case("ivea7h") { dggrs_name = &"IVEA7H"; }
      else if arg1.eq_ignore_ascii_case("ivea7h_z7") { dggrs_name = &"IVEA7H_Z7"; }
      else if arg1.eq_ignore_ascii_case("rtea4r") { dggrs_name = &"RTEA4R"; }
      else if arg1.eq_ignore_ascii_case("rtea9r") { dggrs_name = &"RTEA9R"; }
      else if arg1.eq_ignore_ascii_case("rtea3h") { dggrs_name = &"RTEA3H"; }
      else if arg1.eq_ignore_ascii_case("rtea7h") { dggrs_name = &"RTEA7H"; }
      else if arg1.eq_ignore_ascii_case("rtea7h_z7") { dggrs_name = &"RTEA7H_Z7"; }
      else if arg1.eq_ignore_ascii_case("rHEALPIx") { dggrs_name = &"rHEALPix"; }
      else if arg1.eq_ignore_ascii_case("HEALPIx") { dggrs_name = &"HEALPix"; }
      else if arg1.eq_ignore_ascii_case("gnosis") { dggrs_name = &"GNOSISGlobalGrid"; }
      a += 1;
   }

   if argc > a {
      coordinates = &args[a];
      a+=1;
   }

   if argc > a {
      level = args[a].parse::<i32>().unwrap();
      a+=1;
   }

   while a < argc {
      let key = &args[a];
      a+=1;
      if key.as_bytes()[0] == '-' as u8 {
         let k = &key[1..];
         if k == "depth" {
            if a < argc {
               options.insert(k, &args[a]);
               a+=1;
            }
            else {
               exit_code = 1;
               show_syntax = true;
            }
         }
         else {
            options.insert(k, "");
         }
      }
      else
      {
         exit_code = 1;
         show_syntax = true;
      }
   }

   if dggrs_name != "" && exit_code == 0 {
      let dggrs: DGGRS = DGGRS::new(&dggal, dggrs_name).expect("Unknown DGGRS");

      println!("DGGRS: https://maps.gnosis.earth/ogcapi/dggrs/{dggrs_name}");

      if exit_code == 0 {
         exit_code = query_zone(dggrs, coordinates, level, options);
      }
   }
   else {
      show_syntax = true;
      exit_code = 1;
   }

   if show_syntax {
      println!("Syntax:");
      println!("   zone <dggrs> <lat,lon> <level> [options]");
      println!("where dggrs is one of gnosis, isea(4r/9r/3h/7h/7h_z7), ivea(4r/9r/3h/7h/7h_z7), rtea(4r/9r/3h/7h/7h_z7), HEALPix, rHEALPix");
   }

   exit(exit_code)
}



================================================
FILE: commands/compact.ec
================================================
public import IMPORT_STATIC "ecrt"
import IMPORT_STATIC "dggal"

int compactZones(DGGRS dggrs, const String inputFile, Map<String, const String> options)
{
   // TODO:
   return 0;
}



================================================
FILE: commands/decompact.ec
================================================
public import IMPORT_STATIC "ecrt"
import IMPORT_STATIC "dggal"

int decompactZones(DGGRS dggrs, const String inputFile, Map<String, const String> options)
{
   // TODO:
   return 0;
}



================================================
FILE: commands/geom.ec
================================================
public import IMPORT_STATIC "ecrt"
import IMPORT_STATIC "dggal"

CRS resolveCRSString(const String crsOption)
{
   CRS crs = 0;
   if(crsOption)
   {
      // NOTE: Currently re-using the same CRS identifiers regardless of actual projection for 5x6 and icosahedron net space
           if(!strcmpi(crsOption, "5x6" )) crs = { ogc, 153456 };
      else if(!strcmpi(crsOption, "ico") ||
             !strcmpi(crsOption, "isea") ||
             !strcmpi(crsOption, "ivea") ||
             !strcmpi(crsOption, "rtea")) crs = { ogc, 1534 };
      else if(!strcmpi(crsOption, "OGC:CRS84")) crs = { ogc, 84 };
      else if(!strcmpi(crsOption, "EPSG:4326")) crs = { epsg, 4326 };
      else if(!strcmpi(crsOption, "rhp") || !strcmpi(crsOption, "hpx") || !strcmpi(crsOption, "hlp")) crs = { ogc, 99999 };
   }
   return crs;
}

void generateZoneFeature(DGGRS dggrs, DGGRSZone zone, CRS crs, int64 id, bool centroids, bool fc, Map<String, FieldValue> properties)
{
   char zoneID[256];
   const String t = fc ? "   " : "";

   dggrs.getZoneTextID(zone, zoneID);

   PrintLn("{");
   PrintLn(t, "   \"type\" : \"Feature\",");
   Print  (t, "   \"id\" : ");
   if(id)
      Print(id);
   else
      printf("\"%s\"", zoneID);
   PrintLn(",");

   generateZoneGeometry(dggrs, zone, crs, id, centroids, fc);

   PrintLn(",");

   PrintLn(t, "   \"properties\" : {");
   Print  (t, "     \"zoneID\" : \"");
   printf("%s", zoneID);
   Print("\"");
   if(properties)
   {
      for(p : properties)
      {
         const String key = &p;
         FieldValue v = p;
         Print(",\n", t, "     \"", key, "\" : ", v);
      }
   }

   PrintLn("");
   PrintLn(t, "   }");
   Print(t, "}");
}

void generateZoneGeometry(DGGRS dggrs, DGGRSZone zone, CRS crs, int64 id, bool centroids, bool fc)
{
   const String t = fc ? "   " : "";

   PrintLn(t, "   \"geometry\" : {");
   PrintLn(t, "      \"type\" : \"", centroids ? "Point" : "Polygon", "\",");
   Print  (t, "      \"coordinates\" : [");

   if(!crs || crs == { ogc, 84 } || crs == { epsg, 4326 })
   {
      if(centroids)
      {
         GeoPoint centroid;
         dggrs.getZoneWGS84Centroid(zone, centroid);
         Print(" ", centroid.lon, ", ", centroid.lat);
      }
      else
      {
         Array<GeoPoint> vertices = dggrs.getZoneRefinedWGS84Vertices(zone, 0);
         if(vertices)
         {
            int count = vertices.count, i;

            PrintLn("");
            Print(t, "         [ ");
            for(i = 0; i < count; i++)
               Print(i ? ", " : "", "[", vertices[i].lon, ", ", vertices[i].lat, "]");
            Print(i ? ", " : "", "[", vertices[0].lon, ", ", vertices[0].lat, "]");
            PrintLn(" ]");
         }
         delete vertices;
         Print(t, "     ");
      }
   }
   else
   {
      if(centroids)
      {
         Pointd centroid;
         dggrs.getZoneCRSCentroid(zone, crs, centroid);
         Print(" ", centroid.x, ", ", centroid.y);
      }
      else
      {
         Array<Pointd> vertices = dggrs.getZoneRefinedCRSVertices(zone, crs, 0);
         if(vertices)
         {
            int count = vertices.count, i;

            PrintLn("");
            Print(t, "         [ ");
            for(i = 0; i < count; i++)
               Print(i ? ", " : "", "[", vertices[i].x, ", ", vertices[i].y, "]");
            Print(i ? ", " : "", "[", vertices[0].x, ", ", vertices[0].y, "]");
            PrintLn(" ]");
         }
         delete vertices;
         Print(t, "     ");
      }
   }
   PrintLn(" ]");
   Print(t, "   }");
}

int generateGeometry(DGGRS dggrs, DGGRSZone zone, Map<String, const String> options)
{
   if(zone != nullZone)
   {
      bool centroids = options && options["centroids"] != null;
      const String crsOption = options ? options["crs"] : null;
      CRS crs = resolveCRSString(crsOption);

      generateZoneFeature(dggrs, zone, crs, 0, centroids, false, null);
      PrintLn("");
      return 0;
   }
   else
      PrintLn($"geom command requires a zone");
   return 1;
}



================================================
FILE: commands/grid.ec
================================================
public import IMPORT_STATIC "ecrt"
import IMPORT_STATIC "dggal"

import "geom"
import "list" // for bbox parsing

int generateGrid(DGGRS dggrs, int level, Map<String, const String> options)
{
   int exitCode = 0;
   bool centroids = options && options["centroids"] != null;
   bool compact = options && options["compact"] != null;
   GeoExtent bbox = wholeWorld;
   int64 id = 1;
   const String crsOption = options ? options["crs"] : null;
   CRS crs = resolveCRSString(crsOption);

   if(!parseBBox(options, bbox))
      exitCode = 1;
   if(compact && centroids)
   {
      exitCode = 1;
      PrintLn($"Cannot return compact list of zones as centroids");
   }

   if(level == -1)
      level = 0;

   if(!exitCode)
   {
      Array<DGGRSZone> zones = dggrs.listZones(level, bbox);
      if(zones)
      {
         if(compact)
            dggrs.compactZones(zones);

         PrintLn("{");
         PrintLn("   \"type\": \"FeatureCollection\",");
         Print  ("   \"features\": [ ");
         for(z : zones)
         {
            Print(id > 1 ? ", " : "   ");
            generateZoneFeature(dggrs, z, crs, id++, centroids, true, null);
         }
         PrintLn(" ]");
         PrintLn("}");

         delete zones;
      }
   }
   return 0;
}



================================================
FILE: commands/index.ec
================================================
public import IMPORT_STATIC "ecrt"
import IMPORT_STATIC "dggal"

int subZoneIndex(DGGRS dggrs, DGGRSZone parent, DGGRSZone subZone, Map<String, const String> options)
{
   int exitCode = 1;

   if(parent != nullZone && subZone != nullZone)
   {
      int levelParent = dggrs.getZoneLevel(parent), levelSub = dggrs.getZoneLevel(subZone);
      if(levelSub >= levelParent)
      {
         if(levelSub - levelParent <= dggrs.getIndexMaxDepth())
         {
            char zoneID[256], subZoneID[256];
            int64 index = dggrs.zoneHasSubZone(parent, subZone) ? dggrs.getSubZoneIndex(parent, subZone) : -1;

            dggrs.getZoneTextID(parent, zoneID);
            dggrs.getZoneTextID(subZone, subZoneID);

            if(index != -1)
            {
               PrintLn(subZoneID, $" is at index ", index, $" of ", zoneID, $" at depth ", levelSub - levelParent);
               exitCode = 0;
            }
            else
               PrintLn($"sub-zone ", subZoneID, $" not found within parent ", zoneID);
         }
         else
            PrintLn($"sub-zone is too many refinement level apart from parent (", levelSub - levelParent, ")");
      }
      else
         PrintLn($"invalid sub-zone at a coarser refinement level than parent");
   }
   else
      PrintLn($"index command requires a parent and a sub-zone");
   return exitCode;
}



================================================
FILE: commands/info.ec
================================================
public import IMPORT_STATIC "ecrt"
import IMPORT_STATIC "dggal"

import "geom"  // For resolveCRSString()

int displayInfo(DGGRS dggrs, DGGRSZone zone, Map<String, const String> options)
{
   if(zone != nullZone)
      return zoneInfo(dggrs, zone, options);
   else
      return dggrsInfo(dggrs, options);
}

static int zoneInfo(DGGRS dggrs, DGGRSZone zone, Map<String, const String> options)
{
   int level = dggrs.getZoneLevel(zone);
   int nEdges = dggrs.countZoneEdges(zone);
   GeoPoint geoCentroid;
   GeoExtent geoExtent;
   GeoPoint geoVertices[6];
   Pointd vertices[6];
   Pointd centroid;
   CRSExtent extent;
   char zoneID[256];
   double area = dggrs.getZoneArea(zone);
   int depth = dggrs.get64KDepth();
   DGGRSZone parents[3], neighbors[6], children[13];
   int nParents = dggrs.getZoneParents(zone, parents);
   int nbTypes[6];
   int nNeighbors = dggrs.getZoneNeighbors(zone, neighbors, nbTypes);
   int nChildren = dggrs.getZoneChildren(zone, children);
   DGGRSZone centroidParent = dggrs.getZoneCentroidParent(zone);
   DGGRSZone centroidChild = dggrs.getZoneCentroidChild(zone);
   bool isCentroidChild = dggrs.isZoneCentroidChild(zone);
   int i;
   int64 nSubZones;
   const String depthOption = options ? options["depth"] : null;
   const String crsOption = options ? options["crs"] : null;
   CRS crs = resolveCRSString(crsOption);
   const String crsString = crsOption ? crsOption : "EPSG:4326";
   int nVertices;

   if(crsOption)
      nVertices = dggrs.getZoneCRSVertices(zone, crs, vertices);
   else
      nVertices = dggrs.getZoneWGS84Vertices(zone, geoVertices);

   if(depthOption)
   {
      int maxDepth = dggrs.getMaxDepth();
      depth.OnGetDataFromString(depthOption);
      if(depth > maxDepth)
      {
         PrintLn($"Invalid depth (maximum: ", maxDepth, ")");
         return 1;
      }
   }

   nSubZones = dggrs.countSubZones(zone, depth);

   if(crsOption)
   {
      dggrs.getZoneCRSCentroid(zone, crs, centroid);
      dggrs.getZoneCRSExtent(zone, crs, extent);
   }
   else
   {
      dggrs.getZoneWGS84Centroid(zone, geoCentroid);
      dggrs.getZoneWGS84Extent(zone, geoExtent);
   }

   dggrs.getZoneTextID(zone, zoneID);

   PrintLn($"Textual Zone ID: ", zoneID);
   Print($"64-bit integer ID: ", (uint64)zone, " (");
   printf(FORMAT64HEX, zone);
   PrintLn(")");
   PrintLn("");
   PrintLn($"Level ", level, $" zone (", nEdges, $" edges", isCentroidChild ? $", centroid child)" : ")");
   PrintLn(area, " m² (", area / 1000000, " km²)");
   PrintLn(nSubZones, $" sub-zones at depth ", depth);
   if(crsOption)
   {
      PrintLn($"Centroid: ", centroid.x, ", ", centroid.y);
      PrintLn($"Extent: { top-left: { ", extent.tl.x, ", ", extent.tl.y, " }, bottom-right: { ", extent.br.x, ", ", extent.br.y, " } }");
   }
   else
   {
      PrintLn($"WGS84 Centroid (lat, lon): ", geoCentroid.lat, ", ", geoCentroid.lon);
      PrintLn($"WGS84 Extent (lat, lon): { ", geoExtent.ll.lat, ", ", geoExtent.ll.lon, " }, { ", geoExtent.ur.lat, ", ", geoExtent.ur.lon, " }");
   }

   PrintLn("");
   if(nParents)
   {
      PrintLn($"Parent", nParents > 1 ? "s" : "", " (", nParents, "):");
      for(i = 0; i < nParents; i++)
      {
         char pID[256];
         dggrs.getZoneTextID(parents[i], pID);
         Print("   ", pID);
         if(centroidParent == parents[i])
            Print($" (centroid child)");
         PrintLn("");
      }
   }
   else
      PrintLn($"No parent");

   PrintLn("");
   PrintLn($"Children (", nChildren, "):");
   for(i = 0; i < nChildren; i++)
   {
      char cID[256];
      dggrs.getZoneTextID(children[i], cID);
      Print("   ", cID);
      if(centroidChild == children[i])
         Print($" (centroid)");
      PrintLn("");
   }

   PrintLn("");
   PrintLn($"Neighbors (", nNeighbors, "):");
   for(i = 0; i < nNeighbors; i++)
   {
      char nID[256];
      dggrs.getZoneTextID(neighbors[i], nID);
      PrintLn($"   (direction ", nbTypes[i], "): ", nID);
   }

   PrintLn("");
   PrintLn("[", crsString, $"] Vertices (", nVertices, "):");

   for(i = 0; i < nVertices; i++)
   {
      if(crsOption)
         PrintLn("   ", vertices[i].x, ", ", vertices[i].y);
      else
         PrintLn("   ", geoVertices[i].lat, ", ", geoVertices[i].lon);
   }
   return 0;
}

static int dggrsInfo(DGGRS dggrs, Map<String, const String> options)
{
   int depth64k = dggrs.get64KDepth();
   int ratio = dggrs.getRefinementRatio();
   int maxLevel = dggrs.getMaxDGGRSZoneLevel();

   PrintLn($"Refinement Ratio: ", ratio);
   PrintLn($"Maximum level for 64-bit global identifiers (DGGAL DGGRSZone): ", maxLevel);
   PrintLn($"Default ~64K sub-zones relative depth: ", depth64k);
   return 0;
}



================================================
FILE: commands/level.ec
================================================
public import IMPORT_STATIC "ecrt"
import IMPORT_STATIC "dggal"

int levelInfo(DGGRS dggrs, int level, Map<String, const String> options, bool asTable)
{
   int exitCode = 1;
   int depth = dggrs.get64KDepth();
   double mmPerPixel = 0.28;
   const String depthOption = options ? options["depth"] : null;
   const String displayResOption = options ? options["display-res"] : null;

   if(depthOption)
   {
      int maxDepth = dggrs.getMaxDepth();

      depth.OnGetDataFromString(depthOption);
      if(depth > maxDepth)
      {
         PrintLn($"Invalid depth (maximum: ", maxDepth, ")");
         return 1;
      }
   }
   if(displayResOption)
      mmPerPixel.OnGetDataFromString(displayResOption);

   if(level == -1)
   {
      // TODO: Support -mpp, -scale, -pixels from options
      int maxLevel = dggrs.getMaxDGGRSZoneLevel();

      PrintLn($"Assuming sub-zone depth of ", depth, $" and display resolution of ", mmPerPixel, $" mm/pixel:");

      // The "meters/sub-zone" is the length of a square with same area as a hexagon
      // divide by sqrt(pi)/2        = 0.8862269254528 (x ~1.1283791671) for the diameter of a circle with same area
      // divide by sqrt(1.5*sqrt(3)) = 1.6118548977353 (x ~0.6204032394) for the measure of a hexagon's edge / radius of circumscribed circle
      // divide by sqrt(pi)          = 1.7724538509055 (x ~0.5641895835) for the radius of a circle with same area
      // divide by 2*sqrt(sqrt(3)/2) = 1.8612097182042 (x ~0.5372849659) for the measure of a hexagon's apothem
      PrintLn($"Level       Reference Area                             Sub-zones count        Sub-zone area                                                 Scale                   Meters/Sub-zone");
      PrintLn("-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------");
      for(level = 0; level <= maxLevel; level++)
         levelInfo(dggrs, level, options, true);
      exitCode = 0;
   }
   else
   {
      double metersPerSubZone = dggrs.getMetersPerSubZoneFromLevel(level, depth);
      double scaleDenominator = dggrs.getScaleDenominatorFromLevel(level, depth, mmPerPixel);
      DGGRSZone testZone = dggrs.getZoneFromWGS84Centroid(level, { 0, 10 }); // Avoiding ISEA3H pentagon at 0,0 at level 1 and 2
      uint64 nSubZones = dggrs.countSubZones(testZone, depth);
      double refArea = dggrs.getRefZoneArea(level);

      if(asTable)
      {
         printf("%2d: %23.8f m² (%17.8f km²)     %10d    ", level, refArea, refArea / 1000000, (int)nSubZones);
         printf("%24.8f m² (%27.8f cm²) %3d:%12.0f %19.8f m (%19.8f cm)\n", refArea/nSubZones, refArea * 10000 / nSubZones,
            scaleDenominator > 1 ? 1 : (uint)(1/scaleDenominator + 0.5), scaleDenominator < 1 ? 1.0 : scaleDenominator,
            metersPerSubZone, 100 * metersPerSubZone);
      }
      else
      {
         PrintLn($"Refinement Level: ", level);
         PrintLn($"Reference area: ", refArea, " m² (", refArea / 1000000, " km²)");
         PrintLn("");
         PrintLn($"Assuming sub-zone depth of ", depth, " (", nSubZones, $" sub-zones) and display resolution of ", mmPerPixel, $" mm/pixel:");
         PrintLn($"   Sub-zones area: ", refArea / nSubZones, " m² (", refArea * 10000 / nSubZones, " cm²)");
         PrintLn($"   Cartographic scale: ",
            scaleDenominator > 1 ? 1 : (uint)(1/scaleDenominator + 0.5), ":",
            scaleDenominator < 1 ? 1LL : (uint64)scaleDenominator);
         PrintLn($"   Physical meters/sub-zone: ", metersPerSubZone, " (", metersPerSubZone * 100, $" cm/sub-zone)");
      }
      exitCode = 0;
   }
   return exitCode;
}



================================================
FILE: commands/list.ec
================================================
public import IMPORT_STATIC "ecrt"
import IMPORT_STATIC "dggal"

bool parseBBox(Map<String, const String> options, GeoExtent bbox)
{
   bool result = true;
   const String bboxOption = options ? options["bbox"] : null;
   if(bboxOption)
   {
      String s = CopyString(bboxOption);
      String tokens[4];
      int nTokens = TokenizeWith(s, 4, tokens, ",", false);
      double a,b,c,d;
      if(nTokens == 4 &&
         a.OnGetDataFromString(tokens[0]) &&
         b.OnGetDataFromString(tokens[1]) &&
         c.OnGetDataFromString(tokens[2]) &&
         d.OnGetDataFromString(tokens[3]) &&
         a < 90 && a >= -90 && c <= 90 && c > -90)
         bbox = { { a, b }, { c, d } };
      else
      {
         PrintLn($"Invalid bounding box specified");
         result = false;
      }
      delete s;
   }
   return result;
}

int listZones(DGGRS dggrs, int level, Map<String, const String> options)
{
   int exitCode = 0;
   bool centroids = options && options["centroids"] != null;
   bool compact = options && options["compact"] != null;
   GeoExtent bbox = wholeWorld;

   if(!parseBBox(options, bbox))
      exitCode = 1;
   if(compact && centroids)
   {
      exitCode = 1;
      PrintLn($"Cannot return compact list of zones as centroids");
   }

   if(level == -1)
      level = 0;

   if(!exitCode)
   {
      int64 i = 0;
      Array<DGGRSZone> zones = dggrs.listZones(level, bbox);
      if(compact)
         dggrs.compactZones(zones);

      Print("[");
      if(zones)
         for(z : zones)
         {
            Print(i > 0 ? ", " : " ");
            if(centroids)
            {
               GeoPoint centroid;
               dggrs.getZoneWGS84Centroid(z, centroid);
               Print("[ ", centroid.lat, ", ", centroid.lon, " ]");
            }
            else
            {
               char zoneID[256];
               dggrs.getZoneTextID(z, zoneID);
               Print("\"", zoneID, "\"");
            }
            i++;
         }
      PrintLn(" ]");
      delete zones;
   }
   return 0;
}



================================================
FILE: commands/rel.ec
================================================
public import IMPORT_STATIC "ecrt"
import IMPORT_STATIC "dggal"

int relationInfo(DGGRS dggrs, DGGRSZone a, DGGRSZone b, Map<String, const String> options)
{
   int exitCode = 1;
   if(a != nullZone && b != nullZone)
   {
      if(a == b)
      {
         PrintLn($"These two zones are the same");
         exitCode = 0;
      }
      else
      {
         char zoneID[2][256];
         int levelA = dggrs.getZoneLevel(a), levelB = dggrs.getZoneLevel(b);
         double areaA = dggrs.getZoneArea(a), areaB = dggrs.getZoneArea(b);
         bool neighbors = dggrs.areZonesNeighbors(a, b);
         bool siblings = dggrs.areZonesSiblings(a, b);
         bool aChildOfB = dggrs.isZoneImmediateChildOf(a, b);
         bool aParentOfB = dggrs.isZoneImmediateParentOf(a, b);
         bool aAncestorOfB = dggrs.isZoneAncestorOf(a, b, 0);
         bool aDescendantOfB = dggrs.isZoneDescendantOf(a, b, 0);
         bool aContainedInB = dggrs.isZoneContainedIn(a, b);
         bool aContainsB = dggrs.doesZoneContain(a, b);
         bool aSubZoneOfB = dggrs.zoneHasSubZone(b, a);
         bool bSubZoneOfA = dggrs.zoneHasSubZone(a, b);
         int maxDepth = dggrs.getMaxDepth(), maxIndexDepth = dggrs.getIndexMaxDepth();
         int64 aIndexInB = aSubZoneOfB && levelA - levelB <= maxDepth ? dggrs.getSubZoneIndex(b, a) : -1;
         int64 bIndexInA = bSubZoneOfA && levelB - levelA <= maxDepth ? dggrs.getSubZoneIndex(a, b) : -1;
         bool overlap = dggrs.doZonesOverlap(a, b);

         dggrs.getZoneTextID(a, zoneID[0]);
         dggrs.getZoneTextID(b, zoneID[1]);
         PrintLn($"Relationships between zones ", zoneID[0], " (A) and ", zoneID[1], " (B):\n");

         if(levelA == levelB)
            PrintLn($"These zones are at the same refinement level (", levelA, ")");
         else if(levelA < levelB)
            PrintLn($"Zone A is coarser than zone B by ", levelB - levelA, $" refinement level", levelB - levelA > 1 ? $"s" : "");
         else
            PrintLn($"Zone A is finer than zone B by ", levelA - levelB, $" refinement level", levelA - levelB > 1 ? $"s" : "");

         if(areaA == areaB)
            PrintLn($"The areas of these zones are exactly the same");
         else if(areaA < areaB)
            PrintLn($"The area of zone A is smaller than the area of zone B (area of A is ", areaA * 100 / areaB, " % of zone B)");
         else
            PrintLn($"The area of zone A is greater than the area of zone B (area of B is ", areaB * 100 / areaA, " % of zone A)");

         PrintLn($"Zone A is ", aChildOfB ? "" : $"NOT ", $"an immediate child of zone B");
         PrintLn($"Zone A is ", aParentOfB ? "" : $"NOT ", $"an immediate parent of zone B");
         PrintLn($"Zone A is ", aDescendantOfB ? "" : $"NOT ", $"a descendant of zone B");
         PrintLn($"Zone A is ", aAncestorOfB ? "" : $"NOT ", $"an ancestor of zone B");

         Print($"Zone A is ", aSubZoneOfB ? "" : $"NOT ", $"a sub-zone of zone B");
         if(aIndexInB != -1)
            Print($" (at depth ", levelA - levelB, ", index ", aIndexInB, ")");
         else if(aSubZoneOfB)
            Print($" (depth ", levelA - levelB, $" is too many levels apart -- max: ", maxDepth,
               levelA - levelB <= maxIndexDepth ?
                  $", use index command to compute index -- currently slow)" :
                  $", not currently able to compute index)");
         PrintLn("");
         Print($"Zone A ", bSubZoneOfA ? "has" : $"does NOT have", $" B as a sub-zone");
         if(bIndexInA != -1)
            Print(" (at depth ", levelB - levelA, ", index ", bIndexInA, ")");
         else if(bSubZoneOfA)
            Print($" (depth ", levelB - levelA, $" is too many levels apart -- max: ", maxDepth,
               levelB - levelA <= maxIndexDepth ?
                  $", use index command to compute index -- currently slow)" :
                  $", not currently able to compute index)");
         PrintLn("");
         PrintLn($"These zones are ", neighbors ? "" : $"NOT ", $"neighbors");
         PrintLn($"These zones are ", siblings ? "" : $"NOT ", $"siblings");
         PrintLn($"Zone A is ", aContainedInB ? "" : $"NOT ", $"contained in zone B");
         PrintLn($"Zone A ", aContainsB ? $"contains" : $"does not contain", $" zone B");
         PrintLn($"Zone A and B ", !overlap ? $"do NOT " : "", $"overlap");

         exitCode = 0;
      }
   }
   else
      PrintLn($"rel command requires two zones");
   return exitCode;
}



================================================
FILE: commands/sub.ec
================================================
public import IMPORT_STATIC "ecrt"
import IMPORT_STATIC "dggal"
import "geom"

int subZones(DGGRS dggrs, DGGRSZone zone, int64 index, Map<String, const String> options)
{
   int exitCode = 1;
   int depth = dggrs.get64KDepth();
   const String depthOption = options ? options["depth"] : null;
   bool centroids = options && options["centroids"] != null;
   const String crsOption = options ? options["crs"] : null;
   CRS crs = resolveCRSString(crsOption);

   if(depthOption)
   {
      int maxDepth = index == -1 ? dggrs.getMaxDepth() : dggrs.getIndexMaxDepth();

      depth.OnGetDataFromString(depthOption);
      if(depth > maxDepth)
      {
         PrintLn($"Invalid depth (maximum: ", maxDepth, ")");
         return 1;
      }
   }

   if(zone != nullZone)
   {
      char zoneID[256], subZoneID[256];
      DGGRSZone zoneAtIndex = index == -1 ? nullZone : dggrs.getSubZoneAtIndex(zone, depth, index);

      dggrs.getZoneTextID(zone, zoneID);

      if(zoneAtIndex == nullZone && index != -1)
         PrintLn($"Invalid zone index for zone ", zoneID, $" at depth ", depth, " (", dggrs.countSubZones(zone, depth), $" sub-zones)");
      else if(zoneAtIndex != nullZone)
      {
         if(centroids)
         {
            if(crs)
            {
               Pointd centroid;
               dggrs.getZoneCRSCentroid(zoneAtIndex, crs, centroid);
               Print("[", centroid.x, ", ", centroid.y, "]");
            }
            else
            {
               GeoPoint centroid;
               dggrs.getZoneWGS84Centroid(zoneAtIndex, centroid);
               Print("[", centroid.lat, ", ", centroid.lon, "]");
            }
         }
         else
         {
            dggrs.getZoneTextID(zoneAtIndex, subZoneID);
            PrintLn("\"", subZoneID, "\"");
         }
         exitCode = 0;
      }
      else
      {
         Array<DGGRSZone> subZones = dggrs.getSubZones(zone, depth);
         if(subZones)
         {
            int i = 0;
            Print("[ ");
            for(i = 0; i < subZones.count; i++)
            {
               if(i) Print(", ");
               if(centroids)
               {
                  if(crs)
                  {
                     Pointd centroid;
                     dggrs.getZoneCRSCentroid(subZones[i], crs, centroid);
                     Print("[", centroid.x, ", ", centroid.y, "]");
                  }
                  else
                  {
                     GeoPoint centroid;
                     dggrs.getZoneWGS84Centroid(subZones[i], centroid);
                     Print("[", centroid.lat, ", ", centroid.lon, "]");
                  }
               }
               else
               {
                  dggrs.getZoneTextID(subZones[i], subZoneID);
                  Print("\"", subZoneID, "\"");
               }
            }
            PrintLn(" ]");
            delete subZones;
         }
         else
            PrintLn("null");
         exitCode = 0;
      }
   }
   else
      PrintLn($"sub command requires a zone");
   return exitCode;
}



================================================
FILE: commands/togeo.ec
================================================
public import IMPORT_STATIC "ecrt"
import IMPORT_STATIC "dggal"
import "geom"

int convertToGeoJSON(const String inputFile, Map<String, const String> options)
{
   int exitCode = 1;
   File f = FileOpen(inputFile, read);
   if(f)
   {
      DGGSJSON dggsJSON = readDGGSJSON(f);
      if(dggsJSON)
      {
         char dggrsID[256];
         subclass(DGGRS) dggrsClass = null;

         GetLastDirectory(dggsJSON.dggrs, dggrsID);

         if(!strncasecmp(dggrsID, "GNOSIS", 6)) dggrsClass = class(GNOSISGlobalGrid);
         else if(!strncasecmp(dggrsID, "ISEA3H", 6))   dggrsClass = class(ISEA3H);
         else if(!strncasecmp(dggrsID, "ISEA9R", 6))   dggrsClass = class(ISEA9R);
         else if(!strncasecmp(dggrsID, "ISEA7H_Z7", 9))   dggrsClass = class(ISEA7H_Z7);
         else if(!strncasecmp(dggrsID, "ISEA7H", 6))   dggrsClass = class(ISEA7H);
         else if(!strncasecmp(dggrsID, "ISEA4R", 6))   dggrsClass = class(ISEA4R);
         else if(!strncasecmp(dggrsID, "IVEA3H", 6))   dggrsClass = class(IVEA3H);
         else if(!strncasecmp(dggrsID, "IVEA9R", 6))   dggrsClass = class(IVEA9R);
         else if(!strncasecmp(dggrsID, "IVEA7H_Z7", 9))   dggrsClass = class(IVEA7H_Z7);
         else if(!strncasecmp(dggrsID, "IVEA7H", 6))   dggrsClass = class(IVEA7H);
         else if(!strncasecmp(dggrsID, "IVEA4R", 6))   dggrsClass = class(IVEA4R);
         else if(!strncasecmp(dggrsID, "RTEA3H", 6))   dggrsClass = class(RTEA3H);
         else if(!strncasecmp(dggrsID, "RTEA9R", 6))   dggrsClass = class(RTEA9R);
         else if(!strncasecmp(dggrsID, "RTEA7H_Z7", 9))   dggrsClass = class(RTEA7H_Z7);
         else if(!strncasecmp(dggrsID, "RTEA7H", 6))   dggrsClass = class(RTEA7H);
         else if(!strncasecmp(dggrsID, "RTEA4R", 6))   dggrsClass = class(RTEA4R);
         else if(!strncasecmp(dggrsID, "rHEALPix", 8)) dggrsClass = class(rHEALPix);
         else if(!strncasecmp(dggrsID, "HEALPix", 7))  dggrsClass = class(HEALPix);

         if(dggrsClass)
         {
            const String zoneID = dggsJSON.zoneId;
            DGGRS dggrs = eInstance_New(dggrsClass);
            DGGRSZone zone = dggrs.getZoneFromTextID(zoneID);

            if(zone != nullZone)
            {
               if(dggsJSON.depths)
               {
                  int d;
                  int maxDepth = -1;

                  for(d = 0; d < dggsJSON.depths.count; d++)
                  {
                     int depth = dggsJSON.depths[d];
                     if(depth > maxDepth)
                     {
                        maxDepth = depth;
                        break;
                     }
                  }
                  if(d < dggsJSON.depths.count)
                  {
                     int depth = maxDepth;
                     Array<DGGRSZone> subZones = dggrs.getSubZones(zone, depth);
                     bool centroids = options && options["centroids"] != null;
                     const String crsOption = options ? options["crs"] : null;
                     CRS crs = resolveCRSString(crsOption);

                     if(subZones)
                     {
                        int64 i = 0;
                        Map<String, FieldValue> props { };

                        PrintLn("{");
                        PrintLn("   \"type\": \"FeatureCollection\",");
                        Print  ("   \"features\": [ ");

                        for(z : subZones)
                        {
                           props.Free();
                           Print(i > 0 ? ", " : "   ");

                           for(prop : dggsJSON.values)
                           {
                              const String key = &prop;
                              Array<DGGSJSONDepth> depths = prop;

                              if(key && depths && depths.count > d)
                              {
                                 DGGSJSONDepth djDepth = depths[d];
                                 Array<FieldValue> data = (Array<FieldValue>)djDepth.data;
                                 props[key] = data[(uint)i];
                              }
                           }

                           generateZoneFeature(dggrs, z, crs, i + 1, centroids, true, props);

                           i++;
                        }
                        delete subZones;

                        props.Free();
                        delete props;
                        PrintLn(" ]");
                        PrintLn("}");
                     }
                  }
               }
            }
            else
               PrintLn($"Invalid zone ID: ", zoneID);

            delete dggrs;
         }
         else
            PrintLn($"Failure to recognize DGGRS");
         delete dggsJSON;
      }
      else
         PrintLn($"Failure to parse DGGS-JSON file ", inputFile);
      delete f;
   }
   else
      PrintLn($"Failure to open file ", inputFile);
   return exitCode;
}



================================================
FILE: commands/zone.ec
================================================
public import IMPORT_STATIC "ecrt"
import IMPORT_STATIC "dggal"

import "info"
import "geom"  // For resolveCRSString()

int queryZone(DGGRS dggrs, const String coordinates, int level, Map<String, const String> options)
{
   int exitCode = 1;
   String coords[2];
   String s = CopyString(coordinates);
   int n = s ? TokenizeWith(s, 2, coords, ",", false) : 0;
   Degrees lat, lon;
   if(n == 2 && lat.OnGetDataFromString(coords[0]) && lon.OnGetDataFromString(coords[1]) &&
                lat <= Degrees {90} && lat >= Degrees {-90})
   {
      DGGRSZone zone;
      const String crsOption = options ? options["crs"] : null;
      CRS crs = resolveCRSString(crsOption);

      if(level == -1)
         level = 0;

      if(crs)
         zone = dggrs.getZoneFromCRSCentroid(level, crs, { lat, lon });
      else
         zone = dggrs.getZoneFromCRSCentroid(level, { epsg, 4326 }, { lat, lon });
      if(zone != nullZone)
      {
         displayInfo(dggrs, zone, options);
         exitCode = 0;
      }
      else
         PrintLn($"Could not identify zone from coordinates");
   }
   else if(coordinates)
      PrintLn($"Invalid coordinates for zone query");
   else
      PrintLn($"Missing coordinates for zone query");
   delete s;
   return exitCode;
}



================================================
FILE: dggal.org/index.html
================================================
<html>
<head>
<meta charset="UTF-8">
<title>DGGAL: Discrete Global Grid Abstraction Library</title>

</head>

<body bgcolor='#202030' text='#F0F0F0' link='#A0FFFF' vlink='#80DFDF' style='background: url("images/global-grids.png"); background-position: -40px -80px; background-color: #202030; background-repeat: repeat; width: 100%; height: 100%;'>
<div style='display:flex; min-height: 100%'>
<div style='min-width:40px; min-height: 100%; display:inline;'></div>
<div style='max-width:min(1560px,100% - 60px); text-align:left; margin: 30px auto auto auto; background-color: #202030; padding-top: 0px; padding-left: 10px; padding-right: 10px; padding-bottom: 10px;'>
<h1>DGGAL, the Discrete Global Grid Abstraction Library</h1>

<h2><em>DGGAL provides a common interface to perform various operations on Discrete Global Grid Reference Systems (DGGRS), facilitating the implementation of Discrete Global Grid Systems (DGGS), including implementing Web APIs based on
the <a href='https://docs.ogc.org/is/21-038r1/21-038r1.html'>OGC API - DGGS Standard</a>.</em></h2>
<h3>GitHub repository: <a href='https://github.com/ecere/dggal'>ecere/dggal</a></h3>

<h3><a href='https://github.com/ecere/dggal/archive/refs/heads/main.zip'>Latest Source Code</a></h3>

<h3><a href='https://github.com/ecere/dggal/blob/main/LICENSE'>License: BSD-3</a></h3>

<a href='https://dggal.org/docs/html/dggal/Classes/DGGRS.html'><img alt='DGGAL docs' src='https://img.shields.io/badge/docs-API_documentation-green.svg'></a>
<a href='https://pepy.tech/projects/dggal'><img alt='PyPI Downloads' src='https://static.pepy.tech/personalized-badge/dggal?period=total&units=INTERNATIONAL_SYSTEM&left_color=gray&right_color=GREEN&left_text=downloads'></a>

<h2>Installation from PyPI</h2>

Both a source distribution and built distribution for Linux, Windows and macOS, including the <code>dgg</code> utility and Python bindings are available <a href='https://pypi.org/project/dggal/'>from PyPI</a> and can be installed with:
<br/><br/>
<code>pip install dggal</code>

<h2>DGGAL integration in other software</h2>

DGGAL is already being integrated in several DGGS-enabled software, notably:

<ul>
<li><a href='https://plugins.qgis.org/plugins/vgridtools/'>Vgrid plugin for QGIS</a>, <a href='https://vgrid.gishub.vn/notebooks/08_dggal/'>Vgrid DGGS</a> and <a href='https://github.com/opengeoshub/vgrid-maplibre'>Vgrid plugin for Map Libre</a>,
<li>FME Community Modules: <a href='https://community.safe.com/fme-hub-alerts-55/dggsindexer-38685'>DGGS Indexer</a>, <a href='https://community.safe.com/fme-hub-alerts-55/dggsrelator-38765'>DGGS Relator</a>,
<a href='https://community.safe.com/fme-hub-alerts-55/dggsjsondecoder-387740'>DGGS-JSON Decoder</a>, and <a href='https://community.safe.com/fme-hub-alerts-55/dggsjsonencoder-38787'>DGGS-JSON Encoder</a>,
<li><a href='https://a5geo.org/'>a5geo</a> (adapting the DGGAL code for the DSEA / IVEA equal-area projection),
<li><a href='https://github.com/LandscapeGeoinformatics/pydggsapi/tree/dggal'>pydggsapi<a>,
<li><a href='https://github.com/GeoPlegma'>GeoPlegma</a>,
<li><a href='https://github.com/Geomatys/geotoolkit'>Geotoolkit</a>, a testing ground for <a href='https://sis.apache.org/'>Apache SIS</a>,
<li><a href='https://ecere.ca'>Ecere</a>'s <a href='http://gnosis.earth/'>GNOSIS Software Development Kit</a> and <a href='https://maps.gnosis.earth'>GNOSIS Map Server</a>.
</ul>

<h2>Supported Discrete Global Grid Reference Systems</h2>

DGGAL currently supports all nine DGGRS described in <a href='https://docs.ogc.org/is/21-038r1/21-038r1.html#annex-dggrs-def'>OGC API - DGGS Annex B</a>, as well as additional DGGRSs:
<h3>Axis-aligned DGGRS in WGS84 latitude and longitude (simple bounding boxes)</h3>

<ul>
<li> <a href='https://docs.ogc.org/is/21-038r1/21-038r1.html#ggg-dggrs'>GNOSIS Global Grid</a>: An axis-aligned quad-tree defined in WGS84 latitude and
longitude, with special handling of polar regions achieving an approximate maximum of ~48% variance from median zone area, corresponding to the
<a href='https://docs.ogc.org/is/17-083r4/17-083r4.html#toc58'>OGC 2D Tile Matrix Set of the same name</a>)
</ul>

<h3>Equal-Area DGGRSs based on Icosahedral Projections (aperture 3 and 7 Hexagonal, aperture 4 and 9 Axis-Aligned Rhombic)</h3>

All of these Icosahedral DGGRSs achieve equal-area on the WGS84 ellipsoid, and are oriented with a first vertex of the icosahedron positioned at
authalic latitude of <em>arctan(φ)</em> (where φ is the golden ratio), and longitude 11.20°E, with second vertex due North, resulting in only one
vertex / pentagon on land. Each of the 12 pentagons occupies 5/6th the area of a hexagon at the same refinement level.

<br/><br/>
Starting from version 0.0.6, the aperture 7 hexagonal grids and indexing are fully functional, including support for listing and resolving sub-zones for both hexagonal and pentagonal ancestral zones.
<br/><br/>

<h4>Icosahedral Snyder Equal Area (ISEA) projection</h4>

(<a href='https://doi.org/10.3138%2F27H7-8K88-4882-1752'>An Equal-Area Map Projection for Polyhedral Globes (1992)</a>, or dodecahedron configuration (DVEA)
of <a href='https://www.tandfonline.com/doi/abs/10.1559/152304006779500687'>Slice & Dice (2006)</a>)

<ul>
<li> <b>ISEA4R</b>: An equal area rhombic grid with a refinement ratio of 4 defined in the  transformed into a 5x6 Cartesian space resulting in axis-aligned square zones
<li> <a href='https://docs.ogc.org/is/21-038r1/21-038r1.html#isea9r-dggrs'>ISEA9R</a>: An equal area rhombic grid with a refinement ratio of 9 defined in the ISEA projection transformed into a 5x6 Cartesian space resulting in axis-aligned square zones
<li> <a href='https://docs.ogc.org/is/21-038r1/21-038r1.html#isea3h-dggrs'>ISEA3H</a>: An equal area hexagonal grid with a refinement ratio of 3 defined in the ISEA projection
<li> <a href='https://docs.ogc.org/is/21-038r1/21-038r1.html#isea7h-dggrs'>ISEA7H</a>: An equal area hexagonal grid with a refinement ratio of 7 defined in the ISEA projection
<li> <b>ISEA7H_Z7</b>: Same Discrete Global Grid Hierarchy (DGGH) and sub-zone order as ISEA7H, but using the Z7 indexing for interoperability with <a href='https://github.com/sahrk/DGGRID'>DGGRID</a> and <a href='https://agile-giss.copernicus.org/articles/6/32/2025/'>IGEO7</a>.
<br/><br/>
<b>NOTE:</b> The DGGRID / IGEO7 interoperability of ISEA7H_Z7 relies on converting the authalic latitudes produced by DGGRID to geodetic latitudes to reference them to the WGS84 ellipsoid,
and using the orientation which can be specified in DGGRID with <code>dggs_vert0_lon 11.20</code>, <code>dggs_vert0_lat 58.282525588538994675786</code> and <code>dggs_vert0_azimuth 0.0</code>.
Efficient conversion from authalic latitude to geodetic latitudes is described by <a href='https://arxiv.org/pdf/2212.05818'>Charles Karney's "On auxiliary latitudes"</a>
and can be performed using <a href='https://geographiclib.sourceforge.io/doc/library.html'>Geographiclib</a> or with the <code>authalicSetup()</code>, <code>latGeodeticToAuthalic()</code> and <code>latAuthalicToGeodetic()</code>
<a href='https://github.com/ecere/dggal/blob/main/src/projections/authalic.ec'>functions from DGGAL</a>.

</ul>

<h4>Icosahedral Vertex-oriented great circle Equal Area (IVEA) projection</h4>

(<a href='https://www.tandfonline.com/doi/abs/10.1559/152304006779500687'>Slice & Dice (2006)</a>, or applying <a href='https://doi.org/10.3138%2F27H7-8K88-4882-1752'>Snyder 1992</a> to the dodecahedron (DSEA))

<ul>
<li> <b>IVEA4R</b>: An equal area rhombic grid with a refinement ratio of 4 defined in the IVEA projection transformed into a 5x6 Cartesian space resulting in axis-aligned square zones, using the same global indexing and sub-zone ordering as for ISEA4R
<li> <a href='https://docs.ogc.org/is/21-038r1/21-038r1.html#ivea9r-dggrs'>IVEA9R</a>: An equal area rhombic grid with a refinement ratio of 9 defined in the IVEA projection transformed into a 5x6 Cartesian space resulting in axis-aligned square zones, using the same global indexing and sub-zone ordering as for ISEA9R
<li> <a href='https://docs.ogc.org/is/21-038r1/21-038r1.html#ivea3h-dggrs'>IVEA3H</a>: An equal area hexagonal grid with a refinement ratio of 3 defined in the IVEA projection, using the same global indexing and sub-zone ordering as for ISEA3H
<li> <a href='https://docs.ogc.org/is/21-038r1/21-038r1.html#ivea7h-dggrs'>IVEA7H</a>: An equal area hexagonal grid with a refinement ratio of 7 defined in the IVEA projection, using the same global indexing and sub-zone ordering as for ISEA7H
<li> <b>IVEA7H_Z7</b>: Same DGGH and sub-zone order as IVEA7H, but using same Z7 indexing as for ISEA7H_Z7.
</ul>

<b>NOTE:</b> This projection is superior to ISEA and RT(S)EA at avoiding perceptible cusps, resulting in more compact/regular zones.

<h4>Rhombic Triacontahedron (Snyder) Equal-Area (RT(S)EA) projection</h4>

(applying <a href='https://doi.org/10.3138%2F27H7-8K88-4882-1752'>Snyder 1992</a> to the Rhombic Triacontahedron,
 alternate configuration of <a href='https://www.tandfonline.com/doi/abs/10.1559/152304006779500687'>Slice & Dice (2006)</a>,
<a href='http://hdl.handle.net/1880/114595'>Disdyakis Triacontahedron Discrete Global Grid System</a>, or
<a href='https://doi.org/10.1080/17538947.2022.2130459'>Construction of rhombic triacontahedron discrete global grid systems</a>)

<ul>
<li> <b>RTEA4R</b>: An equal area rhombic grid with a refinement ratio of 4 defined in the RTEA projection transformed into a 5x6 Cartesian space resulting in axis-aligned square zones, using the same global indexing and sub-zone ordering as for ISEA4R
<li> <b>RTEA9R</b>: An equal area rhombic grid with a refinement ratio of 9 defined in the RTEA projection transformed into a 5x6 Cartesian space resulting in axis-aligned square zones, using the same global indexing and sub-zone ordering as for ISEA9R
<li> <b>RTEA3H</b>: An equal area hexagonal grid with a refinement ratio of 3 defined in the RTEA projection using the same global indexing and sub-zone ordering as for ISEA3H
<li> <b>RTEA7H</b>: An equal area hexagonal grid with a refinement ratio of 7 defined in the RTEA projection using the same global indexing and sub-zone ordering as for ISEA7H
<li> <b>RTEA7H_Z7</b>: Same DGGH and sub-zone order as RTEA7H, but using same Z7 indexing as for ISEA7H_Z7.
</ul>

<h3>Axis-aligned and Equal-Area DGGRSs based on HEALPix Projection</h3>

(<a href='https://arxiv.org/pdf/astro-ph/0409513'>HEALPix projection</a>)

<ul>
<li> <a href='https://docs.ogc.org/is/21-038r1/21-038r1.html#HEALPix-dggrs'>HEALPix</a>: An equal area and axis-aligned grid with square zones topology and a
refinement ratio of 4 defined in the HEALPix projection, using configuration Nφ/H = 4, Nθ/K = 3 (same as default
<a href='https://proj.org/en/stable/operations/projections/healpix.html'>PROJ implementation</a>), the new indexing described in OGC API - DGGS Annex B,
and scanline-based sub-zone ordering
<li> <a href='https://docs.ogc.org/is/21-038r1/21-038r1.html#rHEALPix-dggrs'>rHEALPix</a>: An equal area and axis-aligned grid with square zones topology and
a refinement ratio of 9 defined in the rHEALPix projection using 50° E prime meridian
(equivalent to <a href='https://proj.org/en/stable/operations/projections/rhealpix.html'>PROJ implementation</a> with parameters
<code>+proj=rhealpix +lon_0=50 +ellps=WGS84</code>),
the <a href='https://iopscience.iop.org/article/10.1088/1755-1315/34/1/012012'>original hierarchical indexing</a>, and scanline-based sub-zone ordering
</ul>

<h2>libDGGAL <a href='docs/html/dggal/Classes/DGGRS.html'>API documentation</a></h2>

The API documentation can be <a href='https://dggal.org/docs/html/dggal/Classes/DGGRS.html'>found here</a>.
<br/><br/>

The <code>DGGRS</code> class provides most of the functionality of the library, allowing to resolve DGGRS zones by textual ID to a unique 64-bit zone integer identifier (<code>DGGRSZone</code>).
The geometry and sub-zones of a particular zone can also be queried.
The concept of <a href='https://docs.ogc.org/is/21-038r1/21-038r1.html#term-sub-zone'>sub-zones</a> is key to encoding both vector and raster geospatial data quantized to a DGGRS.
The DGGAL library also allows to resolve a sub-zone index at a particular depth from a parent zone, allowing to read DGGS-optimized data such as
<a href='http://dggs-json.org'>DGGS-JSON</a> and <a href='https://docs.ogc.org/is/21-038r1/21-038r1.html#rc_data-dggs-jsonfg'>DGGS-JSON-FG</a>.

<a name='building-dggal'><h2>Building DGGAL</h2></a>

The recommended method to obtain and build DGGAL and the <code>dgg</code> tool is to follow the instructions in <a href='https://github.com/ecere/dggal/blob/main/BUILDING.md'>BUILDING.md</a>,
or running <a href='https://raw.githubusercontent.com/ecere/dggal/refs/heads/main/fetchAndBuild.sh'>fetchAndBuild.sh<a> /
<a href='https://raw.githubusercontent.com/ecere/dggal/refs/heads/main/fetchAndBuild.bat'>fetchAndBuild.bat</a>.<br/><br/>

DGGAL is now built using the <a href='https://github.com/ecere/eC'>stand-alone eC development kit and eC runtime library</a>,
avoiding unnecessary dependencies on other components of the legacy monolithic Ecere SDK runtime library.<br/><br/>

The script will clone both the eC and DGGAL repositories and build everything, including the C, C++, Rust and Python bindings
if the required development tools are properly installed and configured.

<h2>Language bindings</h2>

While the library is written in the <a href='https://ec-lang.org'>eC programming language</a>, object-oriented bindings for C, C++ and Python generated using the
Ecere SDK's <a href='https://github.com/ecere/bgen'><code>bgen</code> tool</a> are provided. Bindings for Rust, Java and JavaScript (for WebAssembly build) are available as well.
Support for additional languages may be added in the future.

<h3>C Bindings</h3>

C bindings with zero overhead invoking the eC methods, but relying on macros, are <a href='https://github.com/ecere/dggal/tree/main/bindings/c'>available here</a>.<br/><br/>

A C example implementing the <code>dgg info</code> command using these DGGAL C bindings is <a href='https://github.com/ecere/dggal/blob/main/bindings_examples/c/info.c'>available here</a>.<br/><br/>

A second set of C bindings with the small overhead of additional function calls but avoiding the need for macros are <a href='https://github.com/ecere/dggal/tree/main/bindings/c_fn'>available here</a>.
These bindings still rely on the first set of C bindings with no overhead, but their C header file and function exports make them more suitable for third-party bindings generator for additional languages.<br/><br/>

A C example implementing the <code>dgg info</code> command using the no-macros C bindings is <a href='https://github.com/ecere/dggal/blob/main/bindings_examples/c_fn/info.c'>available here</a>.

<h3>C++ Bindings</h3>

C++ bindings (depending on the C bindings)  are <a href='https://github.com/ecere/dggal/tree/main/bindings/cpp'>available here</a>.<br/><br/>

A C++ example implementing the <code>dgg info</code> command using the DGGAL C++ bindings is <a href='https://github.com/ecere/dggal/blob/main/bindings_examples/cpp/info.cpp'>available here</a>.

<h3>Python Bindings</h3>

Python bindings (depending on the C bindings) are <a href='https://github.com/ecere/dggal/tree/main/bindings/py'>available here</a>.<br/><br/>

A Python example using the DGGAL Python bindings is <a href='https://github.com/ecere/dggal/blob/main/bindings_examples/py/info.py'>available here</a>.

<h3>Rust Bindings</h3>

Rust bindings (depending on the C bindings) are <a href='https://github.com/ecere/dggal/tree/main/bindings/rust'>available here</a>.<br/><br/>

A Rust example using the DGGAL Rust bindings is <a href='https://github.com/ecere/dggal/blob/main/bindings_examples/rust/info.rs'>available here</a>.

<h3>Java Bindings</h3>

Java bindings generated with the help of <a href='https://openjdk.org/projects/panama/'>Panama</a> (depending on both the zero overhead and no-macro bindings) are
<a href='https://github.com/jsorel/dggal-java/commits/main/'>available here</a>, currently maintained by <a href='https://github.com/jsorel'>Johann Sorel</a> from <a href='https://www.geomatys.com/'>Geomatys</a>.

<h3>WebAssembly build and JavaScript Bindings</h3>

JavaScript bindings (based on both the zero overhead and no-macro bindings) are available here: <a href='https://github.com/ecere/dggal/blob/main/bindings/js/dggal.js'>dggal.js</a>,
depending on <a href='https://dggal.org/web/libdggal.js'>libdggal.js</a> and <a href='https://dggal.org/web/libdggal_c_fn.js.0.0.wasm'>libdggal_c_fn.js.0.0.wasm</a>.<br/><br/>

HTML / JavaScript examples using the DGGAL JavaScript bindings are <a href='https://github.com/ecere/dggal/tree/main/bindings_examples/js'>available here</a>, with a <a href='https://dggal.org/web/'>live demo here</a>.<br/><br/>

See the <a href='https://raw.githubusercontent.com/ecere/dggal/refs/heads/main/fetchAndBuildWASM.sh'>fetchAndBuildWASM.sh</a> script for building the DGGAL WASM module from source.

<h2><code>dgg</code> tool</h2>

<h3>Syntax</h3>
<pre>
   dgg &lt;dggrs&gt; &lt;command&gt; [options] &lt;arguments&gt;
</pre>

<h3>Supported DGGRSs</h3>
<ul>
<li> <code>gnosis</code> (Global Grid)
<li> <code>isea4r</code>, <code>isea9r</code>, <code>isea3h</code>, <code>isea7h</code>, <code>isea7h_z7</code>
<li> <code>ivea4r</code>, <code>ivea9r</code>, <code>ivea3h</code>, <code>ivea7h</code>, <code>ivea7h_z7</code>
<li> <code>rtea4r</code>, <code>rtea9r</code>, <code>rtea3h</code>, <code>rtea7h</code>, <code>rtea7h_z7</code>
<li> <code>rhealpix</code> (aperture 9, 50° E)
<li> <code>healpix</code> (aperture 4, Nφ/H = 4, Nθ/K = 3)
</ul>

<h3>Commands</h3>
<dl>
<dt>
<a href='#info'><b>info</b></a> [<em>zone</em>]
</dt>
<dd>
Display information about a DGGRS or about a zone of a DGGRS
</dd><br>
<dt>
<a href='#zone'><b>zone</b></a> &lt;<em>coord1,coord2</em>&gt; [<em>level</em>]
</dt>
<dd>
Return DGGRS zone at position -- specified in EPSG:4326 (lat,lon)
</dd><br>
<dt>
<a href='#level'><b>level</b></a> [<em>level</em>]
</dt>
<dd>
Display information about a DGGRS refinement level
</dd><br>
<dt>
<a href='#grid'><b>grid</b></a> [<em>level</em>]
</dt>
<dd>
Generate DGGRS grid at specified refinement level (default: 0)
</dd><br>
<dt>
<a href='#geom'><b>geom</b></a> &lt;<em>zone</em>&gt;
</dt>
<dd>
Generate geometry for a particular zone
</dd><br>
<dt>
<a href='#list'><b>list</b></a> [<em>level</em>]
</dt>
<dd>
List DGGRS zones (as JSON string array)
</dd><br>
<dt>
<a href='#rel'><b>rel</b></a> &lt;<em>zone 1</em>&gt; &lt;<em>zone 2</em>&gt;
</dt>
<dd>
Display information about the relationships between two zones of a DGGRS
</dd><br>
<dt>
<a href='#sub'><b>sub</b></a> &lt;<em>zone</em>&gt; [<em>index</em>]
</dt>
<dd>
List subzones of a DGGRS zone or resolve a sub-zone by index
</dd><br>
<dt>
<a href='#index'><b>index</b></a> &lt;<em>parent zone</em>&gt; &lt;<em>sub-zone</em>&gt;
</dt>
<dd>
Display index of sub-zone within parent
</dd><br>
<dt>
<b>compact</b> &lt;<em>JSON input zone file (zone ID strings array)</em>&gt;
</dt>
<dd>
Compact input zone list
</dd><br>
<dt>
<b>decompact</b> &lt;<em>JSON input zone file (zone ID strings array)</em>&gt; [<em>level</em>]
</dt>
<dd>
Decompact zone list
</dd><br>
<dt>
<a href='#togeo'><b>togeo</b></a> &lt;<em>DGGS-(UB)JSON(-FG) input file</em>&gt;
</dt>
<dd>
Convert DGGS-JSON (DGGS-quantized raster data) or DGGS-JSON-FG (DGGS-quantized vector data) to GeoJSON
</dd>
</dl>

<h3>Options</h3>

<dl>
<dt>
<b>-o</b> &lt;<em>filename</em>&gt;
</dt><dd>
Output to file instead of standard output

</dd><br><dt>
<b>-crs</b> &lt;<em>crs</em>&gt;
</dt><dd>
Select an output coordinate reference system, one of:
EPSG:4326, OGC:CRS84, 5x6, ico (icosahedron net), rhp (rHEALPix), hpx (HEALPix)

</dd><br><dt>
<b>-depth</b> &lt;<em>relative depth</em>&gt;
</dt><dd>
For sub, specify relative depth<br>
Also to change depth considered for calculating optional [level] from -scale, -mpp and -pixels<br>
default: depth corresponding to ~64K sub-zones (ISEA: 5, ISEA3H: 10, GNOSIS: 8)

</dd><br><dt>
<b>-bbox</b> &lt;<em>llLat,llLon,urLat,urLon</em>&gt;
</dt><dd>
Specify extent for which to list zones, generate grid, or reference extent for -pixels<br>
example: -bbox 60,-120,62,-118 -- specified in EPSG:4326 (lat,lon)

</dd><br><dt>
<b>-centroids</b>
</dt><dd>
For sub, list centroids instead of sub-zone identifiers<br>
For togeo, use centroid points for geometry instead of polygons

</dd><br><dt>
<b>-compact</b>
</dt><dd>
For list and grid, return compact list of zones

</dd><br><dt>
<b>-mpp</b> &lt;<em>physical meters per sub-zone</em>&gt;
</dt><dd>
Specify physical meters per sub-zone as substitute for optional [level] arguments

</dd><br><dt>
<b>-scale-denom</b> &lt;<em>scale denominator</em>&gt;
</dt><dd>
Specify scale-denominator as substitute for optional [level] arguments (based on -depth)

</dd><br><dt>
<b>-pixels</b> &lt;<em>with,height</em>&gt;
</dt><dd>
Specify display pixels as a substitute for optional [level] argument (in combination with -bbox)

</dd><br><dt>
<b>-display-res</b> &lt;<em>mm-per-pixels</em>&gt;
</dt><dd>
Specify display resolution in millimeters/pixel in combination with -scale and -pixels (default: 0.28)
</dd>
</dl>

<h3>Example Usage</h3>

<a name='info'><h4><code>info</code></h4></a>

<h5>Information about a particular DGGRS</h5>

<pre>
&gt; dgg isea3h info
DGGRS: https://maps.gnosis.earth/ogcapi/dggrs/ISEA3H
Refinement Ratio: 3
Maximum level for 64-bit global identifiers (DGGAL DGGRSZone): 33
Default ~64K sub-zones relative depth: 10
</pre>

<h5>Information about a particular zone</h5>

<pre>
&gt; dgg isea3h info A4-0-A
DGGRS: https://maps.gnosis.earth/ogcapi/dggrs/ISEA3H
Textual Zone ID: A4-0-A
64-bit integer ID: 36028797018963968 (0x80000000000000)

Level 0 zone (5 edges, centroid child)
42505468477007.4 m² (42505468.4770074 km²)
49411 sub-zones at depth 10
WGS84 Centroid (lat, lon): 0, -20.517474730219
WGS84 Extent (lat, lon): { -35.385452137707, -57.8948427221833 }, { 35.385452137707, 11.2 }

No parent

Children (6):
   A4-0-B (centroid)
   A4-0-C
   A4-0-D
   A3-0-C
   A2-0-D
   A2-0-C

Neighbors (5):
   (direction 2): A2-0-A
   (direction 3): A6-0-A
   (direction 0): AA-0-A
   (direction 6): A3-0-A
   (direction 7): A5-0-A

[EPSG:4326] Vertices (5):
   20.9908527620464, 11.2
   -20.9908527620465, 11.2
   -35.385452137707, -33.8
   0, -57.8948427221833
   35.385452137707, -33.8
</pre>

<a name='zone'><h4><code>zone</code></h4></a>

Identify zone at a particular geodetic position.

<pre>
&gt; dgg isea3h zone 34,-70
DGGRS: https://maps.gnosis.earth/ogcapi/dggrs/ISEA3H
Textual Zone ID: A2-0-A
64-bit integer ID: 18014398509481984 (0x40000000000000)

Level 0 zone (5 edges, centroid child)
42505468477007.4 m² (42505468.4770074 km²)
49411 sub-zones at depth 10
WGS84 Centroid (lat, lon): 31.832357532016, -78.8
WGS84 Extent (lat, lon): { 0, -123.8 }, { 69.1802093248182, -33.8 }

No parent

Children (6):
   A2-0-B (centroid)
   A2-0-C
   A2-0-D
   A1-0-C
   A0-0-D
   A0-0-C

Neighbors (5):
   (direction 2): A0-0-A
   (direction 3): A4-0-A
   (direction 0): AA-0-A
   (direction 6): A1-0-A
   (direction 7): A3-0-A

[EPSG:4326] Vertices (5):
   35.385452137707, -33.8
   0, -57.8948427221833
   0, -99.7051575819393
   35.3854519371908, -123.8
   69.1802093248182, -78.8
</pre>

<a name='level'><h4><code>level</code></h4></a>

<h5>Information about levels of a particular DGGRS</h5>

<pre>
&gt; dgg isea3h level
DGGRS: https://maps.gnosis.earth/ogcapi/dggrs/ISEA3H
Assuming sub-zone depth of 10 and display resolution of 0.28 mm/pixel:
Level       Reference Area                             Sub-zones count        Sub-zone area                                                 Scale                   Meters/Sub-zone
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 0: 42505468477007.39843750 m² (42505468.47700740 km²)          49411          860243032.46255684 m² (     8602430324625.56933594 cm²)   1:   104965840      29390.43523832 m (   2939043.52383217 cm)
 1: 15939550678877.77343750 m² (15939550.67887777 km²)          59293          268826854.41582942 m² (     2688268544158.29394531 cm²)   1:    60602124      16968.59485403 m (   1696859.48540341 cm)
 2:  5544191540479.22558594 m² ( 5544191.54047923 km²)          59293           93504992.84028849 m² (      935049928402.88488770 cm²)   1:    34988666       9796.82649363 m (    979682.64936343 cm)
 3:  1875241256338.56152344 m² ( 1875241.25633856 km²)          59293           31626688.75480346 m² (      316266887548.03460693 cm²)   1:    20200718       5656.20112285 m (    565620.11228463 cm)
 4:   628159632665.13391113 m² (  628159.63266513 km²)          59293           10594161.75037751 m² (      105941617503.77513123 cm²)   1:    11662891       3265.60937742 m (    326560.93774175 cm)
 5:   209730929985.23385620 m² (  209730.92998523 km²)          59293            3537195.45283986 m² (       35371954528.39860535 cm²)   1:     6733573       1885.40047940 m (    188540.04793995 cm)
 6:    69948659040.60459900 m² (   69948.65904060 km²)          59293            1179711.92283414 m² (       11797119228.34138870 cm²)   1:     3887630       1088.53647937 m (    108853.64793690 cm)
 7:    23320483802.30837250 m² (   23320.48380231 km²)          59293             393309.22372470 m² (        3933092237.24695539 cm²)   1:     2244524        628.46683036 m (     62846.68303597 cm)
 8:     7773968507.65239239 m² (    7773.96850765 km²)          59293             131111.06720275 m² (        1311110672.02745557 cm²)   1:     1295877        362.84549387 m (     36284.54938723 cm)
 9:     2591375496.48476219 m² (    2591.37549648 km²)          59293              43704.57720953 m² (         437045772.09531683 cm²)   1:      748175        209.48894360 m (     20948.89435974 cm)
10:      863797683.49797928 m² (     863.79768350 km²)          59293              14568.29108829 m² (         145682910.88290006 cm²)   1:      431959        120.94849799 m (     12094.84979852 cm)
11:      287933211.32035321 m² (     287.93321132 km²)          59293               4856.10799454 m² (          48561079.94541568 cm²)   1:      249392         69.82964787 m (      6982.96478712 cm)
12:       95977809.34637524 m² (      95.97780935 km²)          59293               1618.70388320 m² (          16187038.83196587 cm²)   1:      143986         40.31616600 m (      4031.61659961 cm)
13:       31992611.14208768 m² (      31.99261114 km²)          59293                539.56809644 m² (           5395680.96437820 cm²)   1:       83131         23.27654929 m (      2327.65492906 cm)
14:       10664204.60587722 m² (      10.66420461 km²)          59293                179.85604719 m² (           1798560.47187311 cm²)   1:       47995         13.43872200 m (      1343.87219987 cm)
15:        3554734.96771997 m² (       3.55473497 km²)          59293                 59.95201740 m² (            599520.17400367 cm²)   1:       27710          7.75884976 m (       775.88497635 cm)
16:        1184911.66691713 m² (       1.18491167 km²)          59293                 19.98400599 m² (            199840.05985818 cm²)   1:       15998          4.47957400 m (       447.95739996 cm)
17:         394970.55686243 m² (       0.39497056 km²)          59293                  6.66133535 m² (             66613.35349239 cm²)   1:        9237          2.58628325 m (       258.62832545 cm)
18:         131656.85242341 m² (       0.13165685 km²)          59293                  2.22044512 m² (             22204.45118706 cm²)   1:        5333          1.49319133 m (       149.31913332 cm)
19:          43885.61748957 m² (       0.04388562 km²)          59293                  0.74014837 m² (              7401.48373157 cm²)   1:        3079          0.86209442 m (        86.20944182 cm)
20:          14628.53916487 m² (       0.01462854 km²)          59293                  0.24671612 m² (              2467.16124414 cm²)   1:        1778          0.49773044 m (        49.77304444 cm)
21:           4876.17972181 m² (       0.00487618 km²)          59293                  0.08223871 m² (               822.38708141 cm²)   1:        1026          0.28736481 m (        28.73648061 cm)
22:           1625.39324062 m² (       0.00162539 km²)          59293                  0.02741290 m² (               274.12902714 cm²)   1:         593          0.16591015 m (        16.59101481 cm)
23:            541.79774688 m² (       0.00054180 km²)          59293                  0.00913763 m² (                91.37634238 cm²)   1:         342          0.09578827 m (         9.57882687 cm)
24:            180.59924896 m² (       0.00018060 km²)          59293                  0.00304588 m² (                30.45878079 cm²)   1:         129          0.03620456 m (         3.62045625 cm)
25:             60.19974965 m² (       0.00006020 km²)          59293                  0.00101529 m² (                10.15292693 cm²)   1:          95          0.02656689 m (         2.65668857 cm)
26:             20.06658322 m² (       0.00002007 km²)          59293                  0.00033843 m² (                 3.38430898 cm²)   1:          56          0.01574749 m (         1.57474944 cm)
27:              6.68886107 m² (       0.00000669 km²)          59293                  0.00011281 m² (                 1.12810299 cm²)   1:          36          0.01004134 m (         1.00413390 cm)
28:              2.22962036 m² (       0.00000223 km²)          59293                  0.00003760 m² (                 0.37603433 cm²)   1:          21          0.00581872 m (         0.58187229 cm)
29:              0.74320679 m² (       0.00000074 km²)          59293                  0.00001253 m² (                 0.12534478 cm²)   1:          12          0.00348148 m (         0.34814838 cm)
30:              0.24773560 m² (       0.00000025 km²)          59293                  0.00000418 m² (                 0.04178159 cm²)   1:           7          0.00201092 m (         0.20109213 cm)
31:              0.08257853 m² (       0.00000008 km²)          59293                  0.00000139 m² (                 0.01392720 cm²)   1:           4          0.00117525 m (         0.11752498 cm)
32:              0.02752618 m² (       0.00000003 km²)          59293                  0.00000046 m² (                 0.00464240 cm²)   1:           2          0.00067856 m (         0.06785649 cm)
33:              0.00917539 m² (       0.00000001 km²)          59293                  0.00000015 m² (                 0.00154747 cm²)   1:           1          0.00039338 m (         0.03933785 cm)
</pre>

<h5>Information about a particular DGGRS level</h5>
<pre>
>  dgg isea3h level 15
DGGRS: https://maps.gnosis.earth/ogcapi/dggrs/ISEA3H
Refinement Level: 15
Reference area: 3554734.96771997 m² (3.55473496771997 km²)

Assuming sub-zone depth of 10 (59293 sub-zones) and display resolution of 0.28 mm/pixel:
   Sub-zones area: 59.9520174003672 m² (599520.174003672 cm²)
   Cartographic scale: 1:27710
   Physical meters/sub-zone: 7.75884976353492 (775.884976353492 cm/sub-zone)
</pre>

<a name='grid'><h4><code>grid</code></h4></a>

<h5>Generate grid geometry for a particular refinement level</h5>

Output is <a href='https://geojson.org'>GeoJSON</a>:<br/><br/>

<code>
&gt; dgg isea3h -crs ico grid 3 > isea3h-level3-isea.geojson
</code>

<br/><br/>
<center><img src='images/isea3h-grid-level3.png' width='100%'/></center>
<br/><br/>

<code>
&gt; dgg isea3h grid 3 > isea3h-level3-crs84.geojson
</code>

<br/><br/>
<center><img src='images/isea3h-grid-level3-crs84.png' width='800'/></center>

<h5>Generate grid geometry for a given bounding box using compacted zones</h5>

<pre>
&gt; dgg isea3h grid 15 -compact -bbox 44,-76,46,-74
</pre>

<br/><br/>
<center><img src='images/compact-grid.png' width='500'/></center>


<a name='geom'><h4><code>geom</code></h4></a>

Generate geometry of a specific zone<br/>

<pre>
&gt; dgg isea3h geom A4-0-A
</pre>

<center><img src='images/A4-0-A.png' width='800'/></center>

<!--pre>
{
   "type" : "Feature",
   "id" : "A4-0-A",
   "geometry" : {
      "type" : "Polygon",
      "coordinates" : [
         [ [11.2, 20.9908533396875], [11.2, 18.9046368254835], [11.2, 16.817317021754], [11.2, 14.7282441160477], [11.2, 12.6367658994772], [11.2, 10.5422256002322], [11.2, 8.44395966388283], [11.2, 6.3412954618102], [11.2, 4.2335489079295], [11.2, 2.12002196235325], [11.2, -0.00000000000000958], [11.2, -2.12002196235327], [11.2, -4.2335489079295], [11.2, -6.34129546181022], [11.2, -8.44395966388284], [11.2, -10.5422256002322], [11.2, -12.6367658994773], [11.2, -14.7282441160477], [11.2, -16.817317021754], [11.2, -18.9046368254835], [11.2, -20.9908533396875], [9.25904611568614, -22.022704447347], [7.2894978850024, -23.0315860032884], [5.2895073521231, -24.0162595826945], [3.2572732870332, -24.9754140020123], [1.19105174674043, -25.907662551343], [-0.910831437312103, -26.8115406666264], [-3.04996620024865, -27.6855041419538], [-5.22784181139874, -28.5279279934546], [-7.44582852527487, -29.3371060956138], [-9.70515744760715, -30.111251717508], [-11.9990182364648, -30.8460627665615], [-14.3199274459944, -31.5377272377057], [-16.6678118661126, -32.1851262644314], [-19.0423550054196, -32.7871381036537], [-21.4429904142008, -33.3426478478608], [-23.868897601607, -33.8505577351568], [-26.319001132268, -34.3097979200868], [-28.791973441741, -34.7193375329077], [-31.2862418322802, -35.0781958218138], [-33.7999999994894, -35.385453143805], [-35.328584064796, -33.7294909375037], [-36.7997931901407, -32.0544538235723], [-38.2190895198383, -30.3615150627895], [-39.591520816704, -28.651669714028], [-40.9217621171856, -26.9257555850354], [-42.2141557503646, -25.184471421695], [-43.4727493595782, -23.4283926793226], [-44.7013318005733, -21.6579851878463], [-45.9034669523704, -19.8736169902905], [-47.0825255880168, -18.075568603016], [-48.2378134716698, -16.2702095110336], [-49.3687568644497, -14.463940351611], [-50.4786064975358, -12.656986739445], [-51.5704092970534, -10.8495265877445], [-52.647041014988, -9.04169850753405], [-53.7112358369818, -7.23360915100237], [-54.765613515085, -5.42533970970474], [-55.8127045186767, -3.61695174870332], [-56.8549736519885, -1.80849253470827], [-57.894842551487, 0.0000000010850795], [-56.8549736519113, 1.80849253683432], [-55.8127045185966, 3.61695175082982], [-54.7656135150002, 5.425339711832], [-53.7112358368904, 7.2336091531306], [-52.6470410148878, 9.04169850966353], [-51.5704092969423, 10.8495265898755], [-50.4786064974117, 12.6569867415778], [-49.36875686431, 14.4639403537457], [-48.237813471512, 16.2702095131705], [-47.082525588539, 18.0755686040723], [-45.9034669536086, 19.873616990275], [-44.7013318018277, 21.6579851878424], [-43.47274936085, 23.428392679331], [-42.214155751655, 25.1844714217162], [-40.9217621184958, 26.9257555850703], [-39.5915208180354, 28.651669714077], [-38.219089521192, 30.3615150628536], [-36.799793191518, 32.0544538236523], [-35.328584066198, 33.7294909376005], [-33.8000000009355, 35.3854531438384], [-31.2862418337828, 35.0781958220137], [-28.7919734432313, 34.7193375331383], [-26.3190011337452, 34.3097979203474], [-23.86889760307, 33.850557735447], [-21.442990415649, 33.34264784818], [-19.0423550068522, 32.787138104001], [-16.6678118675294, 32.1851262648063], [-14.319927447395, 31.5377272381076], [-11.9990182378492, 30.8460627669896], [-9.70515744897538, 30.1112517179616], [-9.7051574476072, 30.1112517175078], [-7.44582852527492, 29.3371060956137], [-5.2278418113988, 28.5279279934545], [-3.0499662002487, 27.6855041419537], [-0.91083143731212, 26.8115406666263], [1.1910517467404, 25.907662551343], [3.2572732870332, 24.9754140020123], [5.289507352124, 24.0162595826945], [7.28949788500238, 23.0315860032884], [9.259046115687, 22.022704447347], [11.2, 20.9908533396875] ]
      ]
   },
   "properties" : {
     "zoneID" : "A4-0-A"
   }
}
</pre-->

<pre>
&gt; dgg -crs ico isea3h geom A4-0-A
</pre>

<center><img src='images/zone-geom.png'/></center>

<a name='list'><h4><code>list</code></h4></a>

<h5>List zones of a given refinement level</h5>

<pre>
&gt; dgg isea3h list 0
</pre>

<pre>
[ "A0-0-A", "A1-0-A", "A2-0-A", "A3-0-A", "A4-0-A", "A5-0-A",
"A6-0-A", "A7-0-A", "A8-0-A", "A9-0-A", "AA-0-A", "AB-0-A" ]
</pre>

<h5>List compacted zones of a given refinement level for a particular bounding box</h5>

<pre>
&gt; dgg isea3h list 10 -compact -bbox 44,-76,46,-74
</pre>

<pre>
[ "E0-1397-A", "F0-AAC7-A", "F0-ABB7-A", "F0-ABB8-A", "F0-ABB9-A", "F0-ABBA-A",
"F0-ABBB-A", "F0-ACA9-A", "F0-ACAA-A", "F0-ACAB-A", "F0-ACAC-A", "F0-ACAD-A",
"F0-ACAE-A", "F0-AD9D-A", "F0-AD9E-A", "F0-ADA1-A", "F0-ADA2-A", "F0-AE91-A",
"F0-AE95-A", "F0-AF84-A", "F0-AF85-A", "F0-AF88-A", "F0-AF89-A", "F0-B078-A",
"F0-B079-A", "F0-B07A-A", "F0-B07B-A", "F0-B07C-A", "F0-B16B-A", "F0-B16C-A",
"F0-B16D-A", "F0-B16E-A", "F0-B16F-A", "F0-B170-A", "F0-B25F-A", "F0-B260-A",
"F0-B261-A", "F0-B262-A", "F0-B263-A", "F0-B352-A", "F0-B353-A", "F0-B354-A",
"F0-B355-A", "F0-B356-A", "F0-B357-A", "F0-B446-A", "F0-B447-A", "F0-B448-A" ]
</pre>

<a name='rel'><h4><code>rel</code></h4></a>

Show relationships between two zones

<pre>
&gt; dgg isea3h rel A4-0-A D4-20-D
DGGRS: https://maps.gnosis.earth/ogcapi/dggrs/ISEA3H
Relationships between zones A4-0-A (A) and D4-20-D (B):

Zone A is coarser than zone B by 7 refinement levels
The area of zone A is greater than the area of zone B (area of B is 0.054869684499314 % of zone A)
Zone A is NOT an immediate child of zone B
Zone A is NOT an immediate parent of zone B
Zone A is NOT a descendant of zone B
Zone A is an ancestor of zone B
Zone A is NOT a sub-zone of zone B
Zone A has B as a sub-zone (at depth 7, index 1034)
These zones are NOT neighbors
These zones are NOT siblings
Zone A is NOT contained in zone B
Zone A contains zone B
Zone A and B overlap
</pre>

<a name='sub'><h4><code>sub</code></h4></a>

<h5>Query sub-zones of parent zone at a particular relative depth</h5>

<pre>
&gt; dgg isea3h sub A4-0-A -depth 3
</pre>

<pre>
[ "B2-7-B", "B2-4-D", "B2-4-C", "B2-5-B", "B2-7-D", "B2-7-C", "B2-8-B",
"B2-5-D", "B2-5-C", "B3-1-C", "B3-2-B", "B2-8-D", "B2-8-C", "B4-1-B",
"B4-1-C", "B3-5-B", "B3-2-D", "B3-2-C", "B4-0-B", "B4-0-C", "B4-1-D",
"B4-5-B", "B3-5-C", "B4-3-B", "B4-0-D", "B4-4-B", "B4-4-C", "B4-3-D",
"B4-3-C", "B4-4-D", "B4-7-B" ]
</pre>

<h5>Identify sub-zone of parent zone at a particular relative depth and index</h5>

<pre>
&gt; dgg isea3h sub A4-0-A 8 -depth 3
</pre>
<pre>
"B2-5-C"
</pre>

<a name='index'><h4><code>index</code></h4></a>

<h5>Query index of sub-zone</h5>

<pre>
&gt; dgg isea3h index A4-0-A B2-5-C
DGGRS: https://maps.gnosis.earth/ogcapi/dggrs/ISEA3H
B2-5-C is at index 8 of A4-0-A at depth 3
</pre>

<pre>
&gt; dgg isea3h index A4-0-A B6-5-C
DGGRS: https://maps.gnosis.earth/ogcapi/dggrs/ISEA3H
sub-zone B6-5-C not found within parent A4-0-A
</pre>

<a name='togeo'><h4><code>togeo</code></h4></a>

Converts <a href'http://dggs-json.org'>DGGS-JSON</a> (and eventually <a href='https://docs.ogc.org/is/21-038r1/21-038r1.html#rc_data-dggs-jsonfg'>DGGS-JSON-FG</a> and <a href='https://ubjson.org/'>UBJSON</a> variants) to GeoJSON
to facilitate interoperability with traditional GIS software / software not aware of the DGGRS.

<br><br>
<a href='https://maps.gnosis.earth/ogcapi/collections/sentinel2-l2a/dggs/ISEA3H/zones/G7-67252-B/data.json?zone-depth=8&datetime=2022-10-28&properties=B08'>
https://maps.gnosis.earth/ogcapi/collections/sentinel2-l2a/dggs/ISEA3H/zones/G7-67252-B/data.json?zone-depth=8&datetime=2022-10-28&properties=B08
</a>

<pre>
&gt; dgg isea3h togeo -crs ico G7-67252-B-B08.json
</pre>

<center>
<img width='600' src='images/B08.png'/><br/>
<br/>
<em>B08 (near-infrared) band retrieved as DGGS-JSON data from <a href='https://sentinel.esa.int/web/sentinel/missions/sentinel-2'>Copernicus/ESA sentinel-2</a> converted to GeoJSON and visualized in QGIS</em>
</center>
<br/><br/>
<em>Copyright © 2025 Ecere Corporation</em>
<br/><br/>
</div>
<div style='min-width:100px; min-height: 100%; display:inline;'></div>
</div>
</body>
</html>



================================================
FILE: docs/dggal/_global-defs.econ
================================================
{
   description = "DGGAL, the Discrete Global Grid Abstraction Library, provides a common interface to perform various operations on Discrete Global Grid Reference Systems (DGGRS), facilitating the implementation of Discrete Global Grid Systems (DGGS), including implementing Web APIs based on the OGC API - DGGS Standard.",
   defines = [
      {"nullZone", {
         description = "Special DGGRSZone value representing a null zone"
      }},
      {"wgs84InvFlattening", {
         description = "The inverse flattening of the WGS84 ellispsoid"
      }},
      {"wgs84Major", {
         description = "Length of the WGS84 ellipsoid major radius in meters"
      }},
      {"wgs84Minor", {
         description = "Length of the WGS84 ellipsoid minor radius in meters"
      }},
      {"wholeWorld", {
         description = "The geographic extent for the whole world"
      }}
   ],
   functions = [
      {"readDGGSJSON", {
         description = "Function to read DGGS-JSON data files, storing raster data quantized to a particular DGGRS for a specific DGGRS zone at one or more depths relative to that parent zone",
         example = "   File f = FileOpen(\"someFile.dggs.json\", read);<br>"
            "   if(f)<br>"
            "   {<br>"
            "      DGGSJSON dggsJSON = readDGGSJSON(f);<br>"
            "      if(dggsJSON)<br>"
            "      {<br>"
            "         // See DGGAL/commands/togeo.ec for full example converting DGGS-JSON to GeoJSON<br>"
            "         delete dggsJSON;<br>"
            "      }<br>"
            "      delete f;<br>"
            "   }",
         also = "FileOpen",
         parameters = [
            {"f", {
               description = "Opened file object",
               position = 1
            }}
         ],
         returnValue = "An object representing the DGGS-JSON data"
      }}
   ]
}



================================================
FILE: docs/dggal/CRS.econ
================================================
{
   description = "Identifier for a Coordinate Reference System",
   fields = [
      {"crsID", {
         description = "Numerical identifier of this CRS within the registry"
      }},
      {"h", {
         description = "True for \"h\" version of the CRS (for, CRS84h)"
      }},
      {"registry", {
         description = "Authoritative registry in which this CRS is defined"
      }}
   ]
}



================================================
FILE: docs/dggal/CRSExtent.econ
================================================
{
   description = "Geospatial extent expressed in a particular CRS",
   fields = [
      {"br", {
         description = "Bottom right coordinates of the extent in CRS units"
      }},
      {"crs", {
         description = "CRS in which the extent is defined"
      }},
      {"tl", {
         description = "Top left coordinates of the extent in CRS units"
      }}
   ]
}



================================================
FILE: docs/dggal/CRSRegistry.econ
================================================
{
   description = "Identifier for an authority defining a CRS",
   also = "CRS",
   values = [
      {"epsg", {
         description = "For CRS maintained by the IOGP Geomatics Committee in registry originating from the European Petroleum Survey Group"
      }},
      {"ogc", {
         description = "For CRS defined by the Open Geospatial Consortium"
      }}
   ]
}



================================================
FILE: docs/dggal/DGGRS.econ
================================================
{
   description = "Main DGGAL class for defining and querying a particular Discrete Global Grid Reference System",
   methods = [
      {"areZonesNeighbors", {
         description = "Check whether two zones are neighbors ",
         remarks = "This method does not consider zones sharing a partial or full boundary as neighbors if they are not of the same refinement level.",
         parameters = [
            {"a", {
               description = "First zone",
               position = 1
            }},
            {"b", {
               description = "Second zone",
               position = 2
            }}
         ],
         returnValue = "True if the two zones are neighbors"
      }},
      {"areZonesSiblings", {
         description = "Check whether two zones are siblings",
         remarks = "Sibling zones are zones of the same refinement level sharing a parent zone.",
         parameters = [
            {"a", {
               description = "First zone",
               position = 1
            }},
            {"b", {
               description = "Second zone",
               position = 2
            }}
         ],
         returnValue = "True if the two zones are siblings"
      }},
      {"compactZones", {
         description = "Compact a list of zones by recursively replacing a full set of children of a parent zone by that parent zone",
         parameters = [
            {"zones", {
               description = "The array of zones to compact",
               position = 1
            }}
         ]
      }},
      {"countSubZones", {
         description = "Return the number of sub-zones within a parent zone at a specific relative depth",
         parameters = [
            {"depth", {
               description = "The relative depth at which to count sub-zones",
               position = 2
            }},
            {"zone", {
               description = "The parent zone for which to count sub-zones",
               position = 1
            }}
         ],
         returnValue = "The number of sub-zones"
      }},
      {"countZoneEdges", {
         description = "Return the number of edges for a zone",
         parameters = [
            {"zone", {
               description = "The zone for which to count edges",
               position = 1
            }}
         ],
         returnValue = "The number of edges"
      }},
      {"countZones", {
         description = "Return the number of zones at a specific refinement level",
         parameters = [
            {"level", {
               description = "The refinement level for which to count zones",
               position = 1
            }}
         ],
         returnValue = "The number of zones"
      }},
      {"doZonesOverlap", {
         description = "Check whether two zones overlap",
         remarks = "Zones overlap if they are of a different refinement level and one is a sub-zone of the other.",
         parameters = [
            {"a", {
               description = "First zone",
               position = 1
            }},
            {"b", {
               description = "Second zone",
               position = 2
            }}
         ],
         returnValue = "True if the two zones overlap"
      }},
      {"doesZoneContain", {
         description = "Check whether a zone contains another zone",
         remarks = "A zone contains another if the contained zone is a sub-zone of the containing zone, and not a sub-zone of any neighbor of the containing zone.",
         parameters = [
            {"hayStack", {
               description = "The parent zone",
               position = 1
            }},
            {"needle", {
               description = "The contained zone",
               position = 2
            }}
         ],
         returnValue = "True if hayStack contains needle."
      }},
      {"get64KDepth", {
         description = "Return the relative depth at which a typical parent zone has the closest sub-zones count to 64,000",
         remarks = "The 64K depth is 8 for GNOSIS Gobal Grid, 10 for ISEA3H, and 5 for ISEA9R.",
         returnValue = "The relative depth at which a typical parent zone has the closest sub-zones count to 64,000"
      }},
      {"getFirstSubZone", {
         description = "Return the first sub-zone of a parent zone at a particular relative depth based on the deterministic order of sub-zones",
         parameters = [
            {"relativeDepth", {
               description = "The relative depth for which to return the first sub-zone",
               position = 2
            }},
            {"zone", {
               description = "The parent zone for which to return the first sub-zone",
               position = 1
            }}
         ],
         returnValue = "The first sub-zone"
      }},
      {"getIndexMaxDepth", {
         description = "Return the maximum relative depth at which sub-zone indices can be queried and resolved for this DGGRS",
         returnValue = "The maximum depth at which sub-zone indices can be queried and resolved for this DGGRS"
      }},
      {"getLevelFromMetersPerSubZone", {
         description = "Return the refinement level of a parent zone corresponding to a specified meters per sub-zone for a particular relative depth",
         remarks = "The meters per sub-zone is based on the side length of a square with the same area as a typical zone.",
         parameters = [
            {"physicalMetersPerSubZone", {
               description = "The number of physical meters per sub-zone",
               position = 1
            }},
            {"relativeDepth", {
               description = "The relative depth",
               position = 2
            }}
         ],
         returnValue = "The refinement level of a parent zone corresponding to the physical meters per sub-zone and relative depth"
      }},
      {"getLevelFromPixelsAndExtent", {
         description = "Return the refinement level of a parent zone corresponding to particular pixel dimensions, geographic extent and relative depth",
         remarks = "This method may be used to select the refinement level of zones for which to request data to fill a visualization viewport.",
         parameters = [
            {"extent", {
               description = "A geographic extent to consider",
               position = 1
            }},
            {"pixels", {
               description = "The pixel dimensions to consider",
               position = 2
            }},
            {"relativeDepth", {
               description = "The relative depth to consider",
               position = 3
            }}
         ],
         returnValue = "The refinement level of a parent zone corresponding to the specified pixel dimensions, geographic extent and relative depth"
      }},
      {"getLevelFromRefZoneArea", {
         description = "Return the refinement level corresponding to the reference area specified in meters squared.",
         remarks = "The reference zone area is the ellipsoid surface area divided by the number of zones at a particular refinement level.",
         parameters = [
            {"metersSquared", {
               description = "The reference zone area",
               position = 1
            }}
         ],
         returnValue = "The refinement level corresponding to the reference area. "
      }},
      {"getLevelFromScaleDenominator", {
         description = "Return the refinement level of a parent zone corresponding to a specified scale denominator for a particular relative depth and display resolution (in millimeters per pixel)",
         parameters = [
            {"mmPerPixel", {
               description = "The display resolution in millimeters per pixels to consider",
               position = 3
            }},
            {"relativeDepth", {
               description = "The relative depth to consider",
               position = 2
            }},
            {"scaleDenominator", {
               description = "The scale denominator to consider",
               position = 1
            }}
         ],
         returnValue = "The refinement level of a parent zone corresponding to the specified scale denominator, relative depth and display resolution"
      }},
      {"getMaxChildren", {
         description = "Return the maximum number of children for this DGGRS",
         returnValue = "The maximum number of children for this DGGRS"
      }},
      {"getMaxDGGRSZoneLevel", {
         description = "Return the maximum refinement level which a DGGRSZone can identify for this DGGSRS",
         returnValue = "The maximum refinement level which a DGGRSZone can identify for this DGGSRS"
      }},
      {"getMaxDepth", {
         description = "Get the maximum depth at which a full list of sub-zones can be returned",
         returnValue = "The maximum depth at which a full list of sub-zones can be returned"
      }},
      {"getMaxNeighbors", {
         description = "Return the maximum number of neighbors for this DGGRS",
         returnValue = "The maximum number of neighbors for this DGGRS"
      }},
      {"getMaxParents", {
         description = "Return the maximum number of parents for this DGGRS",
         returnValue = "The maximum number of parents for this DGGRS"
      }},
      {"getMetersPerSubZoneFromLevel", {
         description = "Return the meters per sub-zone for the specified parent zone refinement level and relative depth",
         remarks = "The meters per sub-zone is based on the side length of a square with the same area as a typical zone.",
         parameters = [
            {"parentLevel", {
               description = "The parent zone refinement level to consider",
               position = 1
            }},
            {"relativeDepth", {
               description = "The relative depth to consider",
               position = 2
            }}
         ],
         returnValue = "The meters per sub-zone for the specified parent zone refinement level and relative depth"
      }},
      {"getRefZoneArea", {
         description = "Return the reference area specified in meters squared for a particular refinement level",
         remarks = "The reference zone area is the ellipsoid surface area divided by the number of zones at a particular refinement level.",
         parameters = [
            {"level", {
               description = "The refinement level",
               position = 1
            }}
         ],
         returnValue = "The reference area specified in meters squared"
      }},
      {"getRefinementRatio", {
         description = "Return the refinement ratio of this DGGRS",
         remarks = "The refinement ratio is 4 for GNOSIS Global Grid, 3 for ISEA3H and 9 for ISEA9R.",
         returnValue = "The refinement ratio of this DGGRS"
      }},
      {"getScaleDenominatorFromLevel", {
         description = "Return the scale denominator for a particular relative depth and display resolution (in millimeters per pixel) associated with a specified parent zone refinement level",
         parameters = [
            {"mmPerPixel", {
               description = "The display resolution to consider",
               position = 3
            }},
            {"parentLevel", {
               description = "The parent zone refinement level",
               position = 1
            }},
            {"relativeDepth", {
               description = "The relative depth to consider",
               position = 2
            }}
         ],
         returnValue = "The scale denominator associated with the specified refinement level"
      }},
      {"getSubZoneAtIndex", {
         description = "Return a DGGRS zone for the sub-zone at a particular index and relative depth for a parent zone",
         also = "getSubZoneIndex",
         parameters = [
            {"index", {
               description = "The index within the detereministic order at which to return the sub-zone",
               position = 3
            }},
            {"parent", {
               description = "The zone for which to return the sub-zone",
               position = 1
            }},
            {"relativeDepth", {
               description = "The relative depth at which to return the sub-zone",
               position = 2
            }}
         ],
         returnValue = "The DGGRS zone at the specified index and relative depth"
      }},
      {"getSubZoneCRSCentroids", {
         description = "Return the centroids (in a particular CRS or the default CRS) for all sub-zone of a parent zone at a particular relative depth in the deterministic order",
         parameters = [
            {"crs", {
               description = "The CRS of the returned sub-zone centroids coordinates (0 for default CRS)",
               position = 2
            }},
            {"parent", {
               description = "The parent zone for which to return sub-zone centroids",
               position = 1
            }},
            {"relativeDepth", {
               description = "The relative depth at which to return sub-zone centroids",
               position = 3
            }}
         ],
         returnValue = "An array of sub-zone centroids in the deterministic sub-zone order using coordinates expressed in the requested CRS "
      }},
      {"getSubZoneIndex", {
         description = "Return the index of a sub-zone in a parent's zone sub-zones based on the deterministic order",
         also = "getSubZoneAtIndex",
         parameters = [
            {"parent", {
               description = "The parent zone for which to query a sub-zone index",
               position = 1
            }},
            {"subZone", {
               description = "The sub-zone whose index will be returned",
               position = 2
            }}
         ],
         returnValue = "The index of the sub-zone in the deterministic sub-zone order of the parent zone (-1 if subZone is not a sub-zone of the parent)"
      }},
      {"getSubZoneWGS84Centroids", {
         description = "Return the centroids (in WGS84 geodetic coordinates)  for all sub-zone of a parent zone at a particular relative depth in the deterministic order",
         parameters = [
            {"parent", {
               description = "The parent zone for which to return sub-zone centroids",
               position = 1
            }},
            {"relativeDepth", {
               description = "The relative depth at which to return sub-zone centroids",
               position = 2
            }}
         ],
         returnValue = "An array of sub-zone centroids in the deterministic sub-zone order expressed in WGS84 geodetic coordinates"
      }},
      {"getSubZones", {
         description = "Return the sub-zones of a parent zone at a particular relative depth",
         parameters = [
            {"parent", {
               description = "The parent zone for which to return sub-zones",
               position = 1
            }},
            {"relativeDepth", {
               description = "The relative depth at which to return sub-zones",
               position = 2
            }}
         ],
         returnValue = "The sub-zones of the parent zone at the specified relative depth in the deterministic sub-zone order of the DGGRS"
      }},
      {"getZoneArea", {
         description = "Return the geodetic area of a zone in meters squared",
         parameters = [
            {"zone", {
               description = "The zone for which to return the area",
               position = 1
            }}
         ],
         returnValue = "The geodetic area of the zone in meters squared"
      }},
      {"getZoneCRSCentroid", {
         description = "Return the centroid of a DGGRS zone (in a particular CRS or the default CRS)",
         parameters = [
            {"centroid", {
               description = "The centroid of the DGGRS zone being returned",
               position = 3
            }},
            {"crs", {
               description = "The CRS in which to return the centroid coordinates (0 for the default)",
               position = 2
            }},
            {"zone", {
               description = "The zone for which to return the centroid",
               position = 1
            }}
         ]
      }},
      {"getZoneCRSExtent", {
         description = "Return the extent of a DGGRS zone (in a particular CRS or the default CRS)",
         parameters = [
            {"crs", {
               description = "The CRS in which to return the extent (0 for the default)",
               position = 2
            }},
            {"extent", {
               description = "The extent of the DGGRS zone being returned",
               position = 3
            }},
            {"zone", {
               description = "The zone for which to return the extent",
               position = 1
            }}
         ]
      }},
      {"getZoneCRSVertices", {
         description = "Return the vertices of a DGGRS zone (in a particular CRS or the default CRS) ",
         also = "countZoneEdges",
         parameters = [
            {"crs", {
               description = "The CRS in which to return the vertices (0 for the default)",
               position = 2
            }},
            {"vertices", {
               description = "A pre-allocated buffer for returning the zone vertices",
               position = 3
            }},
            {"zone", {
               description = "The zone for which to return vertices",
               position = 1
            }}
         ],
         returnValue = "The number of vertices returned"
      }},
      {"getZoneCentroidChild", {
         description = "Return the centroid child zone of a DGGRS zone",
         remarks = "nullZone will be returned for a DGGRS without centroid children.",
         parameters = [
            {"zone", {
               description = "The parent zone for which to return the centroid child",
               position = 1
            }}
         ],
         returnValue = "Return the centroid child zone of a DGGRS zone"
      }},
      {"getZoneCentroidParent", {
         description = "Return the parent zone of a DGGRS zone which parent is itself a centroid child ",
         remarks = "nullZone will be returned for a DGGRS without centroid children.<br>"
            "nullZone also currently returned for ISEA9R for which this is not yet implemented, even though ISEA9R zones technically have centroid children from the 3x3 refinement.",
         parameters = [
            {"zone", {
               description = "The child zone for which to return the parent which is itself a centroid child",
               position = 1
            }}
         ],
         returnValue = "The parent zone of a DGGRS zone which parent is itself a centroid child "
      }},
      {"getZoneChildren", {
         description = "Return the children zones of a DGGRS zone",
         also = "getMaxChildren",
         parameters = [
            {"children", {
               description = "A pre-allocated buffer in which to return the children zones",
               position = 2
            }},
            {"zone", {
               description = "The parent zone",
               position = 1
            }}
         ],
         returnValue = "The number of children returned"
      }},
      {"getZoneFromCRSCentroid", {
         description = "Return the DGGRS zone within which the specified coordinates (in a particular CRS or the default CRS) fall",
         example = "ISEA3H isea3H { };<br>"
            "DGGRSZone zone = isea3H.getZoneFromCRSCentroid(16, { epsg, 4326 }, { 45, -75 });",
         remarks = "This method will likely be renamed to reflect the fact that the specified position no longer needs to be the centroid of a zone.",
         parameters = [
            {"centroid", {
               description = "The position for which to return the zone within which it falls",
               position = 3
            }},
            {"crs", {
               description = "The CRS in which the position coordinates are expressed (0 for the default)",
               position = 2
            }},
            {"level", {
               description = "The refinement level of the zone to return",
               position = 1
            }}
         ],
         returnValue = "The zone in which the position falls"
      }},
      {"getZoneFromTextID", {
         description = "Return the DGGRS zone associated with a textual identifier",
         example = "ISEA3H isea3H { };<br>"
            "DGGRSZone zone = isea3H.getZoneFromTextID(\"A4-0-A\");",
         also = "nullZone",
         parameters = [
            {"zoneID", {
               description = "The textual zone identifier",
               position = 1
            }}
         ],
         returnValue = "The DGGRS zone associated with the textual identifier (nullZone if textual identifier is invalid)"
      }},
      {"getZoneFromWGS84Centroid", {
         description = "Return the DGGRS zone within which the specified coordinates (in WGS84 geodetic coordinates) fall",
         example = "ISEA3H isea3H { };<br>"
            "DGGRSZone zone = isea3H.getZoneFromCRSCentroid(16, { 45, -75 });",
         remarks = "This method will likely be renamed to reflect the fact that the specified position no longer needs to be the centroid of a zone.",
         parameters = [
            {"centroid", {
               description = "The geodetic position for which to return the zone within which it falls",
               position = 2
            }},
            {"level", {
               description = "The refinement level of the zone to return",
               position = 1
            }}
         ],
         returnValue = "The zone in which the position falls"
      }},
      {"getZoneLevel", {
         description = "Return the refinement level of a DGGRS zone",
         parameters = [
            {"zone", {
               description = "The zone for which to return the refinement level",
               position = 1
            }}
         ],
         returnValue = "The refinement level of the specified zone"
      }},
      {"getZoneNeighbors", {
         description = "Return the neighboring zones of a DGGRS zone",
         also = "getMaxNeighbors",
         parameters = [
            {"nbType", {
               description = "An optional pointer to an integer buffer in which to return a type identifying the relative position of each neighbors",
               position = 3
            }},
            {"neighbors", {
               description = "A pre-allocated buffer in which to return neighbors",
               position = 2
            }},
            {"zone", {
               description = "The zone for which to return neighbors",
               position = 1
            }}
         ],
         returnValue = "The number of neighbors returned"
      }},
      {"getZoneParents", {
         description = "Return the parent zones of a DGGRS zone",
         remarks = "All zones of GNOSIS Global Grid and ISEA9R have a single parents, whereas ISEA3H zones have one parent if they are a centroid child, and three parents otherwise if they are a vertex child.",
         parameters = [
            {"parents", {
               description = "A pre-allocated buffer in which to return parents",
               position = 2
            }},
            {"zone", {
               description = "The zone for which to return parents",
               position = 1
            }}
         ],
         returnValue = "The number of paerents returned"
      }},
      {"getZoneRefinedCRSVertices", {
         description = "Return the vertices of a DGGRS zone (in a particular CRS or the default CRS), including intermediate points refining the geometry of the zone suitable for accurately representing this geometry",
         remarks = "Custom edgeRefinement is currently only supported for ISEA3H and WGS84 CRSs.<br>"
            "This function also adds extra vertices based on how the selected CRS wraps around  allowing to render the zone geometry correctly.",
         parameters = [
            {"crs", {
               description = "The CRS in which the coordinates of the refined vertices are to be returned (0 for the default)",
               position = 2
            }},
            {"edgeRefinement", {
               description = "The number of refined vertices per zone edge (0 for automatic refinement based on the zone refinement level, resulting in more refinement vertices at coarser refinement levels)",
               position = 3
            }},
            {"zone", {
               description = "The zone for which to return refined vertices",
               position = 1
            }}
         ],
         returnValue = "An array containing the refined vertices"
      }},
      {"getZoneRefinedWGS84Vertices", {
         description = "Return the vertices of a DGGRS zone (in WGS84 geodetic coordinates), including intermediate points refining the geometry of the zone suitable for accurately representing this geometry",
         remarks = "Custom edgeRefinement is currently only supported for ISEA3H.<br>"
            "This function also adds extra vertices based on wrapping around the anti-meridian allowing to render the zone geometry correctly.",
         parameters = [
            {"edgeRefinement", {
               description = "The number of refined vertices per zone edge (0 for automatic refinement based on the zone refinement level, resulting in more refinement vertices at coarser refinement levels)",
               position = 2
            }},
            {"zone", {
               description = "The zone for which to return refined vertices",
               position = 1
            }}
         ],
         returnValue = "An array containing the refined vertices"
      }},
      {"getZoneTextID", {
         description = "Return the textual identifier of a DGGRS zone",
         parameters = [
            {"zone", {
               description = "The zone for which to return the textual identifier",
               position = 1
            }},
            {"zoneID", {
               description = "A pre-allocated buffer in which to return the textual identifier",
               position = 2
            }}
         ]
      }},
      {"getZoneWGS84Centroid", {
         description = "Return the centroid of a DGGRS zone (in WGS84 geodetic coordinates)",
         parameters = [
            {"centroid", {
               description = "The centroid of the DGGRS zone being returned",
               position = 2
            }},
            {"zone", {
               description = "The zone for which to return the centroid",
               position = 1
            }}
         ]
      }},
      {"getZoneWGS84Extent", {
         description = "Return the extent of a DGGRS zone (in WGS84 geodetic coordinates)",
         parameters = [
            {"extent", {
               description = "The extent of the DGGRS zone being returned",
               position = 2
            }},
            {"zone", {
               description = "The zone for which to return the extent",
               position = 1
            }}
         ]
      }},
      {"getZoneWGS84Vertices", {
         description = "Return the vertices of a DGGRS zone (in WGS84 geodetic coordinates)",
         parameters = [
            {"vertices", {
               description = "A pre-allocated buffer for returning the zone vertices",
               position = 2
            }},
            {"zone", {
               description = "The zone for which to return vertices",
               position = 1
            }}
         ],
         returnValue = "The number of vertices returnned"
      }},
      {"isZoneAncestorOf", {
         description = "Check whether a zone is an ancestor of another zone",
         parameters = [
            {"ancestor", {
               description = "The ancestor zone",
               position = 1
            }},
            {"descendant", {
               description = "The descendant zone",
               position = 2
            }},
            {"maxDepth", {
               description = "The maximum relative depth to consider (0 for maximum)",
               position = 3
            }}
         ],
         returnValue = "True if the first zone is an ancestor of the second"
      }},
      {"isZoneCentroidChild", {
         description = "Check whether the zone is the centroid child of a parent zone",
         parameters = [
            {"zone", {
               description = "The zone to check whether it is a centroid child",
               position = 1
            }}
         ],
         returnValue = "True if the specified zone is the centroid child of a parent zone"
      }},
      {"isZoneContainedIn", {
         description = "Check whether a zone is contained within another zone",
         parameters = [
            {"hayStack", {
               description = "The containing zone",
               position = 2
            }},
            {"needle", {
               description = "The contained zone",
               position = 1
            }}
         ],
         returnValue = "True if the first zone is contained within the second"
      }},
      {"isZoneDescendantOf", {
         description = "Check whether a zone is a descendant of another zone",
         parameters = [
            {"ancestor", {
               description = "The ancestor zone",
               position = 2
            }},
            {"descendant", {
               description = "The descendant zone",
               position = 1
            }},
            {"maxDepth", {
               description = "The maximum relative depth to consider (0 for maximum)",
               position = 3
            }}
         ],
         returnValue = "True if the first zone is a descendant of the second"
      }},
      {"isZoneImmediateChildOf", {
         description = "Check whether a zone is an immediate child of another zone",
         parameters = [
            {"child", {
               description = "The child zone",
               position = 1
            }},
            {"parent", {
               description = "The parent zone",
               position = 2
            }}
         ],
         returnValue = "True if the first zone is an immediate child of the second"
      }},
      {"isZoneImmediateParentOf", {
         description = "Check whether a zone is an immediate parent of another zone",
         parameters = [
            {"child", {
               description = "The child zone",
               position = 2
            }},
            {"parent", {
               description = "The parent zone",
               position = 1
            }}
         ],
         returnValue = "True if the first zone is a parent of the second"
      }},
      {"listZones", {
         description = "Return the list of zones at a particular refinement level within a bounding box expressed in WGS84 geodetic coordinates",
         parameters = [
            {"bbox", {
               description = "The bounding box for which to return all zones whose geometry intersects with it",
               position = 2
            }},
            {"level", {
               description = "The refinement level at which to return zones",
               position = 1
            }}
         ],
         returnValue = "An array of DGGRS zones containing all zones of specified refinement level whose geometry intersects the specified bounding box"
      }},
      {"zoneHasSubZone", {
         description = "Check whether a zone has another zone as a sub-zone",
         remarks = "A descendant zone is a sub-zone of an ancestor zone if the descendant zone is fully or partially contained within the ancestor zone.",
         also = "getSubZoneIndex",
         parameters = [
            {"hayStack", {
               description = "The parent zone",
               position = 1
            }},
            {"needle", {
               description = "The sub-zone",
               position = 2
            }}
         ],
         returnValue = "True if the first zone has the second zone as a sub-zone"
      }}
   ]
}



================================================
FILE: docs/dggal/DGGRSZone.econ
================================================
{
   description = "64-bit integer identifying a particular zone of a Discrete Global Grid Reference System"
}



================================================
FILE: docs/dggal/DGGSJSON.econ
================================================
{
   description = "Object representing the content of a DGGS-JSON file storing raster data quantized to a particular DGGRS for a specific DGGRS zone at one or more depths relative to that parent zone"
}



================================================
FILE: docs/dggal/DGGSJSONDepth.econ
================================================
{
   description = "Component of a DGGS-JSON data file for a specific relative depth"
}



================================================
FILE: docs/dggal/DGGSJSONGrid.econ
================================================
{
   description = "Component of a DGGS-JSON data file describing a regular or irregular grid for dimensions not part of the DGGRS"
}



================================================
FILE: docs/dggal/DGGSJSONShape.econ
================================================
{
   description = "Component of a DGGS-JSON data file describing the shape of data values (the number of data values in terms of zones and other dimensions)"
}



================================================
FILE: docs/dggal/FieldType.econ
================================================
{
   description = "Identifier for basic data types",
   also = "FieldValue",
   values = [
      {"array", {
         description = "array of values"
      }},
      {"blob", {
         description = "arbitrary binary data"
      }},
      {"integer", {
         description = "64-bit integer"
      }},
      {"map", {
         description = "map of keys to values"
      }},
      {"nil", {
         description = "null value"
      }},
      {"real", {
         description = "64-bit double precision floating point number"
      }},
      {"text", {
         description = "null-terminated string of characters"
      }}
   ]
}



================================================
FILE: docs/dggal/FieldTypeEx.econ
================================================
{
   description = "Data type identifier with additional information such as format and memory allocation details",
   also = "FieldValue",
   fields = [
      {"format", {
         description = "Format identifier providing additional information about data representation"
      }},
      {"isDateTime", {
         description = "True if the integer represents a date and time"
      }},
      {"isUnsigned", {
         description = "True if an integer value is unsigned"
      }},
      {"mustFree", {
         description = "True if the data of a FieldValue  is explicitly owned and must be freed"
      }},
      {"type", {
         description = "Basic data type"
      }}
   ]
}



================================================
FILE: docs/dggal/FieldValue.econ
================================================
{
   description = "Data type for holding field values including type identifier",
   fields = [
      {"a", {
         description = "For array values"
      }},
      {"b", {
         description = "For blob values"
      }},
      {"i", {
         description = "For integer values"
      }},
      {"m", {
         description = "For map values"
      }},
      {"r", {
         description = "For real values"
      }},
      {"s", {
         description = "For text values"
      }},
      {"type", {
         description = "Data type of this value"
      }}
   ]
}



================================================
FILE: docs/dggal/FieldValueFormat.econ
================================================
{
   description = "Data type-specific format identifier"
}



================================================
FILE: docs/dggal/GeoExtent.econ
================================================
{
   description = "Geospatial extent expressed in WGS84 geodetic coordinates",
   fields = [
      {"ll", {
         description = "Coordinates of the lower-left corner of the extent"
      }},
      {"ur", {
         description = "Coordinates of the upper-right corner of the extent"
      }}
   ],
   properties = [
      {"geodeticArea", {
         description = "Property returning the geodetic extent of the extent based on the WGS84 ellipsoid"
      }}
   ],
   methods = [
      {"clear", {
         description = "Clear the extent"
      }},
      {"intersects", {
         description = "Checks whether the extent intersects with another"
      }}
   ]
}



================================================
FILE: docs/dggal/GeoPoint.econ
================================================
{
   description = "Geospatial position expressed in geodetic coordinates",
   fields = [
      {"lat", {
         description = "Geodetic latitude"
      }},
      {"lon", {
         description = "Geodetic longitude"
      }}
   ]
}



================================================
FILE: docs/dggal/GGGZone.econ
================================================
{
   description = "64-bit integer identifying a particular zone of the GNOSIS Global Grid DGGRS"
}



================================================
FILE: docs/dggal/GNOSISGlobalGrid.econ
================================================
{
   description = "DGGRS class for GNOSIS Global Grid, an axis-aligned quad-tree defined in WGS84 latitude and longitude, with special handling of polar regions, corresponding to the OGC 2D Tile Matrix Set of the same name"
}



================================================
FILE: docs/dggal/I3HZone.econ
================================================
{
   description = "64-bit integer identifying a particular zone of the RhombicIcosahedral3H DGGRSs (such as ISEA3H and IVEA3H)"
}



================================================
FILE: docs/dggal/I9RZone.econ
================================================
{
   description = "64-bit integer identifying a particular zone of the RhombicIcosahedral9R DGGRSs (such as ISEA9R and IVEA9R)"
}



================================================
FILE: docs/dggal/ISEA3H.econ
================================================
{
   description = "DGGRS class for ISEA3H, an equal area hexagonal grid with a refinement ratio of 3 defined in the Icosahedral Snyder Equal Area (ISEA) projection"
}



================================================
FILE: docs/dggal/ISEA9R.econ
================================================
{
   description = "DGGRS class for ISEA9R, an equal area rhombic grid with a refinement ratio of 9 defined in the ISEA projection transformed into a 5x6 Cartesian space resulting in axis-aligned square zones"
}



================================================
FILE: docs/dggal/JSONSchema.econ
================================================
{
   description = "Object representing a JSON Schema",
   usage = "Used within DGGS-JSON to represent the logical schema of data values"
}



================================================
FILE: docs/dggal/JSONSchemaType.econ
================================================
{
   description = "Identifier for JSON Schema types"
}



================================================
FILE: high-vibes/README.md
================================================
# DGGAL High Vibes

## A set of high-level vibe-coded tools demonstrating DGGAL usage in Python

### Example usage

#### dgg-import

Create a Scalable UBJSON DGGS Data Store from a GeoTIFF (quantizing to a DGGRS)

```
python dgg-import.py gebco.tiff --dggrs IVEA4R --fields Elevation
```

#### dgg-fetch

Create a Scalable UBJSON DGGS Data Store from an OGC API - DGGS deployment (implementing an OGC API - DGGS client):

```
python dgg-fetch.py http://localhost:8080/collections/gebco/dggs/IVEA4R
```

#### dgg-export

Export a GeoTIFF from a Scalable UBJSON DGGS Data Store (relatively well optimized):

```
python dgg-export.py data out.tif --collection gebco --level 10
```

#### dgg-serve

Deploy an OGC API - DGGS interface to DGGS-quantized collections in Scalable UBJSON DGGS Data Stores through OGC API - DGGS with DGGAL High Vibes (implementation of an OGC API - DGGS server):

```
python dgg-serve.py --data-root data --port 8080
```

### Limitations

This code should all work with the last [0.0.6 DGGAL release](https://github.com/ecere/dggal/releases/tag/v0.0.6).

This is an early version with some limitations:
- the tools do not currently support additional dimensions (time, pressure...) but this is conceptually supported by DGGS-UBJSON and this DGGS Data Store layout,
- Vector stores are currently limited to icosahedral equal-area projections (IVEA, ISEA, RTEA) DGGRSs and have only been tested with IVEA3H and polygons so far,
- a future version will likely introduce a DGGS-JSON (field value) quantization extension significantly reducing data size.



================================================
FILE: high-vibes/dgg-export.py
================================================
#!/usr/bin/env python3
import argparse
import logging
from dggal import *
from dggsStore.store import DGGSDataStore
from dggsExport.raster import rasterize_to_geotiff
# add GeoJSON exporter
from dggsExport.exportFeatures import export_to_geojson

app = Application(appGlobals=globals()); pydggal_setup(app)

def parse_args():
   p = argparse.ArgumentParser(prog="dgg-export")
   p.add_argument("datastore", help="base datastore directory")
   p.add_argument("outfile", help="output path (GeoTIFF or GeoJSON). GeoJSON export writes a FeatureCollection of vector features")
   p.add_argument("--collection", required=True, help="collection name")
   p.add_argument("--dggrs", required=False, help="(ignored) store provides dggrs instance")
   p.add_argument("--level", type=int, required=True, help="DGGS level to sample")
   p.add_argument("--workers", type=int, default=16)
   p.add_argument("--debug", action="store_true")
   p.add_argument("--nodata", type=float, default=3.4028235e+38)
   p.add_argument("--compress", default="lzw")
   p.add_argument("--fields", help="comma-separated list of fields to include in output")
   p.add_argument("--grid-size", default=1e-2, help="grid size for Shapely union when merging vector output")
   return p.parse_args()

def main():
   args = parse_args()
   if args.debug:
      logging.getLogger().setLevel(logging.DEBUG)

   store: DGGSDataStore = DGGSDataStore(args.datastore, args.collection)
   if not hasattr(store, "dggrs"):
      return

   if args.level > store.maxRefinementLevel:
      print("INFO:Clamping level to store's maximum refinement level:", store.maxRefinementLevel)
      args.level = store.maxRefinementLevel

   out_fields = None
   if args.fields:
      out_fields = [f.strip() for f in args.fields.split(",") if f.strip()]

   # choose exporter by outfile extension: .geojson/.json -> GeoJSON (vector), otherwise GeoTIFF (raster)
   out_lower = args.outfile.lower()
   if out_lower.endswith(".geojson") or out_lower.endswith(".json"):
      export_to_geojson(store, args.level, args.outfile,
         workers=args.workers, debug=args.debug, grid_size=float(args.grid_size))
      logging.info("done: GeoJSON export complete")
   else:
      result = rasterize_to_geotiff(
         store,
         args.level,
         args.outfile,
         workers=args.workers,
         nodata=args.nodata,
         compress=args.compress,
         debug=args.debug,
         fields=out_fields
      )
      logging.info("done: elapsed=%.1f s", result["elapsed_seconds"])

if __name__ == "__main__":
   main()



================================================
FILE: high-vibes/dgg-fetch.py
================================================
#!/usr/bin/env python3
# dgg-fetch.py
from dggal import *
from typing import List, Any, Dict, Iterator, Iterable, Optional, Tuple
import os, logging, argparse, json, sys
from itertools import islice

from ogcapi.dggs import client as dggs_client
from dggsStore.store import DGGSDataStore, read_package_root_ids_from_sqlite

app = Application(appGlobals=globals()); pydggal_setup(app)

LOG_FMT = "%(asctime)s %(levelname)s %(message)s"
logging.basicConfig(level=logging.INFO, format=LOG_FMT)
logger = logging.getLogger("raster")


def parse_args():
   p = argparse.ArgumentParser(prog="raster")
   p.add_argument("resource_url", help="Full DGGS resource URL e.g. https://host/.../collections/{collection}/dggs/{dggrsId}")
   p.add_argument("--outdir", default="data", help="Output directory for packages (default data/)")
   p.add_argument("--groupSize", type=int, default=5, help="Levels per package (written to collection.json and passed to store)")
   p.add_argument("--depth", type=int, help="data depth (zone-depth) to request (default from DGGRS defaultDepth)")
   p.add_argument("--max-level", type=int, default=None, help="Maximum refinement level (default from server maxRefinementLevel)")
   p.add_argument("--batch-size", type=int, default=32, help="Number of root zones to request per HTTP call (default 32)")
   p.add_argument("--no-resume", action="store_true")
   p.add_argument("--resume-verbose", action="store_true", help="Show resume-related info for skipped roots")
   p.add_argument("--dry-run", action="store_true")
   p.add_argument("--debug", action="store_true", help="Enable debug logging")
   return p.parse_args()

# Top-level helper functions (no nested functions, no exception handlers)
def _extract_props_and_strip(features, feature_props):
   # Mutates parsed in-place: strips "properties" from features and collects them
   for feat in features:
      fid = feat.get("id")
      if isinstance(fid, int):
         fid_int = fid
      else:
         fid_int = int(fid)
      props = feat.get("properties", None)
      feature_props[fid_int] = props
      if props is not None:
         del feat["properties"]


def process_batch(
   store: DGGSDataStore,
   zones: List[int],
   pkg_index: int,
   batch_num: int,
   args,
   existing_ids: set,
   pkg_path: str,
   bases_stack: List[int],
   per_package_workers: int,
   depth: int,
   landing: str,
   collection: str,
   dggrs_id: str
) -> int:
   dggrs = store.dggrs

   zone_by_text: Dict[str, int] = {}
   to_fetch_texts: List[str] = []

   for zone in zones:
      ztext = dggrs.getZoneTextID(zone)
      zone_by_text[ztext] = zone
      if ztext not in existing_ids:
         to_fetch_texts.append(ztext)

   if not to_fetch_texts:
      logger.info("PACKAGE #%d BATCH %d: all roots present, skipping", pkg_index, batch_num)
      return 0

   if not landing or not collection or not dggrs_id:
      logger.error("Invalid fetch context; skipping batch")
      return 0

   if args.dry_run:
      for ztext in to_fetch_texts:
         url = f"{landing.rstrip('/')}/collections/{collection}/dggs/{dggrs_id}/zones/{ztext}/data"
         params = f"?zone-depth={depth}"
         logger.info("DRY %s <- %s%s", pkg_path, url, params)
      return 0

   # Fetch raw zone data (may be dicts or bytes)
   fetched = dggs_client.fetch_zone_data_parallel(landing, collection, dggrs_id, to_fetch_texts, workers=per_package_workers, depth=depth)

   # Build entries mapping zone_id -> stripped payload (dict)
   entries: Dict[int, Any] = {}
   # Collect properties per feature id (last-one-wins)
   feature_props: Dict[int, Dict[str, Any]] = None

   for ztext in to_fetch_texts:
      if ztext not in fetched: continue
      raw = fetched[ztext]
      if not raw or not isinstance(raw, Dict): continue

      # Collect and strip properties for DGGS-JSON-FG
      features = raw.get('features', None)
      if isinstance(features, list):
         if feature_props is None: feature_props = {}
         _extract_props_and_strip(features, feature_props)
      zone = zone_by_text[ztext]
      zone_id = int(zone)
      entries[zone_id] = raw

   if not entries:
      logger.info("PACKAGE #%d BATCH %d: no fetched entries", pkg_index, batch_num)
      return 0

   # If we collected any feature properties, write them into the store attributes DB
   if feature_props:
      # build a GeoJSON-style features list from the id->properties map
      features_list = []
      for fid, props in feature_props.items():
         features_list.append({"id": int(fid), "properties": props})

      store.write_collection_attributes(features_list)
      logger.info("PACKAGE #%d BATCH %d: wrote %d feature attributes to attributes DB", pkg_index, batch_num, len(feature_props))

   # Write the stripped zone payloads into the store
   store.write_zone_batch(base_zone=zones[0], entries=entries, base_ancestor_list=bases_stack, precompressed=False)
   written = len(entries)
   logger.info("PACKAGE #%d: wrote %d roots (batch %d) to %s", pkg_index, written, batch_num, pkg_path)
   return written


def main():
   args = parse_args()
   logger.setLevel(logging.DEBUG if args.debug else logging.INFO)

   landing, collection, dggrs_id = dggs_client.parse_resource_url(args.resource_url)
   if not landing or not collection or not dggrs_id:
      logger.error("Invalid resource_url; must include collection and dggrs id")
      return

   landing = landing.rstrip('/')

   dggrs_desc = dggs_client.get_dggrs_description(landing, collection, dggrs_id)
   depth = args.depth if args.depth is not None else int(dggrs_desc.get("defaultDepth", 8))

   # Use explicit --max-level if provided; otherwise prefer server's maxRefinementLevel; fallback to 24
   server_max = dggrs_desc.get("maxRefinementLevel")
   if args.max_level is not None:
      max_refinement = int(args.max_level)
   elif server_max is not None:
      max_refinement = int(server_max)
   else:
      logger.error("Server did not provide maxRefinementLevel and --max-level not specified; aborting")
      return

   coll_meta = dggs_client.get_collection_info(landing, collection)
   title = coll_meta.get("title") or coll_meta.get("name") or collection
   description = coll_meta.get("description") or coll_meta.get("abstract") or coll_meta.get("summary") or title

   coll_info = {
      "dggrs": dggrs_id,
      "maxRefinementLevel": max_refinement,
      "depth": depth,
      "groupSize": args.groupSize,
      "title": title,
      "description": description,
      "version": coll_meta.get("version", "1.0")
   }

   base = os.path.join(args.outdir, collection)
   os.makedirs(base, exist_ok=True)
   coll_json_path = os.path.join(base, "collection.json")
   with open(coll_json_path, "w", encoding="utf-8") as fh:
      json.dump(coll_info, fh, indent=2)
   logger.info("Wrote collection config to %s", coll_json_path)

   logger.info("Instantiating DGGSDataStore groupSize=%d dggrs=%s depth=%s", coll_info["groupSize"], coll_info["dggrs"], coll_info["depth"])
   store = DGGSDataStore(args.outdir, collection, config=coll_info)
   dggrs = store.dggrs

   total_written = 0
   fetch_batch_size = int(args.batch_size)
   per_package_workers = min(fetch_batch_size, 32)

   deepest_root_level = max(0, max_refinement - depth)
   max_base_level = store._base_level_for_root(deepest_root_level)
   logger.info("Computed levels: depth=%d max_base_level=%d groupSize=%d fetch_batch_size=%d",
               depth, max_base_level, store.groupSize, fetch_batch_size)

   logger.info("Beginning package iteration (max_base_level=%d)", max_base_level)

   pkg_index = 0

   for base_zone, base_ancestors in store.iter_bases(max_base_level, up_to=True):
      pkg_index += 1

      base_text = dggrs.getZoneTextID(base_zone)
      pkg_path = store.compute_package_path_for_root_zone(base_zone, base_ancestors)
      logger.info("PACKAGE #%d: base_zone=%s pkg_path=%s", pkg_index, base_text, pkg_path)

      base_level = dggrs.getZoneLevel(base_zone)
      package_group_levels = store.group0Size if base_level == 0 else store.groupSize
      max_root_level = base_level + package_group_levels - 1
      roots_iter = store.iter_roots_for_base(base_zone, max_root_level, up_to=True)


      existing_ids = set()
      if not args.no_resume:
         existing_ids = set(read_package_root_ids_from_sqlite(pkg_path))
         if args.resume_verbose:
            logger.info("PACKAGE #%d: resume existing_ids_count=%d", pkg_index, len(existing_ids))

      batch_num = 0
      batch_zones: List[int] = []
      for zone in roots_iter:
         ztext = dggrs.getZoneTextID(zone)

         if ztext in existing_ids:
            if args.resume_verbose:
               logger.debug("PACKAGE #%d: skipping already-present root %s", pkg_index, ztext)
            continue

         batch_zones.append(zone)
         if len(batch_zones) >= fetch_batch_size:
            batch_num += 1
            written = process_batch(store, batch_zones, pkg_index, batch_num, args, existing_ids, pkg_path, base_ancestors, per_package_workers, depth, landing, collection, dggrs_id)
            total_written += written
            batch_zones = []

      if batch_zones:
         batch_num += 1
         written = process_batch(store, batch_zones, pkg_index, batch_num, args, existing_ids, pkg_path, base_ancestors, per_package_workers, depth, landing, collection, dggrs_id)
         total_written += written

   logger.info("all processing complete; total written=%d; output=%s", total_written, args.outdir)


if __name__ == "__main__":
   main()



================================================
FILE: high-vibes/dgg-fg.py
================================================
#!/usr/bin/env python3
# dgg-fg
# CLI for DGGS-JSON-FG operations (tiledg and togeo; reproj, fix, clip, tile, clipdg)

import sys
import os
import json
import argparse
from dggal import *
import glob
from typing import Iterable, Dict, Any, List, Sequence
import shapely
import gc
from shapely.geometry import shape, mapping, Polygon, MultiPolygon, LineString, MultiLineString, Point, MultiPoint, GeometryCollection

from fg.reproj import *
from fg.fix_topology_5x6 import fix_feature_collection_5x6_topology, fix_geojson_file_5x6_topology
from fg.dggsJSONFG import write_dggs_json_fg_to_file, read_dggs_json_fg_file
from fg.dgToGeoMulti import togeo_multi_mode
from fg.clippingShapely import clip_featurecollection_to_zone

GRID_SIZE=1e-2

# initialize DGGAL (assumes Application and pydggal_setup are available)
app = Application(appGlobals=globals())
pydggal_setup(app)

def _prepare_input_pipeline(input_path: str, dggrs_name: str, ico: bool, skip_reproj: bool, skip_fix: bool):
   # Load input GeoJSON, optionally reproject and optionally run 5x6 topology fix.
   # Returns a GeoJSON FeatureCollection ready for clipping.

   # load input (assume GeoJSON FeatureCollection)
   src = geojson_load(input_path)

   # reproj step (unless skipped)
   if not skip_reproj:
      proj = instantiate_projection_for_dggrs_name(dggrs_name)
      print("Reprojecting to native CRS of", dggrs_name, "...")
      src = reproject_featurecollection(src, proj, ico=ico)

   # topology fix step (unless skipped)
   if not skip_fix:
      print("Fixing reprojected features topology...")
      src = fix_feature_collection_5x6_topology(src)

   return src

def main(argv):
   p = argparse.ArgumentParser(prog="dgg-fg")
   sub = p.add_subparsers(dest="cmd", required=True)

   # reproj subcommand
   r = sub.add_parser("reproj", help="Reproject GeoJSON into DGGRS native CRS")
   r.add_argument("--dggrs", required=True)
   r.add_argument("--ico", action="store_true", default=False, help="apply icosahedron-net transform after projection")
   r.add_argument("--input", dest="input_opt", default=None)
   r.add_argument("--output", dest="output_opt", default=None)
   r.add_argument("input_pos", nargs="?", default=None)
   r.add_argument("output_pos", nargs="?", default=None)

   # fix subcommand
   r = sub.add_parser("fix", help="Fix topology of DGGRS native CRS GeoJSON")
   r.add_argument("--dggrs", required=True)
   r.add_argument("--ico", action="store_true", default=False, help="use icosahedron-net CRS")
   r.add_argument("--input", dest="input_opt", default=None)
   r.add_argument("--output", dest="output_opt", default=None)
   r.add_argument("input_pos", nargs="?", default=None)
   r.add_argument("output_pos", nargs="?", default=None)

   # clip subcommand
   c = sub.add_parser("clip", help="Clip GeoJSON to a single DGGRS zone")
   c.add_argument("--dggrs", required=True)
   c.add_argument("--zone", required=True)
   c.add_argument("--refined", action="store_true", default=False)
   c.add_argument("--ico", action="store_true", default=False, help="use icosahedron-net CRS for zone geometry and reprojection")
   c.add_argument("--skip-reproj", action="store_true", default=False, help="assume input is already reprojected (skip reproj step)")
   c.add_argument("--skip-fix", action="store_true", default=False, help="assume input is already reproj'ed and topology-fixed (skip reproj and fix)")
   c.add_argument("--input", dest="input_opt", default=None)
   c.add_argument("--output", dest="output_opt", default=None)
   c.add_argument("input_pos", nargs="?", default=None)
   c.add_argument("output_pos", nargs="?", default=None)

   # clipdg subcommand (DGGS-JSON-FG output for single zone)
   cd = sub.add_parser("clipdg", help="Clip GeoJSON to a single DGGRS zone and write DGGS-JSON-FG")
   cd.add_argument("--dggrs", required=True)
   cd.add_argument("--zone", required=True)
   cd.add_argument("--refined", action="store_true", default=False)
   cd.add_argument("--ico", action="store_true", default=False, help="use icosahedron-net CRS for zone geometry and reprojection")
   cd.add_argument("--skip-reproj", action="store_true", default=False, help="assume input is already reprojected (skip reproj step)")
   cd.add_argument("--skip-fix", action="store_true", default=False, help="assume input is already reproj'ed and topology-fixed (skip reproj and fix)")
   cd.add_argument("--input", dest="input_opt", default=None)
   cd.add_argument("--output", dest="output_opt", default=None)
   cd.add_argument("input_pos", nargs="?", default=None)
   cd.add_argument("output_pos", nargs="?", default=None)
   cd.add_argument("--depth", type=int, default=None, help="depth for sub-zone index resolution (default: 2 * ~64K sub-zones depth)")

   # tile (multiclip) subcommand
   t = sub.add_parser("tile", help="Clip GeoJSON to all zones at a refinement level")
   t.add_argument("--dggrs", required=True)
   t.add_argument("--level", type=int, default=0, help="refinement level (default 0)")
   t.add_argument("--bbox", nargs=4, type=float, metavar=("LAT0","LON0","LAT1","LON1"),
                  help="WGS84 bounding box: lat0 lon0 lat1 lon1 (degrees). Default: wholeWorld")
   t.add_argument("--outdir", default="zone_tiles", help="output directory (default: zone_tiles)")
   t.add_argument("--refined", action="store_true", default=False,
                  help="pass refined=True to clip_featurecollection_to_zone")
   t.add_argument("--ico", action="store_true", default=False, help="use icosahedron-net CRS for zone geometry and reprojection")
   t.add_argument("--skip-reproj", action="store_true", default=False, help="assume input is already reprojected (skip reproj step)")
   t.add_argument("--skip-fix", action="store_true", default=False, help="assume input is already reproj'ed and topology-fixed (skip reproj and fix)")
   t.add_argument("--input", dest="input_opt", default=None)
   t.add_argument("input_pos", nargs="?", default=None)

   # tiledg subcommand (DGGS-JSON-FG output for tiled zones)
   td = sub.add_parser("tiledg", help="Clip GeoJSON to all zones at a refinement level and write DGGS-JSON-FG files")
   td.add_argument("--dggrs", required=True)
   td.add_argument("--level", type=int, default=0, help="refinement level (default 0)")
   td.add_argument("--bbox", nargs=4, type=float, metavar=("LAT0","LON0","LAT1","LON1"),
                   help="WGS84 bounding box: lat0 lon0 lat1 lon1 (degrees). Default: wholeWorld")
   td.add_argument("--outdir", default="zone_tiles_dg", help="output directory (default: zone_tiles_dg)")
   td.add_argument("--refined", action="store_true", default=False,
                   help="pass refined=True to clip_featurecollection_to_zone")
   td.add_argument("--ico", action="store_true", default=False, help="use icosahedron-net CRS for zone geometry and reprojection")
   td.add_argument("--skip-reproj", action="store_true", default=False, help="assume input is already reprojected (skip reproj step)")
   td.add_argument("--skip-fix", action="store_true", default=False, help="assume input is already reproj'ed and topology-fixed (skip reproj and fix)")
   td.add_argument("--input", dest="input_opt", default=None)
   td.add_argument("input_pos", nargs="?", default=None)
   td.add_argument("--depth", type=int, default=None, help="depth for sub-zone index resolution (default: 2 * ~64K sub-zones depth)")

   # togeo subcommand
   #tg = sub.add_parser("togeo", help="Convert DGGS-JSON-FG to GeoJSON using DGGAL centroids")
   #tg.add_argument("input", help="Input DGGS-JSON-FG file")
   #tg.add_argument("output", help="Output GeoJSON file")
   tg = sub.add_parser("togeo", help="Convert DGGS-JSON-FG to GeoJSON")
   tg.add_argument("paths", nargs="+", help="Input files/dirs/glob/.lst and output file (last argument is output)")
   tg.add_argument("--grid-size", dest="grid_size", default=GRID_SIZE)
   tg.add_argument("--wgs84-refine", dest="wgs84_refine", type=float, default=None, help="maximum 5x6 distance between points before unprojecting to WGS84 (might currently cause issues)")

   args = p.parse_args(argv)
   skip_reproj = getattr(args, 'skip_reproj', False) or getattr(args, 'skip_fix', False)

   if args.cmd == "reproj":
      input_path = args.input_opt if args.input_opt is not None else args.input_pos
      output_path = args.output_opt if args.output_opt is not None else args.output_pos
      if input_path is None or output_path is None:
         raise SystemExit("usage: dgg-fg reproj --dggrs <DGGRS> <input> <output>  (or use --input/--output)")
      dggrs = get_dggrs(args.dggrs)
      proj = instantiate_projection_for_dggrs_name(args.dggrs)
      src = geojson_load(input_path)
      # reproject_featurecollection returns a GeoJSON FeatureCollection
      out_fc = reproject_featurecollection(src, proj, ico=args.ico)
      geojson_dump(out_fc, output_path)
      return

   if args.cmd == "fix":
      input_path = args.input_opt if args.input_opt is not None else args.input_pos
      output_path = args.output_opt if args.output_opt is not None else args.output_pos
      if input_path is None or output_path is None:
         raise SystemExit("usage: dgg-fg fix --dggrs <DGGRS> <input> <output>  (or use --input/--output)")
      dggrs = get_dggrs(args.dggrs)
      proj = instantiate_projection_for_dggrs_name(args.dggrs)
      fix_geojson_file_5x6_topology(input_path, output_path)
      return

   if args.cmd == "clip":
      input_path = args.input_opt if args.input_opt is not None else args.input_pos
      output_path = args.output_opt if args.output_opt is not None else args.output_pos
      if input_path is None or output_path is None:
         raise SystemExit("usage: dgg-fg clip --dggrs <DGGRS> --zone <ZONEID> <input> <output>  (or use --input/--output)")
      dggrs = get_dggrs(args.dggrs)
      zone = dggrs.getZoneFromTextID(args.zone)
      if zone == nullZone:
         print("Invalid zone identifier", args.zone)
         return

      # prepare input: reproj + fix unless skipped
      src = _prepare_input_pipeline(input_path, args.dggrs, args.ico, skip_reproj, args.skip_fix)

      out_fc, feature_entry_exit_indices = clip_featurecollection_to_zone(src, dggrs, zone, refined=args.refined, ico=args.ico)
      geojson_dump(out_fc, output_path)
      return

   if args.cmd == "clipdg":
      input_path = args.input_opt if args.input_opt is not None else args.input_pos
      output_path = args.output_opt if args.output_opt is not None else args.output_pos
      if input_path is None or output_path is None:
         raise SystemExit("usage: dgg-fg clipdg --dggrs <DGGRS> --zone <ZONEID> <input> <output>  (or use --input/--output)")
      dggrs = get_dggrs(args.dggrs)
      zone = dggrs.getZoneFromTextID(args.zone)
      if zone == nullZone:
         print("Invalid zone identifier", args.zone)
         return

      src = _prepare_input_pipeline(input_path, args.dggrs, args.ico, skip_reproj, args.skip_fix)

      depth_val = args.depth if args.depth is not None else 2 * dggrs.get64KDepth()
      out_fc, feature_entry_exit_indices = clip_featurecollection_to_zone(src, dggrs, zone, refined=args.refined, ico=args.ico)
      write_dggs_json_fg_to_file(out_fc, feature_entry_exit_indices, output_path, dggrs, zone, depth_val)
      return

   if args.cmd == "tile":
      input_path = args.input_opt if args.input_opt is not None else args.input_pos
      if input_path is None:
         raise SystemExit("usage: dgg-fg tile --dggrs <DGGRS> [--level N] [--bbox lat0 lon0 lat1 lon1] [--outdir DIR] --input <input.geojson>")
      dggrs = get_dggrs(args.dggrs)

      # bounding box: either wholeWorld or GeoExtent((lat0,lon0),(lat1,lon1))
      if args.bbox is None:
         boundingBox = wholeWorld
      else:
         lat0, lon0, lat1, lon1 = args.bbox
         boundingBox = GeoExtent((lat0, lon0), (lat1, lon1))

      refinementLevel = args.level
      zones = dggrs.listZones(refinementLevel, boundingBox)

      outdir = args.outdir
      os.makedirs(outdir, exist_ok=True)

      # prepare input once (reproj + fix unless skipped)
      src = _prepare_input_pipeline(input_path, args.dggrs, args.ico, skip_reproj, args.skip_fix)

      for zone in zones:
         textid = dggrs.getZoneTextID(zone)
         print("Clipping to zone", textid)
         out_fc, feature_entry_exit_indices = clip_featurecollection_to_zone(src, dggrs, zone, ico=args.ico)   #refined=args.refined,
         out_path = os.path.join(outdir, f"{textid}.geojson")
         geojson_dump(out_fc, out_path)

      return

   if args.cmd == "tiledg":
      input_path = args.input_opt if args.input_opt is not None else args.input_pos
      if input_path is None:
         raise SystemExit("usage: dgg-fg tiledg --dggrs <DGGRS> [--level N] [--bbox lat0 lon0 lat1 lon1] [--outdir DIR] --input <input.geojson>")
      dggrs = get_dggrs(args.dggrs)

      # bounding box: either wholeWorld or GeoExtent((lat0,lon0),(lat1,lon1))
      if args.bbox is None:
         boundingBox = wholeWorld
      else:
         lat0, lon0, lat1, lon1 = args.bbox
         boundingBox = GeoExtent((lat0, lon0), (lat1, lon1))

      refinementLevel = args.level
      zones = dggrs.listZones(refinementLevel, boundingBox)

      outdir = args.outdir
      os.makedirs(outdir, exist_ok=True)

      # prepare input once (reproj + fix unless skipped)
      src = _prepare_input_pipeline(input_path, args.dggrs, args.ico, skip_reproj, args.skip_fix)

      depth_val = args.depth if args.depth is not None else 2 * dggrs.get64KDepth()

      for zone in zones:
         textid = dggrs.getZoneTextID(zone)
         print("Clipping to zone", textid)

         out_fc, feature_entry_exit_indices = clip_featurecollection_to_zone(src, dggrs, zone, refined=args.refined, ico=args.ico)
         out_path = os.path.join(outdir, f"{textid}.dggs.json")

         write_dggs_json_fg_to_file(out_fc, feature_entry_exit_indices, out_path, dggrs, zone, depth_val)

      return

   if args.cmd == "togeo":
      paths = args.paths
      if len(paths) < 2:
         p.error("provide at least one input and one output path")

      *input_args, output_path = paths

      # legacy single-file fast path: exactly one input and it is a regular file (not .lst, not dir, not glob)
      single_input = False
      if len(input_args) == 1:
         a = input_args[0]
         if os.path.isfile(a) and not a.lower().endswith(".lst") and not os.path.isdir(a):
            single_input = True

      if single_input:
         obj = read_dggs_json_fg_file(input_args[0], refine_wgs84=args.wgs84_refine)
         with open(output_path, "w", encoding="utf-8") as fh:
            fh.write(pretty_json(obj))
            fh.write("\n")
      else:
         # Level 0 spacing / depth 16 gives ~0.00979 degrees so 0.01 makes sense here
         # Derive from use dggrs.getMetersPerSubZoneFromLevel(root_zone_level, depth) ?
         # multi-file mode: expand inputs (each arg may be a file, dir, glob, or .lst)
         togeo_multi_mode(input_args, output_path, grid_size=float(args.grid_size), refine_wgs84=args.wgs84_refine)
      return 0

if __name__ == "__main__":
   main(sys.argv[1:])



================================================
FILE: high-vibes/dgg-import.py
================================================
#!/usr/bin/env python3
# dgg-import.py
# Import a raster or vector file into a DGGS Data Store by
# sampling the raster at, or quantizing the vector coordinates to, DGGS sub-zone centroids
# and writing results into the store via DGGSDataStore.write_zone_batch.
#
# Usage:
#  python dgg-import.py input.(tif|json) --dggrs IVEA4R --data-root data --collection mycol
#
# Notes:
# - Default import level is computed from the raster native resolution via DGGRS.getLevelFromPixelsAndExtent.
# - The finest root level = data_level - depth (depth defaults to dggrs.get64KDepth()).
# - Batching mirrors dgg-fetch: roots are grouped and written with write_zone_batch.

from dggal import *
import argparse
import os
import rasterio
import sys

from dggsImport.rasterImport import *
from dggsImport.vectorImport import import_vector

# initialize dggal runtime
app = Application(appGlobals=globals()); pydggal_setup(app)

# ---------------------------------------------------------------------------
# CLI
# ---------------------------------------------------------------------------
def _parse_bands_and_fields_arg(args, ds_count: int):
   # Returns (bands: Optional[List[int]], fields: Optional[List[str]], err: Optional[str]).
   if args.bands is None:
      bands = None
   else:
      parts = [p.strip() for p in args.bands.split(",") if p.strip()]
      bands = []
      for p in parts:
         if not p.isdigit():
            return None, None, "Invalid --bands: must be comma-separated positive integers (1-based)."
         b = int(p)
         if b < 1 or b > ds_count:
            return None, None, f"Invalid band index {b}: must be 1..{ds_count}."
         bands.append(b)

   fields = [f.strip() for f in args.fields.split(",") if f.strip()] if args.fields else None

   if fields is not None:
      expected = ds_count if bands is None else len(bands)
      if len(fields) != expected:
         return None, None, f"Field count {len(fields)} does not match expected {expected}."

   return bands, fields, None

def main():
   p = argparse.ArgumentParser(prog="dgg-import")
   p.add_argument("input_file", help="input raster file or vector GeoJSON (.json/.geojson)")
   p.add_argument("--dggrs", default="IVEA4R", help="DGGRS name (class name or string)")
   p.add_argument("--collection", default=None, help="collection id (defaults to filename without ext)")
   p.add_argument("--data-root", default="data", help="data root directory (default data)")
   p.add_argument("--level", type=int, default=None, help="DGGS data level (defaults to raster native resolution)")
   p.add_argument("--depth", type=int, default=None, help="depth (default dggrs.get64KDepth())")
   p.add_argument("--fields", default=None, help="comma-separated field names (defaults to field1[,field2...])")
   p.add_argument("--bands", default=None, help="comma-separated 1-based band indices to sample (defaults to all bands)")
   p.add_argument("--batch-size", type=int, default=32, help="Number of root zones per write batch")
   p.add_argument("--groupSize", type=int, default=5, help="Levels per package (default 5)")
   p.add_argument("--max-workers", type=int, default=16, help="Max worker processes")
   p.add_argument("--skip-reproj", action="store_true", help="Skip reprojection step for vector import")
   p.add_argument("--skip-fix", action="store_true", help="Skip topology fix step for vector import")
   args = p.parse_args()

   input_path = args.input_file
   ext = os.path.splitext(input_path)[1].lower()

   collection_id = args.collection if args.collection else os.path.splitext(os.path.basename(input_path))[0]

   # Vector import branch for GeoJSON files
   if ext in (".json", ".geojson"):
      print(f"[IMPORT] Detected vector input {input_path}; using vector import", flush=True)

      if args.level is None:
         print("Error: --level is required for vector import (absolute quantize level).", flush=True)
         return 1

      rc = import_vector(
         input_geojson_path=input_path,
         collection_id=collection_id,
         dggrs_name=args.dggrs,
         data_root=args.data_root,
         level=args.level,
         depth=args.depth,
         batch_size=args.batch_size,
         groupSize=args.groupSize,
         max_workers=args.max_workers,
         skip_reproj=args.skip_reproj,
         skip_fix=args.skip_fix
      )
      return rc

   # Raster import branch (default)
   try:
      ds = rasterio.open(input_path)
   except Exception as e:
      print(f"Error: failed to open raster {input_path}: {e}", flush=True)
      return 1

   ds_count = ds.count

   bands, fields, err = _parse_bands_and_fields_arg(args, ds_count)
   if err:
      print("Error:", err, flush=True)
      ds.close()
      return 1

   rc = import_raster(
      ds=ds,
      collection_id=collection_id,
      dggrs_name=args.dggrs,
      data_root=args.data_root,
      level=args.level,
      depth=args.depth,
      fields=fields,
      bands=bands,
      batch_size=args.batch_size,
      groupSize=args.groupSize,
      max_workers=max_workers
   )

   return rc

if __name__ == "__main__":
   sys.exit(main())



================================================
FILE: high-vibes/dgg-serve.py
================================================
#!/usr/bin/env python3
# dgg-serve.py
# Main entrypoint that composes the smaller ogcapi-* modules into a working Flask app.

import os
import logging
import argparse
import atexit
from flask import Flask
from dggal import *
import signal
import traceback

app = Application(appGlobals=globals()); pydggal_setup(app)

# Configure logging
logging.basicConfig(level=logging.INFO, format="%(asctime)s %(levelname)s %(message)s")
logger = logging.getLogger("dgg-serve")

# Import the modular blueprints
from ogcapi.common.landingPage import bp as landing_bp
from ogcapi.common.conformance import bp as conformance_bp
from ogcapi.common.collections import bp as collections_bp
from ogcapi.dggs.dggrs import bp as dggrs_bp
from ogcapi.dggs.zones import bp as dggs_zones_bp
from ogcapi.dggs.zoneInfo import bp as dggs_zoneinfo_bp
from ogcapi.dggs.zoneData import bp as dggs_zoneData_bp

# Import store lifecycle helpers so we can close stores on shutdown
from dggsStore.store import *

# Create Flask app and register blueprints
def create_app(data_root: str, dggrs_schema_uri: str = None) -> Flask:
    app = Flask(__name__)
    # Configuration
    app.config["DATA_ROOT"] = data_root

    # Register blueprints (they include their own url_prefix where appropriate)
    app.register_blueprint(landing_bp)            # root "/"
    app.register_blueprint(conformance_bp)       # "/conformance"
    app.register_blueprint(collections_bp)       # "/collections"
    app.register_blueprint(dggrs_bp)             # "/collections/<collectionId>/dggs"
    app.register_blueprint(dggs_zones_bp)        # "/collections/<collectionId>/dggs/<dggrsId>"
    app.register_blueprint(dggs_zoneinfo_bp)     # "/collections/<collectionId>/dggs/<dggrsId>"
    app.register_blueprint(dggs_zoneData_bp)     # "/collections/<collectionId>/dggs/<dggrsId>"

    # Simple CORS and Vary headers for all responses
    @app.after_request
    def _add_cors_and_vary(resp):
        resp.headers.setdefault("Access-Control-Allow-Origin", "*")
        resp.headers.setdefault("Access-Control-Allow-Methods", "GET,OPTIONS,POST")
        resp.headers.setdefault("Access-Control-Allow-Headers", "Content-Type,Accept,Accept-Encoding")
        vary = resp.headers.get("Vary", "")
        vary_set = set([v.strip() for v in (vary.split(",") if vary else []) if v.strip()])
        vary_set.update(["Accept", "Accept-Encoding"])
        resp.headers["Vary"] = ", ".join(sorted(vary_set))
        return resp

    return app

def parse_args():
    p = argparse.ArgumentParser(prog="dgg-serve", description="OGC API - DGGS server (modular)")
    p.add_argument("--data-root", help="Data root directory (default: ./data)", default=os.path.join(os.getcwd(), "data"))
    p.add_argument("--host", help="Host to bind", default="0.0.0.0")
    p.add_argument("--port", help="Port to listen on", type=int, default=int(os.environ.get("PORT", "8080")))
    p.add_argument("--debug", help="Enable debug mode", action="store_true")
    return p.parse_args()

def dump_traces_and_exit(signum, frame):
    for tid, fr in sys._current_frames().items():
        print(f"\n--- Thread {tid} ---", file=sys.stderr)
        traceback.print_stack(fr, file=sys.stderr)
    signal.signal(signal.SIGINT, signal.SIG_DFL)
    raise KeyboardInterrupt

def main():
    args = parse_args()
    DATA_ROOT = args.data_root
    if not os.path.isdir(DATA_ROOT):
        print(f"ERROR: DATA_ROOT directory does not exist: {DATA_ROOT!r}")
        return
    logger.info("Starting dgg-serve on %s:%d with data root: %s", args.host, args.port, DATA_ROOT)
    app = create_app(DATA_ROOT)
    atexit.register(lambda: (logger.info("Closing all stores..."), close_all_stores()))
    signal.signal(signal.SIGINT, dump_traces_and_exit)
    app.run(host=args.host, port=args.port, debug=args.debug, use_reloader=False, threaded=True)

if __name__ == "__main__":
    main()



================================================
FILE: high-vibes/high-vibes.epj
================================================
{
   "Version" : 0.2,
   "ModuleName" : "high-vibes",
   "Options" : {
      "Warnings" : "All",
      "TargetType" : "Executable",
      "TargetFileName" : "high-vibes",
      "Console" : true
   },
   "Configurations" : [
      {
         "Name" : "Debug",
         "Options" : {
            "Debug" : true,
            "Optimization" : "None",
            "PreprocessorDefinitions" : [
               "_DEBUG"
            ],
            "FastMath" : false
         }
      },
      {
         "Name" : "Release",
         "Options" : {
            "Debug" : false,
            "Optimization" : "Speed",
            "FastMath" : true
         }
      }
   ],
   "Files" : [
      {
         "Folder" : "dggsExport",
         "Files" : [
            "raster.py",
            "rasterZoneGrid.py",
            "exportFeatures.py"
         ]
      },
      {
         "Folder" : "dggsStore",
         "Files" : [
            "customDepths.py",
            "store.py",
            "aggregation.py"
         ]
      },
      {
         "Folder" : "ogcapi",
         "Files" : [
            {
               "Folder" : "common",
               "Files" : [
                  "collections.py",
                  "conformance.py",
                  "landingPage.py"
               ]
            },
            {
               "Folder" : "dggs",
               "Files" : [
                  "client.py",
                  "dggrs.py",
                  "zoneData.py",
                  "zoneInfo.py",
                  "zones.py"
               ]
            },
            "utils.py"
         ]
      },
      {
         "Folder" : "dggsImport",
         "Files" : [
            "rasterSampling.py",
            "rasterImport.py",
            "vectorImport.py"
         ]
      },
      {
         "Folder" : "fg",
         "Files" : [
            "fix_topology_5x6.py",
            "reproj.py",
            "sutherlandHodgman.py",
            "dggsJSONFG.py",
            "faces.py",
            "distance.py",
            "interruption.py",
            "fixWGS84.py",
            "dgToGeoMulti.py",
            "unprojectToWGS84.py",
            "clippingShapely.py",
            "wkbc.py"
         ]
      },
      {
         "Folder" : "clipping",
         "Files" : [
            "clipping.py",
            "clippingCore.py",
            "clipUtils.py"
         ]
      },
      "dgg-export.py",
      "dgg-fetch.py",
      "dgg-import.py",
      "dgg-serve.py",
      "../bindings/py/dggal.py",
      "../../eC/bindings/py/ecrt.py",
      "dgg-fg.py"
   ],
   "ResourcesPath" : "",
   "Resources" : [

   ]
}



================================================
FILE: high-vibes/clipping/clipping.py
================================================
#!/usr/bin/env python3
# clipping.py
# Thin wrapper that exposes clip_feature_to_zone and clip_featurecollection_to_zone
# while delegating core work to clippingCore.py.
#
# - uses clipping_log() for debug output.

from dggal import *
from typing import List, Dict, Optional
from bisect import bisect_left

from clipping.clippingCore import *

# Controls: None => all rings; int => only that polygon index for MultiPolygon
POLY_DEBUG_INDEX: Optional[int] = None
# If False -> only outer ring (ring 0) processed; True -> include inner rings
INCLUDE_INNER_RINGS: bool = True

def clipping_log(*args):
   if DEBUG_LEVEL >= 1:
      print(*args)

def attach_hole_ring(out_ring, r_clip_info, hole, h_clip_info, zone):
   # Attach `hole` into `out_ring` in-place using metadata.
   # Contracts:
   #   - r_clip_info["clipper_vertices_out_ix"] is a list of dicts {"out_ix":int, "source_edge_ix":int}
   #   - h_clip_info["clipper_vertices_out_ix"] is the same shape for the hole
   #   - r_clip_info["crossings"] and h_clip_info["crossings"] exist when appropriate
   #   - zone is the clipper polygon vertex list (len(zone) == n_edges)
   # Returns True on success.

   # pick test location from hole's first crossing exit (fallback to entry)
   h0 = h_clip_info["crossings"][0]
   test = h0.get("exit") or h0.get("entry")
   test_edge = test["clipper_edge_ix"]
   test_t = test["clipper_edge_t"]

   n_edges = len(zone)

   # find the outer crossing interval that contains the test (if any)
   target_cross = None
   for oc in r_clip_info.get("crossings", []):
      outer_entry = oc["entry"]
      outer_exit = oc["exit"]
      if crossing_is_between(outer_exit["clipper_edge_ix"], outer_exit["clipper_edge_t"],
                             outer_entry["clipper_edge_ix"], outer_entry["clipper_edge_t"],
                             test_edge, test_t, n_edges):
         target_cross = oc
         break

   # scalar position helper
   def scalar_pos(edge, t, start_edge, start_t, n):
      delta = (edge - start_edge) % n
      return delta + (t - start_t)

   # --- prepare unified candidate search parameters ---
   outer_clippers = r_clip_info.get("clipper_vertices_out_ix", [])

   if target_cross is not None:
      entry = target_cross["entry"]
      exit = target_cross["exit"]
      start_edge, start_t = entry["clipper_edge_ix"], entry["clipper_edge_t"]
      restrict_interval = (exit["clipper_edge_ix"], exit["clipper_edge_t"], start_edge, start_t)
      test_pos = scalar_pos(test_edge, test_t, start_edge, start_t, n_edges)
   else:
      # no crossings: if there are outer clippers use the first as base, else we'll append at end
      if outer_clippers:
         base = outer_clippers[0]
         start_edge, start_t = base["source_edge_ix"], 0.0
         restrict_interval = None
         test_pos = scalar_pos(test_edge, test_t, start_edge, start_t, n_edges)
      else:
         # nothing to search; insert at end
         insert_at = len(out_ring)
         restrict_interval = None
         test_pos = None

   # --- unified candidate search ---
   matched = None
   if test_pos is not None and outer_clippers:
      candidates = []
      if restrict_interval is not None:
         exit_edge, exit_t, entry_edge, entry_t = restrict_interval
         for rec in outer_clippers:
            src_edge = rec["source_edge_ix"]
            if crossing_is_between(exit_edge, exit_t, entry_edge, entry_t, src_edge, 0.0, n_edges):
               pos = scalar_pos(src_edge, 0.0, start_edge, start_t, n_edges)
               if pos < test_pos:
                  candidates.append((pos, rec))
      else:
         # whole-cycle search relative to start_edge/start_t
         for rec in outer_clippers:
            src_edge = rec["source_edge_ix"]
            pos = scalar_pos(src_edge, 0.0, start_edge, start_t, n_edges)
            if pos < test_pos:
               candidates.append((pos, rec))

      if candidates:
         candidates.sort(key=lambda x: x[0])
         matched = candidates[-1][1]

   # determine insert_at using matched or fallback
   if 'insert_at' not in locals():
      if matched is not None:
         insert_at = matched["out_ix"] + 1
      else:
         if target_cross is not None:
            insert_at = target_cross["entry"]["out_vertex_ix"] + 1
         else:
            insert_at = len(out_ring)

   # --- remove outer clipper records not present in the hole (keep only those in hole) ---
   hole_src_edges = {rec["source_edge_ix"] for rec in h_clip_info.get("clipper_vertices_out_ix", [])}
   outer_clippers = r_clip_info.get("clipper_vertices_out_ix", [])
   kept_outer = [rec for rec in outer_clippers if rec["source_edge_ix"] in hole_src_edges]
   removed_out_ixs = sorted({rec["out_ix"] for rec in outer_clippers if rec["source_edge_ix"] not in hole_src_edges})

   if removed_out_ixs:
      original_len = len(out_ring)
      from bisect import bisect_left
      def count_removed_before(idx):
         return bisect_left(removed_out_ixs, idx)

      rem_set = set(removed_out_ixs)
      new_vertices = [v for i, v in enumerate(out_ring) if i not in rem_set]
      out_ring[:] = new_vertices

      # adjust kept_outer out_ix by subtracting number of removed indices before them
      for rec in kept_outer:
         old_out = rec["out_ix"]
         rec["out_ix"] = old_out - count_removed_before(old_out)

      # adjust crossings: if a crossing's out_vertex_ix was removed, move it to the next surviving index
      def next_surviving(old_idx):
         if old_idx >= original_len:
            return len(new_vertices)
         cur = old_idx
         while cur in rem_set:
            cur += 1
            if cur >= original_len:
               return len(new_vertices)
         return cur - count_removed_before(cur)

      for cr in r_clip_info.get("crossings", []):
         cr["entry"]["out_vertex_ix"] = next_surviving(cr["entry"]["out_vertex_ix"])
         cr["exit"]["out_vertex_ix"]  = next_surviving(cr["exit"]["out_vertex_ix"])

      # remap insert_at relative to the new vertex array
      if insert_at >= original_len:
         insert_at = len(out_ring)
      else:
         if insert_at in rem_set:
            insert_at = next_surviving(insert_at)
         else:
            insert_at = insert_at - count_removed_before(insert_at)

      r_clip_info["clipper_vertices_out_ix"] = kept_outer
   else:
      r_clip_info["clipper_vertices_out_ix"] = kept_outer

   # --- prepare hole vertices (drop closing duplicate, drop hole clipper vertices by out_ix) ---
   hole_vertices = list(hole)
   if hole_vertices and hole_vertices[0] == hole_vertices[-1]:
      hole_vertices = hole_vertices[:-1]

   hole_remove_out_ixs = {rec["out_ix"] for rec in h_clip_info.get("clipper_vertices_out_ix", [])}
   filtered = [v for i, v in enumerate(hole_vertices) if i not in hole_remove_out_ixs]
   to_insert = filtered  # keep original order

   # --- insert and update indices by simple increments ---
   out_ring[insert_at:insert_at] = to_insert
   len_inserted = len(to_insert)

   if len_inserted:
      for rec in r_clip_info.get("clipper_vertices_out_ix", []):
         if rec["out_ix"] >= insert_at:
            rec["out_ix"] += len_inserted

      for cr in r_clip_info.get("crossings", []):
         if cr["entry"]["out_vertex_ix"] >= insert_at:
            cr["entry"]["out_vertex_ix"] += len_inserted
         if cr["exit"]["out_vertex_ix"] >= insert_at:
            cr["exit"]["out_vertex_ix"] += len_inserted

   # --- cleanup consecutive duplicates ---
   cleaned = []
   prev = None
   for v in out_ring:
      if prev is None or v != prev:
         cleaned.append(v)
      prev = v
   out_ring[:] = cleaned

   return True

def insert_whole_hole_ring(polygons, holeRing):
   for poly in polygons:
      out_ring = poly[0]
      # if rings_overlap(out_ring, holeRing):
      for p in holeRing:
         if point_in_ring(p, out_ring):
            # sprint("Inserting hole ring into polygon")
            poly.append(holeRing)
            break

def insert_clipped_hole_ring(polygons, outer_clip_info, holeRings, hole_clip_info, zone):
   for pix, poly in enumerate(polygons):
      out_ring = poly[0]
      for hix, hole in enumerate(holeRings):
         # print("Testing if we attach this one here")
         #if rings_overlap(out_ring, hole):
         for p in hole:
            if point_in_ring(p, out_ring):
               # print("YES WE DO?")
               attach_hole_ring(out_ring, outer_clip_info[pix], hole, hole_clip_info[hix], zone)
               break

def clip_polygon(rings, metadata, zone_vertices):

   if not rings: return None
   outer_ring = rings[0]

   clipped = clip_ring_to_zone(outer_ring, zone_vertices)
   if clipped is None: return None

   clip_info = clipped["clip_info"]

   clipped_polygons = []
   metadata["clip_infos"].append(clip_info)

   for ring in clipped.get("rings", []):
      clipped_polygons.append([ring])

   if INCLUDE_INNER_RINGS and len(clipped_polygons):
      for ri in range(1, len(rings)):
         ring = rings[ri]

         if DEBUG_LEVEL >= 2:
            clipping_log("   processing inner ring", ri)

         in_clipped = clip_ring_to_zone(ring, zone_vertices)
         in_result = in_clipped["result"]
         if DEBUG_LEVEL >= 2:
            print("Inner ring", ri, "result is", in_result)

         if in_result == "full":        # Entire polygon is removed by hole
            return [ ]
         elif in_result == "empty":     # Hole is completely outside the zone
            continue
         elif in_result == "unchanged": # Hole was not clipped in any way -- add to right polygon
            insert_whole_hole_ring(clipped_polygons, in_clipped["rings"][0])
         elif in_result == "modified":  # Hole was clipped, and therefore no longer a hole in clipped polygon
            hole_clip_info = in_clipped["clip_info"]
            insert_clipped_hole_ring(clipped_polygons, clip_info,
               in_clipped["rings"], hole_clip_info, zone_vertices)
   return clipped_polygons

def clip_feature_to_zone(feature: Dict, dggrs, zone, refined=True, feature_id=None, ico=False):
   if DEBUG_LEVEL >= 2:
      fID = feature.get('id') if feature_id is None else feature_id
      clipping_log(f"processing FEATURE id={fID}")

   zone_vertices = get_zone_polygon(dggrs, zone, refined=refined, ico=ico)
   orientation_sign = -1
   geom = feature["geometry"]
   t = geom["type"]
   metadata = {"clip_infos": []}

   if t == "Polygon" or t == "MultiPolygon":
      if t == "Polygon":
         if POLY_DEBUG_INDEX is None or POLY_DEBUG_INDEX == 0:
            clipped_polygons = clip_polygon(geom["coordinates"], metadata, zone_vertices)
      else:
         polys = geom["coordinates"]
         poly_indices = range(len(polys)) if POLY_DEBUG_INDEX is None else ([POLY_DEBUG_INDEX] if 0 <= POLY_DEBUG_INDEX < len(polys) else [])
         clipped_polygons = []
         for pi in poly_indices:
            #if DEBUG_LEVEL >= 2:
            #   print("START processing MultiPolygon poly", pi)
            poly = polys[pi]
            clipped_polygons.extend(clip_polygon(poly, metadata, zone_vertices))

      if clipped_polygons:
         if len(clipped_polygons) == 1:
            out_geom = {"type": "Polygon", "coordinates": clipped_polygons[0]}
         else:
            out_geom = {"type": "MultiPolygon", "coordinates": clipped_polygons}

         out_feature = {"type": "Feature", "id": feature.get("id"), "properties": feature.get("properties"), "geometry": out_geom}
         return out_feature, metadata
      return None, metadata

   if t == "LineString":
      coords = geom["coordinates"]
      clipped = clip_ring_to_zone(coords, zone_vertices, orientation_sign)
      metadata["crossings"].append(clipped["crossings"] if clipped is not None else [])
      lines = [run for run in clipped["polygons"] if run and len(run) >= 2]
      if not lines:
         return None, metadata
      out_geom = {"type": "LineString", "coordinates": lines[0]} if len(lines) == 1 else {"type": "MultiLineString", "coordinates": lines}
      out_feature = {"type": "Feature", "id": feature.get("id"), "properties": feature.get("properties"), "geometry": out_geom}
      return out_feature, metadata

   if t == "MultiLineString":
      lines = []
      for ls in geom["coordinates"]:
         clipped = clip_ring_to_zone(ls, zone_vertices, orientation_sign)
         metadata["crossings"].append(clipped["crossings"] if clipped is not None else [])
         for run in clipped["polygons"]:
            if run and len(run) >= 2:
               lines.append(run)
      if not lines:
         return None, metadata
      out_geom = {"type": "MultiLineString", "coordinates": lines}
      out_feature = {"type": "Feature", "id": feature.get("id"), "properties": feature.get("properties"), "geometry": out_geom}
      return out_feature, metadata

   if t == "Point":
      pt = feature["geometry"]["coordinates"]
      if point_in_ring(pt, zone_vertices):
         return {"type": "Feature", "id": feature.get("id"), "properties": feature.get("properties"), "geometry": {"type": "Point", "coordinates": [float(pt[0]), float(pt[1])] }}, metadata
      return None, metadata

   if t == "MultiPoint":
      pts = []
      for p in feature["geometry"]["coordinates"]:
         if point_in_ring(p, zone_vertices):
            pts.append([float(p[0]), float(p[1])])
      if not pts:
         return None, metadata
      out_geom = {"type": "MultiPoint", "coordinates": pts}
      out_feature = {"type": "Feature", "id": feature.get("id"), "properties": feature.get("properties"), "geometry": out_geom}
      return out_feature, metadata

   return None, metadata

def clip_featurecollection_to_zone(fc: Dict, dggrs, zone, refined=False, ico=False):
   out_features = []
   metadata = {}
   for feat in fc.get("features", []):
      feature_id = feat.get("id", None)
      #if feature_id != 68: continue  # Canada
      #if feature_id != 182: continue # Italy
      #if feature_id != 195: continue # Luxembourg
      #if feature_id != 68 and feature_id != 182: continue
      clipped, meta = clip_feature_to_zone(feat, dggrs, zone, refined=refined, feature_id=feature_id, ico=ico)
      metadata[feat.get("id")] = meta
      if clipped is not None:
         out_features.append(clipped)

   out_fc = {"type": "FeatureCollection", "features": out_features}
   return out_fc, metadata



================================================
FILE: high-vibes/clipping/clippingCore.py
================================================
#!/usr/bin/env python3
# clippingCore.py
# Core hand-crafted clipping logic
# - Exposes: get_zone_polygon, clip_ring_to_zone

from dggal import *
from typing import List, Dict, Any, Optional
from clipping.clipUtils import *

DEBUG_LEVEL = 2

def get_zone_polygon(dggrs, zone, refined=True, ico=False):
   #Return a list of [x,y] coordinates for the zone polygon in the requested CRS.
   #If ico is True, use the icosahedron-net CRS (OGC:1534) when requesting vertices.
   #Otherwise use CRS(0) as the native CRS.
   if ico:
      crs = CRS(ogc, 1534)
   else:
      crs = CRS(0)

   if refined:
      verts_container = dggrs.getZoneRefinedCRSVertices(zone, crs)
   else:
      verts_container = dggrs.getZoneCRSVertices(zone, crs)

   return [[float(v.x), float(v.y)] for v in verts_container]

def sort_key_for_hits(h: Dict[str, Any]):
   et = h.get("edge_t")
   etv = et if (et is not None) else 0.0
   return (h["t"], h["edge_index"], etv)

def crossing_is_between(a_edge_start: int, a_t_from_start: float,
                        b_edge_start: int, b_t_from_start: float,
                        test_edge_start: int, test_t_from_start: float,
                        n_edges: int) -> bool:

   a = a_edge_start + a_t_from_start
   b = b_edge_start + b_t_from_start
   t = test_edge_start + test_t_from_start

   #print("T = ", t, ", A = ", a, ", B = ", b)

   t = (t - a) % n_edges
   b = (b - a) % n_edges
   r = 0 <= t <= b
   #print("   returning ", r)
   return r

   #t = (t - a) % n_edges
   #b = (b - a) % n_edges
   #return 0 <= t <= b

   #if t > a and t < b: return True
   #if t > b and a > b: return True
   #return False

def vertex_index_is_between(a_e: int, a_t: float, b_e: int, b_t: float,
                            vertex_index: int, n_edges: int, cyclic = True) -> bool:

   if cyclic:
      r = crossing_is_between(a_e, a_t, b_e, b_t, vertex_index, 0, n_edges)
   else:
      a = a_e + a_t
      b = b_e + b_t - (n_edges if vertex_index == 0 else 0)
      r = vertex_index > a and vertex_index < b
   return r

def interval_contains(exit_e: int, exit_t: float,
                      end_e: int, end_t: float,
                      new_e: int, new_t: float,
                      n_edges: int,
                      tol_local: float = 1e-12) -> bool:
   return crossing_is_between(exit_e, exit_t, end_e, end_t, new_e, new_t, n_edges)

def collect_segment_hits(zone, nEdges, A, B):
   seg_hits = []
   for ei in range(nEdges):
      C = zone[ei]
      D = zone[(ei + 1) % nEdges]
      subhits = segment_segment_intersections(C, D, A, B)
      for h in subhits:
         t = h["t"]
         hit = {
            "t": t,
            "edge_t": t,
            "point": h["point"],
            "edge_index": ei
         }
         seg_hits.append(hit)

   seg_hits.sort(key=sort_key_for_hits)
   return seg_hits

def create_new_ring(rings, entry_edge, entry_edge_t, entry_point):
   # Create and append a new ring record with a pending interval and return its index.
   new_ring = {
      "entry_edge": entry_edge,
      "entry_edge_t": entry_edge_t,
      "entry_point": entry_point,
      "vertices": [entry_point] if entry_point is not None else [],
      "intervals": [
         {
            "entry_edge": entry_edge,
            "entry_t": entry_edge_t,
            "exit_edge": None,
            "exit_t": None,
            "pending": True
         }
      ],
      "last_exit_point": None
   }
   rings.append(new_ring)
   return len(rings) - 1

def finalize_rings(rings, zone, nEdges):
   if len(rings):
      print("__Finalization pass__")

   for p_idx in range(len(rings)):
      ring_rec = rings[p_idx]
      intervals = ring_rec.get("intervals", [])
      if not intervals:
         continue

      last = intervals[-1]

      entry_edge = ring_rec.get("entry_edge")
      entry_point = ring_rec.get("entry_point")
      entry_edge_t = ring_rec.get("entry_edge_t")

      synthetic_hit = {"edge_index": entry_edge, "point": entry_point, "edge_t": entry_edge_t}

      ring_len_before = len(ring_rec.get("vertices", []))
      intervals_before = len(intervals)

      process_entry(rings, synthetic_hit, zone, nEdges, target_pidx=p_idx)

      ring_len_after = len(ring_rec.get("vertices", []))
      intervals_after = len(ring_rec.get("intervals", []))

      if ring_len_after == ring_len_before and intervals_after == intervals_before:
         vertices = ring_rec.setdefault("vertices", [])
         if not vertices or vertices[-1] != entry_point:
            vertices.append(entry_point)
         last["entry_edge"] = entry_edge
         last["entry_t"] = entry_edge_t
         last["pending"] = False

   # Return List[Ring] where each Ring is a List[List[float]]
   out_rings = []
   clip_info = []
   for ring_ix, ring_rec in enumerate(rings):
      ring = ring_rec.get("vertices", [])
      if not ring:
         continue
      # ensure ring is closed
      if ring[0] != ring[-1]:
         ring = list(ring)
         ring.append(ring[0])
      out_rings.append(ring)

      # build clip info for this ring from the accumulated metadata
      crossings = ring_rec.get("crossings", [])
      clipper_vertices_out_ix = ring_rec.get("clipper_vertices_out_ix", [])
      clip_info.append({
         "ring_ix": ring_ix,
         "crossings": crossings,
         "clipper_vertices_out_ix": clipper_vertices_out_ix
      })

   return (out_rings, clip_info)

def process_entry(rings, hit, zone, nEdges, target_pidx=None):
   entry_edge = hit["edge_index"]
   entry_point = hit["point"]
   entry_edge_t = hit["edge_t"]

   print("-> Entering zone from edge", entry_edge, "at", entry_point)

   found_pidx = None
   ring_rec = None
   exit_e = None; exit_t = None
   appended = []

   if target_pidx is not None:
      ring_rec = rings[target_pidx]
      intervals = ring_rec["intervals"]
      if intervals:
         last = intervals[-1]
         exit_e = last.get("exit_edge")
         exit_t = last.get("exit_t")
      found_pidx = target_pidx
   else:
      for p_idx in list(range(len(rings) - 1, -1, -1)):
         ring_rec = rings[p_idx]
         intervals = ring_rec["intervals"]
         for int_idx in range(len(intervals) - 1, -1, -1):
            interval = intervals[int_idx]
            exit_e = interval["exit_edge"]; exit_t = interval["exit_t"]

            if exit_e is None or exit_t is None:
               continue

            entry_e0 = interval["entry_edge"]; entry_t0 = interval["entry_t"]

            if DEBUG_LEVEL >= 2:
               print("Checking if ", entry_edge + entry_edge_t, " is between ",
                  exit_e + exit_t, " and ", entry_e0 + entry_t0)

            if interval_contains(exit_e, exit_t, entry_e0, entry_t0, entry_edge, entry_edge_t, nEdges, 0.0):
               if DEBUG_LEVEL >= 2:
                  print("Continuing an existing ring!")

               left_interval = {
                  "exit_edge": interval["exit_edge"], "exit_t": interval["exit_t"],
                  "entry_edge": entry_edge,           "entry_t": entry_edge_t,
                  "pending": False
               }
               right_interval = {
                  "exit_edge": None,                    "exit_t": None,
                  "entry_edge": interval["entry_edge"], "entry_t": interval["entry_t"],
                  "pending": True
               }
               intervals[int_idx:int_idx+1] = [left_interval, right_interval]
               found_pidx = p_idx
               break
         if found_pidx is not None:
            break
      if found_pidx is None:
         found_pidx = create_new_ring(rings, entry_edge, entry_edge_t, entry_point)
         ring_rec = rings[found_pidx]

   if found_pidx is not None:
      ring_rec.setdefault("crossings", [])
      ring_rec.setdefault("vertices", [])
      ring_rec.setdefault("clipper_vertices_out_ix", [])   # now list of dicts: {"out_ix":int, "source_edge_ix":int}
      ring_rec.setdefault("pending_entry", None)

      if exit_e is not None and exit_t is not None:
         for vi in range(nEdges):
            if DEBUG_LEVEL >= 2:
               print("Checking ", vi, "between", exit_e + exit_t, " to ", entry_edge + entry_edge_t)
            if vertex_index_is_between(exit_e, exit_t, entry_edge, entry_edge_t, vi, nEdges,
               cyclic = target_pidx is not None):
               if DEBUG_LEVEL >= 2:
                  print("...adding zone vertex (between edge", vi, "and", (vi + 1) % nEdges, ")")
               vpt = zone[vi]
               ix = len(ring_rec["vertices"])
               ring_rec["vertices"].append(vpt)
               # record both the output index and the source clipper edge index (t is implicitly 0)
               ring_rec["clipper_vertices_out_ix"].append({"out_ix": ix, "source_edge_ix": vi})
               appended.append(vpt)

      ix = len(ring_rec["vertices"])
      ring_rec["vertices"].append(entry_point)
      appended.append(entry_point)

      entry_token = {
         "out_vertex_ix": ix,
         "clipper_edge_ix": entry_edge,
         "clipper_edge_t": entry_edge_t
      }
      ring_rec["pending_entry"] = entry_token

   return (found_pidx, appended)

def process_exit(rings, hit, zone, nEdges):

   exit_edge = hit["edge_index"]
   exit_point = hit["point"]
   exit_edge_t = hit["edge_t"]

   print("<- Exiting zone from edge ", exit_edge, " at ", exit_point)

   idx = len(rings) - 1 if rings else create_new_ring(rings, None, None, None)
   ring_rec = rings[idx]
   interval = ring_rec["intervals"][-1]
   interval["exit_edge"] = exit_edge
   interval["exit_t"] = exit_edge_t
   interval["pending"] = False

   # ensure metadata containers exist
   ring_rec.setdefault("crossings", [])
   ring_rec.setdefault("vertices", [])
   ring_rec.setdefault("clipper_vertices_out_ix", [])
   ring_rec.setdefault("pending_entry", None)

   # append exit point and record its index
   ix = len(ring_rec["vertices"])
   ring_rec["vertices"].append(exit_point)
   ring_rec["last_exit_point"] = exit_point

   # pair with the single pending_entry token
   entry_token = ring_rec.get("pending_entry", None)
   ring_rec["pending_entry"] = None

   crossing_pair = {
      "entry": {
         "out_vertex_ix": entry_token["out_vertex_ix"] if entry_token else None,
         "clipper_edge_ix": entry_token["clipper_edge_ix"] if entry_token else None,
         "clipper_edge_t": entry_token["clipper_edge_t"] if entry_token else None
      },
      "exit": {
         "out_vertex_ix": ix,
         "clipper_edge_ix": exit_edge,
         "clipper_edge_t": exit_edge_t
      }
   }
   ring_rec["crossings"].append(crossing_pair)

   return (idx, [exit_point])

def clip_ring_to_zone(ring_coords, zone):
   nEdges = len(zone) if zone is not None else 0
   if nEdges == 0 or not ring_coords or len(ring_coords) < 2:
      return {"rings": [], "clip_info": [], "result": "empty"}

   n = len(ring_coords)

   # find first outside point (we want to start outside)
   first_out = None
   for j in range(0, n):
      if not point_in_ring(ring_coords[j], zone):
         first_out = j
         break

   # Special case 1: no outside point found -> entire ring is inside the zone (no intersection)
   if first_out is None:
      ring = list(ring_coords)
      if ring[0] != ring[-1]:
         ring.append(ring[0])

      clip_info = [{
         "ring_ix": 0,
         "crossings": [],
         "clipper_vertices_out_ix": []
      }]

      return {"rings": [ring], "clip_info": clip_info, "result": "unchanged"}

   # Special case 2: all zone vertices are inside the ring -> full clipped zone
   all_zone_inside = True
   for zv in zone:
      if not point_in_ring(zv, ring_coords):
         all_zone_inside = False
         break
   if all_zone_inside:
      full_zone = list(zone)
      if full_zone[0] != full_zone[-1]:
         full_zone.append(full_zone[0])

      # clipper_vertices_out_ix should contain indices 0..len(zone)-1
      clipper_vertices_out_ix = [{"out_ix": i, "source_edge_ix": i} for i in range(len(zone))]
      clip_info = [{
         "ring_ix": 0,
         "crossings": [],
         "clipper_vertices_out_ix": clipper_vertices_out_ix
      }]
      return {"rings": [full_zone], "clip_info": clip_info, "result": "full"}

   start = first_out
   state_inside = point_in_ring(ring_coords[start], zone)
   rings = []

   i = start
   while True:
      A = ring_coords[i]
      B = ring_coords[(i + 1) % n]
      seg_hits = collect_segment_hits(zone, nEdges, A, B)

      # process hits in traversal order (seg_hits assumed ordered by t)
      for hit in seg_hits:
         #print(hit)

         prev_state = state_inside
         state_inside = not state_inside
         if (not prev_state) and state_inside:
            process_entry(rings, hit, zone, nEdges)
         elif prev_state and (not state_inside):
            process_exit(rings, hit, zone, nEdges)

      new_state = point_in_ring(B, zone)
      if new_state != state_inside:
         print("MISMATCHED STATE!!!!")

      if state_inside:
         rings[-1]["vertices"].append(B)
      i = (i + 1) % n
      if i == start:
         break

   out_rings, clip_info = finalize_rings(rings, zone, nEdges)
   return {"rings": out_rings, "clip_info": clip_info, "result": "modified"}



================================================
FILE: high-vibes/clipping/clipUtils.py
================================================
# clipUtils.py
# Utility functions used by the clipper modules:
# - geometry predicates (point-in-polygon, segment intersections)
# - bbox helpers
# - zone boundary helpers (edges, boundary slice)
# - ring cleanup and small helpers

from typing import List, Dict, Optional, Tuple
EPS = 1e-12

def almost_equal_points(a: List[float], b: List[float], tol: float = 1e-9) -> bool:
   return abs(a[0] - b[0]) <= tol and abs(a[1] - b[1]) <= tol

def signed_area(verts: List[List[float]]) -> float:
    a = 0.0
    n = len(verts)
    for i in range(n):
        x0, y0 = verts[i]
        x1, y1 = verts[(i + 1) % n]
        a += (x0 * y1 - x1 * y0)
    return 0.5 * a

def point_in_polygon_old(pt: List[float], ring: List[List[float]]) -> bool:
    x, y = pt
    inside = False
    n = len(ring)
    for i in range(n):
        x0, y0 = ring[i]
        x1, y1 = ring[(i + 1) % n]
        cond = ((y0 > y) != (y1 > y))
        if cond:
            x_intersect = x0 + (x1 - x0) * (y - y0) / (y1 - y0)
            if x_intersect > x:
                inside = not inside
    return inside

def point_in_ring(pt, ring, eps=1e-12):
   # Winding-number point-in-polygon test adapted from libCartoSym's pointInsideContour2.
   # Returns True if point is inside or on the edge of the polygon, False otherwise.
   x, y = pt
   n = len(ring)
   if n < 3:
      return False

   # compute extent and quick reject
   xs = [p[0] for p in ring]
   ys = [p[1] for p in ring]
   minx, maxx = min(xs), max(xs)
   miny, maxy = min(ys), max(ys)
   if x < minx - abs(eps) or x > maxx + abs(eps) or y < miny - abs(eps) or y > maxy + abs(eps):
      return False

   # handle repeated final point equal to first
   def almost_equal(a, b, tol):
      return abs(a - b) <= tol

   if n > 2 and almost_equal(ring[-1][0], ring[0][0], eps) and almost_equal(ring[-1][1], ring[0][1], eps):
      count = n - 1
   else:
      count = n

   winding = 0

   def cross_from_line(px, py, ax, ay, bx, by):
      # cross product of (B-A) and (P-A): positive if P is left of AB
      return (bx - ax) * (py - ay) - (by - ay) * (px - ax)

   for i in range(count):
      ax, ay = ring[i]
      if i == count - 1:
         bx, by = ring[0]
      else:
         bx, by = ring[i + 1]

      d = float('inf')

      if ay <= y:
         if by > y:
            d = cross_from_line(x, y, ax, ay, bx, by)
            if d > eps:
               winding += 1
      else:
         if by <= y:
            d = cross_from_line(x, y, ax, ay, bx, by)
            if d < -eps:
               winding -= 1

      # on-edge detection: either d was not computed or is very small
      if d == float('inf') or abs(d) < eps:
         # bounding box check for the segment using x/y names
         minY = ay if ay < by else by
         maxY = by if ay < by else ay
         minX = ax if ax < bx else bx
         maxX = bx if ax < bx else ax
         if (y >= minY - eps and y <= maxY + eps and x >= minX - eps and x <= maxX + eps):
            # recompute d if needed
            if d == float('inf'):
               d = cross_from_line(x, y, ax, ay, bx, by)
               if abs(d) > eps:
                  continue
            return True

   return True if winding != 0 else False

def bbox_from_vertices(verts: List[List[float]]) -> List[float]:
    xs = [v[0] for v in verts]
    ys = [v[1] for v in verts]
    return [min(xs), min(ys), max(xs), max(ys)]

def segment_bbox(A: List[float], B: List[float]) -> List[float]:
    return [min(A[0], B[0]), min(A[1], B[1]), max(A[0], B[0]), max(A[1], B[1])]

def bbox_reject(seg_bbox: List[float], box: List[float]) -> bool:
    return (seg_bbox[2] < box[0] or seg_bbox[0] > box[2] or seg_bbox[3] < box[1] or seg_bbox[1] > box[3])

def segment_segment_intersections(A: List[float], B: List[float], C: List[float], D: List[float]) -> List[Dict]:
    x1, y1 = A
    x2, y2 = B
    x3, y3 = C
    x4, y4 = D
    den = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4)
    results = []
    if abs(den) > EPS:
        t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / den
        u = ((x1 - x3) * (y1 - y2) - (y1 - y3) * (x1 - x2)) / den
        if -EPS <= t <= 1 + EPS and -EPS <= u <= 1 + EPS:
            ix = x1 + t * (x2 - x1)
            iy = y1 + t * (y2 - y1)
            results.append({"t": max(0.0, min(1.0, t)), "u": max(0.0, min(1.0, u)), "point": [float(ix), float(iy)], "type": "point"})
        return results
    # collinear / overlap
    cross = (x2 - x1) * (y3 - y1) - (y2 - y1) * (x3 - x1)
    if abs(cross) > EPS:
        return results
    if abs(x2 - x1) >= abs(y2 - y1):
        a0, a1 = x1, x2
        b0, b1 = x3, x4
    else:
        a0, a1 = y1, y2
        b0, b1 = y3, y4
    a_min, a_max = min(a0, a1), max(a0, a1)
    b_min, b_max = min(b0, b1), max(b0, b1)
    if a_max < b_min - EPS or b_max < a_min - EPS:
        return results
    def param_t_for_val(val, a0, a1):
        if abs(a1 - a0) < EPS:
            return 0.0
        return (val - a0) / (a1 - a0)
    ov_start = max(a_min, b_min)
    ov_end = min(a_max, b_max)
    if abs(x2 - x1) >= abs(y2 - y1):
        t0 = param_t_for_val(ov_start, x1, x2)
        t1 = param_t_for_val(ov_end, x1, x2)
    else:
        t0 = param_t_for_val(ov_start, y1, y2)
        t1 = param_t_for_val(ov_end, y1, y2)
    p0 = [x1 + t0 * (x2 - x1), y1 + t0 * (y2 - y1)]
    p1 = [x1 + t1 * (x2 - x1), y1 + t1 * (y2 - y1)]
    results.append({"t": max(0.0, min(1.0, t0)), "u": None, "point": [float(p0[0]), float(p0[1])], "type": "overlap_start"})
    results.append({"t": max(0.0, min(1.0, t1)), "u": None, "point": [float(p1[0]), float(p1[1])], "type": "overlap_end"})
    return results

def cleanup_ring(ring: List[List[float]]) -> Optional[List[List[float]]]:
    if not ring:
        return None
    out = [ring[0]]
    for p in ring[1:]:
        if not almost_equal_points(p, out[-1]):
            out.append(p)
    def collinear(a, b, c):
        return abs((b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0])) <= EPS
    i = 0
    while i < len(out) - 2:
        if collinear(out[i], out[i + 1], out[i + 2]):
            del out[i + 1]
        else:
            i += 1
    if len(out) < 4:
        return None
    if not almost_equal_points(out[0], out[-1]):
        out.append(out[0])
    return out



================================================
FILE: high-vibes/dggsExport/exportFeatures.py
================================================
# dggsExport/exportFeatures.py
# GeoJSON exporter for DGGSDataStore
# - worker re-opens DGGSDataStore by path and collection and returns a dict mapping fid -> WKB
# - main thread merges package results, unions geometries with shapely, then populates attributes

from dggal import *

from typing import Dict, Any, List, Optional, Iterable
from concurrent.futures import ProcessPoolExecutor, as_completed
import os
import gc
import sys
import traceback
import shapely
from shapely import wkb as _wkb
from shapely.geometry import shape, mapping, Point, MultiPoint, LineString, MultiLineString, Polygon, MultiPolygon, GeometryCollection

from ogcapi.utils import pretty_json
from fg.dggsJSONFG import read_dggs_json_fg
from dggsStore.store import DGGSDataStore, iter_packages
from fg.reproj import instantiate_projection_for_dggrs_name
from fg.dggsJSONFG import unproject_and_fix

GRID_SIZE_DEFAULT = 1e-2
WORKERS = 16

def combine_geojson_geometries(geoms: List[Optional[Dict[str, Any]]]) -> Optional[Dict[str, Any]]:
   # Merge a list of GeoJSON geometry dicts into a single GeoJSON geometry dict.
   # - geoms: list of geometry dicts (e.g., {"type":"Polygon","coordinates":...}) or None
   # - returns a single geometry dict or None
   if not geoms:
      return None

   # filter out falsy entries
   items = [g for g in geoms if g]
   if not items:
      return None

   # classify by family
   pts: List[List[float]] = []
   lines: List[List[List[float]]] = []
   polys: List[List[List[List[float]]]] = []
   others: List[Dict[str, Any]] = []

   for g in items:
      t = g.get("type")
      if t == "Point":              pts.append(g["coordinates"])     # coords: [x,y,...]
      elif t == "MultiPoint":       pts.extend(g["coordinates"])     # coords: [[x,y], ...]
      elif t == "LineString":       lines.append(g["coordinates"])   # coords: [[x,y], ...]
      elif t == "MultiLineString":  lines.extend(g["coordinates"])   # coords: [[[x,y],...], ...]
      elif t == "Polygon":          polys.append(g["coordinates"])   # coords: [[ring], [ring], ...]  (ring = [[x,y],...])
      elif t == "MultiPolygon":     polys.extend(g["coordinates"])   # coords: [[[ring],...], [[ring],...], ...]
      else:                         others.append(g)  # unknown or GeometryCollection etc. keep original

   # if mixed families present, return GeometryCollection preserving order:
   families_present = sum(bool(x) for x in (pts, lines, polys, others))
   if families_present > 1:
      # preserve original geometries order from items
      coll = []
      for g in items:
         coll.append(g)
      return {"type": "GeometryCollection", "geometries": coll}

   # only points
   if pts and not lines and not polys and not others:
      if len(pts) == 1:
         return {"type": "Point", "coordinates": pts[0]}
      else:
         return {"type": "MultiPoint", "coordinates": pts}

   # only lines
   if lines and not pts and not polys and not others:
      if len(lines) == 1:
         return {"type": "LineString", "coordinates": lines[0]}
      else:
         return {"type": "MultiLineString", "coordinates": lines}

   # only polygons
   if polys and not pts and not lines and not others:
      if len(polys) == 1:
         # single polygon: keep Polygon shape
         return {"type": "Polygon", "coordinates": polys[0]}
      else:
         # multiple polygons -> MultiPolygon (each polygon is a list of rings)
         return {"type": "MultiPolygon", "coordinates": polys}

   # only others (e.g., GeometryCollection or unknown types)
   if others and not pts and not lines and not polys:
      if len(others) == 1:
         return others[0]
      else:
         return {"type": "GeometryCollection", "geometries": others}

   # fallback: if nothing matched, return None
   return None

# merge_shapely_geometries: merge iterable of Shapely geometries and return a single Shapely geometry
# - strict contract: geoms is an iterable of Shapely geometry objects (caller responsibility)
# - do_buffer defaults to False
# - if do_buffer is True and grid_size == 0, perform a single buffer(0) call; otherwise perform buffer(grid).buffer(-grid)
def merge_shapely_geometries(
   geoms: Iterable[Any],
   *,
   do_buffer: bool = False,
   grid_size: float = 1e-10
) -> Optional[Any]:
   # convert iterable to list (caller must supply valid Shapely geometries)
   geom_list = list(geoms)
   if not geom_list:
      return None

   # single geometry -> use directly
   if len(geom_list) == 1:
      merged = geom_list[0]
   else:
      merged = shapely.union_all(geom_list, grid_size=grid_size)

   if merged is None or merged.is_empty:
      return None

   # optional cleanup: single buffer when grid_size == 0, otherwise buffer(grid).buffer(-grid)
   if do_buffer:
      if grid_size == 0:
         merged = merged.buffer(0)
      else:
         merged = merged.buffer(grid_size).buffer(-grid_size)

   # return merged Shapely geometry
   return merged

# worker: collects GeoJSON per feature id, coalesces with combine_geojson_geometries,
# converts to Shapely, merges with merge_shapely_geometries(do_buffer=False),
# serializes merged geometry to WKB, and returns Dict[int, bytes]
def _worker_process_package(
   datastore_path: str,
   collection: str,
   pkg_path: str,
   base_zone_id: int,
   root_level: int,
   target_level: int,
   debug: bool,
   grid_size: float = GRID_SIZE_DEFAULT
) -> Dict[int, bytes]:
   store = DGGSDataStore(datastore_path, collection)
   print(f'Processing root zones of level {root_level} under base zone {store.dggrs.getZoneTextID(base_zone_id)} in process {os.getpid()}', flush=True)

   # accumulate GeoJSON geometries per feature id (string keys while reading)
   features: Dict[int, List[Dict[str, Any]]] = {}

   for root_zone in store.iter_roots_for_base(base_zone_id, root_level, up_to=False):
      dggsubjson = store.read_and_decode_zone_blob(pkg_path, root_zone)
      geojson = read_dggs_json_fg(dggsubjson, unproject=False, refine_wgs84=None) if dggsubjson else None
      if geojson:
         feats = geojson.get('features', []) or []
         for feat in feats:
            geom_json = feat.get('geometry')
            fid = feat.get('id')

            # We're assuming non-zero integer feature IDs
            if not fid or not isinstance(fid, int):
               raise BaseException

            # append raw GeoJSON geometry (may be None)
            if geom_json is not None:
               if fid not in features:
                  features[fid] = []
               features[fid].append(geom_json)

   # merge per-feature and serialize to WKB; worker does NOT run final buffer cleanup
   projection = instantiate_projection_for_dggrs_name(store.config['dggrs'])
   ge = GeoExtent()
   store.dggrs.getZoneWGS84Extent(base_zone_id, ge)
   extent = [float(ge.ll.lon), float(ge.ll.lat), float(ge.ur.lon), float(ge.ur.lat)]

   result: Dict[int, bytes] = {}
   for fid, geoms in features.items():
      merged_geojson = combine_geojson_geometries(geoms)
      if merged_geojson is None: continue
      # free memory for this entry
      geoms.clear()

      if merged_geojson:
         merged_geojson = unproject_and_fix(projection, extent, merged_geojson, fid, refine_wgs84=None) #1e-2)

      if merged_geojson is None: continue

      shp = shape(merged_geojson)
      if shp is None: continue

      # merge shapely geometries (worker-level union across parts), no buffer cleanup here
      merged_shp = merge_shapely_geometries([shp], do_buffer=False, grid_size=grid_size)
      if merged_shp is None: continue

      # serialize to WKB (binary) and store under integer feature id
      result[fid] = _wkb.dumps(merged_shp, hex=False)

   Instance.delete(projection)

   gc.collect()
   return result

# orchestrator: receives list of worker results (each Dict[int, bytes]),
# aggregates WKBs per feature id, rehydrates to Shapely, calls merge_shapely_geometries(do_buffer=True),
# converts final Shapely geometry to GeoJSON mapping
def orchestrator_finalize(
   package_results: List[Dict[int, bytes]],
   projection,
   *,
   grid_size: float = GRID_SIZE_DEFAULT
) -> Dict[int, dict]:
   # aggregate WKB lists per feature id
   agg: Dict[int, List[bytes]] = {}
   for pkg in package_results:
      for fid, wkb_bytes in pkg.items():
         if fid not in agg:
            agg[fid] = []
         agg[fid].append(wkb_bytes)

   # merge per-feature across workers, perform final buffer cleanup, convert to GeoJSON
   final_geoms: Dict[int, dict] = {}
   #extent = [-180,-90,180,90]
   for fid, wkb_list in agg.items():
      # rehydrate all WKBs to Shapely geometries
      shps = [_wkb.loads(b) for b in wkb_list]
      # merge across workers and perform final cleanup (do_buffer=True)
      merged = merge_shapely_geometries(shps, do_buffer=True, grid_size=grid_size)
      geojson = mapping(merged) if merged else None
      # REVIEW: It would be ideal to unproject at the end, but it currently runs into topology issues
      #if geojson:
      #   geojson = unproject_and_fix(projection, extent, geojson, fid, refine_wgs84=1e-2)
      final_geoms[fid] = geojson

   return final_geoms

def export_to_geojson(
   store: DGGSDataStore,
   sampling_level: int,
   output_path: str,
   *,
   level: Optional[int] = None,
   workers: Optional[int] = None,
   debug: bool = False,
   max_packages: Optional[int] = None,
   grid_size: float = GRID_SIZE_DEFAULT
) -> None:
   """
   Orchestrate export:
   - sampling_level: requested sampling level (CLI --level)
   - clamps to store.maxRefinementLevel
   - computes root_level = max(0, sampling_level_clamped - store.depth)
   - computes base_level = store._base_level_for_root(root_level)
   - iterates packages at base_level, dispatches one package per worker
   - merges package results, unions geometries, populates attributes, writes GeoJSON
   """
   requested_level = sampling_level if level is None else level
   sampling_level_clamped = min(requested_level, store.maxRefinementLevel)
   root_level = max(0, sampling_level_clamped - store.depth)
   base_level = store._base_level_for_root(root_level)

   cpu_count = os.cpu_count() or 1
   worker_count = workers if workers is not None else min(WORKERS, max(1, cpu_count))

   datastore_path = store.data_root
   collection = store.collection

   pkg_iter = iter_packages(store, base_level)

   futures = []
   package_results: List[Dict[int, bytes]] = []
   submitted = 0

   projection = None #instantiate_projection_for_dggrs_name(store.config['dggrs'])

   with ProcessPoolExecutor(max_workers=worker_count) as ex:
      for pkg_path, base_zone_id, base_ancestors_ids in pkg_iter:
         if max_packages and submitted >= max_packages:
            break
         submitted += 1
         fut = ex.submit(
            _worker_process_package,
            datastore_path,
            collection,
            pkg_path,
            base_zone_id,
            root_level,
            sampling_level_clamped,
            debug,
         )
         futures.append(fut)

      for fut in as_completed(futures):
         exc = fut.exception()
         if exc:
            traceback.print_exception(type(exc), exc, exc.__traceback__, file=sys.stderr)
            raise BaseException
            continue
         res = fut.result()
         if not res:
            continue
         package_results.append(res)

   # aggregate and finalize geometries from workers
   print("All zone data processed, merging final features...")
   final_geoms: Dict[int, dict] = orchestrator_finalize(package_results, projection, grid_size=grid_size)

   if projection:
      Instance.delete(projection)

   # build feature list from finalized geometries (workers do not return props)
   out_features: List[Dict[str, Any]] = []
   for fid in sorted(final_geoms):
      out_features.append({
         'type': 'Feature',
         'id': fid,
         'properties': {},
         'geometry': final_geoms[fid]
      })

   print("Populating feature attributes...")
   # populate attributes from store
   ids = [f['id'] for f in out_features]
   if ids:
      attrs_map = store.get_attributes_for_feature_ids(ids)
      for feat in out_features:
         feat['properties'] = attrs_map.get(feat['id'], {}) or {}

   print("Writing final geoJSON (", output_path, ")...")
   out_obj = {'type': 'FeatureCollection', 'features': out_features}
   with open(output_path, 'w', encoding='utf-8') as fh:
      fh.write(pretty_json(out_obj))
      fh.write('\n')

   gc.collect()



================================================
FILE: high-vibes/dggsExport/raster.py
================================================
#!/usr/bin/env python3
# raster.py
# Streaming, multiprocessing rasterizer for DGGS packages
# - Parent creates shared memory for zone grid and output buffer
# - Parent pre-fills the zone grid
# - Parent submits one task per package; each worker re-creates a lightweight
#   DGGSDataStore from a small config and iterates roots lazily
# - Workers map shared memory by name and write into the shared output buffer

from __future__ import annotations
from dggal import *
import dggal
from dggsStore.store import DGGSDataStore, iter_packages
import time
import math
import logging
from concurrent.futures import ProcessPoolExecutor, as_completed
from typing import Tuple, Dict, List, Iterator

import numpy as np
import rasterio
from rasterio.transform import from_origin
import os

from .rasterZoneGrid import create_shared_zone_grid, prefill_zone_grid
from multiprocessing import shared_memory as _shm

# FFI handle
dggal_ffi = dggal.ffi

# logging
logging.basicConfig(level=logging.INFO, format="%(levelname)s:%(message)s")
logger = logging.getLogger(__name__)

# geometry helpers
def compute_raster_dimensions(dggrs, level: int) -> Tuple[float, float, int, int, object]:
   meters_per_subzone = dggrs.getMetersPerSubZoneFromLevel(level, 0)
   meters_per_degree = 111319.49079327358
   deg_per_pixel = meters_per_subzone / meters_per_degree
   width = int(math.ceil(360.0 / deg_per_pixel))
   height = int(math.ceil(180.0 / deg_per_pixel))
   transform = from_origin(-180.0, 90.0, deg_per_pixel, deg_per_pixel)
   return meters_per_subzone, deg_per_pixel, width, height, transform

def _lon_ranges_for_extent(min_lon: float, max_lon: float) -> List[Tuple[float, float]]:
   if max_lon > 180.0:
      max_lon -= 360.0
   if (max_lon - min_lon) >= 360.0 - 1e-9:
      return [(-180.0, 180.0)]
   if max_lon < min_lon:
      return [(min_lon, 180.0), (-180.0, max_lon)]
   return [(min_lon, max_lon)]

def prepare_root(store: DGGSDataStore, dggrs, pkg_path: str, zone: DGGRSZone,
   depth: int, deg_per_pixel: float, width: int, height: int, nodata: float,
   fields: List[str]
   ) -> Tuple[Dict[str, np.ndarray], np.ndarray, Dict[int,int], List[Tuple[float,float]], int, int, float]:
   t0 = time.time()
   decoded = store.read_and_decode_zone_blob(pkg_path, zone)
   if decoded is None:
      #if not os.path.exists(pkg_path):
      #   print("WARNING: reading from non-existing package", pkg_path)
      #else:
      #   print("WARNING: failure to read or decode blob for zone", dggrs.getZoneTextID(zone), "in package", pkg_path)
      return None, None, None, None, None, None, None
   decode_s = time.time() - t0

   # Build a dict of field -> numpy array for the requested depth
   values_map: Dict[str, np.ndarray] = {}
   for field in fields:
      values = decoded["values"].get(field)
      chosen = next((e for e in values if int(e["depth"]) == depth), None) if values is not None else None
      if chosen is None:
         values_map[field] = np.full(0, nodata, dtype=np.float64)
         continue
      raw = list(chosen["data"])
      values_map[field] = np.array([nodata if v is None else float(v) for v in raw],
         dtype=np.float64, copy=True)

   # Subzone index mapping
   subs_obj = dggrs.getSubZones(zone, depth)
   subs_count = subs_obj.count
   subs_ptr = ffi.cast("uint64_t *", subs_obj.array)
   idx_map = { int(subs_ptr[i]): i for i in range(subs_count) }
   Instance.delete(subs_obj)

   # Extent and pixel row bounds
   ext = GeoExtent()
   dggrs.getZoneWGS84Extent(zone, ext)
   ll_lon = float(ext.ll.lon); ll_lat = float(ext.ll.lat)
   ur_lon = float(ext.ur.lon); ur_lat = float(ext.ur.lat)

   lon_ranges = _lon_ranges_for_extent(ll_lon, ur_lon)

   min_y = max(0, int(math.floor((90.0 - ur_lat) / deg_per_pixel - 0.5)))
   max_y = min(height - 1, int(math.floor((90.0 - ll_lat) / deg_per_pixel - 0.5)))

   return values_map, subs_ptr, idx_map, lon_ranges, min_y, max_y, decode_s

# paint worker: maps shared memory and writes values
def _paint_worker(shm_zone_name: str, shm_out_name: str,
   width: int, height: int,
   deg_per_pixel: float,
   lon_ranges: List[Tuple[float,float]],
   min_y: int, max_y: int,
   subs_array: np.ndarray, values: np.ndarray,
   nodata: float, null_zone_int: int,
   idx_map: Dict[int,int],
   band_index: int, n_fields: int):

   shm_zone = _shm.SharedMemory(name=shm_zone_name)
   zone_grid = np.ndarray((height, width), dtype=np.uint64, buffer=shm_zone.buf)

   shm_out = _shm.SharedMemory(name=shm_out_name)
   out_all = np.ndarray((n_fields, height, width), dtype=np.float32, buffer=shm_out.buf)
   out_band = out_all[band_index]

   nz = int(null_zone_int)
   nod = nodata

   for lon_min, lon_max in lon_ranges:
      min_x = max(0, int(math.floor((lon_min + 180.0) / deg_per_pixel - 0.5)))
      max_x = min(width - 1, int(math.floor((lon_max + 180.0) / deg_per_pixel - 0.5)))
      if max_x < min_x:
         continue

      cols = max_x - min_x + 1

      block = zone_grid[min_y:max_y+1, min_x:max_x+1].astype(np.uint64, copy=False)
      block_flat = block.ravel()

      valid_mask = (block_flat != nz)
      if not np.any(valid_mask):
         continue

      valid_positions = np.flatnonzero(valid_mask)
      zone_vals = block_flat[valid_positions]

      idxs = np.fromiter((idx_map.get(int(z), -1) for z in zone_vals),
                         dtype=np.int32, count=zone_vals.size)

      present_mask = (idxs >= 0)
      if not np.any(present_mask):
         continue

      present_positions = valid_positions[present_mask]
      value_indices = idxs[present_mask]

      gathered_vals = values[value_indices]
      valid_value_mask = (gathered_vals != nod)
      if not np.any(valid_value_mask):
         continue

      final_positions = present_positions[valid_value_mask]
      final_values = gathered_vals[valid_value_mask].astype(np.float32, copy=False)

      rows_idx = final_positions // cols
      cols_idx = final_positions % cols
      out_band[min_y + rows_idx, min_x + cols_idx] = final_values

   shm_zone.close()
   shm_out.close()
   return None


# per-package worker: reconstruct store and DGGRSZone from ids inside worker
def _paint_package_worker(pkg_path: str,
   base_zone_id: int,
   base_ancestors_ids: List[int],
   worker_config: dict,
   root_level: int,
   depth: int,
   deg_per_pixel: float,
   width: int,
   height: int,
   shm_zone_name: str,
   shm_out_name: str,
   nodata: float,
   null_zone_int: int,
   fields: List[str],
   n_fields: int):
   data_root = worker_config["_data_root"]
   collection = worker_config["collection"]
   collection_config = worker_config["collection_config"]

   store = DGGSDataStore(data_root, collection, config=collection_config)
   dggrs = store.dggrs

   base_zone = DGGRSZone(base_zone_id)

   for root_zone in store.iter_roots_for_base(base_zone, root_level, up_to=False):
      values_map, subs_array, idx_map, lon_ranges, min_y, max_y, _decode_s = prepare_root(
         store, dggrs, pkg_path, root_zone, depth, deg_per_pixel, width, height, nodata, fields
      )
      if values_map is None: continue

      for band_index, field in enumerate(fields):
         values = values_map.get(field)
         if values is None or values.size == 0:
            continue
         _paint_worker(shm_zone_name, shm_out_name,
            width, height,
            deg_per_pixel,
            lon_ranges,
            min_y, max_y,
            subs_array, values,
            nodata, null_zone_int,
            idx_map,
            band_index, n_fields)


# top-level rasterize: streaming, no materialization of all roots
def rasterize_to_geotiff(store: DGGSDataStore, level: int, outfile: str, workers: int = 8,
   nodata: float = np.finfo(np.float32).max, compress: str = "lzw",
   debug: bool = False, max_packages: int = 0, fields: Optional[List[str]] = None) -> dict:
   start = time.time()
   logger.info("rasterize start level=%d workers=%d", level, workers)

   dggrs = store.dggrs
   depth = store.depth

   meters_per_subzone, deg_per_pixel, width, height, transform = compute_raster_dimensions(dggrs, level)

   # determine which fields to include in output
   out_fields = list(fields) if fields is not None else store.fields
   n_fields = len(out_fields)

   MAX_ALLOC_BYTES = 7 * 1024**3

   itemsize = np.dtype(np.float32).itemsize
   size_out = n_fields * width * height * itemsize

   if size_out > MAX_ALLOC_BYTES:
      print(f"Output raster is {size_out:,} bytes; cap is {MAX_ALLOC_BYTES:,} bytes", flush=True)
      return {"elapsed_seconds": 0}

   logger.info("Allocating shared global zone_grid %dx%d (uint64) and out buffer (float32)", width, height)
   zone_grid, shm_zone = create_shared_zone_grid(width, height, int(nullZone))

   logger.info("Allocating float32 buffer %dx%d for %d fields", width, height, n_fields)
   shm_out = _shm.SharedMemory(create=True, size=size_out)
   out_shared = np.ndarray((n_fields, height, width), dtype=np.float32, buffer=shm_out.buf)
   out_shared.fill(nodata)

   # prefill zone grid in parent
   prefill_zone_grid(shm_zone.name, dggrs, level, deg_per_pixel, workers=workers)

   logger.info("zone grid fill complete")

   root_level = max(0, level - depth)

   # worker_config contains parsed collection.json to avoid disk reparse
   worker_config = {
      "_data_root": store.data_root,
      "collection": store.collection,
      "collection_config": store.config
   }

   futures = []
   submitted = 0
   null_zone_int = int(nullZone)

   with ProcessPoolExecutor(max_workers=workers) as ex:
      for pkg_path, base_zone_id, base_ancestors_ids in iter_packages(store, root_level):
         if max_packages and submitted >= max_packages:
            break
         submitted += 1
         fut = ex.submit(
            _paint_package_worker,
            pkg_path, base_zone_id, base_ancestors_ids,
            worker_config, root_level, depth,
            deg_per_pixel, width, height,
            shm_zone.name, shm_out.name,
            float(nodata), null_zone_int,
            out_fields, n_fields
         )
         futures.append(fut)

      for fut in as_completed(futures):
         fut.result()

   elapsed = time.time() - start
   logger.info("rasterize complete elapsed=%.2f s", elapsed)

   profile = {
      "driver": "GTiff",
      "height": height,
      "width": width,
      "count": n_fields,
      "dtype": "float32",
      "crs": "EPSG:4326",
      "transform": transform,
      "nodata": nodata,
      "compress": compress
   }

   os.makedirs(os.path.dirname(outfile) or ".", exist_ok=True)
   with rasterio.open(outfile, "w", **profile) as dst:
      dst.write(out_shared)

   # cleanup shared memory handles
   shm_out.close()
   shm_out.unlink()
   shm_zone.close()
   shm_zone.unlink()

   return {"elapsed_seconds": elapsed}



================================================
FILE: high-vibes/dggsExport/rasterZoneGrid.py
================================================
#!/usr/bin/env python3
# rasterZoneGrid.py
# Shared-memory global zone buffer creation and multiprocessing prefill.
# Provides:
# - create_shared_zone_grid(width, height, null_zone_int) -> (zone_grid, shm)
# - prefill_zone_grid(shm_name, dggrs, level, deg_per_pixel, workers)
# Notes:
# - On Unix with fork we use uintptr_t optimization to avoid re-creating DGGRS.
# - On other platforms / start methods we pass a DGGRS id and recreate DGGRS in workers.

from __future__ import annotations
from dggal import *
import os
import math
from concurrent.futures import ProcessPoolExecutor, as_completed
from multiprocessing import shared_memory, get_start_method
from typing import Tuple, Optional

import numpy as np

dggal_ffi = dggal.ffi

# module-level worker state set by initializer in each process
_WORKER_DGGRS_IMPL = None
_WORKER_SHAPE: Tuple[int,int] = None

# initializer receives either a non-zero dggrs_impl_addr (uintptr_t) OR a dggrs_id string/int
# initargs layout: (dggrs_impl_addr:int, dggrs_id:Optional[str], shape:Tuple[int,int])
def _proc_initializer(dggrs_impl_addr: int, dggrs_id: Optional[str], shape: Tuple[int,int]):
   import dggal as _dggal
   ffi_local = _dggal.ffi

   if dggrs_impl_addr:
      # uintptr_t path: cast integer back to void*
      impl = ffi_local.cast("void *", dggrs_impl_addr)
   else:
      # id path: recreate DGGRS in worker and take its impl
      # expects dggal to expose get_or_create_dggrs(dggrs_id)
      dggrs_obj = _dggal.get_or_create_dggrs(dggrs_id)
      impl = dggrs_obj.impl

   globals()["_WORKER_DGGRS_IMPL"] = impl
   globals()["_WORKER_SHAPE"] = shape

def _proc_fill_tile(shm_name: str, level: int, deg_per_pixel: float,
                    px_min: int, px_max: int, py_min: int, py_max: int):
   import numpy as _np
   import math as _math
   import dggal as _dggal
   from dggal import GeoPoint as _GeoPoint
   from multiprocessing import shared_memory as _shm

   _WORKER_DGGRS_IMPL = globals()["_WORKER_DGGRS_IMPL"]
   _WORKER_SHAPE = globals()["_WORKER_SHAPE"]

   shm = _shm.SharedMemory(name=shm_name)
   arr = _np.ndarray(_WORKER_SHAPE, dtype=_np.uint64, buffer=shm.buf)
   flat = arr.ravel()

   deg_to_rad = _math.pi / 180.0
   rad_per_pixel = deg_per_pixel * deg_to_rad
   half_pixel_rad = 0.5 * rad_per_pixel
   top_lat_rad = 90.0 * deg_to_rad
   left_lon_rad = -180.0 * deg_to_rad

   gp = _GeoPoint()
   gp_impl = gp.impl
   get_zone_local = _dggal.lib.DGGRS_getZoneFromWGS84Centroid
   dggrs_impl_local = _WORKER_DGGRS_IMPL

   height, width = _WORKER_SHAPE

   for py in range(py_min, py_max + 1):
      lat_rad = top_lat_rad - (py * rad_per_pixel + half_pixel_rad)
      gp_impl.lat = lat_rad
      base = py * width
      for px in range(px_min, px_max + 1):
         gp_impl.lon = left_lon_rad + (px * rad_per_pixel + half_pixel_rad)
         flat[base + px] = _np.uint64(int(get_zone_local(dggrs_impl_local, level, gp_impl)))

   shm.close()
   return None

def create_shared_zone_grid(width: int, height: int, null_zone_int: int):
   # Create a shared-memory uint64 array shaped (height, width) and initialize to null_zone_int.
   # Returns (zone_grid, shm) where shm is the SharedMemory object (caller must close/unlink).
   size = width * height * np.dtype(np.uint64).itemsize
   shm = shared_memory.SharedMemory(create=True, size=size)
   zone_grid = np.ndarray((height, width), dtype=np.uint64, buffer=shm.buf)
   zone_grid.fill(int(null_zone_int))
   return zone_grid, shm

def prefill_zone_grid(shm_name: str, dggrs, level: int, deg_per_pixel: float,
                      workers: int = 8) -> None:
   # Prefill the shared zone buffer identified by shm_name. Uses a 4x2 tiling scheme.
   # This function does not unlink the shared memory; caller is responsible for cleanup.

   # reconstruct shape from dggrs + level to pass to initializer
   meters_per_subzone = dggrs.getMetersPerSubZoneFromLevel(level, 0)
   meters_per_degree = 111319.49079327358
   deg_per_pixel_local = meters_per_subzone / meters_per_degree
   # compute width/height consistent with main raster dimensions
   width = int(math.ceil(360.0 / deg_per_pixel_local))
   height = int(math.ceil(180.0 / deg_per_pixel_local))

   # build 4x2 tile rects
   tile_rects = []
   for tx in range(4):
      for ty in range(2):
         lon_min = -180.0 + tx * 90.0
         lon_max = lon_min + 90.0
         lat_max = 90.0 - ty * 90.0
         lat_min = lat_max - 90.0
         half = 0.5 * deg_per_pixel
         px_min_f = (lon_min + 180.0 - half) / deg_per_pixel
         px_max_f = (lon_max + 180.0 - half) / deg_per_pixel
         px_min = int(math.ceil(px_min_f)); px_max = int(math.floor(px_max_f))
         px_min = max(0, px_min); px_max = min(width - 1, px_max)
         py_min_f = (90.0 - (lat_max + half)) / deg_per_pixel
         py_max_f = (90.0 - (lat_min - half)) / deg_per_pixel
         py_min = int(math.ceil(py_min_f)); py_max = int(math.floor(py_max_f))
         py_min = max(0, py_min); py_max = min(height - 1, py_max)
         if px_max >= px_min and py_max >= py_min:
            tile_rects.append((px_min, px_max, py_min, py_max))

   # decide whether to use uintptr_t optimization
   start_method = get_start_method()
   use_addr = (os.name == "posix" and start_method == "fork")

   if use_addr:
      # cast DGGRS impl pointer to uintptr_t and pass to workers
      addr = int(dggal_ffi.cast("uintptr_t", dggrs.impl))
      initargs = (addr, None, (height, width))
   else:
      # pass DGGRS id and let workers recreate DGGRS (portable)
      dggrs_id = getattr(dggrs, "id", None)
      initargs = (0, dggrs_id, (height, width))

   with ProcessPoolExecutor(max_workers=workers, initializer=_proc_initializer, initargs=initargs) as ex:
      futures = [ex.submit(_proc_fill_tile, shm_name, level, deg_per_pixel, px_min, px_max, py_min, py_max)
                 for (px_min, px_max, py_min, py_max) in tile_rects]
      for fut in as_completed(futures):
         fut.result()

   return None



================================================
FILE: high-vibes/dggsImport/rasterImport.py
================================================
from dggal import *
from typing import List, Dict, Any, Optional
from concurrent.futures import ThreadPoolExecutor, as_completed
import json

from dggsStore.store import *
from dggsStore.customDepths import *

from .rasterSampling import *

import threading
from typing import List, Dict, Any, Optional
from concurrent.futures import ThreadPoolExecutor, ProcessPoolExecutor, as_completed
import rasterio

# top-level process worker (must be picklable)
def _sample_package_worker(ds_path: str,
   zone_id: int,
   worker_config: dict,
   raster_crs: str,
   data_level: int,
   depth: int,
   use_overviews: bool,
   fields: List[str],
   bands: Optional[List[int]] = None
) -> Optional[Dict[str, List[Dict[str, Any]]]]:
   data_root = worker_config["_data_root"]
   collection = worker_config["collection"]
   collection_config = worker_config["collection_config"]
   store = DGGSDataStore(data_root, collection, config=collection_config)
   dggrs = store.dggrs
   # reconstruct zone object from integer id
   zone = DGGRSZone(zone_id)
   with rasterio.open(ds_path) as ds:
      return sample_depth_obj_for_zone(store, ds, raster_crs, dggrs, zone,
         data_level, depth, use_overviews, fields, bands)

# top-level aggregate worker (must be picklable)
def _aggregate_package_worker(worker_config: dict,
   zone_id: int,
   zone_depth: int,
   fields: Optional[List[str]] = None
) -> Optional[Dict[str, List[Dict[str, Any]]]]:
   # Recreate the store inside the child process and call aggregate_zone_at_depth.
   # Accepts only picklable primitives so it can be submitted to ProcessPoolExecutor.
   data_root = worker_config["_data_root"]
   collection = worker_config["collection"]
   collection_config = worker_config["collection_config"]
   store = DGGSDataStore(data_root, collection, config=collection_config)
   # reconstruct zone object from integer id
   root_zone = DGGRSZone(zone_id)
   # call the existing aggregation function (signature unchanged)
   return aggregate_zone_at_depth(store, root_zone, zone_depth, fields)

def _build_blobs_processes(
   store_worker_config: dict,
   ds_path: str,                # dataset path string (ds.name)
   raster_crs: str,
   dggrs,                       # used only in parent for zone text lookup
   dggrs_uri: str,
   zones: List,
   data_level: int,
   depth: int,
   fields: List[str],
   use_overviews: bool,
   aggregate: bool,
   bands: Optional[List[int]] = None,
   max_workers: int = 16
) -> Dict[int, Dict[str, Any]]:
   if not zones:
      return {}

   workers = min(max_workers, max(1, len(zones)))
   blobs: Dict[int, Dict[str, Any]] = {}

   with ProcessPoolExecutor(max_workers=workers) as ex:
      futures = {}
      if aggregate:
         # submit the aggregate wrapper that reconstructs the store in the child
         for z in zones:
            fut = ex.submit(_aggregate_package_worker, store_worker_config, int(z), depth, fields)
            futures[fut] = z
      else:
         for z in zones:
            # pass only picklable primitives to the worker
            fut = ex.submit(_sample_package_worker, ds_path, int(z), store_worker_config,
               raster_crs, data_level, depth, use_overviews, fields, bands)
            futures[fut] = z

      for fut in as_completed(futures):
         zone = futures[fut]
         fields_map = fut.result()
         if not fields_map:
            if aggregate:
               print(f"[AGG] zone={dggrs.getZoneTextID(zone)} aggregate returned empty, skipping", flush=True)
            else:
               print(f"[SAMPLE] zone={dggrs.getZoneTextID(zone)} sample returned empty, skipping", flush=True)
            continue

         zone_text = dggrs.getZoneTextID(zone)
         blobs[int(zone)] = make_dggs_json_blob(dggrs_uri, zone_text, fields_map)
         if aggregate:
            print(f"[AGG] zone={zone_text} agg_blob_accepted", flush=True)
         else:
            print(f"[BUILD] zone={zone_text} blob_ready fields={list(fields_map.keys())}", flush=True)

   return blobs

# ---------------------------------------------------------------------------
# Coordinator: single write boundary (uses the threaded builder)
# - Keeps the original sample_depth_obj_for_zone signature unchanged.
# - Passes the open ds through; the sampling worker will open a per-thread handle.
# ---------------------------------------------------------------------------
def _process_batch(store, ds, raster_crs: str, dggrs, dggrs_uri: str,
   base_zone, batch_zones: List, base_ancestors: List,
   data_level: int, depth: int, fields: List[str], use_overviews: bool, aggregate: bool, bands: List[int] | None = None,
   max_workers: int = 16) -> int:
   if not batch_zones:
      print("[BATCH] empty batch, skipping", flush=True)
      return 0

   print(f"[BATCH] processing batch base_zone={dggrs.getZoneTextID(base_zone)} roots={len(batch_zones)} aggregate={aggregate}", flush=True)

   worker_config = {
      "_data_root": store.data_root,
      "collection": store.collection,
      "collection_config": store.config
   }

   entries = _build_blobs_processes(
      store_worker_config=worker_config,
      ds_path=ds.name,
      raster_crs=raster_crs,
      dggrs=dggrs,
      dggrs_uri=dggrs_uri,
      zones=batch_zones,
      data_level=data_level,
      depth=depth,
      fields=fields,
      use_overviews=use_overviews,
      aggregate=aggregate,
      bands=bands,
      max_workers=max_workers
   )

   if not entries:
      print("[BATCH] no entries produced for this batch, skipping write", flush=True)
      return 0

   print(f"[BATCH] writing {len(entries)} entries to store for base_zone={dggrs.getZoneTextID(base_zone)}", flush=True)
   store.write_zone_batch(
      base_zone=base_zone,
      entries=entries,
      base_ancestor_list=base_ancestors,
      precompressed=False
   )
   print(f"[BATCH] write complete for base_zone={dggrs.getZoneTextID(base_zone)} wrote={len(entries)}", flush=True)
   return len(entries)

# ---------------------------------------------------------------------------
# Main import function (control flow preserved)
# ---------------------------------------------------------------------------

def import_raster(ds, collection_id: str, dggrs_name: str, data_root: str = "data",
   level: int | None = None, depth: int | None = None,
   fields: List[str] | None = None, bands: List[int] | None = None,
   batch_size: int = 32, groupSize: int = 5, aggregate: bool | None = None, max_workers: int = 16):

   # Uses provided open rasterio dataset `ds`. closes ds on every return.
   # Returns 0 on success, 1 on error.

   raster_crs = ds.crs.to_string() if ds.crs is not None else "EPSG:4326"

   has_overviews = False
   if ds.count >= 1:
      has_overviews = bool(ds.overviews(1))

   if aggregate is None:
      aggregate = not has_overviews
   print(f"[IMPORT] has_overviews={has_overviews} aggregate={aggregate}", flush=True)

   use_overviews_for_sampling = (not aggregate) and has_overviews

   dggrs_init = globals().get(dggrs_name)
   if dggrs_init is None:
      print("Unsupported DGGRS:", dggrs_name, flush=True)
      ds.close()
      return 1
   dggrs = dggrs_init()

   if level is None:
      b = ds.bounds
      if raster_crs != "EPSG:4326":
         xs, ys = transform(raster_crs, "EPSG:4326", [b.left, b.right], [b.bottom, b.top])
         min_lon, max_lon = min(xs[0], xs[1]), max(xs[0], xs[1])
         min_lat, max_lat = min(ys[0], ys[1]), max(ys[0], ys[1])
      else:
         min_lon, max_lon = min(b.left, b.right), max(b.left, b.right)
         min_lat, max_lat = min(b.bottom, b.top), max(b.bottom, b.top)
      level = dggrs.getLevelFromPixelsAndExtent(GeoExtent((min_lat, min_lon), (max_lat, max_lon)),
         Point(ds.width, ds.height), 0)
      print(f"[IMPORT] computed data level from raster: {level}", flush=True)

   if depth is None:
      depth = dggrs.get64KDepth()
      print(f"[IMPORT] using default depth (get64KDepth) = {depth}", flush=True)

   data_level = level
   deepest_root_level = max(0, data_level - depth)

   bands_used = bands if bands is not None else list(range(1, ds.count + 1))

   if not fields:
      fields = [f"field{i+1}" for i in range(len(bands_used))]

   print(fields)

   coll_info = {
      "dggrs": dggrs_name, "maxRefinementLevel": data_level, "depth": depth,
      "groupSize": groupSize, "title": collection_id, "description": collection_id, "version": "1.0"
   }
   dggrs_uri = f"[ogc-dggrs:{dggrs_name}]"

   base = os.path.join(data_root, collection_id)
   os.makedirs(base, exist_ok=True)
   with open(os.path.join(base, "collection.json"), "w", encoding="utf-8") as fh:
      json.dump(coll_info, fh, indent=2)
   print(f"[IMPORT] Wrote collection config to {os.path.join(base, 'collection.json')}", flush=True)

   store = DGGSDataStore(data_root, collection_id, config=coll_info)
   dggrs = store.dggrs
   max_base_level = store._base_level_for_root(deepest_root_level)
   print(
      f"[IMPORT] Computed levels: data_level={data_level} depth={depth} finest_root_level={deepest_root_level} "
      f"max_base_level={max_base_level} batch_size={batch_size}", flush=True
   )
   print(f"[DIAG] using groupSize={groupSize} (recommended default is 5)", flush=True)

   pkg_index = 0
   total_written = 0
   finest_level_done = False

   for root_level in range(deepest_root_level, -1, -1):
      base_level = store._base_level_for_root(root_level)
      up_to = False
      for base_zone, base_ancestors in store.iter_bases(base_level, up_to=up_to):
         pkg_index += 1
         base_text = dggrs.getZoneTextID(base_zone)
         print(f"[LEVEL {root_level}] #{pkg_index}: base_zone={base_text}", flush=True)

         base_level = dggrs.getZoneLevel(base_zone)
         package_group_levels = store.group0Size if base_level == 0 else store.groupSize
         package_max = base_level + package_group_levels - 1
         max_root_level = root_level
         if base_level > max_root_level:
            print(f"[SKIP] package base {base_text} (base_level={base_level}) deeper than target {max_root_level}",
               flush=True)
            continue

         roots_iter = store.iter_roots_for_base(base_zone, max_root_level, up_to=up_to)

         batch_num = 0
         batch_zones: List = []
         for zone in roots_iter:
            root_level = dggrs.getZoneLevel(zone)
            if data_level - root_level < 0:
               print(f"[IMPORT] skipping root {dggrs.getZoneTextID(zone)} because data_level < root_level",
                  flush=True)
               continue
            batch_zones.append(zone)
            if len(batch_zones) >= batch_size:
               batch_num += 1
               print(f"[LEVEL {root_level}] #{pkg_index} BATCH {batch_num}: handling {len(batch_zones)} roots",
                  flush=True)
               written = _process_batch(
                  store, ds, raster_crs, dggrs, dggrs_uri, base_zone, batch_zones,
                  base_ancestors, data_level, depth, fields, use_overviews_for_sampling,
                  aggregate and root_level < deepest_root_level, bands_used,
                  max_workers = max_workers
               )
               total_written += written
               batch_zones = []

         if batch_zones:
            batch_num += 1
            print(f"[LEVEL {root_level}] #{pkg_index} BATCH {batch_num}: handling {len(batch_zones)} roots",
               flush=True)
            written = _process_batch(
               store, ds, raster_crs, dggrs, dggrs_uri, base_zone, batch_zones,
               base_ancestors, data_level, depth, fields, use_overviews_for_sampling,
               aggregate and root_level < deepest_root_level, bands_used
            )
            total_written += written

         print(f"[LEVEL {root_level}] #{pkg_index} complete; total_written so far={total_written}", flush=True)

      if aggregate and not finest_level_done:
         finest_level_done = True
         store._compute_fields()

   ds.close()
   print(f"[IMPORT] complete; total written={total_written}", flush=True)
   return 0



================================================
FILE: high-vibes/dggsImport/rasterSampling.py
================================================
from dggal import *
from typing import List, Dict, Any, Optional, Tuple
import itertools
import rasterio
from rasterio.warp import transform
from rasterio.sample import sample_gen
from rasterio.transform import Affine, rowcol
from rasterio.windows import Window
from cffi import FFI
from pyproj import Transformer

import numpy as np

from dggsStore.store import make_dggs_json_depth

# ---------------------------------------------------------------------------
# Low-level sampling / coordinate helpers
# ---------------------------------------------------------------------------

def _coords_for_centroids(centroids, raster_crs: str) -> List[Tuple[float, float]]:
   ffi = FFI()
   n = centroids.count
   ptr = ffi.cast("double *", centroids.array)
   buf = ffi.buffer(ptr, n * 2 * ffi.sizeof("double"))
   arr = np.frombuffer(buf, dtype=np.float64).reshape((n, 2))   # columns: [lat_rad, lon_rad]

   lat_rad = arr[:, 0]
   lon_rad = arr[:, 1]

   # If raster CRS is geographic degrees, we must supply degrees to rasterio.
   if raster_crs == "EPSG:4326":
      # convert radians -> degrees (fast vectorized)
      lon_deg = np.degrees(lon_rad)
      lat_deg = np.degrees(lat_rad)
      coords = np.column_stack((lon_deg, lat_deg))
   else:
      # Otherwise transform directly from radians -> target CRS units without explicit deg conversion
      transformer = Transformer.from_crs("EPSG:4326", raster_crs, always_xy=True)
      # transformer.transform accepts arrays and the radians flag
      xs, ys = transformer.transform(lon_rad, lat_rad, radians=True)
      coords = np.column_stack((xs, ys))
   return [ (float(x), float(y)) for x, y in coords ]

def _sample_values_for_centroids(ds, coords: List[tuple], overview_factor: Optional[int], bands: List[int]) -> List[List[Optional[float]]]:
   # Vectorized sampling: one read covering all coords, then NumPy advanced indexing.
   # Returns per_field_values[band_index][centroid_index] with None for nodata/missing.
   if not coords:
      return []

   n = len(coords)
   bcount = len(bands)

   # preallocate numpy result with NaN sentinel
   result_np = np.full((bcount, n), np.nan, dtype=np.float64)

   # nodata values per band (1-based band numbers)
   nodata_vals = ds.nodatavals
   if not nodata_vals:
      nodata_vals = tuple([ds.nodata] * ds.count)
   nodata_for_bands = np.array([nodata_vals[b - 1] if (b - 1) < len(nodata_vals) else None for b in bands], dtype=object)
   nodata_is_nan = np.array([(nod is not None and nod != nod) for nod in nodata_for_bands], dtype=bool)

   # split coords into arrays
   xs = np.array([c[0] for c in coords], dtype=float)
   ys = np.array([c[1] for c in coords], dtype=float)

   # compute pixel row/col indices at dataset resolution (vectorized)
   rows_all, cols_all = rowcol(ds.transform, xs, ys, op=int)

   # determine bounding window in pixel coordinates (clamped to dataset)
   min_row = int(max(0, rows_all.min()))
   max_row = int(min(ds.height - 1, rows_all.max()))
   min_col = int(max(0, cols_all.min()))
   max_col = int(min(ds.width - 1, cols_all.max()))

   # if all points outside dataset bounds, return lists of None
   if min_row > max_row or min_col > max_col:
      return [[None] * n for _ in range(bcount)]

   win_row_off = min_row
   win_col_off = min_col
   win_height = max_row - min_row + 1
   win_width = max_col - min_col + 1

   # overview/downsampled read if requested
   if overview_factor and overview_factor > 1:
      factor = overview_factor
      out_h = max(1, int(win_height / factor))
      out_w = max(1, int(win_width / factor))
      arr = ds.read(bands, window=Window(win_col_off, win_row_off, win_width, win_height), out_shape=(bcount, out_h, out_w))
      # relative positions inside window
      rel_rows = rows_all - win_row_off
      rel_cols = cols_all - win_col_off
      # map to overview indices (vectorized)
      row_o = np.floor_divide(rel_rows * out_h, max(1, win_height)).astype(int)
      col_o = np.floor_divide(rel_cols * out_w, max(1, win_width)).astype(int)
      valid_mask = (row_o >= 0) & (row_o < out_h) & (col_o >= 0) & (col_o < out_w)
      if valid_mask.any():
         valid_indices = np.nonzero(valid_mask)[0]
         vals = arr[:, row_o[valid_mask], col_o[valid_mask]]   # shape (bcount, n_valid)
         result_np[:, valid_indices] = vals
   else:
      # full-resolution read of the single window
      arr = ds.read(bands, window=Window(win_col_off, win_row_off, win_width, win_height))
      rel_rows = rows_all - win_row_off
      rel_cols = cols_all - win_col_off
      valid_mask = (rel_rows >= 0) & (rel_rows < win_height) & (rel_cols >= 0) & (rel_cols < win_width)
      if valid_mask.any():
         valid_indices = np.nonzero(valid_mask)[0]
         vals = arr[:, rel_rows[valid_mask], rel_cols[valid_mask]]   # shape (bcount, n_valid)
         result_np[:, valid_indices] = vals

   # vectorized nodata handling per band
   for bi in range(bcount):
      nod = nodata_for_bands[bi]
      if nod is None:
         # ensure non-finite values are NaN
         mask = ~np.isfinite(result_np[bi])
         result_np[bi, mask] = np.nan
      else:
         if nodata_is_nan[bi]:
            mask = np.isnan(result_np[bi])
            result_np[bi, mask] = np.nan
         else:
            finite_mask = np.isfinite(result_np[bi])
            eq_mask = finite_mask & (result_np[bi] == float(nod))
            result_np[bi, eq_mask] = np.nan

   # convert to per-field Python lists with None for NaN
   per_field_values: List[List[Optional[float]]] = []
   for bi in range(bcount):
      row = result_np[bi]
      per_field_values.append([None if not np.isfinite(x) else float(x) for x in row])

   return per_field_values

# ---------------------------------------------------------------------------
# Overview selection helpers (meters-per-subzone based)
# ---------------------------------------------------------------------------

def _meters_per_degree_at_lat(lat_deg: float) -> float:
   # approximate meters per degree of longitude at given latitude
   lat_rad = math.radians(lat_deg)
   return 111320.0 * math.cos(lat_rad)

def _choose_overview_factor_for_level(ds, dggrs, zone, root_level: int, relative_depth: int) -> int:
   target = dggrs.getMetersPerSubZoneFromLevel(root_level, relative_depth)
   px_x = abs(ds.transform.a); px_y = abs(ds.transform.e)
   is_geo = (ds.crs is None) or (ds.crs.to_string() == "EPSG:4326")
   max_allowed = target * (1.0 + 0.01) # 1% tolerance

   if is_geo:
      base_x = None
      base_y = px_y * 111132.92  # m/degrees
   else:
      base_x = px_x
      base_y = px_y

   best = 1
   best_eff = 0.0

   factors = itertools.chain([1], ds.overviews(1) if ds.count >= 1 else [])
   for f in factors:
      eff_x = (base_x * f) if (base_x is not None) else 0.0
      eff_y = base_y * f

      candidate_eff = eff_x if eff_x >= eff_y else eff_y
      if candidate_eff <= max_allowed and candidate_eff > best_eff:
         best, best_eff = f, candidate_eff

   # progress print for overview selection
   print(f"[OVERVIEW] zone={dggrs.getZoneTextID(zone)} root_level={root_level} depth={relative_depth} "
         f"target_m_per_subzone={target:.3f} overview_px_m={best_eff:.6f} chosen_factor={best}",
         flush=True)

   return 1 if best_eff == 0.0 else best

# ---------------------------------------------------------------------------
# Sampling and aggregation builders (produce Dict[int, Dict])
# ---------------------------------------------------------------------------

def sample_depth_obj_for_zone(store, ds, raster_crs: str, dggrs, zone, data_level: int,
   depth: int, use_overviews: bool, fields: List[str], bands: List[int] | None = None) -> Optional[Dict[str, List[Dict[str, Any]]]]:
   # Sample centroids for `zone` at `depth` and return fields_map:
   #  { field_name: [ depth_entry ] }
   # Assumes caller's `fields` corresponds to requested `bands`.
   root_level = dggrs.getZoneLevel(zone)
   if data_level - root_level < 0:
      return None

   centroids = dggrs.getSubZoneWGS84Centroids(zone, depth) or []
   count_centroids = len(centroids)

   coords = _coords_for_centroids(centroids, raster_crs)
   Instance.delete(centroids)
   if not coords:
      print(f"[SAMPLE] zone={dggrs.getZoneTextID(zone)} depth={depth} no coords after transform, skipping", flush=True)
      return None

   overview_factor: Optional[int] = None
   if use_overviews:
      factor = _choose_overview_factor_for_level(ds, dggrs, zone, root_level, depth)
      if factor and factor > 1:
         overview_factor = factor

   print(f"[SAMPLE] zone={dggrs.getZoneTextID(zone)} root_level={root_level} depth={depth} "
         f"centroids={count_centroids} overview_factor={overview_factor}", flush=True)

   bands_to_sample = bands if bands is not None else list(range(1, ds.count + 1))
   bcount = len(bands_to_sample)

   # get per-field arrays: per_field_values[band_index][centroid_index]
   per_field_values = _sample_values_for_centroids(ds, coords, overview_factor, bands_to_sample)

   if not per_field_values or len(per_field_values) != bcount or any(len(pv) != count_centroids for pv in per_field_values):
      print(f"[SAMPLE] zone={dggrs.getZoneTextID(zone)} depth={depth} shape_mismatch sampled_bands={len(per_field_values) if per_field_values else 0} expected_bands={bcount} or centroid_count_mismatch, skipping", flush=True)
      return None

   print(f"[SAMPLE] zone={dggrs.getZoneTextID(zone)} depth={depth} sampled_ok", flush=True)

   # Build fields_map directly; fields is expected to align with sampled bands
   fields_map: Dict[str, List[Dict[str, Any]]] = {}
   for i, fname in enumerate(fields):
      per_field_vals = per_field_values[i]   # safe: validated above
      per_field_depth_entry = make_dggs_json_depth(depth, count_centroids, per_field_vals)
      fields_map[fname] = [per_field_depth_entry]

   return fields_map



================================================
FILE: high-vibes/dggsImport/vectorImport.py
================================================
# dggsImport/vectorImport.py
# Import a GeoJSON vector into a DGGS Data Store by:
# - preparing input once (reproj + topology fix)
# - writing collection-level attributes into attributes.sqlite via DGGSDataStore.write_collection_attributes
# - writing a WKBC file for workers via fg.wkbc.write_wkb_collection_file
# - spawning worker processes that read WKBC, clip per-root-zone, call write_dggs_json_fg,
#   convert to UBJSON+gzip and return blobs
# - orchestrator batches returned blobs and calls store.write_zone_batch(..., precompressed=True)

from dggal import *

import io
import os
import json
import gzip
from concurrent.futures import ProcessPoolExecutor, as_completed
from typing import Any, Dict, List, Optional
import ubjson

from dggsStore.store import DGGSDataStore
from fg.reproj import geojson_load, instantiate_projection_for_dggrs_name, reproject_featurecollection
from fg.fix_topology_5x6 import fix_feature_collection_5x6_topology
from fg.clippingShapely import clip_featurecollection_to_zone
from fg.dggsJSONFG import write_dggs_json_fg
from fg.wkbc import write_wkb_collection_file, read_wkb_collection_file

# prepare input pipeline (reproj + fix) executed once in parent
def _prepare_input_pipeline(input_path: str, dggrs_name: str, skip_reproj: bool, skip_fix: bool):
   src = geojson_load(input_path)
   if not skip_reproj:
      proj = instantiate_projection_for_dggrs_name(dggrs_name)
      print("Reprojecting to native CRS of", dggrs_name, "...")
      src = reproject_featurecollection(src, proj)
   if not skip_fix:
      print("Fixing reprojected features topology...")
      src = fix_feature_collection_5x6_topology(src)
   return src

# worker: build a single FG blob for a root zone (picklable top-level)
def _vector_package_worker(wkbc_path: str,
   zone_id: int,
   worker_config: dict,
   dggrs_name: str,
   depth: int) -> Optional[bytes]:
   data_root = worker_config["_data_root"]
   collection = worker_config["collection"]
   collection_config = worker_config["collection_config"]

   store = DGGSDataStore(data_root, collection, config=collection_config)
   dggrs = store.dggrs
   root_zone = DGGRSZone(zone_id)

   # read WKBC (geometry-only feature collection)
   src_fc = read_wkb_collection_file(wkbc_path)

   # clip features to zone (out_fc will have features with ids and no properties)
   out_fc, feature_entry_exit_indices = clip_featurecollection_to_zone(src_fc, dggrs, root_zone, refined=False)

   # free the large WKBC source from memory
   del src_fc

   features = out_fc.get("features", []) or []
   if not features:
      return None

   # produce DGGS-JSON-FG object (properties remain empty in out_fc)
   dggs_obj = write_dggs_json_fg(out_fc, feature_entry_exit_indices, dggrs, root_zone, depth)

   # convert to UBJSON then gzip
   ubbuf = io.BytesIO()
   ubjson.dump(dggs_obj, ubbuf)
   gz = gzip.compress(ubbuf.getvalue(), compresslevel=9)

   return gz

# build blobs in parallel for a batch of zones
def _build_vector_blobs_processes(
   store_worker_config: dict,
   wkbc_path: str,
   dggrs,
   zones: List,
   depth: int,
   max_workers: int = 16
) -> Dict[int, bytes]:
   if not zones:
      return {}
   workers = min(max_workers, max(1, len(zones)))
   blobs: Dict[int, bytes] = {}
   with ProcessPoolExecutor(max_workers=workers) as ex:
      futures = {}
      for z in zones:
         fut = ex.submit(_vector_package_worker, wkbc_path, int(z), store_worker_config, dggrs.__class__.__name__, depth)
         futures[fut] = z
      for fut in as_completed(futures):
         zone = futures[fut]
         res = fut.result()
         if not res:
            print(f"[BUILD] zone={dggrs.getZoneTextID(zone)} returned empty, skipping", flush=True)
            continue
         # store the raw gzip'ed blob bytes directly
         blobs[int(zone)] = res
         print(f"[BUILD] zone={dggrs.getZoneTextID(zone)} blob_ready", flush=True)
   return blobs

# coordinator: process a batch of root zones and write to store (precompressed)
def _process_batch_vector(store, wkbc_path: str, dggrs, base_zone, batch_zones: List, base_ancestors: List,
   depth: int, max_workers: int = 16) -> int:
   if not batch_zones:
      print("[BATCH] empty batch, skipping", flush=True)
      return 0

   print(f"[BATCH] processing batch base_zone={dggrs.getZoneTextID(base_zone)} roots={len(batch_zones)}", flush=True)

   worker_config = {
      "_data_root": store.data_root,
      "collection": store.collection,
      "collection_config": store.config
   }

   entries_map = _build_vector_blobs_processes(
      store_worker_config=worker_config,
      wkbc_path=wkbc_path,
      dggrs=dggrs,
      zones=batch_zones,
      depth=depth,
      max_workers=max_workers
   )

   if not entries_map:
      print("[BATCH] no entries produced for this batch, skipping write", flush=True)
      return 0

   # Build entries according to the store contract:
   # entries is a mapping DGGRSZone -> gzip'ed DGGS-UBJSON-FG blob (bytes)
   entries: Dict[int, bytes] = {}   # int are DGGRSZone
   for zid, blob in entries_map.items():
      zone = DGGRSZone(int(zid))
      entries[int(zone)] = blob

   print(f"[BATCH] writing {len(entries)} entries to store for base_zone={dggrs.getZoneTextID(base_zone)}", flush=True)
   store.write_zone_batch(
      base_zone=base_zone,
      entries=entries,
      base_ancestor_list=base_ancestors,
      precompressed=True
   )
   print(f"[BATCH] write complete for base_zone={dggrs.getZoneTextID(base_zone)} wrote={len(entries)}", flush=True)
   return len(entries)

# top-level import_vector (keeps CLI signature unchanged elsewhere)
def import_vector(input_geojson_path: str,
                  collection_id: str,
                  dggrs_name: str,
                  data_root: str = "data",
                  level: int | None = None,
                  depth: int | None = None,
                  batch_size: int = 32,
                  groupSize: int = 5,
                  max_workers: int = 16,
                  skip_reproj: bool = False,
                  skip_fix: bool = False) -> int:

   dggrs_init = globals().get(dggrs_name)
   if dggrs_init is None:
      print("Unsupported DGGRS:", dggrs_name, flush=True)
      return 1
   dggrs = dggrs_init()

   if depth is None:
      depth = dggrs.get64KDepth()
      print(f"[IMPORT] using default depth (get64KDepth) = {depth}", flush=True)

   if level is None:
      print("import_vector requires --level to be specified (absolute quantize level)", flush=True)
      return 1

   data_level = level
   deepest_root_level = max(0, data_level - depth)

   coll_info = {
      "dggrs": dggrs_name, "maxRefinementLevel": data_level, "depth": depth,
      "groupSize": groupSize, "title": collection_id, "description": collection_id, "version": "1.0"
   }
   dggrs_uri = f"[ogc-dggrs:{dggrs_name}]"

   base = os.path.join(data_root, collection_id)
   os.makedirs(base, exist_ok=True)
   with open(os.path.join(base, "collection.json"), "w", encoding="utf-8") as fh:
      json.dump(coll_info, fh, indent=2)
   print(f"[IMPORT] Wrote collection config to {os.path.join(base, 'collection.json')}", flush=True)

   store = DGGSDataStore(data_root, collection_id, config=coll_info)
   dggrs = store.dggrs
   max_base_level = store._base_level_for_root(deepest_root_level)
   print(
      f"[IMPORT] Computed levels: data_level={data_level} depth={depth} finest_root_level={deepest_root_level} "
      f"max_base_level={max_base_level} batch_size={batch_size}", flush=True
   )
   print(f"[DIAG] using groupSize={groupSize} (recommended default is 5)", flush=True)

   # prepare input once (reproj + fix)
   src = _prepare_input_pipeline(input_geojson_path, dggrs_name, skip_reproj=skip_reproj, skip_fix=skip_fix)

   # write collection-level attributes (features list) into store.attributes.sqlite
   features = src.get("features", []) or []
   if features:
      store.write_collection_attributes(features)
      print(f"[IMPORT] wrote collection attributes for {len(features)} features", flush=True)

   # write WKBC file for workers (WKBC contains geometries and feature ids; properties are not included)
   tmp_wkbc_path = os.path.join(store.collection_dir, "tmp_input.wkbc")
   write_wkb_collection_file(src, tmp_wkbc_path)
   print(f"[IMPORT] wrote WKBC to {tmp_wkbc_path}", flush=True)

   pkg_index = 0
   total_written = 0

   for root_level in range(deepest_root_level, -1, -1):
      base_level = store._base_level_for_root(root_level)
      up_to = False
      for base_zone, base_ancestors in store.iter_bases(base_level, up_to=up_to):
         pkg_index += 1
         base_text = dggrs.getZoneTextID(base_zone)
         print(f"[LEVEL {root_level}] #{pkg_index}: base_zone={base_text}", flush=True)

         base_level = dggrs.getZoneLevel(base_zone)
         package_group_levels = store.group0Size if base_level == 0 else store.groupSize
         package_max = base_level + package_group_levels - 1
         max_root_level = root_level
         if base_level > max_root_level:
            print(f"[SKIP] package base {base_text} (base_level={base_level}) deeper than target {max_root_level}", flush=True)
            continue

         roots_iter = store.iter_roots_for_base(base_zone, max_root_level, up_to=up_to)

         batch_num = 0
         batch_zones: List = []
         for zone in roots_iter:
            root_level = dggrs.getZoneLevel(zone)
            if data_level - root_level < 0:
               print(f"[IMPORT] skipping root {dggrs.getZoneTextID(zone)} because data_level < root_level", flush=True)
               continue
            batch_zones.append(zone)
            if len(batch_zones) >= batch_size:
               batch_num += 1
               print(f"[LEVEL {root_level}] #{pkg_index} BATCH {batch_num}: handling {len(batch_zones)} roots", flush=True)
               written = _process_batch_vector(
                  store, tmp_wkbc_path, dggrs, base_zone, batch_zones, base_ancestors,
                  depth, max_workers=max_workers
               )
               total_written += written
               batch_zones = []

         if batch_zones:
            batch_num += 1
            print(f"[LEVEL {root_level}] #{pkg_index} BATCH {batch_num}: handling {len(batch_zones)} roots", flush=True)
            written = _process_batch_vector(
               store, tmp_wkbc_path, dggrs, base_zone, batch_zones, base_ancestors,
               depth, max_workers=max_workers
            )
            total_written += written
            batch_zones = []

         print(f"[LEVEL {root_level}] #{pkg_index} complete; total_written so far={total_written}", flush=True)

   # cleanup temporary WKBC
   if os.path.exists(tmp_wkbc_path):
      os.remove(tmp_wkbc_path)

   print(f"[IMPORT] complete; total written={total_written}", flush=True)
   return 0



================================================
FILE: high-vibes/dggsStore/aggregation.py
================================================
#!/usr/bin/env python3
from dggal import *

from typing import Dict, List, Optional, Mapping, Sequence, TypedDict, Union, Any
import logging

ffi = dggal.ffi

from .store import *

logger = logging.getLogger("dggs-serve.aggregation")

def collect_ancestors_at_level(dggrs, start_zone, target_level):
   nested: bool = dggrs.getMaxNeighbors() != 6
   out = []
   stack = [start_zone]
   seen = set()
   while stack:
      n = stack.pop()
      nid = int(n)
      if nid in seen:
         continue
      seen.add(nid)
      lvl = int(dggrs.getZoneLevel(n))
      if lvl == target_level:
         out.append(n)
         continue
      if lvl <= target_level:
         continue
      parents = dggrs.getZoneParents(n)
      for p in parents:
         if nested == False and not dggrs.zoneHasSubZone(p, start_zone):
            continue # Skip ancestors not overlapping the sub-zone
         stack.append(p)
      if parents is not None:
         Instance.delete(parents)
   return out

def assemble_aggregate_from_level0(store, root_zone, zone_depth, fields: List[str] | None = None) -> Optional[Dict[str, List[Dict[str, Any]]]]:
   # Returns a ValuesObject: field -> [ValueEntry]
   # collect level-0 ancestors (roots at level 0 that cover this root_zone)
   # paint their values (at store's depth) onto the target root zone at target depth
   # (assumed to be of a refinement level coarser than the level0 source store depth values)
   ancestors = collect_ancestors_at_level(store.dggrs, root_zone, 0)
   return _aggregate_stored_roots(store, root_zone, zone_depth, ancestors, store.depth, fields)

def aggregate_from_children(store, root_zone, zone_depth, fields: List[str]):
   # Returns a ValuesObject: field -> [ValueEntry]
   # collect immediate children of target root zone
   # paint their values (at store's depth) onto the target root zone
   # (this is currently only used with zone_depth == store.depth)
   children = store.dggrs.getZoneChildren(root_zone)
   values = _aggregate_stored_roots(store, root_zone, zone_depth, children, store.depth, fields)
   if not isinstance(children, list):
      Instance.delete(children)
   return values

def _aggregate_stored_roots(store: DGGSDataStore,
   target_root_zone: DGGRSZone, target_depth: int,
   root_zones, source_depth, fields: List[str], average: bool = True ):

   dggrs = store.dggrs

   subs_count = dggrs.countSubZones(target_root_zone, target_depth)

   # per-field accumulators
   sums_map = { fname: [0.0] * subs_count for fname in fields }
   counts_map = { fname: [0] * subs_count for fname in fields }

   subs = dggrs.getSubZones(target_root_zone, target_depth)
   subs_ptr = ffi.cast("uint64_t *", subs.array)
   sub_index = { int(subs_ptr[i]): i for i in range(subs_count) }

   gzc = dggal.lib.DGGRS_getZoneChildren
   dggrs_impl = dggrs.impl

   if fields is None:
      fields = store.fields

   fields_src_data = [None] * len(fields)

   cBuf = None
   for root_zone in root_zones:
      pkg = store.compute_package_path_for_root_zone(root_zone)
      decoded = None if not pkg else store.read_and_decode_zone_blob(pkg, root_zone)
      if not decoded:
         #print("WARNING: Could not decode blob for zone ", dggrs.getZoneTextID(root_zone))
         continue
      source_subs = dggrs.getSubZones(root_zone, source_depth)
      source_ptr = ffi.cast("uint64_t *", source_subs.array)
      src_index = { int(source_ptr[i]): i for i in range(len(source_subs)) }
      Instance.delete(source_subs)

      rel_depth = dggrs.getZoneLevel(source_ptr[0]) - dggrs.getZoneLevel(subs_ptr[0])

      fieldIX = 0
      for fname in fields:
         fData = None
         entries = decoded["values"].get(fname)
         if entries:
            chosen = next((e for e in entries if int(e["depth"]) == source_depth), None)
            if chosen:
               fData = chosen["data"]
         fields_src_data[fieldIX] = fData
         fieldIX = fieldIX + 1

      if rel_depth == 1 and not cBuf:
         cBuf = ffi.new("uint64_t[13]")
      for si in range(len(subs)):
         t = subs_ptr[si]
         t_idx = sub_index.get(int(t))
         if t_idx is None:
            continue

         if rel_depth == 1:
            n_z = gzc(dggrs_impl, t, cBuf)
            weights = dggrs.getChildrenWeights(t)
            zptr = cBuf
         else:
            src_zones = dggrs.getSubZones(t, rel_depth)
            weights = dggrs.getSubZoneWeights(t, rel_depth)
            n_z = len(src_zones)
            zptr = ffi.cast("uint64_t *", src_zones.array)

         fieldIX = 0
         for fname in fields:
            src_data = fields_src_data[fieldIX]
            fieldIX = fieldIX + 1
            if src_data is None:
               continue

            sums = sums_map[fname]
            counts = counts_map[fname]

            sum = sums[t_idx]
            count = counts[t_idx]

            if weights is None:
               for i in range(n_z):
                  idx = src_index.get(zptr[i])
                  if idx is None:
                     continue
                  val = src_data[idx]
                  if val is None:
                     continue
                  sum += val
                  count += 1.0
            else:
               for i in range(n_z):
                  idx = src_index.get(zptr[i])

                  if idx is None:
                     continue

                  val = src_data[idx]

                  if val is None:
                     continue
                  weight = weights[i]
                  sum += val * weight
                  count += weight

            sums[t_idx] = sum
            counts[t_idx] = count

         if rel_depth != 1:
            Instance.delete(src_zones)

   Instance.delete(subs)

   # compute averages (None when no contributors) per field
   # wrap into ValuesObject: each field maps to a list of ValueEntry dicts
   values_obj: Dict[str, List[Dict[str, Any]]] = {}
   for fname in fields:
      sums = sums_map[fname]
      counts = counts_map[fname]
      if average == True:
         out = [ (sums[i] / counts[i]) if counts[i] > 0 else None for i in range(subs_count) ]
      else:
         out = [ sums[i] if counts[i] > 0 else None for i in range(subs_count) ]
      # REVIEW: Do we want to return None if fully empty or not? Parameter option?
      values_obj[fname] = [ make_dggs_json_depth(target_depth, subs_count, out) ]

   return values_obj



================================================
FILE: high-vibes/dggsStore/customDepths.py
================================================
#!/usr/bin/env python3
from dggal import *

from typing import Dict, List, Optional, Mapping, Sequence, TypedDict, Union
import logging

from .store import *
from .aggregation import *

logger = logging.getLogger("dggs-serve.customDepths")

# --- utilities ---
def parse_zone_depths(param: str) -> "List[int]":
   if not param:
      return []
   parts = [p.strip() for p in param.split(",") if p.strip()]
   depths: List[int] = []
   for p in parts:
      if "-" in p:
         a, b = p.split("-", 1)
         a_i, b_i = int(a), int(b)
         depths.extend(range(a_i, b_i + 1))
      else:
         depths.append(int(p))
   # ensure unique ascending depths (canonical DGGS-JSON ordering)
   return sorted(set(depths))

# --- helpers ---

def _paint_from_stored_root_multi(store, target_root_zone : DGGRSZone, target_depth: int,
   stored_roots, stored_depth, fields) -> Dict[str, List[Optional[float]]]:

   # For each requested field, find the depth entry at store_depth and paint
   dggrs = store.dggrs

   fields_src_data = [None] * len(fields)
   target_maps = [None] * len(fields)

   subs = dggrs.getSubZones(target_root_zone, target_depth)
   subs_ptr = ffi.cast("uint64_t *", subs.array)
   subs_len = subs.count
   sub_index = { int(subs_ptr[i]): i for i in range(subs_len) }

   fieldIX = 0
   target_map = { }
   for fname in fields:
      tgt = [None] * subs_len
      target_map[fname] = tgt
      tgt = target_map[fname]
      target_maps[fieldIX] = tgt
      fieldIX = fieldIX + 1

   dggrs = store.dggrs
   dggrs_impl = dggrs.impl
   getSZ = dggal.lib.DGGRS_getSubZones
   array_offset = dggal.lib.class_Array.offset

   any_data = False

   for stored_root in stored_roots:
      # Decode the stored_root package once and update target_map for all fields.
      # - target_map: Dict[field, List[Optional[float]]] (preallocated length = n)
      # - fields: list of requested field names
      pkg = store.compute_package_path_for_root_zone(stored_root)
      decoded = store.read_and_decode_zone_blob(pkg, stored_root) if pkg else None
      if not decoded:
         continue

      source_subs = dggrs.getSubZones(stored_root, stored_depth)
      source_ptr = ffi.cast("uint64_t *", source_subs.array)
      src_index = { int(source_ptr[i]): i for i in range(len(source_subs)) }
      # relative depth between source_subs and target subs
      rel_depth = dggrs.getZoneLevel(source_ptr[0]) - dggrs.getZoneLevel(subs_ptr[0])
      Instance.delete(source_subs)

      fieldIX = 0
      for fname in fields:
         fData = None
         entries = decoded["values"].get(fname)
         if entries:
            chosen = next((e for e in entries if int(e["depth"]) == stored_depth), None)
            if chosen:
               fData = chosen["data"]
         fields_src_data[fieldIX] = fData
         fieldIX = fieldIX + 1

      # paint: first non-None contributor wins
      for tIX in range(subs_len):
         t = subs_ptr[tIX]
         t_idx = sub_index.get(int(t))
         if t_idx is None:
            continue

         #src_zones = dggrs.getSubZones(t, rel_depth)
         #src_zones_ptr = ffi.cast("uint64_t *", src_zones.array)
         #src_zones_len = len(src_zones)

         # Skip Python bindings for better performance
         src_zones = getSZ(dggrs_impl, t, rel_depth)
         a = ffi.cast("struct class_members_Array *", ffi.cast("char *", src_zones) + array_offset)
         src_zones_ptr = ffi.cast("uint64_t *", a.array)
         src_zones_len = a.count

         fieldIX = 0
         for fname in fields:
            tgt = target_maps[fieldIX]
            src_data = fields_src_data[fieldIX]
            fieldIX = fieldIX + 1
            if src_data is None:
               continue
            if tgt[t_idx] is not None:
               continue

            for sIX in range(src_zones_len):
               idx = src_index.get(src_zones_ptr[sIX])
               if idx is None:
                  continue
               val = src_data[idx]
               if val is not None:
                  tgt[t_idx] = val
                  any_data = True
                  break
         # Instance.delete(src_zones)
         lib.Instance_delete(src_zones)
   Instance.delete(subs)

   if any_data:
      values_obj = { }
      for fname, arr in target_map.items():
         values_obj[fname] = [ make_dggs_json_depth(target_depth, subs_len, arr) ]
   else:
      values_obj = None

   return values_obj

# ValueEntry and ValuesObject assumed:
# ValueEntry = {"depth": int, "shape": {"count": int, "subZones": int, ...}, "data": Sequence[Optional[float]]}
# ValuesObject = Dict[str, List[ValueEntry]]

def _assemble_from_descendants(store, root_zone, zone_depth, source_root_level, fields: List[str] | None = None):
   dggrs = store.dggrs
   if fields is None:
      fields = store.fields

   root_level = dggrs.getZoneLevel(root_zone)
   rel_depth = source_root_level - root_level
   descendants = dggrs.getSubZones(root_zone, rel_depth)

   values_obj = _paint_from_stored_root_multi(store, root_zone, zone_depth, descendants, store.depth, fields)

   Instance.delete(descendants)

   return values_obj

def _assemble_from_ancestors(store, root_zone, zone_depth, source_root_level, fields: List[str] | None = None) -> Optional[Dict[str, List[Dict[str, Any]]]]:
   dggrs = store.dggrs
   if fields is None:
      fields = store.fields
   ancestors = collect_ancestors_at_level(dggrs, root_zone, source_root_level)
   if not ancestors:
      return None
   return _paint_from_stored_root_multi(store, root_zone, zone_depth, ancestors, store.depth, fields)

def assemble_zone_at_depth(store, root_zone, zone_depth, fields: List[str] | None = None) -> Optional[Dict[str, List[Dict[str, Any]]]]:
   dggrs = store.dggrs
   if fields is None:
      fields = store.fields

   root_level = dggrs.getZoneLevel(root_zone)
   if root_level + zone_depth > store.maxRefinementLevel:
      return None

   source_root_level = root_level + zone_depth - store.depth

   if source_root_level == root_level:
      return None
   elif source_root_level < 0:
      return assemble_aggregate_from_level0(store, root_zone, zone_depth, fields)
   elif source_root_level > root_level:
      return _assemble_from_descendants(store, root_zone, zone_depth, source_root_level, fields)
   else:
      return _assemble_from_ancestors(store, root_zone, zone_depth, source_root_level, fields)

def aggregate_zone_at_depth(store, root_zone, zone_depth, fields: List[str] | None = None) -> Optional[Dict[str, List[Dict[str, Any]]]]:
   if fields is None:
      fields = store.fields

   t = store.dggrs.getZoneTextID(root_zone)
   # print("Aggregating for zone", t, "at depth", zone_depth)
   r = aggregate_from_children(store, root_zone, zone_depth, fields)
   # print("... done aggregating for zone", t, "at depth", zone_depth)
   return r



================================================
FILE: high-vibes/dggsStore/store.py
================================================
# dggsStore.py
from dggal import *
import os
import json
import sqlite3
import gzip
import threading
import logging
import array
from typing import Any, Dict, List, Optional, Tuple, Iterable, Iterator, TypedDict, Mapping, Sequence
from types import MethodType
import ubjson
from concurrent.futures import ThreadPoolExecutor, as_completed

DGGS_JSON_SCHEMA_URI = "https://schemas.opengis.net/ogcapi/dggs/1.0/core/schemas/dggs-json/dggs-json.json"

# --- types ---
class ShapeDict(TypedDict, total=False):
   count: int
   subZones: int
   dimensions: Mapping[str, int]

class ValueEntry(TypedDict):
   depth: int
   shape: ShapeDict
   data: Sequence[Optional[float]]

ValuesObject = Mapping[str, "List[ValueEntry]"]
CollectedValues = Mapping[int, ValuesObject]

def decompress_blob(blob: bytes) -> bytes:
   if blob is None:
      return None
   raw = gzip.decompress(blob) if blob[:2] == b"\x1f\x8b" else blob
   return raw

def decode_blob(blob: bytes) -> Optional[Any]:
   if blob is None:
      return None
   raw = gzip.decompress(blob) if blob[:2] == b"\x1f\x8b" else blob
   return ubjson.loadb(raw)

def to_blob(obj: Any, compress: bool = True) -> bytes:
   ub = ubjson.dumpb(obj)
   return gzip.compress(ub) if compress else ub


logger = logging.getLogger("dggsStore")

store_cache: Dict[str, "DGGSDataStore"] = {}
store_lock = threading.Lock()
dggrs_cache: Dict[str, DGGRS] = {}
dggrs_lock = threading.Lock()

# We'll extend the DGGRS class with getZonePrimaryChildren() and getZonePrimaryParent() which are not yet part of DGGAL
def getZonePrimaryChildren7H(self, zone):
   children = self.getZoneChildren(zone)
   if children is not None:
      children.count = 7 # The first 7 children are the primary children for 7H
   return children

def getZonePrimaryChildren3H(self, zone):
   # The 3H children are associated with the parent who is itself a centroid child (snowflake fractal)
   return self.getZoneChildren(zone) if self.isZoneCentroidChild(zone) else [ self.getZoneCentroidChild(zone) ]

def getZonePrimaryParent3H(self, zone):
   primaryParent = None
   parents = self.getZoneParents(zone)
   nParents = 0 if parents is None else len(parents)
   if nParents == 1:
      primaryParent = parents[0]
   elif nParents > 0:
      # NOTE: as of DGGAL 0.0.6, parents[0] is not always the primary parent for 3H
      for p in parents:
         if self.isZoneCentroidChild(p):
            primaryParent = p
            break;
   if parents is not None:
      Instance.delete(parents)
   return primaryParent

def getZonePrimaryParent0(self, zone):
   parents = self.getZoneParents(zone)
   # NOTE: parents[0] should always be the primary parent for 7H
   primaryParent = parents[0] if parents is not None and len(parents) > 0 else None
   if parents is not None:
      Instance.delete(parents)
   return primaryParent

# These match the getSubZones() order

def getSubZoneWeights7H(self, zone: DGGRSZone, depth: int):
   if depth != 1:
      return None  # Relative depth > 1 not yet implemented

   nEdges = self.countZoneEdges(zone)
   if nEdges == 5: # Pentagon
      return [
         1/12.0,                             # 1
         1/12.0, 11/12.0, 11/12.0, 1/12.0,   # 2-5
         11/12.0, 1.0, 11/12.0,              # 6-8
         1/12.0, 11/12.0, 1/12.0             # 9-11
      ]
   else:           # Hexagon
      return [
         1/12.0,                             # 1
         1/12.0, 11/12.0, 11/12.0, 1/12.0,   # 2-5
         11/12.0, 1.0, 11/12.0,              # 6-8
         1/12.0, 11/12.0, 11/12.0, 1/12.0,   # 9-12
         1/12.0                              # 13
      ]

def getSubZoneWeights3H(self, zone: DGGRSZone, depth: int):
   if depth != 1:
      return None  # Relative depth > 1 not yet implemented

   nEdges = self.countZoneEdges(zone)
   if nEdges == 5: # Pentagon
      return [
         1/3.0, 1/3.0,       # 1-2
         1/3.0, 1.0, 1/3.0,  # 3-5
         1/3.0               # 6
      ]
   else:           # Hexagon
      return [
         1/3.0, 1/3.0,       # 1-2
         1/3.0, 1.0, 1/3.0,  # 3-5
         1/3.0, 1/3.0        # 6-7
      ]

def getSubZoneWeightsNested(self, zone: DGGRSZone, depth: int):
   return None  # Fully nested DGGRSs sub-zones have equal weighting

# These match the getZoneChildren() order

_3H_CH_WEIGHTS = array.array('d', [1.0, 1.0/3.0, 1.0/3.0, 1.0/3.0, 1.0/3.0, 1.0/3.0, 1.0/3.0])
_7H_CH_WEIGHTS = array.array('d', [1.0,
   11/12.0, 11/12.0, 11/12.0, 11/12.0, 11/12.0, 11/12.0,
    1/12.0,   1/12.0, 1/12.0,  1/12.0,  1/12.0,  1/12.0 ])

def getChildrenWeights7H(self, zone: DGGRSZone):
   return _7H_CH_WEIGHTS

#def getChildrenWeights7H(self, zone: DGGRSZone):
#   nEdges = self.countZoneEdges(zone)
#   if nEdges == 5: # Pentagon
#      return [
#         1.0, # Centroid
#         11/12.0, 11/12.0, 11/12.0, 11/12.0, 11/12.0,  # Primary Children
#          1/12.0,  1/12.0,  1/12.0,  1/12.0,  1/12.0   # Secondary Children
#      ]
#   else:           # Hexagon
#      return [
#         1.0, # Centroid
#         11/12.0, 11/12.0, 11/12.0, 11/12.0, 11/12.0, 11/12.0, # Primary Children
#          1/12.0,  1/12.0,  1/12.0,  1/12.0,  1/12.0,  1/12.0  # Secondary Children
#      ]

def getChildrenWeights3H(self, zone: DGGRSZone):
   return _3H_CH_WEIGHTS

#def getChildrenWeights3H(self, zone: DGGRSZone):
#   nEdges = self.countZoneEdges(zone)
#   if nEdges == 5: # Pentagon
#      return [
#         1.0, # Centroid
#         1/3.0, 1/3.0, 1/3.0, 1/3.0, 1/3.0        # Vertex Children
#      ]
#   else:           # Hexagon
#      return [
#         1.0, # Centroid
#         1/3.0, 1/3.0, 1/3.0, 1/3.0, 1/3.0, 1/3.0 # Vertex Children
#      ]

def getChildrenWeightsNested(self, zone: DGGRSZone):
   return None  # Fully nested DGGRSs sub-zones have equal weighting

def get_or_create_dggrs(dggrsID: str) -> DGGRS:
   key = f"dggrs:{dggrsID}"
   with dggrs_lock:
      dggrs = dggrs_cache.get(key)
      if dggrs is not None:
         return dggrs
      cls = globals().get(dggrsID)
      if cls is None:
         print(f"DGGRS class not found: {dggrsID}")
         return None
      dggrs = cls()

      maxNB = dggrs.getMaxNeighbors()
      if maxNB == 6: # This is only true for 3H and 7H as of DGGAL 0.0.6
         # Hexagonal DGGRS
         ratio = dggrs.getRefinementRatio()
         if ratio == 3:
            dggrs.getZonePrimaryChildren = MethodType(getZonePrimaryChildren3H, dggrs)
            dggrs.getZonePrimaryParent = MethodType(getZonePrimaryParent3H, dggrs)
            dggrs.getSubZoneWeights = MethodType(getSubZoneWeights3H, dggrs)
            dggrs.getChildrenWeights = MethodType(getChildrenWeights3H, dggrs)
         else:
            dggrs.getZonePrimaryChildren = MethodType(getZonePrimaryChildren7H, dggrs)
            dggrs.getZonePrimaryParent = MethodType(getZonePrimaryParent0, dggrs)
            dggrs.getSubZoneWeights = MethodType(getSubZoneWeights7H, dggrs)
            dggrs.getChidlrenWeights = MethodType(getChildrenWeights7H, dggrs)
      else:
         # Fully nested DGGRS
         dggrs.getZonePrimaryChildren = dggrs.getZoneChildren
         dggrs.getZonePrimaryParent = MethodType(getZonePrimaryParent0, dggrs)
         dggrs.getSubZoneWeights = MethodType(getSubZoneWeightsNested, dggrs)
         dggrs.getChildrenWeights = MethodType(getChildrenWeightsNested, dggrs)

      dggrs_cache[key] = dggrs
      return dggrs

def ensure_package_table(path: str) -> None:
   os.makedirs(os.path.dirname(path), exist_ok=True)
   conn = sqlite3.connect(path)
   conn.execute("PRAGMA synchronous=OFF")
   cur = conn.cursor()
   cur.execute("""
     CREATE TABLE IF NOT EXISTS zone_data(
       root_zone_id TEXT PRIMARY KEY,
       data BLOB NOT NULL
     )""")
   conn.commit()
   conn.close()

def write_sqlite_two_col(path: str, entries: List[Tuple[str, bytes]]) -> int:
   ensure_package_table(path)
   conn = sqlite3.connect(path)
   conn.execute("PRAGMA synchronous=OFF")
   cur = conn.cursor()
   for zid, blob in entries:
      cur.execute("INSERT OR REPLACE INTO zone_data(root_zone_id, data) VALUES(?,?)", (zid, blob))
   conn.commit()
   conn.close()
   return len(entries)

def read_package_root_ids_from_sqlite(pkg_path: str, limit: Optional[int] = None) -> List[str]:
   if not pkg_path or not os.path.exists(pkg_path):
      return []
   conn = sqlite3.connect(f"file:{os.path.abspath(pkg_path)}?mode=ro&immutable=1", uri=True, check_same_thread=False)
   conn.row_factory = sqlite3.Row
   if limit is None:
      cur = conn.execute("SELECT root_zone_id FROM zone_data")
   else:
      cur = conn.execute("SELECT root_zone_id FROM zone_data LIMIT ?", (limit,))
   rows = cur.fetchall()
   conn.close()
   return [r[0] for r in rows if r[0] is not None]

class DGGSDataStore:
   def __init__(self, data_root: str, collection: str, config: Optional[dict] = None):
      self.data_root = data_root
      self.collection = collection
      self.collection_dir = os.path.join(data_root, collection)

      if config is not None:
         os.makedirs(os.path.dirname(self.collection_dir), exist_ok=True)
         self.config = config
      else:
         if not os.path.isdir(self.collection_dir):
            print(f"Collection directory not found: {self.collection_dir!r}")
            return
         cfg_path = os.path.join(self.collection_dir, "collection.json")
         # logger.info("Loading collection config from %s", cfg_path)
         if not os.path.isfile(cfg_path):
            print(f"collection.json not found at {cfg_path!r}")
            return
         with open(cfg_path, "r", encoding="utf-8") as f:
            self.config = json.load(f)

      dggrsID = self.config.get("dggrs")
      if dggrsID is None:
         print("Missing 'dggrs' in collection config")
         return
      self.dggrs = get_or_create_dggrs(dggrsID)

      if "depth" not in self.config:
         print("Missing 'depth' in collection config")
         return
      self.depth = int(self.config["depth"])

      maxRefinementLevel = self.config.get("maxRefinementLevel")
      if maxRefinementLevel is None:
         print("Missing 'maxRefinementLevel' in collection config")
      self.maxRefinementLevel = int(maxRefinementLevel)

      self._compute_groups()
      self._compute_fields()

   def _compute_fields(self):
      # Prefer collection-level attributes.sqlite (vector collection) first,
      # otherwise inspect a package .sqlite (raster case).
      self.fields: List[str] = None

      attr_path = self._attributes_db_path()
      if os.path.exists(attr_path):
         conn = sqlite3.connect(f"file:{os.path.abspath(attr_path)}?mode=ro&immutable=1", uri=True, check_same_thread=False)
         cur = conn.cursor()
         cur.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='attributes'")
         if cur.fetchone():
            cur.execute("PRAGMA table_info(attributes)")
            cols = [r[1] for r in cur.fetchall()]
            conn.close()
            cols = [c for c in cols if c != "feature_id"]
            if cols:
               self.fields = cols
         else:
            conn.close()
         self.is_vector = True
      else:
         # attributes.sqlite not present -> inspect package .sqlite files
         sample_pkg = None
         for root, _, names in os.walk(self.collection_dir):
            for n in names:
               if n.endswith(".sqlite"):
                  sample_pkg = os.path.join(root, n)
                  break
            if sample_pkg:
               break

         if sample_pkg:
            root_ids = read_package_root_ids_from_sqlite(sample_pkg, limit=1)
            if root_ids:
               sample_root = root_ids[0]
               conn2 = sqlite3.connect(f"file:{os.path.abspath(sample_pkg)}?mode=ro&immutable=1", uri=True, check_same_thread=False)
               conn2.row_factory = sqlite3.Row
               cur2 = conn2.execute("SELECT data FROM zone_data WHERE root_zone_id = ?", (sample_root,))
               r2 = cur2.fetchone()
               conn2.close()
               if r2:
                  blob = r2["data"]
                  if blob:
                     raw = gzip.decompress(blob) if blob[:2] == b"\x1f\x8b" else blob
                     decoded = ubjson.loadb(raw)
                     values_map = decoded.get("values") if isinstance(decoded, dict) else None
                     if isinstance(values_map, dict):
                        self.fields = list(values_map.keys())
         self.is_vector = False
      # print("Computed fields: ", self.fields)

   def _compute_groups(self) -> None:
       self.groupSize = self.config.get("groupSize", 1)
       self.deepest_root = max(0, self.maxRefinementLevel - self.depth)
       count = self.deepest_root + 1
       num_groups = (count + self.groupSize - 1) // self.groupSize
       self.group0Size = count - (num_groups - 1) * self.groupSize

   def _is_base_level(self, level: int) -> bool:
      # Return True if `level` is a group base (level 0 or group0Size + k*groupSize).
      if level == 0:
         return True
      if level < self.group0Size:
         return False
      return (level - self.group0Size) % self.groupSize == 0

   def _base_level_for_root(self, root_level: int) -> int:
      if root_level == 0:
         base_level = 0
      else:
         if root_level < self.group0Size:
            base_level = 0
         else:
            k = (root_level - self.group0Size) // self.groupSize
            base_level = self.group0Size + k * self.groupSize
      # print("Returned base = ", base_level, " for ", root_level)
      return base_level

   def _compute_ancestral_group_base_list(self, zone: DGGRSZone) -> list:
       # Collect group-base ancestors in digging-down order (top -> ... -> deepest).
       # Walks from `zone` up to root, but PREPENDS each discovered base so the final
       # list is ordered as if discovered by digging down.
       # Each entry is a tuple (level, zone).

       dggrs = self.dggrs
       bases: list = []

       current_level = dggrs.getZoneLevel(zone)
       while True:
           if self._is_base_level(current_level):
               # prepend so final order is top -> ... -> deepest
               bases.insert(0, zone)
           zone = dggrs.getZonePrimaryParent(zone)
           if zone is None:
               break
           current_level = dggrs.getZoneLevel(zone)

       return bases

   def compute_package_path_for_root_zone(self, zone: DGGRSZone, base_ancestor_list: Optional[list] = None) -> str:
      # Compute package path for root `zone`. If `base_ancestor_list` is not provided,
      # build it with _compute_ancestral_group_base_list. The list is expected in
      # digging-down order (top -> ... -> deepest). All base ancestors are added
      # as parent directories in that same order; the filename is derived from the
      # closest-to-zone base (the last item in the list).

      dggrs = self.dggrs
      if base_ancestor_list is None:
         base_ancestor_list = self._compute_ancestral_group_base_list(zone)

      # base_ancestor_list is top -> ... -> deepest
      base_texts = [dggrs.getZoneTextID(int(n)) for n in base_ancestor_list if n is not None]

      # closest-to-zone base is the last entry
      base_zone = base_ancestor_list[-1]
      base_level = dggrs.getZoneLevel(base_zone)
      base_text = base_texts[-1]

      group_end = base_level + (self.group0Size if base_level == 0 else self.groupSize) - 1
      filename = f"{base_text}_L{group_end}.sqlite"

      # directories are ALL base_texts except the last, in the same top->... order
      dirs = base_texts[:-1]

      parts = [self.collection_dir] + dirs + [filename]

      return os.path.join(*parts)

   def read_zone_blob(self, pkg_path: str, zone: DGGRSZone) -> Optional[bytes]:
      if not os.path.isfile(pkg_path):
         return None
      zone_text = self.dggrs.getZoneTextID(zone)
      conn = sqlite3.connect(f"file:{os.path.abspath(pkg_path)}?mode=ro&immutable=1", uri=True, check_same_thread=False)
      conn.row_factory = sqlite3.Row
      cur = conn.execute("SELECT data FROM zone_data WHERE root_zone_id = ?", (zone_text,))
      row = cur.fetchone()
      conn.close()
      if not row:
         # logger.warning("read_zone_blob: package=%s missing root_zone_id=%s", pkg_path, zone_text)
         return None
      return row["data"]

   def read_and_decode_zone_blob(self, pkg_path: str, zone: DGGRSZone) -> dict | None:
      return decode_blob(self.read_zone_blob(pkg_path, zone))

   def read_package_root_ids(self, pkg_path: str, limit: Optional[int] = None) -> set:
      ids = read_package_root_ids_from_sqlite(pkg_path, limit=limit)
      return set(ids)

   def _iter_lvl0_seeds(self) -> Iterable[Any]:
      dggrs = self.dggrs
      seeds = dggrs.listZones(0, wholeWorld)
      if not seeds:
         return
      for lvl0 in seeds:
         yield lvl0
      Instance.delete(seeds)

   def iter_bases_under_lvl0(self, lvl0: DGGRSZone, base_level: int, up_to: bool = False,
      in_extent_cb=None) -> Iterable[Tuple[DGGRSZone, List[DGGRSZone]]]:
      if base_level <= 0:
         return
      dggrs = self.dggrs
      stack: List[Tuple[DGGRSZone, List[DGGRSZone]]] = []

      # start from lvl0's children (iter_bases yields lvl0 itself when appropriate)
      children0 = dggrs.getZonePrimaryChildren(lvl0) or []
      for child in children0:
         stack.append((child, [lvl0]))
      if not isinstance(children0, list):
         Instance.delete(children0)

      while stack:
         zone, base_ancestors = stack.pop()

         if in_extent_cb is not None and not in_extent_cb(zone):
            continue

         zone_level = dggrs.getZoneLevel(zone)

         # exact base level: yield and do not descend
         if zone_level == base_level:
            yield (zone, base_ancestors + [zone])
            continue

         # coarser base when up_to=True: yield but still descend to find finer bases
         if up_to and zone_level < base_level and self._is_base_level(zone_level):
            yield (zone, base_ancestors + [zone])
            children = dggrs.getZoneChildren(zone) or []
            for child in children:
               stack.append((child, base_ancestors + [zone]))
            if not isinstance(children, list):
               Instance.delete(children)
            continue

         # otherwise descend normally
         children = dggrs.getZonePrimaryChildren(zone) or []
         for child in children:
            stack.append((child, base_ancestors))
         if not isinstance(children, list):
            Instance.delete(children)

   def iter_bases(self, base_level: int, up_to: bool = False, in_extent_cb=None) -> Iterable[Tuple[DGGRSZone, List[DGGRSZone]]]:
      if not self._is_base_level(base_level):
         return
      dggrs = self.dggrs

      for lvl0 in self._iter_lvl0_seeds():
         lvl0_level = dggrs.getZoneLevel(lvl0)

         # yield lvl0 itself when it qualifies
         if self._is_base_level(lvl0_level) and (lvl0_level == base_level or (up_to and lvl0_level <= base_level)):
            yield (lvl0, [lvl0])

         if base_level > 0:
            # delegate to helper, forwarding flags (do not prefetch)
            for base_zone, base_ancestors in self.iter_bases_under_lvl0(
               lvl0,
               base_level,
               up_to=up_to,
               in_extent_cb=in_extent_cb,
            ):
               yield (base_zone, base_ancestors)

   def iter_roots_for_base(self, base_zone: DGGRSZone, level: int, up_to: bool=False, in_extent_cb=None) -> Iterable[DGGRSZone]:
      dggrs = self.dggrs
      base_level = dggrs.getZoneLevel(base_zone)

      # nothing to do if requested level is above base_level when not up_to
      if not up_to and level == base_level:
         yield base_zone
         return

      # include base itself for up_to when in range
      if up_to and base_level <= level:
         yield base_zone

      # if requested level is shallower than base_level, nothing more to traverse
      if level < base_level:
         return

      stack: List[Tuple[DGGRSZone, int]] = []
      children = dggrs.getZonePrimaryChildren(base_zone) or []
      for child in children:
         stack.append((child, base_level + 1))
      if not isinstance(children, list):
         Instance.delete(children)

      while stack:
         zone, ref = stack.pop()
         zid = int(zone)

         # yield according to up_to vs exact semantics
         if up_to:
            if base_level <= ref <= level:
               yield zone
         else:
            if ref == level:
               yield zone
               continue

         # extent filter
         if in_extent_cb is not None and not in_extent_cb(zone):
            continue

         # only descend while ref < level (children would be ref+1)
         if ref < level:
            children = dggrs.getZonePrimaryChildren(zone) or []
            for child in children:
               stack.append((child, ref + 1))
            if not isinstance(children, list):
               Instance.delete(children)

   def list_zones_with_data_at_level(self, root_level: int, as_textIDs: bool = False) -> List[Any]:
      result: List[Any] = []
      dggrs = self.dggrs
      base_level = self._base_level_for_root(root_level)

      for base_zone, base_ancestors in self.iter_bases(base_level, up_to=False):
         pkg = self.compute_package_path_for_root_zone(base_zone, base_ancestors)
         if not pkg:
            continue
         root_ids = self.read_package_root_ids(pkg)
         if not root_ids:
            continue
         for root_zone in self.iter_roots_for_base(base_zone, root_level, up_to=False):
            zid_text = dggrs.getZoneTextID(root_zone)
            if zid_text and zid_text in root_ids:
               result.append(zid_text if as_textIDs else root_zone)
      return result

   def write_zone_batch(self,
                        base_zone: 'DGGRSZone',
                        entries: Dict['DGGRSZone', Any],
                        base_ancestor_list: Optional[List['DGGRSZone']] = None,
                        pkg_path: Optional[str] = None,
                        precompressed: bool = False,
                        max_workers: int = 8) -> None:
      dggrs = self.dggrs

      if pkg_path is None:
         pkg_path = self.compute_package_path_for_root_zone(base_zone, base_ancestor_list=base_ancestor_list)

      items: List[Tuple[str, Any]] = []
      for zone_obj, data_obj in entries.items():
         zone_text = dggrs.getZoneTextID(zone_obj)
         items.append((zone_text, data_obj))

      output_rows: List[Tuple[str, bytes]] = []

      if items:
         if precompressed:
            for zone_text, data_obj in items:
               output_rows.append((zone_text, data_obj))
         else:
            workers = min(max_workers, max(1, len(items)))
            with ThreadPoolExecutor(max_workers=workers) as ex:
               fut_map = {}
               for zone_text, data_obj in items:
                  fut = ex.submit(to_blob, data_obj)
                  fut_map[fut] = zone_text

               for fut in as_completed(fut_map):
                  zone_text = fut_map[fut]
                  output_rows.append((zone_text, fut.result()))

      pkg_dir = os.path.dirname(pkg_path)
      write_sqlite_two_col(pkg_path, output_rows)

   # Vector Attributes DB
   def _attributes_db_path(self) -> str:
      return os.path.join(self.collection_dir, "attributes.sqlite")

   def _ensure_attributes_db(self) -> None:
      path = self._attributes_db_path()
      os.makedirs(self.collection_dir, exist_ok=True)
      conn = sqlite3.connect(path)
      conn.execute("PRAGMA journal_mode = WAL")
      conn.commit()
      conn.close()

   def write_collection_attributes(self, features: List[Dict[str, Any]]) -> None:
      # features: list of {"id": int_or_str, "properties": {...}}
      # Normalize feature ids to integers; allocate numeric ids if missing or non-integer.
      self._ensure_attributes_db()
      path = self._attributes_db_path()
      conn = sqlite3.connect(path)
      cur = conn.cursor()

      # sequence table for generated ids
      cur.execute("CREATE TABLE IF NOT EXISTS attr_seq(name TEXT PRIMARY KEY, value INTEGER NOT NULL)")
      cur.execute("INSERT OR IGNORE INTO attr_seq(name, value) VALUES('feature_id', 1)")

      # collect attribute keys and sample types
      keys = {}
      for feat in features:
         props = feat.get("properties", {}) or {}
         for k, v in props.items():
            if k in keys:
               continue
            if v is None: continue;
            if isinstance(v, str):
               keys[k] = "text"
            elif isinstance(v, bool):
               keys[k] = "bool"
            elif isinstance(v, (int, float)):
               keys[k] = "number"
            else:
               # arrays and objects -> JSON
               keys[k] = "json"

      # create lookup tables for text attributes
      for k, t in keys.items():
         if t == "text":
            lk = f"attr_{k}_lk"
            cur.execute(
               f"CREATE TABLE IF NOT EXISTS {lk}("
               " id INTEGER PRIMARY KEY AUTOINCREMENT,"
               " value TEXT UNIQUE"
               ")"
            )

      # create main attributes table with dynamic columns
      cols = ["feature_id INTEGER PRIMARY KEY"]
      for k, t in keys.items():
         if t == "text":
            cols.append(f"\"{k}\" INTEGER")        # FK to attr_<k>_lk
         elif t == "number":
            cols.append(f"\"{k}\" REAL")
         elif t == "bool":
            cols.append(f"\"{k}\" INTEGER")
         else:
            cols.append(f"\"{k}\" TEXT")          # JSON text

      cur.execute("CREATE TABLE IF NOT EXISTS attributes(feature_id INTEGER PRIMARY KEY)")
      cur.execute("PRAGMA table_info(attributes)")
      existing = {r[1] for r in cur.fetchall()}
      for col_def in cols[1:]:                       # skip feature_id already created
          col_name = col_def.split()[0].strip('"')
          if col_name not in existing:
              cur.execute(f"ALTER TABLE attributes ADD COLUMN {col_def}")
      # prepare inserts: allocate feature ids if needed, insert lookup values, then insert attributes row
      rows = []
      for feat in features:
         fid = feat.get("id")
         if not isinstance(fid, int) or fid == 0:
            conn.commit()
            cur.execute("BEGIN IMMEDIATE")
            cur.execute("SELECT value FROM attr_seq WHERE name='feature_id'")
            v = cur.fetchone()[0]
            fid = int(v)
            cur.execute("UPDATE attr_seq SET value = ? WHERE name = 'feature_id'", (v + 1,))
            conn.commit()
         props = feat.get("properties", {}) or {}
         row = {"feature_id": int(fid)}
         for k, t in keys.items():
            v = props.get(k)
            if v is None: continue
            if t == "text":
               if v is None:
                  row[k] = None
               else:
                  lk = f"attr_{k}_lk"
                  cur.execute(f"INSERT OR IGNORE INTO {lk}(value) VALUES(?)", (v,))
                  cur.execute(f"SELECT id FROM {lk} WHERE value = ?", (v,))
                  row[k] = cur.fetchone()[0]
            elif t == "number":
               row[k] = float(v) if v is not None else None
            elif t == "bool":
               row[k] = 1 if v else 0 if v is not None else None
            else:
               row[k] = json.dumps(v, separators=(",", ":")) if v is not None else None
         rows.append(row)

      # bulk upsert rows
      if rows:
         col_names = ["feature_id"] + [k for k in keys.keys()]
         placeholders = ",".join("?" for _ in col_names)
         insert_sql = f"INSERT OR REPLACE INTO attributes({', '.join('\"'+c+'\"' for c in col_names)}) VALUES({placeholders})"
         params = []
         for r in rows:
            params.append(tuple(r.get(c) for c in col_names))
         cur.executemany(insert_sql, params)

      conn.commit()
      conn.close()

   def get_attributes_for_feature_ids(self, ids: List[int]) -> Dict[int, Dict[str, Any]]:
      # returns mapping feature_id -> {attr: value} with text FKs resolved to strings
      if not ids:
         return {}
      # self._ensure_attributes_db()
      path = self._attributes_db_path()
      conn = sqlite3.connect(f"file:{os.path.abspath(path)}?mode=ro&immutable=1", uri=True, check_same_thread=False)
      cur = conn.cursor()

      q = ",".join("?" for _ in ids)
      cur.execute(f"PRAGMA table_info(attributes)")
      cols = [r[1] for r in cur.fetchall()]  # column names
      cols_quoted = ",".join(f'"{c}"' for c in cols)
      cur.execute(f"SELECT {cols_quoted} FROM attributes WHERE feature_id IN ({q})", tuple(ids))
      rows = cur.fetchall()
      out = {}
      # find text FK columns by checking for corresponding lookup table existence
      text_cols = []
      for c in cols:
         lk = f"attr_{c}_lk"
         cur.execute("SELECT name FROM sqlite_master WHERE type='table' AND name = ?", (lk,))
         if cur.fetchone():
            text_cols.append(c)

      for r in rows:
         rec = {}
         for ci, c in enumerate(cols):
            if c == "feature_id":
               fid = int(r[ci])
               continue
            val = r[ci]
            if val is None:
               rec[c] = None
            elif c in text_cols:
               lk = '"' + f"attr_{c}_lk" + '"'
               cur.execute(f"SELECT value FROM {lk} WHERE id = ?", (int(val),))
               rec[c] = cur.fetchone()[0]
            else:
               # attempt to parse JSON for json columns, otherwise return numeric/bool as-is
               try:
                  rec[c] = json.loads(val) if isinstance(val, str) else val
               except Exception:
                  rec[c] = val
         out[int(fid)] = rec
      conn.close()
      return out

   def delete_feature_attributes(self, feature_id: int) -> None:
      # Remove a feature's attributes (collection-level). Also cleanup orphaned lookup values.
      path = self._attributes_db_path()
      self._ensure_attributes_db()
      conn = sqlite3.connect(path)
      cur = conn.cursor()
      # remove the attributes row for the feature
      cur.execute("BEGIN IMMEDIATE")
      cur.execute("DELETE FROM attributes WHERE feature_id = ?", (int(feature_id),))
      # find all attr_*_lk tables and remove any lookup rows no longer referenced
      cur.execute("SELECT name FROM sqlite_master WHERE type='table' AND name LIKE 'attr\\_%\\_lk' ESCAPE '\\'")
      lk_tables = [r[0] for r in cur.fetchall()]
      for lk in lk_tables:
         # delete lookup rows not referenced by any attributes row
         # derive attribute column name from lookup table name: attr_<col>_lk -> "<col>"
         col = lk[len("attr_"):-len("_lk")]
         # only attempt cleanup if the attributes table has that column
         cur.execute("PRAGMA table_info(attributes)")
         cols = [r[1] for r in cur.fetchall()]
         if col in cols:
            cur.execute(
               f"DELETE FROM {lk} WHERE id NOT IN (SELECT DISTINCT \"{col}\" FROM attributes WHERE \"{col}\" IS NOT NULL)"
            )
      conn.commit()
      conn.close()

def get_store(data_root: str, collection: str, config: Optional[dict] = None) -> DGGSDataStore:
   key = f"{data_root}::{collection}"
   with store_lock:
      st = store_cache.get(key)
      if st is None:
         st = DGGSDataStore(data_root, collection, config)
         if getattr(st, "group0Size", None) is None:
            st = None
         store_cache[key] = st
      return st

def close_all_stores() -> None:
   with store_lock:
      store_cache.clear()
   with dggrs_lock:
      dggrs_cache.clear()

# Build a canonical DGGS-JSON envelope from a field-organized map.
# - store: DGGSDataStore (provides dggrs and config)
# - zone: DGGRSZone (zone object or int accepted by store.dggrs helpers)
# - fields_map: Dict[fieldName, List[ValueEntry]] where each ValueEntry already
#   contains "depth", "shape", and "data" and follows the contract.
def make_dggs_json_blob(dggrs_uri: str, zone_text: str, fields_map: Dict[str, List[Dict[str, Any]]]) -> Dict[str, Any]:
   depth_nums: List[int] = []
   for fld_depths in fields_map.values():
      for e in fld_depths:
         dn = int(e["depth"])
         if dn not in depth_nums:
            depth_nums.append(dn)

   envelope: Dict[str, Any] = {
      "dggrs": dggrs_uri,
      "zoneId": zone_text,
      "depths": depth_nums,
      "values": { fname: entries for fname, entries in fields_map.items() },
      "$schema": DGGS_JSON_SCHEMA_URI
   }
   # print("Value: ", envelope["values"]["field2"][0]["data"][0])
   return envelope

def make_dggs_json_depth(depth: int, count_centroids: int, sampled_values: Any) -> Dict[str, Any]:
   return {
      "depth": depth,
      "shape": {"count": count_centroids, "subZones": count_centroids},
      "data": sampled_values
   }

# Merge multiple per-depth ValuesObjects into a single field-organized envelope.
# - collected_values: Dict[depth:int, ValuesObject] where ValuesObject is
#   Dict[fieldName, List[ValueEntry]]
# This function delegates to build_zone_blob_from_fields for the final envelope.
def build_dggs_json_from_values(store, zone, collected_values: Dict[int, Dict[str, List[Dict[str, Any]]]]) -> Dict[str, Any]:
   # Merge per-depth ValuesObjects into a single fields_map
   merged_fields: Dict[str, List[Dict[str, Any]]] = {}
   # iterate depths in canonical ascending order
   for d in sorted(int(dk) for dk in collected_values.keys()):
      values_obj = collected_values[d]
      for field, entries in values_obj.items():
         # append entries in the order provided by each depth
         merged_fields.setdefault(field, []).extend(entries)

   dggrs_id = store.config["dggrs"]
   dggrs_uri = f"[ogc-dggrs:{dggrs_id}]"
   zone_text = store.dggrs.getZoneTextID(zone)
   return make_dggs_json_blob(dggrs_uri, zone_text, merged_fields)

# iter_packages yields primitive ids only (no CFFI objects)
def iter_packages(store: DGGSDataStore, root_level: int) -> Iterator[Tuple[str, int, List[int]]]:
   base_level = store._base_level_for_root(root_level)
   for base_zone, base_ancestors in store.iter_bases(base_level, up_to=False):
      pkg_path = store.compute_package_path_for_root_zone(root_level, base_ancestor_list=base_ancestors)
      if not pkg_path:
         continue
      base_zone_id = int(base_zone)
      base_ancestors_ids = [int(b) for b in base_ancestors]
      yield pkg_path, base_zone_id, base_ancestors_ids



================================================
FILE: high-vibes/fg/clippingShapely.py
================================================
from dggal import *
from typing import Dict, Tuple, List, Any, Optional, Sequence
from shapely.geometry import shape, mapping, Polygon, MultiPolygon, LineString, MultiLineString, Point, MultiPoint, GeometryCollection
from shapely.ops import polygonize, unary_union
from shapely.validation import make_valid
import json
import os

import fg.fix_topology_5x6 as topo
from fg.sutherlandHodgman import *

# Helper: write zone polygon GeoJSON for debugging
def write_zone_debug_geojson(zone_poly, dggrs, zone, debug_dir: str = "debug_out") -> None:
   # Write the provided zone polygon (Polygon or MultiPolygon) to
   # debug_dir/{dggrs.getZoneTextID(zone)}.geojson for inspection.
   # ensure a polygonal geometry (if None or empty, write an empty FeatureCollection)
   filename = f"zone-{dggrs.getZoneTextID(zone)}.geojson"
   outpath = os.path.join(debug_dir, filename)
   os.makedirs(debug_dir, exist_ok=True)

   if zone_poly is None:
      fc = {"type": "FeatureCollection", "features": []}
   else:
      # If zone_poly is a Polygon or MultiPolygon, map it directly
      geom = mapping(zone_poly)
      feat = {"type": "Feature", "id": dggrs.getZoneTextID(zone), "properties": {"zone": dggrs.getZoneTextID(zone)}, "geometry": geom}
      fc = {"type": "FeatureCollection", "features": [feat]}

   with open(outpath, "w", encoding="utf-8") as fh:
      json.dump(fc, fh, ensure_ascii=False, indent=3)


def get_zone_polygon(dggrs, zone, refined: bool = False, ico: bool = False) -> Optional[Polygon]:
   # Build the raw zone polygon (refined=False => 5 or 6 vertices), run the
   # same insertion/localize/clip pipeline used for features across all
   # candidate tiles the zone touches, then union the clipped pieces and
   # return a single polygonal geometry (Polygon or MultiPolygon).

   # 1) build raw zone polygon
   crs = CRS(ogc, 1534) if ico else CRS(0)

   if True: #refined:
      verts_container = dggrs.getZoneRefinedCRSVertices(zone, crs, 0)
   else:
      verts_container = dggrs.getZoneCRSVertices(zone, crs)

   coords = [[float(v.x), float(v.y)] for v in verts_container]
   if not coords:
      return Polygon()
   if coords[0] != coords[-1]:
      coords = coords + [coords[0]]

   raw_ring = coords
   #print(raw_ring)

   # 2) run distance5x6 insertion on the raw ring (same routine used for features)

   # This may not be necessary when using the refined tiles, and causes some left-over slivers
   # connecting warping tiles...
   #inserted_coords, _seg_debug = topo._insert_ring_coords(raw_ring, f"zone_{dggrs.getZoneTextID(zone)}", 0)

   #return Polygon(raw_ring) #
   inserted_coords = raw_ring

   # 3) determine candidate tiles the inserted ring touches
   candidates = topo._candidate_tiles_from_vertices(inserted_coords, margin_neighbors=1)
   if not candidates:
      return Polygon()

   # 4) for each candidate tile, clip/localize using the same tile pipeline
   polys = []
   for (tx, ty) in candidates:
      # _tile_and_filter_staircase will localize the ring for each tile and return clipped pieces
      #pieces = topo._tile_and_filter_staircase(inserted_coords, f"zone_{dggrs.getZoneTextID(zone)}", 0)
      pieces = topo._tile_and_filter_staircase(inserted_coords, [], f"zone_{dggrs.getZoneTextID(zone)}", 0)

      # pieces may include many tiles; filter to the current tile (tile_and_filter returns only relevant tiles,
      # but we call it per-ring for consistency with feature pipeline)
      for p in pieces:
         if p.get("tile_x") == tx and p.get("tile_y") == ty:
            #print("Adding piece of clipper from ", tx, ty)
            polys.append(p["geom"])
         #polys.append(p["geom"])

   if not polys:
      return Polygon()

   # 5) staged union/repair using the same routine as features
   merged, skipped = topo._staged_union_polygons(polys, f"zone_{dggrs.getZoneTextID(zone)}")
   if merged is None:
      return Polygon()

   #print(merged)

   # 6) return the merged polygonal geometry (Polygon or MultiPolygon)
   return merged

def get_zone_polygon_before(dggrs, zone, refined: bool = True, ico: bool = False) -> Polygon:
   if ico:
      crs = CRS(ogc, 1534)
   else:
      crs = CRS(0)

   if refined:
      verts_container = dggrs.getZoneRefinedCRSVertices(zone, crs)
   else:
      verts_container = dggrs.getZoneCRSVertices(zone, crs)

   coords = [[float(v.x), float(v.y)] for v in verts_container]
   if not coords:
      return Polygon()
   if coords[0] != coords[-1]:
      coords = coords + [coords[0]]
   return Polygon(coords)


def _collect_boundary_points(shp) -> List[tuple]:
   pts: List[tuple] = []
   if shp is None or shp.is_empty:
      return pts
   if isinstance(shp, Polygon):
      pts.extend(list(shp.exterior.coords))
      for interior in shp.interiors:
         pts.extend(list(interior.coords))
      return pts
   if isinstance(shp, MultiPolygon):
      for poly in shp.geoms:
         pts.extend(list(poly.exterior.coords))
         for interior in poly.interiors:
            pts.extend(list(interior.coords))
      return pts
   if isinstance(shp, (LineString, MultiLineString)):
      if isinstance(shp, LineString):
         pts.extend(list(shp.coords))
      else:
         for line in shp.geoms:
            pts.extend(list(line.coords))
      return pts
   return pts

def _coerce_to_polygonal(g) -> Optional[Polygon]:
   if g is None or g.is_empty:
      return None
   if g.geom_type in ("Polygon", "MultiPolygon"):
      return g
   lines: List[LineString] = []
   if g.geom_type == "LineString":
      lines = [g]
   elif g.geom_type == "MultiLineString":
      lines = list(g.geoms)
   elif g.geom_type == "GeometryCollection":
      for m in getattr(g, "geoms", []) or []:
         if m.geom_type == "LineString":
            lines.append(m)
         elif m.geom_type == "MultiLineString":
            lines.extend(list(m.geoms))
   else:
      return None

   if not lines:
      return None

   merged = unary_union(lines)
   polys = list(polygonize(merged))
   if not polys:
      return None
   if len(polys) == 1:
      return polys[0]
   return MultiPolygon(polys)

# Assumed available in the module:
# - get_zone_polygon(dggrs, zone, refined=False, ico=False)
# - write_zone_debug_geojson(zone_poly, dggrs, zone, debug_dir="zone_tiles")
# - _coerce_to_polygonal(geom) -> returns a polygonal/linear/point geometry or None
# - _collect_boundary_points(shp) -> Iterable[(x,y)] of original source boundary points

def _entry_exit_indices_for_ring(seq: Sequence[Sequence[float]], orig_set: set) -> List[int]:
   """
   Produce ordered entry/exit indices for a ring (circular sequence).
   Rules:
     - initial state is inside
     - inside -> outside at vertex i : append i
     - outside -> inside at vertex i : append next index (i+1 if < n else 0)
     - if 0 is present then ensure n-1 is also present
   Returns: List[int]
   """
   n = len(seq)
   if n == 0:
      return []

   inside_flags = [(float(x), float(y)) in orig_set for (x, y) in seq]

   state = True  # initial state is inside
   entry_exit_indices: List[int] = []
   for i in range(n):
      inside = inside_flags[i]
      if inside != state:
         if state:
            # inside -> outside : append i
            entry_exit_indices.append(i)
         else:
            # outside -> inside : append next index, wrap to 0 for rings
            next_i = i + 1
            entry_exit_indices.append(next_i if next_i < n else 0)
         state = inside

   # wrap consistency: if 0 present then ensure n-1 is present
   if n > 0 and 0 in entry_exit_indices and (n - 1) not in entry_exit_indices:
      entry_exit_indices.append(n - 1)

   return entry_exit_indices

def _entry_exit_indices_for_line(seq: Sequence[Sequence[float]], orig_set: set) -> List[int]:
   """
   Produce ordered entry/exit indices for a line (linear sequence).
   Rules:
     - initial state is inside
     - inside -> outside at vertex i : append i
     - outside -> inside at vertex i : append next index (i+1 if < n else n-1)
     - no circular wrap
   Returns: List[int]
   """
   n = len(seq)
   if n == 0:
      return []

   inside_flags = [(float(x), float(y)) in orig_set for (x, y) in seq]

   state = True
   entry_exit_indices: List[int] = []
   for i in range(n):
      inside = inside_flags[i]
      if inside != state:
         if state:
            entry_exit_indices.append(i)
         else:
            next_i = i + 1
            entry_exit_indices.append(next_i if next_i < n else (n - 1))
         state = inside

   return entry_exit_indices

def _entry_exit_for_polygon(poly: Polygon, orig_set: set) -> List[List[int]]:
   # Return List[List[int]] for a Polygon: exterior then interiors.
   rings_entry_exit: List[List[int]] = []
   exterior_seq = [(float(x), float(y)) for (x, y) in poly.exterior.coords]
   rings_entry_exit.append(_entry_exit_indices_for_ring(exterior_seq, orig_set))
   for interior in poly.interiors:
      seq = [(float(x), float(y)) for (x, y) in interior.coords]
      rings_entry_exit.append(_entry_exit_indices_for_ring(seq, orig_set))
   return rings_entry_exit

def _entry_exit_for_multipolygon(mpoly: MultiPolygon, orig_set: set) -> List[List[List[int]]]:
   # Return List[List[List[int]]] for a MultiPolygon: list of polygons, each a list of rings.
   mpolys_entry_exit: List[List[List[int]]] = []
   for p in mpoly.geoms:
      mpolys_entry_exit.append(_entry_exit_for_polygon(p, orig_set))
   return mpolys_entry_exit

def clip_featurecollection_to_zone(fc: Dict, dggrs, zone,
   refined: bool = False, ico: bool = False) -> Tuple[Dict, List[Any]]:
   """
   Clip GeoJSON FeatureCollection `fc` to `zone`.

   Returns (out_fc_geojson, features_entry_exit_indices) where
   features_entry_exit_indices is aligned 1:1 with features in out_fc and its shape
   strictly matches the *clipped* geometry type produced for each feature:
     - clipped Polygon -> List[List[int]]  (exterior then interiors)
     - clipped MultiPolygon -> List[List[List[int]]] (polygons -> rings -> indices)
     - clipped LineString -> List[int]
     - clipped MultiLineString -> List[List[int]] (one list per line)
   Points and MultiPoint features do not contribute entry/exit indices (an empty list is appended
   to preserve 1:1 alignment but they never contain markers).
   """
   zone_poly = get_zone_polygon(dggrs, zone, refined=refined, ico=ico)
   write_zone_debug_geojson(zone_poly, dggrs, zone, debug_dir="zone_tiles")

   out_fc: Dict[str, Any] = {"type": "FeatureCollection", "features": []}
   features_entry_exit_indices: List[Any] = []

   for feat in fc.get("features", []):
      geom = feat.get("geometry")
      props = feat.get("properties")
      fid = feat.get("id")

      if geom is None:
         continue

      src_shp = shape(geom)

      if not src_shp.is_valid:
         src_shp = make_valid(src_shp)
      if not zone_poly.is_valid:
         zone_poly = make_valid(zone_poly)

      clipped = src_shp.intersection(zone_poly)
      poly_clipped = _coerce_to_polygonal(clipped)
      if poly_clipped is None:
         continue

      out_geom = mapping(poly_clipped)
      out_fc["features"].append({"type": "Feature", "id": fid, "properties": props, "geometry": out_geom})

      # original boundary points are considered "inside"
      orig_pts = _collect_boundary_points(src_shp)
      orig_set = set((float(x), float(y)) for (x, y) in orig_pts)

      # Determine clipped geometry type and produce entry/exit indices shaped to that clipped type.
      clipped_type = poly_clipped.geom_type  # 'Polygon', 'MultiPolygon', 'LineString', 'MultiLineString', 'Point', 'MultiPoint', etc.

      if clipped_type == "Polygon":
         # Return a Polygon-shaped entry_exit: List[List[int]]
         rings_entry_exit = _entry_exit_for_polygon(poly_clipped, orig_set)
         features_entry_exit_indices.append(rings_entry_exit)

      elif clipped_type == "MultiPolygon":
         # Return a MultiPolygon-shaped entry_exit: List[List[List[int]]]
         mpolys_entry_exit = _entry_exit_for_multipolygon(poly_clipped, orig_set)
         features_entry_exit_indices.append(mpolys_entry_exit)

      elif clipped_type == "LineString":
         # Return a LineString-shaped entry_exit: List[int]
         seq = [(float(x), float(y)) for (x, y) in poly_clipped.coords]
         line_entry_exit = _entry_exit_indices_for_line(seq, orig_set)
         features_entry_exit_indices.append(line_entry_exit)

      elif clipped_type == "MultiLineString":
         # Return a MultiLineString-shaped entry_exit: List[List[int]]
         lines_entry_exit: List[List[int]] = []
         for line in poly_clipped.geoms:
            seq = [(float(x), float(y)) for (x, y) in line.coords]
            lines_entry_exit.append(_entry_exit_indices_for_line(seq, orig_set))
         features_entry_exit_indices.append(lines_entry_exit)

      elif clipped_type in ("Point", "MultiPoint"):
         # Points do not add markers. Append an empty list to preserve alignment.
         features_entry_exit_indices.append([])

      else:
         # Unknown/other clipped geometry types: preserve alignment with an empty structure
         features_entry_exit_indices.append([])

   return out_fc, features_entry_exit_indices



================================================
FILE: high-vibes/fg/dggsJSONFG.py
================================================
# dggsJSONFG.py
# Minimal encoder for profile=jsonfg-dggs

from dggal import *
import json
from typing import Dict, Any, List, Sequence, Set
from shapely.geometry import shape
from ogcapi.utils import *
from fg.distance import *
from fg.reproj import get_dggrs, instantiate_projection_for_dggrs_name
from fg.unprojectToWGS84 import *
from fg.fixWGS84 import *

dggal_ffi = dggal.ffi

def _resolve_point_to_subzone_index(shp, dggrs, root_zone, sz_level, sub_indices,
   centroid_pointd, nudge_factor = 1e-8) -> int:
   cx = centroid_pointd.x
   cy = centroid_pointd.y
   defaultCRS = CRS(0)
   px = shp.x; py = shp.y
   #dx = cx - px; dy = cy - py
   #if dx > 3:
   #   dx = dx - 5; dy = dy - 5
   #elif dx < -3:
   #   dx = dx + 5; dy = dy + 5
   #szCentroid = dggal.Pointd(px + dx * nudge_factor, py + dy * nudge_factor)

   d, *unused = distance5x6(Pointd(px, py), centroid_pointd)
   szCentroid = move5x6((px, py), sgn(d.x) * nudge_factor, sgn(d.y) * nudge_factor, 1)
   szCentroid = dggal.Pointd(szCentroid.x, szCentroid.y) # FIXME: utils vs. DGGAL Pointd

   sub_zone = dggrs.getZoneFromCRSCentroid(sz_level, defaultCRS, szCentroid)
   if nullZone == nullZone:
      # idx = dggrs.getSubZoneIndex(root_zone, sub_zone)
      # if idx != -1: idx = idx + 1
      idx = sub_indices.get(int(sub_zone), -2) + 1
   else:
      idx = -1
      print("WARNING: Failed to resolve sub-zone at", szCentroid.x, ",", szCentroid.y)

   if idx == -1:
      print("WARNING:", dggrs.getZoneTextID(sub_zone),
         "is not a sub-zone of", dggrs.getZoneTextID(root_zone), "; skipping vertex",
         px, ",", py)
   return idx

def _ring_to_dggs_indices(ring_coords: Sequence[Sequence[float]], insert_zero_indices: Set[int],
                          dggrs, root_zone, sz_level, sub_indices, centroid_pointd, nudge_factor = 1e-8) -> List[int]:
   out: List[int] = []
   print("Processing ring with ", len(ring_coords), "vertices")

   lastIX = None
   count = 0

   cx = centroid_pointd.x
   cy = centroid_pointd.y
   defaultCRS = CRS(0)
   for i, coord in enumerate(ring_coords):
      if i in insert_zero_indices:
         out.append(0)

      px = coord[0]; py = coord[1]

      #px = 2.9999999995527866
      #py = 2.500000000894427

      #dx = cx - px; dy = cy - py
      #if dx > 3:
      #   dx = dx - 5; dy = dy - 5
      #elif dx < -3:
      #   dx = dx + 5; dy = dy + 5
      #szCentroid = Pointd(px + dx * nudge_factor, py + dy * nudge_factor)

      d, *unused = distance5x6(Pointd(px, py), centroid_pointd)
      dx = d.x * nudge_factor; dy = d.y * nudge_factor
      szCentroid = move5x6((px, py), dx, dy, 1)
      szCentroid = dggal.Pointd(szCentroid.x, szCentroid.y) # FIXME: utils vs. DGGAL Pointd

      sub_zone = dggrs.getZoneFromCRSCentroid(sz_level, defaultCRS, szCentroid)
      if nullZone == nullZone:
         # idx = dggrs.getSubZoneIndex(root_zone, sub_zone)
         # if idx != -1: idx = idx + 1
         idx = sub_indices.get(int(sub_zone), -2) + 1
      else:
         idx = -1
         print("WARNING: Failed to resolve sub-zone at", szCentroid.x, ",", szCentroid.y)

      if idx == -1:
         print("WARNING:", dggrs.getZoneTextID(sub_zone),
            "is not a sub-zone of", dggrs.getZoneTextID(root_zone), "; skipping vertex",
            px, ",", py)
         print("x:", szCentroid.x, "y:", szCentroid.y,
            "cx:", cx, "cy:", cy, "dx:", dx, "dy:", dy,
            "adx:", szCentroid.x - px, "ady:", szCentroid.y - py)

         #idx = dggrs.getSubZoneIndex(root_zone, sub_zone)
         #print("idx =", idx)

         raise BadNudge
      elif lastIX != idx:
         out.append(int(idx))
         lastIX = idx
         count = count + 1
      else:
         pass # TODO: Avoid self-intersection if points get quantized to same sub-zone
      if i and i % 1000 == 0: print(i, "/", len(ring_coords))
   return out, count

def write_dggs_json_fg(out_fc: Dict[str, Any],
                       features_rings_entry_exit_indices: Dict[str, Any],
                       dggrs,
                       root_zone,
                       depth: int,
                       profile_uri: str = "https://www.opengis.net/def/profile/ogc/0/jsonfg-dggs"):
   # strict contract: dggrs.getZoneCRSCentroid(root_zone, CRS(0)) returns Pointd
   centroid_pointd = dggrs.getZoneCRSCentroid(root_zone, CRS(0))

   features = out_fc.get("features", []) or []
   print(f"write_dggs_json_fg: features_in={len(features)}, entry_exits_items={len(features_rings_entry_exit_indices)}")

   dggrs_name = dggrs.__class__.__name__
   dggs_obj: Dict[str, Any] = {
      "conformsTo": [
         "https://www.opengis.net/spec/json-fg-1/0.2/conf/core",
         "https://www.opengis.net/spec/ogcapi-dggs-1/1.0/conf/data-dggs-jsonfg"
      ],
      "links": [
         {"rel": "profile", "href": profile_uri}
      ],
      "dggrs": f"[ogc-dggrs:{dggrs_name}]",
      "zoneId": dggrs.getZoneTextID(root_zone),
      "depth": depth,
      "type": "FeatureCollection",
      "features": []
   }
   ref_ratio = dggrs.getRefinementRatio()
   root_level = dggrs.getZoneLevel(root_zone)
   sz_level = root_level + depth
   nudge_factor = 10.0 / (ref_ratio ** sz_level)
   print("Selecting nudge_factor =", nudge_factor,
      "for root zone of level", root_level, "at depth", depth)

   print("Precalculating all sub-zones...")
   sub_zones = dggrs.getSubZones(root_zone, depth)
   sub_count = sub_zones.count
   sub_ptr = ffi.cast("uint64_t *", sub_zones.array)
   print("Building sub-zone map...")
   sub_indices = { int(sub_ptr[i]): i for i in range(sub_count) }
   Instance.delete(sub_zones)
   print("Quantizing features...")

   for fi, feat in enumerate(features):
      fid = feat.get("id")
      print(f"processing feature {fi} id={fid}")

      props = feat.get("properties", {})
      geom = feat.get("geometry")
      # strict contract: features_rings_entry_exit_indices[fi] exists and has the correct shape for the geometry
      entry_exit_indices = features_rings_entry_exit_indices[fi]
      shp = shape(geom) if geom is not None else None

      dggs_place = None
      if shp is not None:
         if shp.geom_type == "Polygon":
            rings = []
            exterior = list(shp.exterior.coords)
            exterior_entry_exit_indices = entry_exit_indices[0]
            ring, count = _ring_to_dggs_indices(exterior, exterior_entry_exit_indices, dggrs, root_zone, sz_level, sub_indices, centroid_pointd, nudge_factor)
            if ring and count > 3: rings.append(ring)
            for ri, interior in enumerate(shp.interiors, start=1):
               coords = list(interior.coords)
               ring_entry_exit_indices = entry_exit_indices[ri]
               ring, count = _ring_to_dggs_indices(coords, ring_entry_exit_indices, dggrs, root_zone, sz_level, sub_indices, centroid_pointd, nudge_factor)
               if ring and count > 3: rings.append(ring)
            dggs_place = {"type": "Polygon", "coordinates": rings if rings else None}

         elif shp.geom_type == "MultiPolygon":
            mcoords = []
            # strict contract: entry_exit_indices is List[List[List[int]]] (polygons -> rings -> indices)
            for p_index, p in enumerate(shp.geoms):
               poly_rings = []
               polygon_entry_exit_lists = entry_exit_indices[p_index]
               ext = list(p.exterior.coords)
               ext_entry_exit_indices = polygon_entry_exit_lists[0]
               ring, count = _ring_to_dggs_indices(ext, ext_entry_exit_indices, dggrs, root_zone, sz_level, sub_indices, centroid_pointd, nudge_factor)
               if ring and count > 3: poly_rings.append(ring)
               for ri, interior in enumerate(p.interiors, start=1):
                  coords = list(interior.coords)
                  ring_entry_exit_indices = polygon_entry_exit_lists[ri]
                  ring, count = _ring_to_dggs_indices(coords, ring_entry_exit_indices, dggrs, root_zone, sz_level, sub_indices, centroid_pointd, nudge_factor)
                  if ring and count > 3: poly_rings.append(ring)
               if poly_rings:
                  mcoords.append(poly_rings)
            dggs_place = {"type": "MultiPolygon", "coordinates": mcoords if mcoords else None}

         elif shp.geom_type == "LineString":
            coords = list(shp.coords)
            ls, count = _ring_to_dggs_indices(coords, entry_exit_indices, dggrs, root_zone, sz_level, sub_indices, centroid_pointd, nudge_factor)
            dggs_place = {"type": "LineString", "coordinates": ring if ring and count >= 2 else None }

         elif shp.geom_type == "MultiLineString":
            lines_coords = []
            for li, line in enumerate(shp.geoms):
               coords = list(line.coords)
               line_entry_exit = entry_exit_indices[li]
               ls, count = _ring_to_dggs_indices(coords, set(line_entry_exit), dggrs, root_zone, sz_level, sub_indices, centroid_pointd, nudge_factor)
               if ls and count >= 2:
                  lines_coords.append(ls)
            dggs_place = {"type": "MultiLineString", "coordinates": lines_coords if lines_coords else None}

         elif shp.geom_type == "Point":
            idx = _resolve_point_to_subzone_index(shp, dggrs, root_zone, sz_level, sub_indices, centroid_pointd, nudge_factor)
            dggs_place = {"type": "Point", "coordinates": idx if idx != -1 else None }

         elif shp.geom_type == "MultiPoint":
            # MultiPoint -> resolve each point to a subzone index; preserve order
            pts_coords: List[Any] = []
            for p in shp.geoms:
               idx = _resolve_vertex_to_subzone_index(float(p.x), float(p.y), dggrs, root_zone, sz_level, sub_indices, centroid_pointd, nudge_factor)
               if idx != -1:
                  pts_coords.append(idx)
            dggs_place = {"type": "MultiPoint", "coordinates": pts_coords if pts_coords else None}

      out_feature: Dict[str, Any] = {
         "type": "Feature",
         "id": fid,
         "properties": props if props else {},
         "geometry": None,
         "place": None,
         "time": None,
         "dggsPlace": dggs_place
      }
      dggs_obj["features"].append(out_feature)
      print(f"processed feature {fi} id={fid}")

   print(f"write_dggs_json_fg: finished features={len(dggs_obj['features'])}")

   return dggs_obj

def write_dggs_json_fg_to_file(out_fc: Dict[str, Any],
                       features_rings_entry_exit_indices: Dict[str, Any],
                       output_path: str,
                       dggrs,
                       root_zone,
                       depth: int,
                       profile_uri: str = "https://www.opengis.net/def/profile/ogc/0/jsonfg-dggs"):

   dggs_obj = write_dggs_json_fg(out_fc, features_rings_entry_exit_indices, dggrs, root_zone,
      depth, profile_uri)

   if dggs_obj is not None:
      with open(output_path, "w", encoding="utf-8") as fh:
         fh.write(pretty_json(dggs_obj))
         fh.write("\n")

# map a single integer index to an [x,y] coordinate using centroids list
def _index_to_xy(idx: int, centroids: List[Pointd]) -> List[float]:
   if idx <= 0:
      return []
   p = centroids[idx - 1]

   # return [float(p.lon), float(p.lat)]
   return [float(p.x), float(p.y)]

# Recursively resolve coordinate arrays where the leaf elements are integer indices.
# Preserves nesting shape but replaces numeric leaves with [x,y] pairs.
def resolve_coordinates(coords: Any, centroids: List[Pointd]) -> Any:
   if coords is None:
      return []

   t = type(coords)
   if t is list:
      if coords:
         first = coords[0]
         ft = type(first)
         if ft is int or ft is float:
            out: List[List[float]] = []
            for v in coords:
               iv = int(v)
               xy = _index_to_xy(iv, centroids)
               if xy:
                  out.append(xy)

            return out
      out_list: List[Any] = []
      for item in coords:
         resolved = resolve_coordinates(item, centroids)
         out_list.append(resolved)
      return out_list
   iv = int(coords)
   xy = _index_to_xy(iv, centroids)
   if xy:
      return xy
   return []

# Convert a geometry object (GeoJSON geometry) whose coordinates are index-based
# into a geometry with numeric coordinates. Returns a new geometry dict.
def convert_geometry_indexed(geom: Dict[str, Any], centroids: List[Pointd], fid: str) -> Dict[str, Any]:
   gtype = geom["type"]

   if gtype == "Point":
      coords = geom.get("coordinates", [])
      resolved = resolve_coordinates(coords, centroids)
      if not resolved:
         print(f"Warning: Point geometry empty for feature id={fid}")
         return None
      return {"type": "Point", "coordinates": resolved}

   if gtype == "MultiPoint":
      coords = geom.get("coordinates", [])
      resolved = resolve_coordinates(coords, centroids)
      if not resolved:
         print(f"Warning: MultiPoint has 0 points for feature id={fid}")
         return None
      return {"type": "MultiPoint", "coordinates": resolved}

   if gtype == "LineString":
      coords = geom.get("coordinates", [])
      resolved = resolve_coordinates(coords, centroids)
      if not resolved or len(resolved) < 2:
         print(f"Warning: LineString too short (len={len(resolved) if resolved else 0}) for feature id={fid}")
         return None
      return {"type": "LineString", "coordinates": resolved}

   if gtype == "MultiLineString":
      coords = geom.get("coordinates", [])
      resolved = resolve_coordinates(coords, centroids)
      if not resolved:
         print(f"Warning: MultiLineString has 0 LineStrings for feature id={fid}")
         return None
      filtered = [line for line in resolved if line and len(line) >= 2]
      if not filtered:
         print(f"Warning: MultiLineString all LineStrings too short for feature id={fid}")
         return None
      return {"type": "MultiLineString", "coordinates": filtered}

   if gtype == "Polygon":
      coords = geom.get("coordinates", [])
      resolved = resolve_coordinates(coords, centroids)
      if not resolved or not resolved[0] or len(resolved[0]) <= 3:
         print(f"Warning: Polygon exterior ring too short (len={len(resolved[0]) if resolved and resolved[0] else 0}) for feature id={fid}")
         return None
      exterior = resolved[0]
      holes = [h for h in resolved[1:] if h and len(h) > 3]
      return {"type": "Polygon", "coordinates": [exterior] + holes}

   if gtype == "MultiPolygon":
      coords = geom.get("coordinates", [])
      resolved = resolve_coordinates(coords, centroids)
      if not resolved:
         print(f"Warning: MultiPolygon has 0 polygons for feature id={fid}")
         return None
      out_polys: List[List[Any]] = []
      for poly in resolved:
         if not poly or not poly[0] or len(poly[0]) <= 3:
            print(f"Warning: Skipping polygon with short exterior ring (len={len(poly[0]) if poly and poly[0] else 0}) in MultiPolygon for feature id={fid}")
            continue
         exterior = poly[0]
         holes = [h for h in poly[1:] if h and len(h) > 3]
         out_polys.append([exterior] + holes)
      if not out_polys:
         print(f"Warning: MultiPolygon has no valid polygons after filtering for feature id={fid}")
         return None
      return {"type": "MultiPolygon", "coordinates": out_polys}

   if gtype == "GeometryCollection":
      geoms = geom.get("geometries", [])
      out_geoms: List[Dict[str, Any]] = []
      for g in geoms:
         conv = convert_geometry_indexed(g, centroids, fid)
         if conv is None:
            inner_id = g.get("id") or "<no-id>"
            print(f"Warning: GeometryCollection contained empty/invalid geometry id={inner_id} in feature id={fid}")
            continue
         out_geoms.append(conv)
      if not out_geoms:
         print(f"Warning: GeometryCollection empty after conversion for feature id={fid}")
         return None
      return {"type": "GeometryCollection", "geometries": out_geoms}

   coords = geom.get("coordinates")
   if coords is None:
      print(f"Warning: Geometry of type {gtype} missing coordinates for feature id={fid}")
      return None
   return geom

def unproject_and_fix(projection, extent, converted, fid, refine_wgs84=None):
   if converted:
      converted = unproject_geojson_to_wgs84(converted, projection, extent, refine_wgs84=refine_wgs84)

   if converted:
      dlon = extent[2] - extent[0]
      if dlon > 180: dlon = dlon - 360
      eps_zone_tile =  abs(dlon) / 20.0 / 100000.0
      converted = fix_WGS84_geometry(converted, extent, eps_zone_tile, fid)

   return converted

def read_dggs_json_fg_file(path: str, unproject = True, refine_wgs84=None) -> Dict[str, Any]:
   with open(path, "r", encoding="utf-8") as fh:
      data = json.load(fh)
      if data:
         return read_dggs_json_fg(data, unproject=unproject, refine_wgs84=refine_wgs84)
   return None

# read a DGGS-JSON-FG file and convert index-based geometries to numeric coordinates
# Returns the top-level object in the same shape it was read (geometry, Feature, or FeatureCollection)
def read_dggs_json_fg(data: Dict[str, Any], unproject = True, refine_wgs84=None) -> Dict[str, Any]:
   curie = data["dggrs"]
   token = "-dggrs:"
   start = curie.find(token) + len(token)
   end = curie.find("]", start)
   dggrs_id =  curie[start:end]

   dggrs = get_dggrs(dggrs_id)

   zone_text = data["zoneId"]
   depth = int(data["depth"])

   root_zone = dggrs.getZoneFromTextID(zone_text)

   if unproject:
      ge = GeoExtent()
      projection = instantiate_projection_for_dggrs_name(dggrs_id)
      dggrs.getZoneWGS84Extent(root_zone, ge)
      extent = [float(ge.ll.lon), float(ge.ll.lat), float(ge.ur.lon), float(ge.ur.lat)]
   else:
      projection = None

   # centroids: List[GeoPoint] = dggrs.getSubZoneWGS84Centroids(root_zone, depth)
   centroids: List[Pointd] = dggrs.getSubZoneCRSCentroids(root_zone, CRS(0), depth)

   #print("Converting DGGS-JSON-FG for level", dggrs.getZoneLevel(root_zone),
   #   "root zone", zone_text, "of DGGRS", dggrs_id, "at sub-zone depth", depth)

   #print("Done calculating centroids.")

   top_type = data["type"]

   if top_type == "FeatureCollection":
      feats = data["features"]
      out_feats: List[Dict[str, Any]] = []
      for feat in feats:
         geom = feat["dggsPlace"]
         props = feat.get("properties", {})
         id = feat.get("id", None)
         converted = convert_geometry_indexed(geom, centroids, id)
         if unproject: converted = unproject_and_fix(projection, extent, converted, id, refine_wgs84=refine_wgs84)
         feature = {
            "type": "Feature",
            "id": id,
            "properties": {
               "dggrs": curie,
               "zoneId": zone_text,
               "depth": depth,
               **(props or {})
            },
            "geometry": converted
         }
         out_feats.append(feature)
      result = {"type": "FeatureCollection", "features": out_feats}
   elif top_type == "Feature":
      geom = data["dggsPlace"]
      props = data.get("properties", {})
      converted = convert_geometry_indexed(geom, centroids, id)
      if unproject: converted = unproject_and_fix(projection, extent, converted, id, refine_wgs84=refine_wgs84)
      feature = {
         "type": "Feature",
         "properties": {
            "dggrs": curie,
            "zoneId": zone_text,
            "depth": depth,
            **props
         },
         "geometry": converted
      }
      result = feature
   else:
      geom = data
      converted = convert_geometry_indexed(geom, centroids, id)
      if unproject: converted = unproject_and_fix(projection, extent, converted, id, refine_wgs84=refine_wgs84)
      result = converted

   Instance.delete(centroids)
   if projection: Instance.delete(projection)
   Instance.delete(dggrs)

   return result



================================================
FILE: high-vibes/fg/dgToGeoMulti.py
================================================
# dgToGeoMulti.py
# Parallel reader -> WKB aggregator -> rehydrate & union -> write GeoJSON
# - Workers read one DGGS-UBJSON-FG file each via read_dggs_json_fg_file(path)
# - Workers convert GeoJSON geometries to WKB bytes and return tuples:
#     (key, wkb_bytes_or_None, props, raw_id, kind_or_None)
# - Main process aggregates WKB lists per key, rehydrates WKB -> Shapely only
#   when merging a single key, runs shapely.union_all, and writes GeoJSON.
# - This version:
#     * validates grid_size early (must be finite float)
#     * preserves features with geometry == None (returns geometry: null)
#     * ensures workers return JSON-serializable, picklable tuples
#     * tolerates GeometryCollection by emitting it (no silent drop)
#     * flattens pool results robustly and logs minimal diagnostics

from typing import Sequence, Dict, Any, List, Tuple, Iterable, Optional
import multiprocessing as mp
import os
import re
import glob
import gc
from collections import defaultdict
import math
import shapely
from shapely import wkb as _wkb
from shapely.geometry import shape, mapping, Point, MultiPoint, LineString, MultiLineString, Polygon, MultiPolygon, GeometryCollection
from shapely.geometry.base import BaseGeometry

from ogcapi.utils import pretty_json
from fg.dggsJSONFG import read_dggs_json_fg_file

# number of worker processes to use by default
WORKERS = 16

def expand_input_paths_from_arg(arg: str) -> Iterable[str]:
    # .lst file: one path per line
    if arg.lower().endswith(".lst") and os.path.isfile(arg):
        with open(arg, "r", encoding="utf-8") as fh:
            for line in fh:
                p = line.strip()
                if p and os.path.exists(p):
                    yield p
        return

    # directory: only *.dggs.json
    if os.path.isdir(arg):
        pattern = os.path.join(arg, "*.dggs.json")
        for p in sorted(glob.glob(pattern)):
            if os.path.isfile(p):
                yield p
        return

    # glob or single file (shell may already have expanded globs)
    for p in glob.glob(arg):
        if os.path.isfile(p):
            yield p

def expand_input_paths(args_list: Sequence[str]) -> Iterable[str]:
    for a in args_list:
        for p in expand_input_paths_from_arg(a):
            yield p

def numeric_key(k: str):
   try:
      return (0, int(k))
   except Exception:
      try:
         return (1, float(k))
      except Exception:
         m = re.search(r"(\d+)$", str(k))
         if m:
            return (2, int(m.group(1)))
         return (3, str(k))

# Worker: read one file and emit list of tuples:
# (key, wkb_bytes_or_None, props, raw_id, kind_or_None)
def _worker_read_file(path: str, refine_wgs84=None) -> List[Tuple[str, Optional[bytes], Dict[str, Any], Any, Optional[str]]]:
   out: List[Tuple[str, Optional[bytes], Dict[str, Any], Any, Optional[str]]] = []
   obj = read_dggs_json_fg_file(path, refine_wgs84=None)
   feats = obj.get("features", []) or []
   for feat in feats:
      geom_json = feat.get("geometry")
      props = feat.get("properties") or {}
      raw_id = feat.get("id")

      if raw_id is None:
         raise ValueError("id-less feature")

      key = str(raw_id)
      orig_id_val = raw_id

      if geom_json is None:
         # explicit None geometry tuple (worker saw the feature but had no geometry)
         out.append((key, None, dict(props), orig_id_val, None))
         continue

      shp = shape(geom_json)
      if shp is None or getattr(shp, "is_empty", False):
         out.append((key, None, dict(props), orig_id_val, None))
         continue

      gtype = getattr(shp, "geom_type", None)
      if gtype in ("Point", "MultiPoint"):
         kind = "point"
      elif gtype in ("LineString", "MultiLineString"):
         kind = "line"
      elif gtype in ("Polygon", "MultiPolygon"):
         kind = "poly"
      else:
         out.append((key, None, dict(props), orig_id_val, None))
         del shp
         continue

      # emit one tuple per concrete geometry
      if hasattr(shp, "geoms"):
         for part in shp.geoms:
            if part is None or getattr(part, "is_empty", False):
               continue
            out.append((key, _wkb.dumps(part, hex=False), dict(props), orig_id_val, kind))
      else:
         out.append((key, _wkb.dumps(shp, hex=False), dict(props), orig_id_val, kind))

      del shp
   gc.collect()
   return out

def togeo_multi_mode(input_args: Sequence[str], output_path: str, grid_size: float = 1e-10, refine_wgs84 = None) -> None:
   if not isinstance(grid_size, float):
      raise ValueError(f"grid_size must be numeric, got {type(grid_size).__name__}")

   paths = sorted(expand_input_paths(input_args))

   workers = min(WORKERS, max(1, (mp.cpu_count() or 1)))

   with mp.Pool(processes=workers) as pool:
      results = pool.map(_worker_read_file, paths, chunksize=1, refine_wgs84=refine_wgs84)

   # features: Dict[id, {"props": Dict[str,Any], "geoms": List[Shapely geometry]}]
   features: Dict[str, Dict[str, Any]] = {}

   # Single-pass: iterate worker results directly and populate features
   for i, r in enumerate(results):
      if r is None:
         # worker returned nothing for this file
         print(f"worker {i} returned None")
         continue

      # normalize to iterable of tuples
      if not isinstance(r, list):
         if isinstance(r, tuple) and len(r) >= 3:
            tuples_iter = [r]
         else:
            print(f"worker {i} returned unexpected type {type(r).__name__}; skipping")
            continue
      else:
         tuples_iter = r

      for item in tuples_iter:
         if not isinstance(item, tuple) or len(item) < 5:
            print("skipping malformed worker item:", item)
            continue

         key, wkb_bytes, p, raw_id, kind = item

         # ensure features entry exists
         if key not in features:
            features[key] = {"props": {}, "geoms": [], "id": raw_id if raw_id is not None else key}

         # set props if provided and not empty, but do not overwrite existing non-empty props
         if p:
            if not features[key]["props"]:
               features[key]["props"] = dict(p)

         # if geometry is None, do nothing to geoms list (we keep the entry so the feature is known)
         if wkb_bytes is None:
            # explicit no-geometry from this worker; nothing to append
            continue

         # binary-only contract: attempt to load directly; skip if load fails
         try:
            geom = _wkb.loads(wkb_bytes)
         except Exception:
            # failed to load this blob; skip it
            print(f"warning: failed to load WKB for key={key}; skipping this blob")
            continue

         if geom is None or getattr(geom, "is_empty", False):
            # nothing to append
            continue

         # append the rehydrated geometry contributed by this worker
         features[key]["geoms"].append(geom)

         # record kind if not already recorded (optional, not used for props selection)
         if "kind" not in features[key] or features[key].get("kind") is None:
            features[key]["kind"] = kind

   # Build final FeatureCollection from features
   out_features: List[Dict[str, Any]] = []

   for k in sorted(features.keys(), key=numeric_key):
      entry = features[k]
      geoms = entry.get("geoms", [])

      if geoms:
         merged = shapely.union_all(geoms, grid_size=grid_size)

         geom_out = None
         if isinstance(merged, GeometryCollection):
            geom_out = mapping(merged)
         else:
            expected = entry.get("kind")
            if expected == "poly" and not isinstance(merged, (Polygon, MultiPolygon)):
               coerced = shapely.union_all([merged], grid_size=grid_size)
               if not isinstance(coerced, (Polygon, MultiPolygon)):
                  geom_out = None
               else:
                  merged = coerced
            elif expected == "line" and not isinstance(merged, (LineString, MultiLineString)):
               coerced = shapely.union_all([merged], grid_size=grid_size)
               if not isinstance(coerced, (LineString, MultiLineString)):
                  geom_out = None
               else:
                  merged = coerced
            elif expected == "point" and not isinstance(merged, (Point, MultiPoint)):
               coerced = shapely.union_all([merged], grid_size=grid_size)
               if not isinstance(coerced, (Point, MultiPoint)):
                  geom_out = None
               else:
                  merged = coerced

            if geom_out is None:
               if grid_size and grid_size != 0.0:
                  try:
                     merged = merged.buffer(grid_size).buffer(-grid_size)
                  except Exception as e:
                     print(f"warning: buffer cleanup failed for key={k}: {e}")
               geom_out = mapping(merged)

         feature: Dict[str, Any] = {
            "type": "Feature",
            "properties": dict(entry.get("props", {})),
            "geometry": geom_out
         }
         fid = entry.get("id")
         if fid is not None:
            feature["id"] = fid
         out_features.append(feature)
      else:
         # no geometries appended by any worker -> emit geometry:null
         feature: Dict[str, Any] = {
            "type": "Feature",
            "properties": dict(entry.get("props", {})),
            "geometry": None
         }
         fid = entry.get("id")
         if fid is not None:
            feature["id"] = fid
         out_features.append(feature)
         # print("NULL GEOMETRY for", k)

      # cleanup per-entry
      entry["geoms"] = []
      entry["props"] = {}
      entry["id"] = None
      entry["kind"] = None
      gc.collect()

   out_obj = {"type": "FeatureCollection", "features": out_features}
   with open(output_path, "w", encoding="utf-8") as fh:
      fh.write(pretty_json(out_obj))
      fh.write("\n")
   gc.collect()



================================================
FILE: high-vibes/fg/distance.py
================================================
# distance5x6.py
"""
Compute true 5x6-space distance between two 5x6 coordinates, delegating
seam/interruption detection to crosses5x6_interruption_v2_ex from interruption.py.

Public API:
  distance5x6(a: Pointd, b: Pointd) -> (
      distance: Pointd,
      b_in_a_frame: Optional[Pointd],
      mod_a: Optional[Pointd],
      i_src: Optional[Pointd],
      i_dst: Optional[Pointd],
      in_north: Optional[bool],
      ends_at_edge: Optional[bool]
  )

Notes:
 - This module depends on faces.get_face and interruption.crosses5x6_interruption_v2_ex
 - It preserves the original control flow and wrap-around normalization logic.
 - No snapping or precision-reducing operations are performed here.
"""

from typing import Optional, Tuple, Sequence, Union
import math

from fg.faces import Point, Pointd, get_face
from fg.interruption import rotate5x6_offset, crosses5x6_interruption_v2_ex

def sgn(v: float) -> int:
    if v > 0: return 1
    if v < 0: return -1
    return 0

_EPS = 1e-11

def distance5x6(
    a_in: Pointd,
    b_in: Pointd,
) -> Tuple[
    Pointd,
    Optional[Pointd],
    Optional[Pointd],
    Optional[Pointd],
    Optional[Pointd],
    Optional[bool],
    Optional[bool],
]:
    """
    Compute the true 5x6-space distance between points a_in and b_in,
    taking interruptions into account.

    Returns:
      (distance, b_in_a_frame, mod_a, i_src, i_dst, in_north, ends_at_edge)

    - distance: Pointd (dx, dy) or (nan, nan) if faces non-adjacent
    - b_in_a_frame: b expressed in a's frame (or None)
    - mod_a: possibly-modified a after face rotations (or None)
    - i_src, i_dst: interruption source/destination intersection points (or None)
    - in_north: bool indicating north/south interruption side (or None)
    - ends_at_edge: bool indicating the segment ends exactly at the edge (or None)
    """
    # local mutable copies
    a = Pointd(a_in.x, a_in.y)
    b = Pointd(b_in.x, b_in.y)

    # get faces and fractional coords
    f1, d1 = get_face(a)
    f2, d2 = get_face(b)

    dx = f2.x - f1.x
    dy = f2.y - f1.y

    # normalize wrap-around differences
    if dx < -3 or dy < -3:
        dx += 5
        dy += 5
    if dx > 3 or dy > 3:
        dx -= 5
        dy -= 5

    # attempt pole rotations to make faces adjacent when possible
    if abs(dx) > 0 or abs(dy) > 0:
        # a is north-pole-like vertex and can be rotated
        if (f1.x - f1.y) == 0 and d1.x > 1.0 - _EPS and d1.y < _EPS:
            for i in range(5):
                nx = (f1.x + i) % 5
                ny = nx
                tdx = f2.x - nx
                tdy = f2.y - ny
                if tdx < -3 or tdy < -3:
                    tdx += 5; tdy += 5
                if tdx > 3 or tdy > 3:
                    tdx -= 5; tdy -= 5
                if abs(tdx) <= 1 and abs(tdy) <= 1:
                    if abs(dx) > 1 or abs(dy) > 1 or (abs(tdx) < abs(dx) and abs(tdy) < abs(dy)):
                        a.x += (nx - f1.x)
                        a.y += (ny - f1.y)
                        f1 = Point(nx, ny)
                        dx = tdx; dy = tdy
                        if dx == 0 and dy == 0:
                            break
        # b is north-pole-like vertex and can be rotated
        elif (f2.x - f2.y) == 0 and d2.x > 1.0 - _EPS and d2.y < _EPS:
            for i in range(5):
                nx = (f2.x + i) % 5
                ny = nx
                tdx = nx - f1.x
                tdy = ny - f1.y
                if tdx < -3 or tdy < -3:
                    tdx += 5; tdy += 5
                if tdx > 3 or tdy > 3:
                    tdx -= 5; tdy -= 5
                if abs(tdx) <= 1 and abs(tdy) <= 1:
                    if abs(dx) > 1 or abs(dy) > 1 or (abs(tdx) < abs(dx) and abs(tdy) < abs(dy)):
                        b.x += (nx - f2.x)
                        b.y += (ny - f2.y)
                        f2 = Point(nx, ny)
                        dx = tdx; dy = tdy
                        if dx == 0 and dy == 0:
                            break
        # a is south-pole-like vertex and can be rotated
        elif (f1.y - f1.x) == 1 and d1.x < _EPS and d1.y > 1.0 - _EPS:
            for i in range(5):
                nx = (f1.x + i) % 5
                ny = nx + 1
                tdx = f2.x - nx
                tdy = f2.y - ny
                if tdx < -3 or tdy < -3:
                    tdx += 5; tdy += 5
                if tdx > 3 or tdy > 3:
                    tdx -= 5; tdy -= 5
                if abs(tdx) <= 1 and abs(tdy) <= 1:
                    if abs(dx) > 1 or abs(dy) > 1 or (abs(tdx) < abs(dx) and abs(tdy) < abs(dy)):
                        a.x += (nx - f1.x)
                        a.y += (ny - f1.y)
                        f1 = Point(nx, ny)
                        dx = tdx; dy = tdy
                        if dx == 0 and dy == 0:
                            break
        # b is south-pole-like vertex and can be rotated
        elif (f2.y - f2.x) == 1 and d2.x < _EPS and d2.y > 1.0 - _EPS:
            for i in range(5):
                nx = (f2.x + i) % 5
                ny = nx + 1
                tdx = nx - f1.x
                tdy = ny - f1.y
                if tdx < -3 or tdy < -3:
                    tdx += 5; tdy += 5
                if tdx > 3 or tdy > 3:
                    tdx -= 5; tdy -= 5
                if abs(tdx) <= 1 and abs(tdy) <= 1:
                    if abs(dx) > 1 or abs(dy) > 1 or (abs(tdx) < abs(dx) and abs(tdy) < abs(dy)):
                        b.x += (nx - f2.x)
                        b.y += (ny - f2.y)
                        f2 = Point(nx, ny)
                        dx = tdx; dy = tdy
                        if dx == 0 and dy == 0:
                            break

    # If faces still non-adjacent, return NaN distance
    if abs(dx) > 1 or abs(dy) > 1:
        nanp = float("nan")
        mod_a = Pointd(a.x, a.y)
        return Pointd(nanp, nanp), None, mod_a, None, None, None, None

    # same-face case
    if dx == 0 and dy == 0:
        distance = Pointd(b.x - a.x, b.y - a.y)
        # normalize wrap-around
        if distance.x < -3 or distance.y < -3:
            distance.x += 5; distance.y += 5
            b.x += 5; b.y += 5
        elif distance.x > 3 or distance.y > 3:
            distance.x -= 5; distance.y -= 5
            b.x -= 5; b.y -= 5
        b_in_a_frame = Pointd(b.x, b.y)
        mod_a = Pointd(a.x, a.y)
        return distance, b_in_a_frame, mod_a, None, None, None, None

    # adjacent-face case: prepare pivot and rotated coords
    rotation = 0
    pivot = Point(f2.x if (dx > 0 or dy > 0) else f1.x,
                  f2.y if (dx > 0 or dy > 0) else f1.y)

    # compute rb = b - pivot
    rb = Pointd(b.x - pivot.x, b.y - pivot.y)

    # determine rotation amount
    north = pivot.x >= pivot.y
    top = (f1.x == f1.y)
    no_interruptions = (dx <= 0 and dy >= 0) if top else (dx >= 0 and dy <= 0)
    a_is_vertex = (abs(a.y - a.x) < _EPS) if top else (abs(a.y - a.x - 1.0) < _EPS)

    if (not no_interruptions) and (not a_is_vertex):
        if dx == -1:
            if dy == -1:
                rotation = -1 if north else 1
            elif dy == 0:
                rotation = 1 if north else -1
            elif dy == 1:
                rotation = 1
        elif dx == 0:
            if dy == -1:
                rotation = -1
            elif dy == 0:
                rotation = 1
            elif dy == 1:
                rotation = 1
        elif dx == 1:
            if dy == -1:
                rotation = 1
            elif dy == 0:
                rotation = 1
            elif dy == 1:
                rotation = 1 if north else -1

    if pivot.x - b.x < -3:
        pivot = Point(pivot.x + 5, pivot.y + 5)

    # apply rotation offset rotation times
    tmp_rb = Pointd(rb.x, rb.y)
    for _ in range(abs(rotation)):
        rotate5x6_offset(tmp_rb, tmp_rb.x, tmp_rb.y, rotation < 0)
    rb = Pointd(tmp_rb.x + pivot.x, tmp_rb.y + pivot.y)

    ddx = rb.x - a.x
    ddy = rb.y - a.y
    if ddx > 3 or ddy > 3:
        ddx -= 5; ddy -= 5
    elif ddx < -3 or ddy < -3:
        ddx += 5; ddy += 5

    # Delegate seam crossing detection and intersection computation to external function.
    crossing, i_src, i_dst, in_north, ends_at_edge = crosses5x6_interruption_v2_ex(a, ddx, ddy, final_cross=True)

    if not crossing:
        # No seam interruption detected
        if no_interruptions or a_is_vertex:
            distance = Pointd(b.x - a.x, b.y - a.y)
        else:
            distance = Pointd(ddx, ddy)

        # normalize wrap-around
        if distance.x < -3 or distance.y < -3:
            distance.x += 5; distance.y += 5
            b.x += 5; b.y += 5
        elif distance.x > 3 or distance.y > 3:
            distance.x -= 5; distance.y -= 5
            b.x -= 5; b.y -= 5

        b_in_a_frame = Pointd(b.x, b.y)
        mod_a = Pointd(a.x, a.y)
        return distance, b_in_a_frame, mod_a, i_src, i_dst, in_north, ends_at_edge
    else:
        # There is a seam crossing. Return ddx/ddy as nominal vector and rb as bInAFrame
        distance = Pointd(ddx, ddy)
        b_in_a_frame = Pointd(rb.x, rb.y)
        mod_a = Pointd(a.x, a.y)
        return distance, b_in_a_frame, mod_a, i_src, i_dst, in_north, ends_at_edge

def move5x6(o: Union[Pointd, Sequence[float]],
            dx: float,
            dy: float,
            nRotations: int,
            adjX: Optional[Sequence[float]] = None,
            adjY: Optional[Sequence[float]] = None,
            finalCross: bool = False) -> Pointd:
    """
    Port of the DGGAL move5x6 function.

    Parameters
    ----------
    o : Pointd or (x,y)
        Origin point.
    dx, dy : float
        Movement vector components.
    nRotations : int
        Number of 60-degree rotations to apply when interruption occurs.
    adjX, adjY : optional mutable sequences (e.g., [value]) or None
        If provided, they will be updated in-place to mirror pointer behavior.
    finalCross : bool
        If True, allow crossing at the final step.

    Returns
    -------
    Pointd
        The resulting point after moving.
    """
    # normalize origin input
    if isinstance(o, Pointd):
        c = Pointd(o.x, o.y)
    else:
        c = Pointd(float(o[0]), float(o[1]))

    # small constants
    EPS = 1e-11
    TINY = 1e-11

    if c.x < 0 and c.y < 1 + 1e-11:
        c.x += 5.0
        c.y += 5.0

    if abs(dx) < 1e-11 and abs(dy) < 1e-11:
        return c

    while True:
        cdx = c.x
        cdy = c.y
        rotation = 0
        north = not (cdy - cdx > 1)
        iy = int(math.floor(cdy + EPS))
        ix = int(math.floor(cdx + EPS))
        doNudge = True

        # Nudge logic for y-aligned grid lines
        if (abs(c.y - iy) < EPS and 0 <= iy <= 5
            and c.x > float(iy - 1) - EPS and c.x < float(iy) + EPS):
            cdy += 2 * sgn(dy) * EPS
            if c.x > float(iy - 1) + EPS and c.x < float(iy) - EPS:
                doNudge = False

        # Nudge logic for x-aligned grid lines
        if (abs(c.x - ix) < EPS and 0 <= ix <= 5
            and c.y > float(ix) - EPS and c.y < float(ix + 1) + EPS):
            cdx += 2 * sgn(dx) * EPS
            if c.y > float(ix) + EPS and c.y < float(ix + 1) - EPS:
                doNudge = False

        if doNudge:
            if not north:
                cdx += TINY
                cdy -= TINY
            else:
                cdx -= TINY
                cdy += TINY

        # Wrap-around adjustments (5x6 tiling)
        if cdx < 0 and cdy < 1 + 1e-11:
            cdx += 5.0; cdy += 5.0
            c.x += 5.0; c.y += 5.0
        if cdx > 5 and cdy > 5 - 1e-11:
            cdx -= 5.0; cdy -= 5.0
            c.x -= 5.0; c.y -= 5.0
        if cdy < 0 and cdx < 1e-11:
            cdx += 5.0; cdy += 5.0
            c.x += 5.0; c.y += 5.0

        # clamp
        if cdx < 0: cdx = 0.0
        if cdy < 0: cdy = 0.0
        if cdx > 5: cdx = 5.0
        if cdy > 6: cdy = 6.0

        cx = int(math.floor(cdx))
        cy = int(math.floor(cdy))

        # compute px, py (how far we can move within current cell)
        if dx < 0:
            px = max(cx - c.x, dx)
        else:
            px = min(cx + 1 - c.x, dx)

        if dy < 0:
            py = max(cy - c.y, dy)
        else:
            py = min(cy + 1 - c.y, dy)

        # if both dx and dy non-zero, synchronize to the earliest crossing
        if dx != 0.0 and dy != 0.0:
            pkx = px / dx
            pky = py / dy
            if pkx < pky:
                py = pkx * dy
            elif pky < pkx:
                px = pky * dx

        c.x += px
        c.y += py

        # if not finalCross and we've consumed the entire dx/dy, break
        if not finalCross:
            if abs(dx - px) < 1e-11 and abs(dy - py) < 1e-11:
                break

        # determine next cell indices (nx, ny)
        atVertex = (abs(c.x - int(c.x + 0.5)) < EPS and
                    abs(c.y - int(c.y + 0.5)) < EPS)

        nx = int(math.floor(c.x + EPS * sgn(dx)))
        ny = int(math.floor(c.y + EPS * sgn(dy)))

        if atVertex and abs(dx) > EPS and abs(dy) <= EPS:
            ny = cy
            nx = cx + sgn(dx)
        elif atVertex and abs(dy) > EPS and abs(dx) <= EPS:
            nx = cx
            ny = cy + sgn(dy)
        elif nx > cx and ny < cy:
            nx = cx
        elif nx < cx and ny > cy:
            ny = cy

        # interruption handling
        if nx != cx or ny != cy:
            nNorth = not ((cx + cy) & 1)

            if nNorth:
                # North
                if (ny == cy and nx == cx + 1):
                    # Crossing interruption to the right
                    iy2 = int(c.x - 1 + 1e-11)
                    # c = { iy + 2 - (c.y - iy), c.x };
                    c = Pointd(iy2 + 2 - (c.y - iy2), c.x)
                    rotation = -1
                elif nx == cx and ny == cy - 1:
                    # Crossing interruption to the left
                    ix2 = int(c.y + 1e-11)
                    c = Pointd(c.y, ix2 - (c.x - ix2))
                    rotation = 1
            else:
                # South
                if nx == cx and ny == cy + 1:
                    ix2 = int(c.y - 2 + 1e-11)
                    c = Pointd(c.y - 1, ix2 + 3 - (c.x - ix2))
                    rotation = 1
                elif ny == cy and nx == cx - 1:
                    iy2 = int(c.x + 1 + 1e-11)
                    c = Pointd(iy2 - 1 - (c.y - iy2), c.x + 1)
                    rotation = -1

        # consume the portion we moved
        dx -= px
        dy -= py

        # more wrap-around corrections
        if c.x < -1e-11 and c.y < 1 + 1e-11:
            c.x += 5.0; c.y += 5.0
        elif c.y < 0 and c.x < 1e-11:
            c.x += 5.0; c.y += 5.0
        elif c.x > 5 - 1e-11 and c.y > 6 + 1e-11:
            c.x -= 5.0; c.y -= 5.0

        # Apply rotation(s) if interruption required one
        if rotation:
            for _ in range(nRotations):
                if rotation == -1:
                    # 60 degrees clockwise rotation
                    ndx = dx - dy
                    dy = dx
                    dx = ndx
                    if adjX is not None and adjY is not None:
                        nax = adjX[0] - adjY[0]
                        adjY[0] = adjX[0]
                        adjX[0] = nax
                else:
                    # 60 degrees counter-clockwise rotation
                    ndy = dy - dx
                    dx = dy
                    dy = ndy
                    if adjX is not None and adjY is not None:
                        nay = adjY[0] - adjX[0]
                        adjX[0] = adjY[0]
                        adjY[0] = nay

        if abs(dx) < 1e-11:
            dx = 0.0
        if abs(dy) < 1e-11:
            dy = 0.0

        if dx == 0.0 and dy == 0.0:
            break

    return c



================================================
FILE: high-vibes/fg/faces.py
================================================
# faces.py
"""
5x6 face helpers

Provides:
  - Point (integer face coordinates)
  - Pointd (floating 5x6 coordinates)
  - get_face(p) -> (face: Point)

get_face mirrors the behavior of the eC getFace function.
It normalizes wrap-around, applies tiny eps offsets, clamps to valid ranges,
and returns the integer face (cx,cy) and fractional coordinates inside that face.
"""

from dataclasses import dataclass
import math
from typing import Tuple

# Small tolerances copied from the original logic
_EPS_SMALL = 1e-13
_EPS_EDGE = 1e-11

@dataclass
class Point:
    x: int
    y: int

@dataclass
class Pointd:
    x: float
    y: float

def _clamp(v: float, lo: float, hi: float) -> float:
    if v < lo:
        return lo
    if v > hi:
        return hi
    return v

def get_face(a: Pointd) -> Tuple[Point, Pointd]:
    """
    Determine the 5x6 face and fractional coordinates for point `a`.

    Parameters
    - a: Pointd in 5x6 coordinates (may be outside canonical range)

    Returns
    - (face: Point, d: Pointd) where:
        face.x, face.y are integer tile indices (cx, cy)
        d.x, d.y are fractional coordinates inside that tile (cdx - cx, cdy - cy)
    """
    # Work on a copy
    c_x = float(a.x)
    c_y = float(a.y)

    # initial wrap adjustment from original code
    if c_x < 0.0 and c_y < 1.0 + _EPS_EDGE:
        c_x += 5.0
        c_y += 5.0

    # apply tiny epsilon offsets to avoid exact-boundary ambiguity
    cdx = c_x + _EPS_SMALL
    cdy = c_y + _EPS_SMALL

    # additional wrap adjustments mirroring original logic
    if cdx < 0.0 and cdy < 1.0 + _EPS_EDGE:
        cdx += 5.0
        cdy += 5.0
        c_x += 5.0
        c_y += 5.0

    if cdx > 5.0 and cdy > 5.0 - _EPS_EDGE:
        cdx -= 5.0
        cdy -= 5.0
        c_x -= 5.0
        c_y -= 5.0

    if cdy < 0.0 and cdx < 1e-11:
        cdx += 5.0
        cdy += 5.0
        c_x += 5.0
        c_y += 5.0

    # clamp to valid ranges used in original code
    cdx = _clamp(cdx, 0.0, 5.0)
    cdy = _clamp(cdy, 0.0, 6.0)

    cx = int(math.floor(cdx))
    cy = int(math.floor(cdy))

    # special-case adjustments for pole/edge conditions
    if (cx - cy == 1) and (cdx - cx < _EPS_EDGE):
        # North pole or right at left-side of northern interruption
        cx -= 1
    elif (cy - cx == 2) and (cdy - cy < _EPS_EDGE):
        # South pole or right at left-side of southern interruption
        cy -= 1

    face = Point(cx, cy)
    d = Pointd(cdx - cx, cdy - cy)
    return face, d



================================================
FILE: high-vibes/fg/fix_topology_5x6.py
================================================
#!/usr/bin/env python3
# 5x6 space geometry topology-fixer
# - should correctly handle inner-rings (holes) per polygon
# - using Sutherland-Hodgman clipping and distance5x6 insertion logic
# - strict per-polygon processing: we expand MultiPolygon into polygon parts
# - minimal, deterministic fallback if hole subtraction raises

from typing import List, Tuple, Dict, Any, Optional
from copy import deepcopy
import json
import math
import sys

from shapely.geometry import shape, mapping, Polygon, MultiPolygon
from shapely.ops import unary_union
from shapely.affinity import rotate
import shapely

from fg.faces import Pointd
from fg.distance import distance5x6
from fg.sutherlandHodgman import *

# Configuration (kept as in working version)
_PERIOD = 5.0
_TINY = 1e-14
_MAX_ITERS = 512            # safety bound for iterative intersection insertion
_AREA_EPS = 1e-12
_EPS_TIE = 1e-12

TILE_X_COUNT = 5
TILE_Y_COUNT = 6

DUP_EPS = 1e-10

from typing import List, Tuple

def collapse_near_duplicates(ring: List[Tuple[float, float]], eps: float = 1e-9) -> List[Tuple[float, float]]:
    # Remove consecutive nearly identical vertices using Manhattan distance.
    # Preserves a closing duplicate at the end. No area or validity checks.

    if not ring:
        return ring

    # ensure closing duplicate for processing
    if ring[0] != ring[-1]:
        ring = list(ring) + [ring[0]]
    else:
        ring = list(ring)

    out: List[Tuple[float, float]] = [ring[0]]
    for x, y in ring[1:]:
        prev_x, prev_y = out[-1]
        if abs(x - prev_x) + abs(y - prev_y) > eps:
            out.append((x, y))

    # ensure closure
    if out[0] != out[-1]:
        out.append(out[0])

    return out

# ---------------------------
# distance5x6 insertion
# ---------------------------
def _within_same_tile(a: Tuple[float,float], b: Tuple[float,float]) -> bool:
   return (math.floor(a[0]) == math.floor(b[0])) and (math.floor(a[1]) == math.floor(b[1]))

def _choose_segment_shift(a: Tuple[float,float], b: Tuple[float,float], period: float = _PERIOD, max_shift: int = 2) -> Tuple[int,int]:
   ax, ay = a; bx, by = b
   best = (0, 0)
   best_score = float("inf")
   for sx in range(-max_shift, max_shift + 1):
      tx = bx + sx * period
      dx2 = (tx - ax) * (tx - ax)
      for sy in range(-max_shift, max_shift + 1):
         ty = by + sy * period
         dy2 = (ty - ay) * (ty - ay)
         score = dx2 + dy2
         if score < best_score:
            best_score = score
            best = (sx, sy)
   return best

def _insert_segment_exact(a: Tuple[float,float], b: Tuple[float,float],
                          feature_id: str, seg_index: int,
                          seg_debug_store: Dict[int, List[Dict[str,Any]]],
                          period: float = _PERIOD, max_shift: int = 2) -> List[Tuple[float,float]]:
   out_pts: List[Tuple[float,float]] = []
   cur = Pointd(float(a[0]), float(a[1]))
   tgt = Pointd(float(b[0]), float(b[1]))
   per_debug: List[Dict[str,Any]] = []

   if _within_same_tile((cur.x,cur.y),(tgt.x,tgt.y)):
      seg_debug_store[seg_index] = per_debug
      return [(tgt.x, tgt.y)]

   iters = 0
   while True:
      iters += 1
      if iters > _MAX_ITERS:
         per_debug.append({"error":"max_iters"})
         out_pts.append((tgt.x, tgt.y))
         break

      distance, b_in_a_frame, mod_a, i_src, i_dst, in_north, ends_at_edge = distance5x6(cur, tgt)

      entry = {
         "iter": iters,
         "current": (cur.x, cur.y),
         "target": (tgt.x, tgt.y),
         "i_src": (i_src.x, i_src.y) if i_src else None,
         "i_dst": (i_dst.x, i_dst.y) if i_dst else None,
         "in_north": in_north,
         "ends_at_edge": ends_at_edge,
         "note": "raw-endpoints-call"
      }
      per_debug.append(entry)

      if i_src is None or i_dst is None:
         out_pts.append((tgt.x, tgt.y))
         break

      i_src_global = (i_src.x, i_src.y)
      i_dst_global = (i_dst.x, i_dst.y)

      last = out_pts[-1] if out_pts else (cur.x, cur.y)
      if not (abs(last[0] - i_src_global[0]) < _TINY and abs(last[1] - i_src_global[1]) < _TINY):
         out_pts.append(i_src_global)
      last = out_pts[-1] if out_pts else (cur.x, cur.y)
      if not (abs(last[0] - i_dst_global[0]) < _TINY and abs(last[1] - i_dst_global[1]) < _TINY):
         out_pts.append(i_dst_global)

      cur = Pointd(i_dst.x, i_dst.y)

      if abs(cur.x - tgt.x) < _TINY and abs(cur.y - tgt.y) < _TINY:
         if not (abs(out_pts[-1][0] - tgt.x) < _TINY and abs(out_pts[-1][1] - tgt.y) < _TINY):
            out_pts.append((tgt.x, tgt.y))
         break

   seg_debug_store[seg_index] = per_debug
   return out_pts

def _insert_ring_coords(coords: List[Tuple[float,float]], fid: str, part_idx: int) -> Tuple[List[Tuple[float,float]], Dict[int, List[Dict[str,Any]]]]:
   seg_debug_store: Dict[int, List[Dict[str,Any]]] = {}
   out_coords: List[Tuple[float,float]] = [coords[0]]
   for i in range(len(coords)-1):
      a = coords[i]; b = coords[i+1]
      inserted = _insert_segment_exact(a, b, fid, i, seg_debug_store)
      for p in inserted:
         if out_coords and (abs(out_coords[-1][0]-p[0]) < _TINY and abs(out_coords[-1][1]-p[1]) < _TINY):
            continue
         out_coords.append(p)
   if out_coords and (out_coords[0] != out_coords[-1]):
      out_coords.append(out_coords[0])
   return out_coords, seg_debug_store

def _candidate_tiles_from_vertices(coords: List[Tuple[float,float]], margin_neighbors: int = 1) -> List[Tuple[int,int]]:
   tiles = set()
   ring = list(coords)
   if ring and ring[0] != ring[-1]:
      ring.append(ring[0])
   shifts = (0.0, -_PERIOD, +_PERIOD)
   for (x,y) in ring:
      for s in shifts:
         nx = x + s
         ny = y + s
         tx = math.floor(nx)
         ty = math.floor(ny)
         for dx in range(-margin_neighbors, margin_neighbors+1):
            for dy in range(-margin_neighbors, margin_neighbors+1):
               ttx = tx + dx
               tty = ty + dy
               if 0 <= ttx < TILE_X_COUNT and 0 <= tty < TILE_Y_COUNT:
                  tiles.add((ttx, tty))
   return sorted(list(tiles))

# ---------------------------
# Shift selection (prev-vertex continuity rule)
# ---------------------------
from typing import List, Tuple, Optional

def _choose_shifts_prev_vertex(coords: List[Tuple[float, float]],
                               tx: int,
                               ty: int,
                               fid_for_debug: Optional[str] = None) -> List[float]:
    SHIFT = _PERIOD
    EPS_TIE = _EPS_TIE
    cx = tx + 0.5
    cy = ty + 0.5

    ring = list(coords)
    if ring and ring[0] != ring[-1]:
        ring.append(ring[0])
    n = len(ring)
    if n == 0:
        return []

    closed = (ring[0] == ring[-1])
    m = n - 1 if closed else n  # number of unique vertices

    def l1(p, qx, qy):
        return abs(p[0] - qx) + abs(p[1] - qy)

    candidates = [0.0, SHIFT, -SHIFT]
    shifts: List[float] = [0.0] * n

    # per-vertex best single shift (Manhattan)
    best_single_shift: List[float] = [0.0] * n
    best_single_l1: List[float] = [0.0] * n
    for i in range(n):
        xi, yi = ring[i]
        best_s = 0.0
        best_d = l1((xi, yi), cx, cy)
        d_plus = l1((xi + SHIFT, yi + SHIFT), cx, cy)
        d_minus = l1((xi - SHIFT, yi - SHIFT), cx, cy)
        if d_plus + EPS_TIE < best_d:
            best_d = d_plus; best_s = SHIFT
        if d_minus + EPS_TIE < best_d:
            best_d = d_minus; best_s = -SHIFT
        best_single_shift[i] = best_s
        best_single_l1[i] = best_d

    # choose anchor by minimal best-single L1 (exclude duplicate closing vertex)
    anchor = 0
    min_d = None
    for i in range(m):
        if min_d is None or best_single_l1[i] < min_d:
            min_d = best_single_l1[i]
            anchor = i

    # --- conditional uniform-seed shortcut (only when anchor is first and span test) ---
    try:
        poly_orig = Polygon(ring)
    except Exception:
        poly_orig = None
    if best_single_shift[anchor] == 0.0 and poly_orig is not None and poly_orig.is_valid and len(poly_orig.interiors) == 0 and poly_orig.area > _AREA_EPS:
        xs = [p[0] for p in ring[:m]]
        if xs:
            if (max(xs) - min(xs)) > 3:
                seed = best_single_shift[anchor]
                shifted_coords = [(x + seed, y + seed) for (x, y) in ring]
                try:
                    poly_shifted = Polygon(shifted_coords)
                except Exception:
                    poly_shifted = None
                if poly_shifted is not None and poly_shifted.is_valid and len(poly_shifted.interiors) == 0 and poly_shifted.area > _AREA_EPS:
                    return [float(seed) for _ in range(n)]
    # ------------------------------------------------------------------------------

    # seed anchor with its best single shift
    shifts[anchor] = best_single_shift[anchor]

    # forward propagation (anchor+1 .. n-1)
    prev_x = ring[anchor][0] + shifts[anchor]
    prev_y = ring[anchor][1] + shifts[anchor]
    for i in range(anchor + 1, n):
        xi, yi = ring[i]
        ordered_candidates = [shifts[i - 1]] + [c for c in candidates if c != shifts[i - 1]]
        best_s = None
        best_score = None
        for s in ordered_candidates:
            lx = xi + s
            ly = yi + s
            score = abs(lx - prev_x) + abs(ly - prev_y)
            if best_score is None or score + EPS_TIE < best_score:
                best_score = score
                best_s = s
        shifts[i] = best_s if best_s is not None else 0.0
        prev_x = xi + shifts[i]
        prev_y = yi + shifts[i]

    # backward propagation (anchor-1 .. 0)
    for i in range(anchor - 1, -1, -1):
        xi, yi = ring[i]
        ordered_candidates = [shifts[i + 1]] + [c for c in candidates if c != shifts[i + 1]]
        best_s = None
        best_score = None
        next_x = ring[i + 1][0] + shifts[i + 1]
        next_y = ring[i + 1][1] + shifts[i + 1]
        for s in ordered_candidates:
            lx = xi + s
            ly = yi + s
            score = abs(lx - next_x) + abs(ly - next_y)
            if best_score is None or score + EPS_TIE < best_score:
                best_score = score
                best_s = s
        shifts[i] = best_s if best_s is not None else 0.0

    # n >= 3 special-case pass (preserve continuity across closure) using Manhattan metrics
    if n >= 3:
        first_x, first_y = ring[0][0] + shifts[0], ring[0][1] + shifts[0]
        last_idx = n - 1
        last_x, last_y = ring[last_idx][0] + shifts[last_idx], ring[last_idx][1] + shifts[last_idx]
        prev_idx = last_idx - 1
        prev_local_x, prev_local_y = ring[prev_idx][0] + shifts[prev_idx], ring[prev_idx][1] + shifts[prev_idx]
        close_l1 = abs(last_x - first_x) + abs(last_y - first_y)
        avg_edge = (abs(last_x - prev_local_x) + abs(last_y - prev_local_y) +
                    abs(prev_local_x - first_x) + abs(prev_local_y - first_y)) / 2.0
        if avg_edge > 0 and close_l1 > 16.0 * avg_edge:
            ordered_candidates = [shifts[prev_idx]] + [c for c in candidates if c != shifts[prev_idx]]
            best_s = shifts[last_idx]
            best_close = close_l1
            cont_current = abs(last_x - prev_local_x) + abs(last_y - prev_local_y)
            for s in ordered_candidates:
                lx = ring[last_idx][0] + s
                ly = ring[last_idx][1] + s
                new_close = abs(lx - first_x) + abs(ly - first_y)
                cont = abs(lx - prev_local_x) + abs(ly - prev_local_y)
                metric = new_close + 4.0 * cont
                current_metric = best_close + 4.0 * cont_current
                if metric + EPS_TIE < current_metric:
                    best_s = s
                    best_close = new_close
                    cont_current = cont
            if best_s != shifts[last_idx]:
                shifts[last_idx] = best_s

    return [float(s) for s in shifts]

# ---------------------------
# Localize ring using chosen shifts
# ---------------------------
def _localized_ring_on_the_fly(coords, tx, ty, fid=""):
   ring = list(coords)
   if ring and ring[0] != ring[-1]:
      ring.append(ring[0])
   shifts = _choose_shifts_prev_vertex(ring, tx, ty, fid_for_debug=fid)
   localized = []
   for i, (x, y) in enumerate(ring):
      s = shifts[i] if i < len(shifts) else 0.0
      localized.append((x + s, y + s))
   if localized and localized[0] != localized[-1]:
      localized.append(localized[0])
   return localized, None

# ---------------------------
# Tile clipping and assembly (core behavior)
# This version is polygon-part aware: it accepts an exterior ring and a list of hole rings.
# ---------------------------
def _tile_and_filter_staircase_polygon(exterior_coords: List[Tuple[float,float]],
                                       holes_coords: List[List[Tuple[float,float]]],
                                       fid: str, part_idx: int) -> List[Dict[str,Any]]:
   # Build a polygon from the provided rings for area checks; we do not rely on its validity for clipping
   try:
      poly = Polygon(exterior_coords, holes_coords)
   except Exception:
      poly = Polygon(exterior_coords)

   if poly.is_empty:
      return []

   candidates = _candidate_tiles_from_vertices(exterior_coords, margin_neighbors=1)
   pieces: List[Dict[str,Any]] = []
   for tx, ty in candidates:
      #if tx != 1 or ty != 1: continue
      #if fid != 221: continue

      if not (ty == tx or ty == tx + 1):
         continue

      # Localize exterior and holes using the same shift logic
      localized_ext, _ = _localized_ring_on_the_fly(exterior_coords, tx, ty, fid=str(fid))
      localized_holes: List[List[Tuple[float,float]]] = []
      for h in holes_coords or []:
         if not h:
            continue
         # ensure ring closure handling
         hh = list(h)
         if hh and hh[0] != hh[-1]:
            hh.append(hh[0])
         # localize hole relative to exterior shifts by choosing nearest exterior vertex shift
         # reuse _choose_shifts_prev_vertex logic indirectly via _localized_ring_on_the_fly on exterior
         # compute localized hole by mapping each hole vertex to nearest exterior index shift
         # (this mirrors earlier behavior where holes are attached to exterior via nearest vertex)
         # For simplicity and determinism we compute shifts from exterior and apply to hole vertices
         ext_ring = list(exterior_coords)
         if ext_ring and ext_ring[0] != ext_ring[-1]:
            ext_ring.append(ext_ring[0])
         shifts = _choose_shifts_prev_vertex(ext_ring, tx, ty, fid_for_debug=str(fid))
         # drop last duplicate in ext_ring to align shifts length
         if shifts and len(shifts) == len(ext_ring):
            shifts_use = shifts[:-1]
         else:
            shifts_use = shifts
         localized_h = []
         for (hx, hy) in hh:
            # find nearest exterior vertex index
            best_idx = 0
            best_d = None
            for idx, (exx, exy) in enumerate(ext_ring[:-1]):
               dx = hx - exx; dy = hy - exy
               d = dx*dx + dy*dy
               if best_d is None or d < best_d:
                  best_d = d; best_idx = idx
            s = shifts_use[best_idx] if best_idx < len(shifts_use) else 0.0
            localized_h.append((hx + s, hy + s))
         if localized_h and (localized_h[0] != localized_h[-1]):
            localized_h.append(localized_h[0])
         if len(localized_h) >= 3:
            localized_holes.append(localized_h)

      # Clip exterior ring
      clipped = rect_clip_polygon(localized_ext, tx, ty, tx+1, ty+1)
      if not clipped:
         continue

      clipped = collapse_near_duplicates(clipped, eps=DUP_EPS)

      # Clip holes individually and build hole polygons
      hole_polys: List[Polygon] = []
      for hh in localized_holes:
         clipped_h = rect_clip_polygon(hh, tx, ty, tx+1, ty+1)
         if not clipped_h:
            continue

         clipped_h = collapse_near_duplicates(clipped_h, eps=DUP_EPS)

         if clipped_h and clipped_h[0] == clipped_h[-1]:
            clipped_h = clipped_h[:-1]
         if len(clipped_h) < 3:
            continue
         hp = Polygon(clipped_h)
         if hp.is_empty or hp.area <= 0.0:
            continue
         hole_polys.append(hp)

      # Build outer polygon from clipped exterior
      if clipped and clipped[0] == clipped[-1]:
         clipped = clipped[:-1]
      if len(clipped) < 3:
         continue
      outer_poly = Polygon(clipped)
      if outer_poly.is_empty or outer_poly.area <= 0.0:
         continue

      # If there are holes, subtract them; if subtraction fails, fall back to outer_poly (preserve prior behavior)
      final_polys: List[Polygon] = []
      if not hole_polys:
         final_polys = [outer_poly]
      else:
         try:
            hole_union = unary_union(hole_polys)
            # short-circuit trivial cases
            if hole_union.is_empty:
               final_polys = [outer_poly]
            else:
               # attempt difference; if it raises, fall back to outer_poly
               try:
                  result = outer_poly.difference(hole_union)
                  if isinstance(result, Polygon):
                     if not result.is_empty and result.area > 0.0:
                        final_polys = [result]
                  else:
                     for sub in getattr(result, "geoms", []) or []:
                        if isinstance(sub, Polygon) and not sub.is_empty and sub.area > 0.0:
                           final_polys.append(sub)
               except Exception:
                  # fallback to outer only (this mirrors tolerant earlier behavior)
                  final_polys = [outer_poly]
         except Exception:
            final_polys = [outer_poly]

      # Filter and accept pieces
      for geom in final_polys:
         if geom is None or geom.is_empty or geom.area <= 0.0:
            continue
         # quick bounding check: ensure coords lie within tile bounds (with tiny tolerance)
         ok = True
         bounding_tol = 1e-12
         for (cx, cy) in list(geom.exterior.coords):
            if not (tx - bounding_tol <= cx <= tx + 1 + bounding_tol and
                    ty - bounding_tol <= cy <= ty + 1 + bounding_tol):
               ok = False; break
         if not ok:
            continue
         if geom.area <= _AREA_EPS:
            continue
         pieces.append({"tile_x": tx, "tile_y": ty, "geom": geom, "orig_fid": fid, "part_idx": part_idx})
   return pieces

# Wrapper that accepts exterior+holes or a Polygon/MultiPolygon shapely object
def _tile_and_filter_staircase(exterior_or_poly, holes_coords: Optional[List[List[Tuple[float,float]]]], fid: str, part_idx: int) -> List[Dict[str,Any]]:
   """
   Accepts either:
    - exterior_or_poly: list of exterior coords and holes_coords provided separately, or
    - exterior_or_poly: a shapely Polygon or MultiPolygon (in which case holes are extracted)
   For compatibility with the original pipeline we support both call styles.
   """
   # If caller passed a shapely Polygon, extract rings
   if isinstance(exterior_or_poly, Polygon):
      ext = list(exterior_or_poly.exterior.coords)
      holes = [list(h.coords) for h in exterior_or_poly.interiors]
      return _tile_and_filter_staircase_polygon(ext, holes, fid, part_idx)
   if isinstance(exterior_or_poly, MultiPolygon):
      pieces: List[Dict[str,Any]] = []
      for idx, sub in enumerate(getattr(exterior_or_poly, "geoms", []) or []):
         if isinstance(sub, Polygon):
            pieces.extend(_tile_and_filter_staircase_polygon(list(sub.exterior.coords),
                                                            [list(h.coords) for h in sub.interiors],
                                                            fid, part_idx))
      return pieces
   # otherwise assume exterior_or_poly is exterior coords list and holes_coords provided
   if isinstance(exterior_or_poly, list):
      return _tile_and_filter_staircase_polygon(exterior_or_poly, holes_coords or [], fid, part_idx)
   raise ValueError("_tile_and_filter_staircase expects exterior coords list or shapely Polygon/MultiPolygon")

# ---------------------------
# Validation, repair, staged union, assembly
# ---------------------------
def _validate_geom(g):
   return (not g.is_empty) and (g.area > 0.0) and g.is_valid

def _repair_geom(g):
   r = g.buffer(0)
   if not r.is_empty and r.area > 0.0 and r.is_valid:
      return r
   return g

#def _staged_union_polygons(polys: List[Polygon], fid: str):
#   if not polys:
#      return None, []
#   skipped = []
#   merged = unary_union(polys)
#   return merged, skipped

def _staged_union_polygons(polys: List[Polygon], fid: str):
   result = None
   if polys:
      result = shapely.union_all(polys, grid_size=1e-10)
      #result = result.buffer( 1e-9)
      #result = result.buffer(-1e-9)

      #result = unary_union(polys, grid_size=1e-9)
      #result = result.buffer(1e-9)  # This is the smallest epsilon that avoids the seams
      #result = MultiPolygon(polys)
   return result, []

def _assemble_feature_from_pieces(all_kept_pieces: List[Dict[str,Any]], fid: str, props: Dict[str,Any]) -> List[Dict[str,Any]]:
   polys = []
   for p in all_kept_pieces:
      g = p["geom"]
      if isinstance(g, Polygon):
         polys.append(g)
      elif isinstance(g, MultiPolygon):
         for sub in g.geoms:
            polys.append(sub)
      else:
         for sub in getattr(g, "geoms", []) or []:
            if isinstance(sub, Polygon):
               polys.append(sub)
   valid_polys = []
   invalid_indices = []
   for i, p in enumerate(polys):
      if _validate_geom(p):
         valid_polys.append(p)
      else:
         rp = _repair_geom(p)
         if _validate_geom(rp):
            valid_polys.append(rp)
         else:
            invalid_indices.append(i)
   merged, skipped = _staged_union_polygons(valid_polys, fid)
   out_features = []
   if merged is None:
      for i, p in enumerate(valid_polys):
         out_features.append({"type":"Feature","id": f"{fid}_part_{i}","properties": props,"geometry": mapping(p)})
   else:
      if isinstance(merged, Polygon):
         out_features.append({"type":"Feature","id": fid,"properties": props,"geometry": mapping(merged)})
      elif isinstance(merged, MultiPolygon):
         out_features.append({"type":"Feature","id": fid,"properties": props,"geometry": mapping(merged)})
      else:
         polys2 = []
         for g in getattr(merged, "geoms", []) or []:
            if isinstance(g, Polygon):
               polys2.append(g)
            elif isinstance(g, MultiPolygon):
               for sub in g.geoms:
                  polys2.append(sub)
         if not polys2:
            out_features.append({"type":"Feature","id": fid,"properties": props,"geometry": mapping(Polygon())})
         elif len(polys2) == 1:
            out_features.append({"type":"Feature","id": fid,"properties": props,"geometry": mapping(polys2[0])})
         else:
            out_features.append({"type":"Feature","id": fid,"properties": props,"geometry": mapping(MultiPolygon(polys2))})
   return out_features

# ---------------------------
# High-level feature processing (preserve original flow)
# This version expands MultiPolygon into polygon parts and passes exterior+holes to the tileper-part function.
# ---------------------------
def fix_feature_5x6_topology(feature: Dict[str,Any]) -> List[Dict[str,Any]]:
   geom_json = feature.get("geometry")
   if geom_json is None:
      return []
   shp = shape(geom_json)
   fid = feature.get("id") or feature.get("properties",{}).get("id") or "0"
   props = feature.get("properties", {})
   out_features: List[Dict[str,Any]] = []

   parts = []
   # parts will be list of tuples: (exterior_coords, [hole_coords...])
   if shp.geom_type == "Polygon":
      ext = list(shp.exterior.coords)
      holes = [list(h.coords) for h in shp.interiors]
      parts = [(ext, holes)]
   elif shp.geom_type == "MultiPolygon":
      parts = []
      for p in shp.geoms:
         if isinstance(p, Polygon):
            ext = list(p.exterior.coords)
            holes = [list(h.coords) for h in p.interiors]
            parts.append((ext, holes))
   else:
      return []

   all_kept_pieces: List[Dict[str,Any]] = []
   for pidx, (ext_ring, hole_rings) in enumerate(parts):
      inserted_coords, seg_debug = _insert_ring_coords(ext_ring, fid, pidx)
      pieces = _tile_and_filter_staircase(inserted_coords, hole_rings, fid, pidx)
      all_kept_pieces.extend(pieces)

   if not all_kept_pieces:
      return []

   assembled = _assemble_feature_from_pieces(all_kept_pieces, fid, props)
   return assembled

# ---------------------------
# FeatureCollection processing
# ---------------------------
def fix_feature_collection_5x6_topology(gj: Dict[str,Any]) -> Dict[str,Any]:
   if gj.get("type") != "FeatureCollection":
      return {"type":"FeatureCollection","features":[]}
   out_gj = {"type":"FeatureCollection", "features": []}
   for feat in gj.get("features", []):
      out = fix_feature_5x6_topology(feat)
      if out:
         out_gj["features"].extend(out)
   return out_gj

# ---------------------------
# Feature processing pipeline (emit tiles option)
# This mirrors the original pipeline but expands MultiPolygon parts and includes holes.
# ---------------------------
def _process_feature(feature: Dict[str,Any], emit_tiles: bool) -> List[Dict[str,Any]]:
   geom_json = feature.get("geometry")
   if geom_json is None:
      return [feature]
   shp = shape(geom_json)
   fid = feature.get("id") or feature.get("properties",{}).get("id") or "0"
   props = feature.get("properties", {})

   all_kept_pieces: List[Dict[str,Any]] = []

   if shp.geom_type == "Polygon":
      parts = [(list(shp.exterior.coords), [list(h.coords) for h in shp.interiors])]
   elif shp.geom_type == "MultiPolygon":
      parts = []
      for p in shp.geoms:
         if isinstance(p, Polygon):
            parts.append((list(p.exterior.coords), [list(h.coords) for h in p.interiors]))
   else:
      return [feature]

   for pidx, (coords, holes) in enumerate(parts):
      inserted_coords, seg_debug_store = _insert_ring_coords(coords, fid, pidx)
      kept = _tile_and_filter_staircase(inserted_coords, holes, fid, pidx)
      all_kept_pieces.extend(kept)

   if emit_tiles:
      out_feats: List[Dict[str,Any]] = []
      for p in all_kept_pieces:
         geom = p["geom"]
         out_feats.append({"type":"Feature","id": f"{fid}_p{p['part_idx']}_t{p['tile_x']}_{p['tile_y']}",
                           "properties": {"tile_x": p["tile_x"], "tile_y": p["tile_y"], "orig_fid": fid, "part_idx": p["part_idx"]},
                           "geometry": mapping(geom)})
      return out_feats

   return _assemble_feature_from_pieces(all_kept_pieces, fid, props)

def fix_geojson_file_5x6_topology(input_path: str, output_path: str):
   # Load GeoJSON FeatureCollection from input_path, run the high-level
   # topology fixer (fix_feature_collection_5x6_topology) and write the result
   # to output_path.

   with open(input_path, "r", encoding="utf-8") as fh:
      data = json.load(fh)

   out_fc = fix_feature_collection_5x6_topology(data)

   with open(output_path, "w", encoding="utf-8") as fh:
      json.dump(out_fc, fh, ensure_ascii=False, indent=3)



================================================
FILE: high-vibes/fg/fixWGS84.py
================================================
from fg.sutherlandHodgman import *
from fg.fix_topology_5x6 import collapse_near_duplicates

import json
import os
from math import floor
from typing import Any, Dict, List, Optional, Tuple
from shapely.geometry import (
   Point,
   MultiPoint,
   LineString,
   MultiLineString,
   Polygon,
   MultiPolygon,
   GeometryCollection,
   box,
   mapping,
)
from shapely.ops import unary_union, linemerge
from shapely.validation import explain_validity
import shapely

# ---------- simple file-level debug flag (hardcoded) ----------
DEBUG = False # True
_DEBUG_OUT_DIR = "wgs84_debug_tiles"   # directory where per-tile debug files will be written

# ---------- constants ----------
DUP_EPS = 1e-12
_AREA_EPS = 1e-12

# ---------- tiles and thresholds (4 tiles) ----------
# tiles: xmin, ymin, xmax, ymax
TILES_4 = [
   (-180.0, -90.0, -90.0, 90.0),   # q = 0
   (-90.0, -90.0, 0.0, 90.0),      # q = 1
   (0.0, -90.0, 90.0, 90.0),       # q = 2
   (90.0, -90.0, 180.0, 90.0),     # q = 3
]

# small epsilon used in wrapLonAt comparisons (degrees)
_EPS = 1e-9

# ---------- wrap helpers (degree-based translation of Radians code) ----------
def wrap_lon_at(lon: float, c_lon: float) -> float:
   # - lon: input longitude in degrees (raw input, assumed in -180..180).
   # - c_lon: tile center longitude in degrees.

   # Returns shifted longitude (absolute degrees) such that the returned value is
   # within +/-180 of the tile center.

   # Work in lon relative to center
   rel = lon - c_lon

   # coarse wrap into (-180,180] using floor-based single-step style (but allow multiple-step via floor)
   # This mirrors the logic:
   # if(rel < -180 - eps) rel += 360 * floor((180 - rel)/360)
   # elif(rel > 180 + eps) rel -= 360 * floor((rel + 180)/360)
   if rel < -180.0 - _EPS:
      rel += 360.0 * floor((180.0 - rel) / 360.0)
   elif rel > 180.0 + _EPS:
      rel -= 360.0 * floor((rel + 180.0) / 360.0)

   # return absolute lon (relative + center)
   return rel + c_lon

# ---------- localization using wrap_lon_at ----------
def _localize_ring_with_wrap(ring: List[Tuple[float, float]],
                                      tile_center: float
                                      ) -> Tuple[List[Tuple[float, float]], List[float]]:
   """
   Anchor-based localization that calls wrap_lon_at using the neighbor's shifted longitude
   as the reference (no separate normalization step).

   Behavior:
   - Choose an anchor vertex closest in longitude to tile_center.
   - Compute anchor_shifted = wrap_lon_at(anchor_lon, tile_center).
   - Propagate forward from anchor: for each next vertex call
       wrap_lon_at(lon, prev_shifted)
     where prev_shifted is the previously shifted longitude (neighbor-based reference).
   - Propagate backward from anchor similarly (walking backwards).
   - Preserve ring closure if input ring was closed (first == last).
   - Return (localized_ring, shifts) where shifts[i] = localized_lon[i] - original_lon[i].
   """
   n = len(ring)
   if n == 0:
      return [], []

   # preserve whether input was closed (first == last)
   closed_input = (ring[0] == ring[-1]) and n > 1
   # if closed, ignore the duplicate last point for indexing convenience
   if closed_input:
      ring_core = ring[:-1]
   else:
      ring_core = list(ring)

   m = len(ring_core)
   if m == 0:
      return [], []

   # convert to floats
   orig_lons = [float(lon) for lon, _ in ring_core]
   lats = [float(lat) for _, lat in ring_core]

   # anchor: index with lon closest to tile_center
   anchor_idx = min(range(m), key=lambda i: abs(orig_lons[i] - tile_center))

   # compute anchor shifted lon using tile_center as reference for initial placement
   anchor_lon = orig_lons[anchor_idx]
   shifted: List[float] = [0.0] * m
   shifted[anchor_idx] = float(wrap_lon_at(anchor_lon, tile_center))

   # forward propagation: anchor+1 .. end .. wrap to start .. anchor-1
   prev = shifted[anchor_idx]
   i = (anchor_idx + 1) % m
   while i != anchor_idx:
      lon = orig_lons[i]
      # call wrap_lon_at with neighbor (prev) as reference
      shifted[i] = float(wrap_lon_at(lon, prev))
      prev = shifted[i]
      i = (i + 1) % m

   # build localized ring and shifts; re-append closing point if input was closed
   localized: List[Tuple[float, float]] = []
   shifts: List[float] = []
   for idx in range(m):
      s = shifted[idx] - orig_lons[idx]
      localized.append((shifted[idx], lats[idx]))
      shifts.append(s)

   if closed_input:
      # duplicate first entry to close the ring
      localized.append(localized[0])
      shifts.append(shifts[0])

   return localized, shifts

# ---------- ring test using raw lon (no normalization) ----------
def _ring_has_vertex_in_tile_without_shift(ring: List[Tuple[float, float]], xmin: float, xmax: float) -> bool:
   """
   Return True if any vertex of ring (raw lon) lies within [xmin, xmax].
   Uses raw input lon values as requested.
   """
   for lon, _ in ring:
      lonf = float(lon)
      if xmin <= lonf <= xmax:
         return True
   return False

# ---------- staged union helper (kept for future re-enable) ----------
def _staged_union_polygons(polys: List[Polygon], stage_size: int = 64):
   # This function is provided for when geometries are valid and unary_union can be used safely.
   # Currently the pipeline may produce invalid intermediate polygons; when stable, re-enable use.
   if not polys:
      return None, []
   valid = [p for p in polys if p is not None and not p.is_empty and p.area > _AREA_EPS]
   skipped = [i for i, p in enumerate(polys) if p is None or p.is_empty or (hasattr(p, "area") and p.area <= _AREA_EPS)]
   if not valid:
      return None, skipped
   batches = []
   cur: List[Polygon] = []
   for p in valid:
      cur.append(p)
      if len(cur) >= stage_size:
         batches.append(unary_union(cur))
         cur = []
   if cur:
      batches.append(unary_union(cur))
   # merged = unary_union(batches)
   merged = shapely.union_all(batches, grid_size=1e-10)
   return merged, skipped

# ---------- debug store (proper GeoJSON per tile) ----------
_debug_store: Dict[str, List[Dict[str, Any]]] = {}
def _debug_record_tile(xmin: float, xmax: float, record: Dict[str, Any]) -> None:
   if not DEBUG:
      return
   key = f"{int(xmin)}_{int(xmax)}"
   if key not in _debug_store:
      _debug_store[key] = []
   _debug_store[key].append(record)

def _debug_write_files() -> None:
   if not DEBUG:
      return
   os.makedirs(_DEBUG_OUT_DIR, exist_ok=True)
   for key, features in _debug_store.items():
      fname = os.path.join(_DEBUG_OUT_DIR, f"tile_{key}.geojson")
      fc = {"type": "FeatureCollection", "features": features}
      with open(fname, "w", encoding="utf-8") as fh:
         json.dump(fc, fh, ensure_ascii=False, indent=2)

EPS_ZONE_TILE = 1e-3

from typing import Sequence

def intersects_extent_deg(a: Sequence[float], b: Sequence[float], deg_epsilon: float = 1e-12) -> bool:
    # Test intersection of axis-aligned geographic extents in degrees.
    # Each extent is (xmin, ymin, xmax, ymax). Handles dateline-crossing extents
    # by splitting them into two normal extents.
    axmin, aymin, axmax, aymax = float(a[0]), float(a[1]), float(a[2]), float(a[3])
    bxmin, bymin, bxmax, bymax = float(b[0]), float(b[1]), float(b[2]), float(b[3])

    # this extent crosses the dateline (xmin > xmax)
    if axmin > axmax:
        a1 = (axmin, aymin, 180.0, aymax)
        a2 = (-180.0, aymin, axmax, aymax)
        return intersects_extent_deg(a1, b, deg_epsilon) or intersects_extent_deg(a2, b, deg_epsilon)

    # other extent crosses the dateline
    if bxmin > bxmax:
        b1 = (bxmin, bymin, 180.0, bymax)
        b2 = (-180.0, bymin, bxmax, bymax)
        return intersects_extent_deg(a, b1, deg_epsilon) or intersects_extent_deg(a, b2, deg_epsilon)

    #print("Cond0:", aymin < bymax - deg_epsilon)
    #print("Cond1:", bymin < aymax - deg_epsilon)
    #print("Cond2:", axmin < bxmax - deg_epsilon)
    #print("Cond3:", bxmin < axmax - deg_epsilon)
    #print("bxmin < axmax: ", bxmin, axmax - deg_epsilon)

    # simple axis-aligned overlap test in degrees with tiny epsilon
    return (
        aymin < bymax - deg_epsilon
        and bymin < aymax - deg_epsilon
        and axmin < bxmax - deg_epsilon
        and bxmin < axmax - deg_epsilon
    )

# ---------- tile-and-clip for a single polygon using wrap_lon_at ----------
def _tile_and_clip_polygon(exterior_coords: List[Tuple[float, float]],
                           holes_coords: List[List[Tuple[float, float]]],
                           zone_extent, zone_tile_eps, fid, part_idx: int) -> List[Dict[str, Any]]:
   """
   For each of the 4 tiles:
    - Drop exterior ring if it has no vertex inside the tile without shifts (raw lon test).
    - Otherwise apply wrap_lon_at(lon, tile_center) to each vertex.
    - Record shifted polygon as proper GeoJSON in per-tile debug files.
    - Clip rings with rect_clip_polygon and assemble pieces (holes processed similarly).
   """
   poly = Polygon(exterior_coords, holes_coords)
   if poly.is_empty:
      return []

   pieces: List[Dict[str, Any]] = []
   for q, (xmin, ymin, xmax, ymax) in enumerate(TILES_4):
      if not intersects_extent_deg((xmin, ymin, xmax, ymax), zone_extent, zone_tile_eps):
      #   #print("Not processing tile", (xmin, ymin, xmax, ymax), "for zone with extent", zone_extent)
         continue

      tile_center = 0.5 * (xmin + xmax)

      # Drop exterior if it has no vertex inside tile without shifts (raw lon test)
      if not _ring_has_vertex_in_tile_without_shift(exterior_coords, xmin, xmax):
         continue

      # Localize exterior using wrap_lon_at
      localized_ext, ext_shifts = _localize_ring_with_wrap(exterior_coords, tile_center)

      # Build debug geometry (proper GeoJSON Polygon) using shifted coords (ensure closure)
      shifted_ext_closed = list(localized_ext)
      if shifted_ext_closed and shifted_ext_closed[0] != shifted_ext_closed[-1]:
         shifted_ext_closed = shifted_ext_closed + [shifted_ext_closed[0]]

      debug_geom_coords: List[List[List[float]]] = [ [[float(x), float(y)] for (x, y) in shifted_ext_closed] ]
      holes_debug_list: List[Dict[str, Any]] = []

      # Process holes for debug geometry: include shifted holes that pass the raw-vertex test
      for h in holes_coords or []:
         if not h:
            continue
         hh = list(h)
         if hh[0] != hh[-1]:
            hh.append(hh[0])
         if not _ring_has_vertex_in_tile_without_shift(hh, xmin, xmax):
            holes_debug_list.append({"original_hole": hh, "skipped_reason": "no_vertex_in_tile_without_shift"})
            continue
         localized_h, h_shifts = _localize_ring_with_wrap(hh, tile_center)
         shifted_h_closed = list(localized_h)
         if shifted_h_closed and shifted_h_closed[0] != shifted_h_closed[-1]:
            shifted_h_closed = shifted_h_closed + [shifted_h_closed[0]]
         debug_geom_coords.append([[float(x), float(y)] for (x, y) in shifted_h_closed])
         holes_debug_list.append({
            "original_hole": hh,
            "localized_hole_shifted": [[float(x), float(y)] for (x, y) in localized_h],
            "hole_shifts": [float(s) for s in h_shifts]
         })

      # Create debug feature (proper GeoJSON) with shifted polygon geometry
      if DEBUG:
         debug_feature = {
            "type": "Feature",
            "properties": {
               "fid": fid,
               "part_idx": part_idx,
               "tile_xmin": xmin,
               "tile_xmax": xmax,
               "exterior_shifts": [float(s) for s in ext_shifts],
               "holes_info": holes_debug_list
            },
            "geometry": {
               "type": "Polygon",
               "coordinates": debug_geom_coords
            }
         }
         _debug_record_tile(xmin, xmax, debug_feature)

      # Clip exterior ring (use shifted exterior for clipping)
      clipped = rect_clip_polygon(localized_ext, xmin, ymin, xmax, ymax)
      if not clipped:
         continue
      clipped = collapse_near_duplicates(clipped, eps=DUP_EPS)
      if clipped and clipped[0] == clipped[-1]:
         clipped = clipped[:-1]
      if len(clipped) < 3:
         # print("Skipping no clipped")
         continue
      outer_poly = Polygon(clipped)
      if outer_poly.is_empty or outer_poly.area <= 0.0:
         # print("empty or no area")
         continue

      # Process holes: only keep holes that have at least one vertex inside tile without shifts
      hole_polys: List[Polygon] = []
      for h in holes_coords or []:
         if not h:
            continue
         hh = list(h)
         if hh[0] != hh[-1]:
            hh.append(hh[0])
         if not _ring_has_vertex_in_tile_without_shift(hh, xmin, xmax):
            continue
         localized_h, h_shifts = _localize_ring_with_wrap(hh, tile_center)
         clipped_h = rect_clip_polygon(localized_h, xmin, ymin, xmax, ymax)
         if not clipped_h:
            continue
         clipped_h = collapse_near_duplicates(clipped_h, eps=DUP_EPS)
         if clipped_h and clipped_h[0] == clipped_h[-1]:
            clipped_h = clipped_h[:-1]
         if len(clipped_h) < 3:
            continue
         hp = Polygon(clipped_h)
         if hp.is_empty or hp.area <= 0.0:
            continue
         hole_polys.append(hp)

      outer_poly = outer_poly.buffer(0)

      # Subtract holes if present (fail-hard semantics; no try/except)
      if not hole_polys:
         # if outer_poly.is_empty: print("final empty")
         #print("final area:", outer_poly.area)

         final_polys = [outer_poly]
      else:
         hole_union = unary_union(hole_polys)
         if hole_union.is_empty:
            final_polys = [outer_poly]
         else:
            try:
               # outer_poly = outer_poly.buffer(0)
               result = outer_poly.difference(hole_union)
            except:
               print("\nWARNING: Error adding holes to feature", fid)
               print("outer_poly is:", outer_poly)
               print("hole_union is:", hole_union, "\n")

               print("outer valid:", outer_poly.is_valid)
               print("outer validity reason:", explain_validity(outer_poly))
               print("hole_union valid:", hole_union.is_valid)
               print("hole_union validity reason:", explain_validity(hole_union))

               print("outer intersects hole_union:", outer_poly.intersects(hole_union))
               print("outer contains hole_union:", outer_poly.contains(hole_union))
               print("outer covers hole_union:", outer_poly.covers(hole_union))
               print("outer touches hole_union:", outer_poly.touches(hole_union))
               print("outer crosses hole_union:", outer_poly.crosses(hole_union))
               print("outer overlaps hole_union:", outer_poly.overlaps(hole_union))

               result = outer_poly
            if result.geom_type == "Polygon":
               if not result.is_empty and result.area > 0.0:
                  final_polys = [result]
               else:
                  final_polys = []
            else:
               final_polys = [sub for sub in result.geoms if sub.geom_type == "Polygon" and not sub.is_empty and sub.area > 0.0]

      # Filter and accept pieces (handle Polygon, MultiPolygon, GeometryCollection)
      def _accept_polygon_piece(poly):
         # poly is a shapely Polygon

         if poly.is_empty or poly.area <= _AREA_EPS:
            return None
         tol = 1e-12

         #ok = True
         #for cx, cy in list(poly.exterior.coords):
         #   if not (xmin - tol <= cx <= xmax + tol and ymin - tol <= cy <= ymax + tol):
         #      ok = False
         #      break
         #if not ok: return None

         anyInside = False
         for cx, cy in list(poly.exterior.coords):
            if (xmin - tol <= cx <= xmax + tol and ymin - tol <= cy <= ymax + tol):
               anyInside = True
               #print("Discard piece here")
               #return None
         #if not anyInside: return None
         return {"tile_x": xmin, "tile_y": ymin, "geom": poly, "orig_fid": fid, "part_idx": part_idx}

      for g in final_polys:
         # If g is a Polygon, test it directly
         if g.geom_type == "Polygon":
            piece = _accept_polygon_piece(g)
            if piece:
               pieces.append(piece)
            continue

         # If g is a MultiPolygon, iterate sub-polygons
         if g.geom_type == "MultiPolygon":
            for sub in g.geoms:
               piece = _accept_polygon_piece(sub)
               if piece:
                  pieces.append(piece)
            continue

         # If g is a GeometryCollection, extract polygon members
         if g.geom_type == "GeometryCollection":
            for sub in g.geoms:
               if sub.geom_type == "Polygon":
                  piece = _accept_polygon_piece(sub)
                  if piece:
                     pieces.append(piece)
            continue

         # Unexpected geometry type: log and skip
         print(f"Debug: unexpected geometry type {g.geom_type} for fid={fid} part={part_idx}; skipping")

   return pieces

# ---------- wrapper that accepts exterior+holes or polygon-like lists ----------
def _tile_and_clip(exterior_or_poly, holes_coords: Optional[List[List[Tuple[float, float]]]],
   zone_extent, eps_zone_tile, fid, part_idx: int,
   original_geom: Optional[Dict[str,Any]] = None) -> List[Dict[str, Any]]:
   # exterior_or_poly can be a shapely Polygon/MultiPolygon or a list of coords (exterior)
   if hasattr(exterior_or_poly, "exterior"):
      if exterior_or_poly.geom_type == "Polygon":
         ext = list(exterior_or_poly.exterior.coords)
         holes = [list(h.coords) for h in exterior_or_poly.interiors]
         return _tile_and_clip_polygon(ext, holes, zone_extent, eps_zone_tile, fid, part_idx)
      pieces: List[Dict[str, Any]] = []
      for sub in exterior_or_poly.geoms:
         ext = list(sub.exterior.coords)
         holes = [list(h.coords) for h in sub.interiors]
         pieces.extend(_tile_and_clip_polygon(ext, holes, zone_extent, eps_zone_tile, fid, part_idx))
      return pieces
   return _tile_and_clip_polygon(exterior_or_poly, holes_coords or [], zone_extent, eps_zone_tile, fid, part_idx)

# ---------- assemble features from pieces (disabled union to avoid GEOS errors) ----------
def _assemble_feature_from_pieces(all_kept_pieces: List[Dict[str, Any]], fid: str, props: Dict[str, Any]) -> List[Dict[str, Any]]:
   polys: List[Polygon] = []
   for p in all_kept_pieces:
      g = p["geom"]
      if g.geom_type == "Polygon":
         polys.append(g)
      elif g.geom_type == "MultiPolygon":
         for sub in g.geoms:
            polys.append(sub)
      else:
         for sub in getattr(g, "geoms", []) or []:
            if sub.geom_type == "Polygon":
               polys.append(sub)

   valid_polys: List[Polygon] = []
   for p in polys:
      if not p.is_empty and p.area > _AREA_EPS and len(list(p.exterior.coords)) >= 4:
         valid_polys.append(p)
      else:
         rp = p.buffer(0)
         if rp.geom_type == "Polygon" and not rp.is_empty and rp.area > _AREA_EPS:
            valid_polys.append(rp)
         elif rp.geom_type == "MultiPolygon":
            for sub in rp.geoms:
               if not sub.is_empty and sub.area > _AREA_EPS:
                  valid_polys.append(sub)

   # Disabled staged union to avoid GEOS errors while geometries are still invalid.
   # When the clipped polygons are consistently valid, re-enable staged union:
   merged, skipped = _staged_union_polygons(valid_polys, fid)
   # For now produce a MultiPolygon directly from valid_polys to avoid GEOS unary_union on invalid inputs.
   #merged, skipped = (MultiPolygon(valid_polys), None)

   out_features: List[Dict[str, Any]] = []
   if merged is None:
      for i, p in enumerate(valid_polys):
         out_features.append({"type": "Feature", "id": f"{fid}_part_{i}", "properties": props, "geometry": mapping(p)})
      return out_features

   if merged.geom_type in ("Polygon", "MultiPolygon"):
      out_features.append({"type": "Feature", "id": fid, "properties": props, "geometry": mapping(merged)})
      return out_features

   # fallback: extract polygonal parts
   polys2: List[Polygon] = []
   for g in getattr(merged, "geoms", []) or []:
      if g.geom_type == "Polygon":
         polys2.append(g)
      elif g.geom_type == "MultiPolygon":
         for sub in g.geoms:
            polys2.append(sub)
   if not polys2:
      out_features.append({"type": "Feature", "id": fid, "properties": props, "geometry": mapping(Polygon())})
   elif len(polys2) == 1:
      out_features.append({"type": "Feature", "id": fid, "properties": props, "geometry": mapping(polys2[0])})
   else:
      out_features.append({"type": "Feature", "id": fid, "properties": props, "geometry": mapping(MultiPolygon(polys2))})
   return out_features

# ---------- coords lon range helper ----------
def _coords_lon_range(coords: Any) -> Tuple[float, float]:
   if coords is None:
      return (9999.0, -9999.0)
   if isinstance(coords, list):
      if not coords:
         return (9999.0, -9999.0)
      first = coords[0]
      if isinstance(first, (int, float)):
         lon = float(first)
         return (lon, lon)
      minlon = 9999.0
      maxlon = -9999.0
      for item in coords:
         a, b = _coords_lon_range(item)
         if a < minlon:
            minlon = a
         if b > maxlon:
            maxlon = b
      return (minlon, maxlon)
   if isinstance(coords, (int, float)):
      lon = float(coords)
      return (lon, lon)
   return (9999.0, -9999.0)

# ---------- ensure output family and drop degenerate families ----------
def _ensure_output_type(merged, orig_type: str):
   if merged is None:
      return None
   # If merged is a list of shapely geometries (we disabled unary_union), wrap into GeometryCollection
   if isinstance(merged, list):
      merged = GeometryCollection(merged)

   if getattr(merged, "is_empty", False):
      return None

   if orig_type == "Point":
      if merged.geom_type == "Point":
         return mapping(merged)
      if merged.geom_type == "MultiPoint":
         if len(merged.geoms) == 1:
            return mapping(merged.geoms[0])
         return mapping(merged)
      if merged.geom_type == "GeometryCollection":
         pts = [g for g in merged.geoms if g.geom_type == "Point"]
         if not pts:
            return None
         if len(pts) == 1:
            return mapping(pts[0])
         return mapping(MultiPoint([p.coords[0] for p in pts]))
      return None

   if orig_type == "MultiPoint":
      if merged.geom_type == "MultiPoint":
         return mapping(merged)
      if merged.geom_type == "Point":
         return mapping(MultiPoint([merged.coords[0]]))
      if merged.geom_type == "GeometryCollection":
         coords = []
         for g in merged.geoms:
            if g.geom_type == "Point":
               coords.append(g.coords[0])
            elif g.geom_type == "MultiPoint":
               for p in g.geoms:
                  coords.append(p.coords[0])
         if not coords:
            return None
         return mapping(MultiPoint(coords))
      return None

   if orig_type == "LineString":
      if merged.geom_type == "LineString":
         return mapping(merged)
      if merged.geom_type == "MultiLineString":
         if len(merged.geoms) == 1:
            return mapping(merged.geoms[0])
         return mapping(merged)
      if merged.geom_type == "GeometryCollection":
         lines = []
         for g in merged.geoms:
            if g.geom_type == "LineString":
               lines.append(g)
            elif g.geom_type == "MultiLineString":
               for sub in g.geoms:
                  lines.append(sub)
         if not lines:
            return None
         if len(lines) == 1:
            return mapping(lines[0])
         return mapping(MultiLineString([list(l.coords) for l in lines]))
      return None

   if orig_type == "MultiLineString":
      if merged.geom_type == "MultiLineString":
         return mapping(merged)
      if merged.geom_type == "LineString":
         return mapping(MultiLineString([list(merged.coords)]))
      if merged.geom_type == "GeometryCollection":
         parts = []
         for g in merged.geoms:
            if g.geom_type == "LineString":
               parts.append(list(g.coords))
            elif g.geom_type == "MultiLineString":
               for sub in g.geoms:
                  parts.append(list(sub.coords))
         if not parts:
            return None
         return mapping(MultiLineString(parts))
      return None

   if orig_type == "Polygon":
      if merged.geom_type == "Polygon":
         return mapping(merged)
      if merged.geom_type == "MultiPolygon":
         if len(merged.geoms) == 1:
            return mapping(merged.geoms[0])
         return mapping(merged)
      if merged.geom_type == "GeometryCollection":
         polys = []
         for g in merged.geoms:
            if g.geom_type == "Polygon":
               polys.append(g)
            elif g.geom_type == "MultiPolygon":
               for sub in g.geoms:
                  polys.append(sub)
         if not polys:
            return None
         if len(polys) == 1:
            return mapping(polys[0])
         return mapping(MultiPolygon(polys))
      return None

   if orig_type == "MultiPolygon":
      if merged.geom_type == "MultiPolygon":
         return mapping(merged)
      if merged.geom_type == "Polygon":
         return mapping(MultiPolygon([merged]))
      if merged.geom_type == "GeometryCollection":
         parts = []
         for g in merged.geoms:
            if g.geom_type == "Polygon":
               parts.append(g)
            elif g.geom_type == "MultiPolygon":
               for sub in g.geoms:
                  parts.append(sub)
         if not parts:
            return None
         return mapping(MultiPolygon(parts))
      return None

   return mapping(merged)

# ---------- main public function ----------
def fix_WGS84_geometry(obj: Any, zone_extent: List[float], eps_zone_tile = EPS_ZONE_TILE, fid = None) -> Any:
   # quick dateline check
   #if obj["type"] == "FeatureCollection":
   #   minlon = 9999.0
   #   maxlon = -9999.0
   #   for feat in obj["features"]:
   #      geom = feat["geometry"]
   #      a, b = _coords_lon_range(geom["coordinates"] if geom is not None else None)
   #      if a < minlon:
   #         minlon = a
   #      if b > maxlon:
   #         maxlon = b
   #   if maxlon - minlon < 180.0:
   #      return obj
   #else:
   #   geom = obj["geometry"] if obj["type"] == "Feature" else obj
   #   a, b = _coords_lon_range(geom["coordinates"] if geom is not None else None)
   #   if b - a < 180.0:
   #      return obj

   #print("Zone extent:", zone_extent)

   def _process_single_geometry(geom: Optional[Dict[str, Any]], zone_extent: List[float], fid_for_debug = None) -> Optional[Dict[str, Any]]:
      if geom is None:
         return None

      orig_type = geom["type"]
      tile_geoms = []

      if orig_type == "Polygon":
         ext = geom["coordinates"][0]
         holes = geom["coordinates"][1:]
         pieces = _tile_and_clip(ext, holes, zone_extent, eps_zone_tile, fid_for_debug, part_idx=0)
         #print("_tile_and_clip returned", len(pieces), "pieces")
         for p in pieces:
            tile_geoms.append(p["geom"])

      elif orig_type == "MultiPolygon":
         for i, poly in enumerate(geom["coordinates"]):
            ext = poly[0]
            holes = poly[1:]
            pieces = _tile_and_clip(ext, holes, zone_extent, eps_zone_tile, fid_for_debug, part_idx=i)
            for p in pieces:
               tile_geoms.append(p["geom"])
      else:
         for xmin, ymin, xmax, ymax in TILES_4:
            tile_center = 0.5 * (xmin + xmax)
            shp = _geom_to_shapely_shifted(geom, tile_center)
            tile_box = box(xmin, ymin, xmax, ymax)
            inter = shp.intersection(tile_box)
            if not inter.is_empty:
               tile_geoms.append(inter)

      if not tile_geoms:
         return None


      # Disabled unary_union to avoid GEOS errors while geometries are still invalid.
      # When clipped polygons are consistently valid, re-enable:
      merged = unary_union(tile_geoms)
      #merged = shapely.union_all(tile_geoms, grid_size = 1e-9)
      # merged = tile_geoms

      if orig_type in ("Polygon", "MultiPolygon"):
         all_kept_pieces = [{"geom": g} for g in tile_geoms]
         assembled = _assemble_feature_from_pieces(all_kept_pieces, fid_for_debug, props={})
         if not assembled:
            if DEBUG:
               _debug_write_files()
            return None
         if len(assembled) == 1:
            if DEBUG:
               _debug_write_files()
            return assembled[0]["geometry"]
         polys = []
         for f in assembled:
            g = f["geometry"]
            if g is None:
               continue
            if g["type"] == "Polygon":
               polys.append(Polygon(g["coordinates"][0], g["coordinates"][1:]))
            elif g["type"] == "MultiPolygon":
               for sub in g["coordinates"]:
                  polys.append(Polygon(sub[0], sub[1:]))
         if not polys:
            if DEBUG:
               _debug_write_files()
            return None
         if len(polys) == 1:
            if DEBUG:
               _debug_write_files()
            return mapping(polys[0])
         if DEBUG:
            _debug_write_files()
         return mapping(MultiPolygon(polys))

      # For non-polygon families, coerce merged (list) into GeometryCollection and ensure output type
      if DEBUG:
         _debug_write_files()
      return _ensure_output_type(merged, orig_type)

   # preserve top-level shape
   if obj["type"] == "FeatureCollection":
      out = {"type": "FeatureCollection", "features": []}
      for feat in obj["features"]:
         geom = feat["geometry"]
         if geom is None:
            new_feat = dict(feat)
            new_feat["geometry"] = None
            out["features"].append(new_feat)
            continue
         fid = feat.get("id", str(len(out["features"])))
         fixed = _process_single_geometry(geom, zone_extent, fid_for_debug=fid)
         new_feat = dict(feat)
         new_feat["geometry"] = fixed
         out["features"].append(new_feat)
      return out

   if obj["type"] == "Feature":
      geom = obj["geometry"]
      if geom is None:
         return obj
      fid = obj.get("id", "0")
      fixed = _process_single_geometry(geom, zone_extent, fid_for_debug=fid)
      out = dict(obj)
      out["geometry"] = fixed
      return out

   return _process_single_geometry(obj, zone_extent, fid_for_debug=fid)



================================================
FILE: high-vibes/fg/interruption.py
================================================
# interruption.py
"""
Port of crosses5x6InterruptionV2Ex and rotate5x6Offset into Python.

This module depends on faces.Pointd / faces.Point dataclasses (from faces.py).
It implements the interruption detection logic, translated
to Python with the same numeric tolerances and control flow.

Public API:
  - rotate5x6_offset(r: Pointd, dx: float, dy: float, clockwise: bool) -> None
  - crosses5x6_interruption_v2_ex(
        c_in: Pointd,
        dx: float,
        dy: float,
        final_cross: bool = True
    ) -> (bool, Optional[Pointd], Optional[Pointd], Optional[bool], Optional[bool])

Return values for crosses5x6_interruption_v2_ex:
  (result, i_src, i_dst, in_north, ends_at_edge)
  - result: True if an interruption crossing was detected
  - i_src: Pointd of the source-side intersection (or None)
  - i_dst: Pointd of the destination-side intersection (or None)
  - in_north: bool indicating north/south interruption side (or None)
  - ends_at_edge: bool indicating the segment ends exactly at the edge (or None)

This implementation preserves coordinate precision and does not perform snapping.
"""

from typing import Optional, Tuple
import math

from fg.faces import Point, Pointd

# Tolerances copied from the original eC code
_EPS_EDGE = 1e-11
_EPS_SMALL = 1e-11  # used for tiny comparisons in several places


def sgn(v: float) -> int:
    if v > 0:
        return 1
    if v < 0:
        return -1
    return 0


def rotate5x6_offset(r: Pointd, dx: float, dy: float, clockwise: bool) -> None:
    """
    Apply the 60-degree rotation offset used in the 5x6 net.
    Mutates r in place to the rotated coordinates.
    """
    if clockwise:
        # 60 degrees clockwise rotation
        r.x = dx - dy
        r.y = dx
    else:
        # 60 degrees counter-clockwise rotation
        r.x = dy
        r.y = dy - dx


def crosses5x6_interruption_v2_ex(
    c_in: Pointd,
    dx: float,
    dy: float,
    final_cross: bool = True,
) -> Tuple[bool, Optional[Pointd], Optional[Pointd], Optional[bool], Optional[bool]]:
    """
    Detect whether the segment starting at c_in and offset by (dx,dy) crosses
    a 5x6 interruption. Ported from eC implementation.

    Parameters
    - c_in: starting Pointd in 5x6 coordinates
    - dx, dy: offset vector from c_in
    - final_cross: if False, treat exact-end-of-segment as non-crossing

    Returns:
      (result, i_src, i_dst, in_north, ends_at_edge)
    """
    result = False
    # copy input
    c = Pointd(c_in.x, c_in.y)

    # normalize wrap-around near lower-left corner (matches eC)
    if c.x < 0 and c.y < 1.0 + _EPS_EDGE:
        c.x += 5.0
        c.y += 5.0

    # local working copies
    cdx = c.x
    cdy = c.y
    north = (cdx - cdy - _EPS_EDGE) > 0
    # integer cell indices and temporary variables
    cx = cy = 0
    nx = ny = 0
    px = py = 0.0

    # apply tiny bias depending on north/south to avoid exact-boundary ambiguity
    if north:
        cdx -= _EPS_SMALL
        cdy += _EPS_SMALL
    else:
        cdx += _EPS_SMALL
        cdy -= _EPS_SMALL

    # wrap adjustments mirroring original logic
    if cdx < 0 and cdy < 1.0 + _EPS_EDGE:
        cdx += 5.0
        cdy += 5.0
        c.x += 5.0
        c.y += 5.0

    if cdx > 5.0 and cdy > 5.0 - _EPS_EDGE:
        cdx -= 5.0
        cdy -= 5.0
        c.x -= 5.0
        c.y -= 5.0

    if cdy < 0.0 and cdx < 1e-11:
        cdx += 5.0
        cdy += 5.0
        c.x += 5.0
        c.y += 5.0

    # floor to get cell indices
    cx = int(math.floor(cdx))
    cy = int(math.floor(cdy))

    # compute px/py: the portion of dx/dy that reaches the current cell edge
    if dx < 0:
        px = max(cx - c.x, dx)
    else:
        px = min(cx + 1 - c.x, dx)

    if dy < 0:
        py = max(cy - c.y, dy)
    else:
        py = min(cy + 1 - c.y, dy)

    # if both dx and dy non-zero, pick the limiting parametric fraction
    if dx != 0.0 and dy != 0.0:
        pkx = px / dx
        pky = py / dy
        if pkx < pky:
            py = pkx * dy
        elif pky < pkx:
            px = pky * dx

    # advance c by the chosen px/py
    c.x += px
    c.y += py

    # if not finalCross and we've consumed the whole segment, no crossing
    if not final_cross:
        if abs(dx - px) < _EPS_SMALL and abs(dy - py) < _EPS_SMALL:
            return False, None, None, None, None
    else:
        # if finalCross and endsAtEdge detection requested, we would set endsAtEdge
        # but here we don't have an endsAtEdge pointer; we will compute it later if needed
        pass

    # compute next cell indices after the step (with tiny bias in direction of dx/dy)
    nx = int(math.floor(c.x + 1e-11 * sgn(dx)))
    ny = int(math.floor(c.y + 1e-11 * sgn(dy)))

    i_src: Optional[Pointd] = None
    i_dst: Optional[Pointd] = None
    in_north: Optional[bool] = None
    ends_at_edge: Optional[bool] = None

    # check whether we've moved to a different cell and whether conditions indicate an interruption
    moved_cell = (nx != cx or ny != cy)
    cond_extra = (nx > cx or (nx == cx and (ny - nx) == 2) or
                  (abs(dx - px) > _EPS_SMALL) or (abs(dy - py) > _EPS_SMALL))

    if moved_cell and cond_extra:
        root = cx + cy
        # even root => North pattern, odd root => South pattern
        if (root & 1) == 0:
            # North interruption cases
            # Crossing interruption to the right
            if (ny == cy) and (nx == cx + 1):
                iy = int(math.floor(c.x - 1.0 + 1e-11))
                i_src = Pointd(c.x, c.y)
                # iDst = { iy + 2 - (c.y - iy), c.x };
                i_dst = Pointd(iy + 2.0 - (c.y - iy), c.x)
                in_north = True
                if abs(px) > _EPS_SMALL or abs(py) > _EPS_SMALL:
                    result = True
            # Crossing interruption to the left
            elif (nx == cx) and (ny == cy - 1):
                ix = int(math.floor(c.y + 1e-11))
                i_src = Pointd(c.x, c.y)
                # iDst = { c.y, ix - (c.x - ix) };
                i_dst = Pointd(c.y, ix - (c.x - ix))
                in_north = True
                if abs(px) > _EPS_SMALL or abs(py) > _EPS_SMALL:
                    result = True
        else:
            # South interruption cases
            # Crossing interruption to the right
            if (nx == cx) and (ny == cy + 1):
                ix = int(math.floor(c.y - 2.0 + 1e-11))
                i_src = Pointd(c.x, c.y)
                # iDst = { c.y - 1, ix + 3 - (c.x - ix) };
                i_dst = Pointd(c.y - 1.0, ix + 3.0 - (c.x - ix))
                in_north = False
                if abs(px) > _EPS_SMALL or abs(py) > _EPS_SMALL:
                    result = True
            # Crossing interruption to the left
            elif (ny == cy) and (nx == cx - 1):
                iy = int(math.floor(c.x + 1.0 + 1e-11))
                i_src = Pointd(c.x, c.y)
                # iDst = { iy - 1 - (c.y - iy), c.x + 1 };
                i_dst = Pointd(iy - 1.0 - (c.y - iy), c.x + 1.0)
                in_north = False
                if abs(px) > _EPS_SMALL or abs(py) > _EPS_SMALL:
                    result = True

    # final wrap adjustment for iDst if needed (matches eC)
    if result and i_dst is not None and i_dst.x < 0 and i_dst.y < 1.0 + _EPS_EDGE:
        i_dst.x += 5.0
        i_dst.y += 5.0

    # ends_at_edge detection (only meaningful when final_cross True)
    if final_cross and (abs(dx - px) < _EPS_SMALL and abs(dy - py) < _EPS_SMALL):
        # check whether the segment ended exactly at the tile edge (approx)
        # This mirrors the eC logic branch that sets endsAtEdge when finalCross and ends exactly at edge.
        # We compute a conservative boolean here.
        # Determine whether the absolute movement equals the distance to the cell edge in both axes.
        # Note: original code had a more specific check; we approximate equivalently.
        # Compute distances to cell boundaries used earlier:
        dist_x = (cx + 1 - c.x) if dx > 0 else (cx - c.x)
        dist_y = (cy + 1 - c.y) if dy > 0 else (cy - c.y)
        if abs(abs(dx) - abs(dist_x)) < _EPS_SMALL and abs(abs(dy) - abs(dist_y)) < _EPS_SMALL:
            ends_at_edge = True
        else:
            ends_at_edge = False

    return result, i_src, i_dst, in_north, ends_at_edge



================================================
FILE: high-vibes/fg/reproj.py
================================================
from dggal import *
import sys
import json
import argparse

from ogcapi.utils import *

# 3-space indent style throughout this file

def get_dggrs(dggrs_name):
   # resolve DGGRS object from globals exactly as requested
   return globals()[dggrs_name]()

# parse a CURIE like "...-dggrs:ID]" and return a DGGRS instance via get_dggrs()
def get_dggrs_from_curie(curie: str):
   # find the substring after "-dggrs:" and before the next closing bracket ']'
   token = "-dggrs:"
   start = curie.find(token) + len(token)
   end = curie.find("]", start)
   dggrs_id = curie[start:end]
   return get_dggrs(dggrs_id)

def instantiate_projection_for_dggrs_name(dggrs_name):
   # choose projection class by DGGRS short name prefix
   if dggrs_name.startswith("IVEA"):
      return IVEAProjection()
   elif dggrs_name.startswith("RTEA"):
      return RTEAProjection()
   elif dggrs_name.startswith("ISEA"):
      return ISEAProjection()
   elif dggrs_name.startswith("HEALPix"):
      return HEALPixProjection()
   elif dggrs_name.startswith("rHEALPix"):
      return rHEALPixProjection()
   elif dggrs_name.startswith("GNOSISGlobalGrid"):
      # no projection: identity mapping (pass-through lon,lat)
      return None
   else:
      # contract: unrecognized DGGRS name is a hard failure
      raise NameError("unrecognized DGGRS for projection selection: " + dggrs_name)

def geojson_load(path):
   with open(path, "r", encoding="utf-8") as fh:
      return json.load(fh)

def geojson_dump(obj, path):
   with open(path, "w", encoding="utf-8") as fh:
      #json.dump(obj, fh, separators=(",", ":"), ensure_ascii=False)
      fh.write(pretty_json(obj))
      fh.write("\n")

def make_GeoPoint(lon, lat):
   gp = GeoPoint()
   gp.lon = Degrees(lon)
   gp.lat = Degrees(lat)
   return gp

def make_Pointd(x, y):
   pd = Pointd()
   pd.x = float(x)
   pd.y = float(y)
   return pd

def reproject_coord_lonlat_to_crs(lon, lat, proj, ico=False):
   # input: lon, lat in degrees (WGS84)
   # output: [x, y] in DGGRS native CRS (float)
   if proj is None:
      # GNOSISGlobalGrid: identity pass-through (lon, lat)
      return [float(lon), float(lat)]
   in_gp = make_GeoPoint(lon, lat)
   out_pd = Pointd()
   # forward: WGS84 GeoPoint -> projected Pointd; oddGrid False per contract
   proj.forward(in_gp, out_pd)

   # if ico mode requested and projection exposes toIcosahedronNet, apply it in-place
   if ico:
      # projection binding: toIcosahedronNet(v=None, result=None)
      # call with out_pd as both v and result to mutate in-place
      proj.__class__.toIcosahedronNet(out_pd, out_pd)

   return [float(out_pd.x), float(out_pd.y)]

def reproject_coords_array(coords, proj, ico=False):
   out = []
   for lon, lat in coords:
      out.append(reproject_coord_lonlat_to_crs(lon, lat, proj, ico=ico))
   return out

def reproject_geometry(geom, proj, ico=False):
   t = geom["type"]
   if t == "Point":
      lon, lat = geom["coordinates"]
      return {"type": "Point", "coordinates": reproject_coord_lonlat_to_crs(lon, lat, proj, ico=ico)}
   if t == "MultiPoint":
      return {"type": "MultiPoint", "coordinates": reproject_coords_array(geom["coordinates"], proj, ico=ico)}
   if t == "LineString":
      return {"type": "LineString", "coordinates": reproject_coords_array(geom["coordinates"], proj, ico=ico)}
   if t == "MultiLineString":
      return {"type": "MultiLineString", "coordinates": [reproject_coords_array(r, proj, ico=ico) for r in geom["coordinates"]]}
   if t == "Polygon":
      return {"type": "Polygon", "coordinates": [reproject_coords_array(r, proj, ico=ico) for r in geom["coordinates"]]}
   if t == "MultiPolygon":
      return {"type": "MultiPolygon", "coordinates": [[reproject_coords_array(r, proj, ico=ico) for r in poly] for poly in geom["coordinates"]]}
   if t == "GeometryCollection":
      return {"type": "GeometryCollection", "geometries": [reproject_geometry(g, proj, ico=ico) for g in geom["geometries"]]}
   return None

def reproject_feature(feature, proj, ico=False):
   out = {
      "type": "Feature",
      "id": feature.get("id"),
      "properties": feature.get("properties"),
      "geometry": None
   }
   geom = feature.get("geometry")
   if geom is not None:
      out["geometry"] = reproject_geometry(geom, proj, ico=ico)
   return out

def reproject_featurecollection(fc, proj, ico=False):
   out = {
      "type": "FeatureCollection",
      "features": []
   }
   for feat in fc["features"]:
      out["features"].append(reproject_feature(feat, proj, ico=ico))
   return out




================================================
FILE: high-vibes/fg/sutherlandHodgman.py
================================================
from typing import List, Tuple, Dict, Any, Optional

# Sutherland-Hodgman helpers (top-level)
def _intersect_edge(p: Tuple[float,float], q: Tuple[float,float], edge: str,
                    xmin: float, ymin: float, xmax: float, ymax: float) -> Tuple[float,float]:
   x1, y1 = p
   x2, y2 = q
   dx = x2 - x1
   dy = y2 - y1
   if edge == 'left':
      x = xmin
      if abs(dx) < 1e-18:
         return (x, y1)
      t = (xmin - x1) / dx
      return (x, y1 + t * dy)
   if edge == 'right':
      x = xmax
      if abs(dx) < 1e-18:
         return (x, y1)
      t = (xmax - x1) / dx
      return (x, y1 + t * dy)
   if edge == 'bottom':
      y = ymin
      if abs(dy) < 1e-18:
         return (x1, y)
      t = (ymin - y1) / dy
      return (x1 + t * dx, y)
   y = ymax
   if abs(dy) < 1e-18:
      return (x1, y)
   t = (ymax - y1) / dy
   return (x1 + t * dx, y)

def _inside_for_edge(pt: Tuple[float,float], edge: str,
                     xmin: float, ymin: float, xmax: float, ymax: float) -> bool:
   x, y = pt
   if edge == 'left':
      return x >= xmin
   if edge == 'right':
      return x <= xmax
   if edge == 'bottom':
      return y >= ymin
   return y <= ymax

def rect_clip_polygon(ring_coords: List[Tuple[float,float]],
                      xmin: float, ymin: float, xmax: float, ymax: float) -> List[Tuple[float,float]]:
   def clip_edge(coords: List[Tuple[float,float]], edge: str) -> List[Tuple[float,float]]:
      out: List[Tuple[float,float]] = []
      if not coords:
         return out
      prev = coords[-1]
      for curr in coords:
         inside_curr = _inside_for_edge(curr, edge, xmin, ymin, xmax, ymax)
         inside_prev = _inside_for_edge(prev, edge, xmin, ymin, xmax, ymax)
         if inside_curr:
            if inside_prev:
               out.append(curr)
            else:
               out.append(_intersect_edge(prev, curr, edge, xmin, ymin, xmax, ymax))
               out.append(curr)
         else:
            if inside_prev:
               out.append(_intersect_edge(prev, curr, edge, xmin, ymin, xmax, ymax))
         prev = curr
      return out

   # make a working copy
   coords = list(ring_coords)

   # require at least 3 input points to form a polygon
   if len(coords) < 3:
      return []

   # ensure the ring is closed for clipping (first == last)
   if coords[0] != coords[-1]:
      coords.append(coords[0])

   # clip against each edge; if any clip empties the polygon, return empty
   for edge in ('left', 'right', 'bottom', 'top'):
      coords = clip_edge(coords, edge)
      if not coords:
         return []

   # if the result is closed (first == last), drop the duplicate closing point
   if coords and coords[0] == coords[-1]:
      coords = coords[:-1]

   # require at least 3 points (open ring) to form a polygon
   if len(coords) < 3:
      return []

   return coords



================================================
FILE: high-vibes/fg/unprojectToWGS84.py
================================================
from dggal import *
from fg.distance import distance5x6, move5x6
from typing import Any, Dict, List, Tuple, Sequence

_DEFAULT_SUBDIV = 50 #300

def _segment_near_pole_by_crs(p: Tuple[float, float], n: Tuple[float, float]) -> bool:
   # Geographic South Pole
   if n[0] < 2.01 and n[1] > 3.49 and n[1] < 3.51:
      return True
   if p[0] < 2.01 and p[1] > 3.49 and p[1] < 3.51:
      return True

   if n[1] > 2.99 and n[0] > 1.49 and n[0] < 1.51:
      return True
   if p[1] > 2.99 and p[0] > 1.49 and p[0] < 1.51:
      return True

   # Geographic North Pole
   if n[1] < 0.01 and n[0] > 0.49 and n[0] < 0.51:
      return True
   if p[1] < 0.01 and p[0] > 0.49 and p[0] < 0.51:
      return True

   if n[0] > 4.99 and n[1] > 4.49 and n[1] < 4.51:
      return True
   if p[0] > 4.99 and p[1] > 4.49 and p[1] < 4.51:
      return True

   return False

def _choose_twin_point_for_segment(p: Tuple[float, float], n: Tuple[float, float], eps: float = 0.05) -> Tuple[float, float] | None:
   # Return the twin/pole point (in 5x6 CRS coords) relevant to segment p->n,
   # or None if no known twin is close enough.
   # eps is a loose proximity threshold in CRS units.

   # Known seam/twin coordinates (5x6 CRS)
   SOUTH_TWIN_A = (2.0, 3.5)   # main south seam
   SOUTH_TWIN_B = (1.5, 3.0)   # alternate south twin
   NORTH_TWIN_A = (0.5, 0.0)   # main north seam
   NORTH_TWIN_B = (5.0, 4.5)   # alternate north twin (wrap)

   candidates = [SOUTH_TWIN_A, SOUTH_TWIN_B, NORTH_TWIN_A, NORTH_TWIN_B]

   def _dist2(a, b):
      dx = float(a[0]) - float(b[0]); dy = float(a[1]) - float(b[1])
      return dx*dx + dy*dy

   # pick candidate if either endpoint is near it
   for cand in candidates:
      if _dist2(p, cand) <= eps*eps or _dist2(n, cand) <= eps*eps:
         return cand
   return None

def _interpolate_between_5x6(a: Tuple[float, float], b: Tuple[float, float], divs: int) -> List[Tuple[float, float]]:
   # Return intermediate points between a and b in 5x6 space using distance5x6/move5x6.
   # Excludes the start 'a' and excludes the end 'b'.
   # subdivision logic: divs parts -> returns divs-1 intermediate points).
   if divs <= 1:
      return []
   # compute displacement in 5x6 units from a to b
   d, *unused = distance5x6(Pointd(a[0], a[1]), Pointd(b[0], b[1]))
   out: List[Tuple[float, float]] = []
   for j in range(1, divs):
      factor = j / float(divs)
      dx = d.x * factor
      dy = d.y * factor
      moved = move5x6((a[0], a[1]), dx, dy, 1)
      out.append((float(moved.x), float(moved.y)))
   # note: this returns points that lie strictly between a and b; callers decide whether to include endpoints
   return out

def _insert_intermediate_points_crs_segment(p: Tuple[float, float], n: Tuple[float, float],
   refine_wgs84 = None) -> List[Tuple[float, float]]:

   # always start with p
   out: List[Tuple[float, float]] = [(float(p[0]), float(p[1]))]

   near_pole = _segment_near_pole_by_crs(p, n)

   if not near_pole:
      # REVIEW: Improve on automatic refinement
      if refine_wgs84:
         max_5x6_distance = refine_wgs84
         d, *unused = distance5x6(Pointd(p[0], p[1]), Pointd(n[0], n[1]))
         md = abs(d.x) + abs(d.y)
         if md > max_5x6_distance:
            divs = int(floor(md / max_5x6_distance))
            # print("Interpolating with divisions:", divs)
            inter = _interpolate_between_5x6(p, n, divs)
            out.extend(inter)
      return out

   divs = _DEFAULT_SUBDIV

   # choose the twin/pole point relevant to this segment
   twin = _choose_twin_point_for_segment(p, n)
   if twin is None:
      # fallback: if we couldn't pick a twin, fall back to the original single interpolation
      # (interpolate from p toward n, excluding n)
      inter = _interpolate_between_5x6(p, n, divs)
      out.extend(inter)
      return out

   # If twin equals p or is extremely close, skip first interpolation
   eps_close = 1e-12
   if not (abs(twin[0] - p[0]) <= eps_close and abs(twin[1] - p[1]) <= eps_close):
      # interpolate from p toward twin (exclude endpoints)
      seg1 = _interpolate_between_5x6(p, twin, divs)
      # seg1 excludes p and twin; append them in order: seg1 then twin
      out.extend(seg1)

   # explicitly add the twin point (the seam/twin)
   out.append((float(twin[0]), float(twin[1])))

   # If twin equals n or extremely close, we're done (do not add n)
   if abs(twin[0] - n[0]) <= eps_close and abs(twin[1] - n[1]) <= eps_close:
      return out

   # interpolate from twin toward n (exclude endpoints)
   seg2 = _interpolate_between_5x6(twin, n, divs)
   out.extend(seg2)

   return out

def intersects_extent_deg(a: Sequence[float], b: Sequence[float], deg_epsilon: float = 1e-12) -> bool:
    # Test intersection of axis-aligned geographic extents in degrees.
    # Each extent is (xmin, ymin, xmax, ymax). Handles dateline-crossing extents
    # by splitting them into two normal extents.
    axmin, aymin, axmax, aymax = float(a[0]), float(a[1]), float(a[2]), float(a[3])
    bxmin, bymin, bxmax, bymax = float(b[0]), float(b[1]), float(b[2]), float(b[3])

    # this extent crosses the dateline (xmin > xmax)
    if axmin > axmax:
        a1 = (axmin, aymin, 180.0, aymax)
        a2 = (-180.0, aymin, axmax, aymax)
        return intersects_extent_deg(a1, b, deg_epsilon) or intersects_extent_deg(a2, b, deg_epsilon)

    # other extent crosses the dateline
    if bxmin > bxmax:
        b1 = (bxmin, bymin, 180.0, bymax)
        b2 = (-180.0, bymin, bxmax, bymax)
        return intersects_extent_deg(a, b1, deg_epsilon) or intersects_extent_deg(a, b2, deg_epsilon)

    # simple axis-aligned overlap test in degrees with tiny epsilon
    return (
        aymin < bymax - deg_epsilon
        and bymin < aymax - deg_epsilon
        and axmin < bxmax - deg_epsilon
        and bxmin < axmax - deg_epsilon
    )

def _process_ring_crs_to_wgs84(ring_crs: List[Tuple[float, float]], proj: Any, zone_extent,
   pin: Pointd, gp: GeoPoint, refine_wgs84=None) -> List[Tuple[float, float]]:
   closed = list(ring_crs)
   if closed[0] != closed[-1]:
      closed.append(closed[0])
   out_coords: List[Tuple[float, float]] = []
   L = len(closed) - 1
   for i in range(L):
      p = closed[i]
      n = closed[i + 1]
      seg_pts = _insert_intermediate_points_crs_segment(p, n, refine_wgs84=refine_wgs84)
      for (x_crs, y_crs) in seg_pts:
         pin.x = x_crs
         pin.y = y_crs
         proj.inverse(pin, gp, False)
         lat = float(gp.lat)
         lon = float(gp.lon)
         if 90 - abs(lat) < 1e-10 and not intersects_extent_deg((lon, lat, lon, lat), zone_extent):
            continue
         out_coords.append((lon, lat))
   last_x, last_y = closed[-1]
   pin.x = last_x
   pin.y = last_y
   proj.inverse(pin, gp, False)
   out_coords.append((float(gp.lon), float(gp.lat)))
   if out_coords[0] != out_coords[-1]:
      out_coords.append(out_coords[0])
   return out_coords

def unproject_geojson_to_wgs84(obj: Dict[str, Any], proj: Any, zone_extent, refine_wgs84=None) -> Dict[str, Any]:
   pin = Pointd()
   gp = GeoPoint()

   def _process_geom(geom: Dict[str, Any], zone_extent, refine_wgs84 = None) -> Dict[str, Any]:
      gtype = geom["type"]
      if gtype == "Polygon":
         if not geom["coordinates"]:
            raise InvalidPolygonGeometry
         exterior = geom["coordinates"][0]
         holes = geom["coordinates"][1:] if len(geom["coordinates"]) > 1 else []
         ext_wgs = _process_ring_crs_to_wgs84(exterior, proj, zone_extent, pin, gp, refine_wgs84=refine_wgs84)
         holes_wgs = []
         for h in holes:
            hw = _process_ring_crs_to_wgs84(h, proj, zone_extent, pin, gp, refine_wgs84=refine_wgs84)
            if hw:
               holes_wgs.append(hw)
         return {"type": "Polygon", "coordinates": [ext_wgs] + holes_wgs}
      if gtype == "MultiPolygon":
         new_polys = []
         for poly in geom["coordinates"]:
            ext = poly[0]
            holes = poly[1:] if len(poly) > 1 else []
            ext_wgs = _process_ring_crs_to_wgs84(ext, proj, zone_extent, pin, gp, refine_wgs84=refine_wgs84)
            holes_wgs = []
            for h in holes:
               hw = _process_ring_crs_to_wgs84(h, proj, zone_extent, pin, gp, refine_wgs84=refine_wgs84)
               if hw:
                  holes_wgs.append(hw)
            if ext_wgs:
               new_polys.append([ext_wgs] + holes_wgs)
         return {"type": "MultiPolygon", "coordinates": new_polys}
      if gtype == "LineString":
         coords = geom["coordinates"]
         out_coords: List[Tuple[float, float]] = []
         for i in range(len(coords) - 1):
            p = coords[i]
            n = coords[i + 1]
            seg_pts = _insert_intermediate_points_crs_segment(p, n, refine_wgs84=refine_wgs84)
            for (x_crs, y_crs) in seg_pts:
               pin.x = x_crs
               pin.y = y_crs
               proj.inverse(pin, gp, False)
               out_coords.append((float(gp.lon), float(gp.lat)))
         pin.x = coords[-1][0]
         pin.y = coords[-1][1]
         proj.inverse(pin, gp, False)
         out_coords.append((float(gp.lon), float(gp.lat)))
         return {"type": "LineString", "coordinates": out_coords}
      if gtype == "MultiLineString":
         new_lines = []
         for line in geom["coordinates"]:
            out_coords = []
            for i in range(len(line) - 1):
               p = line[i]
               n = line[i + 1]
               seg_pts = _insert_intermediate_points_crs_segment(p, n, refine_wgs84=refine_wgs84)
               for (x_crs, y_crs) in seg_pts:
                  pin.x = x_crs
                  pin.y = y_crs
                  proj.inverse(pin, gp, False)
                  out_coords.append((float(gp.lon), float(gp.lat)))
            pin.x = line[-1][0]
            pin.y = line[-1][1]
            proj.inverse(pin, gp, False)
            out_coords.append((float(gp.lon), float(gp.lat)))
            new_lines.append(out_coords)
         return {"type": "MultiLineString", "coordinates": new_lines}
      if gtype == "Point":
         pin.x = geom["coordinates"][0]
         pin.y = geom["coordinates"][1]
         proj.inverse(pin, gp, False)
         return {"type": "Point", "coordinates": (float(gp.lon), float(gp.lat))}
      if gtype == "MultiPoint":
         pts = []
         for (x_crs, y_crs) in geom["coordinates"]:
            pin.x = x_crs
            pin.y = y_crs
            proj.inverse(pin, gp, False)
            pts.append((float(gp.lon), float(gp.lat)))
         return {"type": "MultiPoint", "coordinates": pts}
      return geom

   typ = obj["type"]
   if typ == "FeatureCollection":
      out = {"type": "FeatureCollection", "features": []}
      for feat in obj["features"]:
         geom = feat.get("geometry")
         if geom is None:
            out["features"].append(dict(feat))
            continue
         new_geom = _process_geom(geom, zone_extent, refine_wgs84=refine_wgs84)
         new_feat = dict(feat)
         new_feat["geometry"] = new_geom
         out["features"].append(new_feat)
      return out
   if typ == "Feature":
      geom = obj["geometry"]
      new_geom = _process_geom(geom, zone_extent, refine_wgs84=refine_wgs84) if geom is not None else None
      out = dict(obj)
      out["geometry"] = new_geom
      return out
   return _process_geom(obj, zone_extent, refine_wgs84=refine_wgs84)



================================================
FILE: high-vibes/fg/wkbc.py
================================================
# fg/wkbc.py
# Write a WKB Collection (WKBC) file using Shapely to produce WKB geometry bytes.
# Header (per spec): Endianness (1 byte), Coordinate Type (1 byte), Geometry Type (2 bytes), Feature Count (4 bytes)
# Followed by feature lookup table: (feature_id:uint64, offset:uint64) * N
# Followed by concatenated WKB geometry blobs (big-endian WKB produced by Shapely).

import struct
from typing import Dict, Any, List
from shapely.geometry import shape, mapping
from shapely import wkb

# Geometry-type codes per WKBC spec (1: point, 2: linestring, 3: polygon)
# Use the most specific code that represents the collection; if mixed, use 0.
_GEOM_CODE_POINT = 1
_GEOM_CODE_LINE = 2
_GEOM_CODE_POLY = 3

def _be_uint8(v: int) -> bytes:
   return struct.pack(">B", v)

def _be_uint16(v: int) -> bytes:
   return struct.pack(">H", v)

def _be_uint32(v: int) -> bytes:
   return struct.pack(">I", v)

def _be_uint64(v: int) -> bytes:
   return struct.pack(">Q", v)

def _detect_coord_type_and_geom_code(features: List[Dict[str, Any]]):
   any_z = False
   geom_kind = None  # one of 'point','line','poly' or None/mixed
   for f in features:
      g = f.get("geometry")
      if not g:
         continue
      shp = shape(g)
      # detect Z by inspecting geometry coordinates via shapely
      # shapely geometries expose has_z
      if getattr(shp, "has_z", False):
         any_z = True
      t = g.get("type")
      if t in ("Point", "MultiPoint"):
         kind = "point"
      elif t in ("LineString", "MultiLineString"):
         kind = "line"
      elif t in ("Polygon", "MultiPolygon"):
         kind = "poly"
      else:
         kind = "mixed"
      if geom_kind is None:
         geom_kind = kind
      elif geom_kind != kind:
         geom_kind = "mixed"
   coord_byte = 0
   if any_z:
      coord_byte |= 1  # Z bit
   # M not handled here (leave bit 0)
   if geom_kind == "point":
      geom_code = _GEOM_CODE_POINT
   elif geom_kind == "line":
      geom_code = _GEOM_CODE_LINE
   elif geom_kind == "poly":
      geom_code = _GEOM_CODE_POLY
   else:
      geom_code = 0  # mixed/unknown
   return coord_byte, geom_code

def write_wkb_collection_file(fc: Dict[str, Any], path: str) -> None:
   features = fc.get("features", []) or []
   count = len(features)

   coord_byte, geom_code = _detect_coord_type_and_geom_code(features)

   # Header: endianness (1 byte, 0 = big), coord type (1 byte), geom type (2 bytes), feature count (4 bytes)
   header = _be_uint8(0) + _be_uint8(coord_byte) + _be_uint16(geom_code) + _be_uint32(count)

   # Build WKB blobs using Shapely (big-endian). Use output_dimension=3 if geometry has Z.
   geom_blobs: List[bytes] = []
   for f in features:
      g = f.get("geometry")
      if not g:
         geom_blobs.append(b"")
         continue
      shp = shape(g)
      dim = 3 if getattr(shp, "has_z", False) else 2
      # shapely.wkb.dumps supports byte_order and output_dimension in modern versions
      # byte_order=0 -> big-endian
      geom_wkb = wkb.dumps(shp, output_dimension=dim, byte_order=0)
      geom_blobs.append(geom_wkb)

   # Compute lookup table offsets (offsets are from start of file)
   lookup_entry_size = 8 + 8  # feature_id:uint64 + offset:uint64
   lookup_table_size = count * lookup_entry_size
   offset_base = len(header) + lookup_table_size

   offsets: List[int] = []
   cur = offset_base
   for b in geom_blobs:
      offsets.append(cur)
      cur += len(b)

   # Write file: header, lookup table, geometries
   with open(path, "wb") as fh:
      fh.write(header)
      for i, f in enumerate(features):
         fid = int(f.get("id", 0))
         off = offsets[i]
         fh.write(_be_uint64(fid))
         fh.write(_be_uint64(off))
      for b in geom_blobs:
         fh.write(b)

# Read a WKBC file written by write_wkb_collection_file and return a GeoJSON-like FeatureCollection
def read_wkb_collection_file(path: str) -> Dict[str, Any]:
   fh = open(path, "rb")
   # header: endianness (1), coord type (1), geom type (2), feature count (4) -- big-endian per spec
   hdr = fh.read(8)
   if len(hdr) < 8:
      fh.close()
      return {"type": "FeatureCollection", "features": []}
   # unpack big-endian
   endianness = struct.unpack(">B", hdr[0:1])[0]
   coord_type = struct.unpack(">B", hdr[1:2])[0]
   geom_code = struct.unpack(">H", hdr[2:4])[0]
   feature_count = struct.unpack(">I", hdr[4:8])[0]

   # read lookup table: feature_id:uint64, offset:uint64
   lookup: List[tuple] = []
   for i in range(feature_count):
      entry = fh.read(16)
      if len(entry) < 16:
         break
      fid = struct.unpack(">Q", entry[0:8])[0]
      off = struct.unpack(">Q", entry[8:16])[0]
      lookup.append((int(fid), int(off)))

   # read geometry blobs using offsets
   geom_blobs: List[tuple] = []
   for i, (fid, off) in enumerate(lookup):
      fh.seek(off)
      if i + 1 < len(lookup):
         next_off = lookup[i + 1][1]
         length = next_off - off
         geom_bytes = fh.read(length)
      else:
         geom_bytes = fh.read()
      geom_blobs.append((fid, geom_bytes))

   fh.close()

   # convert WKB bytes to GeoJSON geometry using shapely
   features: List[Dict[str, Any]] = []
   for fid, gb in geom_blobs:
      if not gb:
         features.append({"type": "Feature", "id": int(fid), "properties": None, "geometry": None})
         continue
      shp = wkb.loads(bytes(gb))
      geojson_geom = mapping(shp)
      features.append({"type": "Feature", "id": int(fid), "properties": None, "geometry": geojson_geom})

   return {"type": "FeatureCollection", "features": features}



================================================
FILE: high-vibes/ogcapi/utils.py
================================================
# ogcapi_utils.py
# Shared helpers: base template, media negotiation, link helpers, html renderer

import os
import json
from typing import Iterable
from flask import current_app, request, render_template_string, Response

BASE_HTML = """<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>{{ title or "DGGS API" }}</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
    body{font-family:system-ui,Segoe UI,Roboto,Arial;margin:18px;color:#222;background:#f6f7fb}
    header{margin-bottom:12px}
    .card{border:1px solid #e1e4ea;padding:12px;margin:8px 0;border-radius:6px;background:#fff}
    .meta{color:#666;font-size:0.9em}
    pre.json{background:#f7f7f9;padding:8px;border-radius:4px;overflow:auto}
    a{color:#0366d6;text-decoration:none}
    a:hover{text-decoration:underline}
    .small{font-size:0.9em;color:#555}
    .grid{display:grid;grid-template-columns:1fr;gap:10px}
    @media(min-width:800px){ .grid{grid-template-columns:repeat(2,1fr)} }
    .format-links{margin-top:8px}
    .format-links a{margin-right:10px}
  </style>
</head>
<body>
  <header><h1>{{ title or "DGGS API" }}</h1></header>
  <main>{% block content %}{% endblock %}</main>
</body>
</html>
"""

def data_root():
    return current_app.config.get("DATA_ROOT", os.getcwd())

def negotiate_format(req, path=None):
    # Decide whether the client wants HTML or JSON.
    p = (path or req.path or "").lower()

    if p.endswith(".json"):      return "json",       False
    if p.endswith(".ubjson"):    return "ubjson",     False
    if p.endswith(".geojson"):   return "geojson",    False
    if p.endswith(".geoubjson"): return "geoubjson",  False

    f = (req.args.get("f") or "").lower()
    if f in ("json", "ubjson", "geojson", "geoubjson", "html"):
        fmt = f
    else:
        accept = (req.headers.get("Accept") or "").lower()
        if "text/html" in accept: fmt = "html"
        elif "application/json"        in accept: fmt = "json"
        elif "application/ubjson"      in accept: fmt = "ubjson"
        elif "application/geo+json"    in accept: fmt = "geojson"
        elif "application/geo+ubjson"  in accept: fmt = "geoubjson"
        else:                                     fmt = "json"

    ae = (req.headers.get("Accept-Encoding") or "").lower()
    gzip_ok = "gzip" in ae or "*" in ae

    return fmt, gzip_ok

GEOJSON_PROFILES = {"rfc7946", "jsonfg", "jsonfg-plus"}
DGGSFG_PROFILES = {"jsonfg-dggs", "jsonfg-dggs-plus", "jsonfg-dggs-zoneids", "jsonfg-dggs-zoneids-plus"}

def negotiate_profile(request, fmt, default_profile=None):
   # collect profile tokens from Accept-Profile header and profile query param
   profile_tokens = []
   accept_profile_hdr = request.headers.get("Accept-Profile", "")
   if accept_profile_hdr:
      for part in accept_profile_hdr.split(","):
         token = part.split(";", 1)[0].strip()
         if token:
            profile_tokens.append(token)
   profile_q = request.args.get("profile", "")
   if profile_q:
      for part in profile_q.split(","):
         token = part.split(";", 1)[0].strip()
         if token:
            profile_tokens.append(token)

   profile = default_profile
   if profile_tokens:
      if fmt == "geojson" or fmt == "geoubjson":
         if any(profile_token_matches(tok, DGGSFG_PROFILES) for tok in profile_tokens):
            profile = "jsonfg-dggs"
         elif any(profile_token_matches(tok, GEOJSON_PROFILES) for tok in profile_tokens):
            profile = "rfc7946"

   return profile

def make_link(href, rel=None, title=None, type=None):
    # Create a link object. Nothing more.
    # You decide where it goes (JSON, HTML top, HTML bottom).
    link = {"href": href}
    if rel:
        link["rel"] = rel
    if title:
        link["title"] = title
    if type:
        link["type"] = type
    return link


def label_for_link(link):
    return link.get("title") or link.get("rel") or "link"


def html_response(body_template: str, **ctx):
    # Render HTML using the base template.
    full = BASE_HTML.replace("{% block content %}{% endblock %}", body_template)
    return Response(
        render_template_string(full, base=BASE_HTML, **ctx),
        mimetype="text/html; charset=utf-8"
    )

# ----------------------------------------------------------------------
# JSON pretty printer with compact arrays
# ----------------------------------------------------------------------

def _is_primitive(v):
    return v is None or isinstance(v, (str, bool, int, float))

def _serialize_primitive(v):
    return json.dumps(v, ensure_ascii=False)

def pretty_json(obj, indent=0, indent_step=3):
    #Pretty-print JSON with:
    #- indentation
    #- arrays of primitives on one line
    #- nested arrays/objects expanded
    sp = " " * indent
    next_sp = " " * (indent + indent_step)

    if _is_primitive(obj):
        return _serialize_primitive(obj)

    if isinstance(obj, list):
        if not obj:
            return "[]"
        if all(_is_primitive(x) for x in obj):
            inner = ", ".join(_serialize_primitive(x) for x in obj)
            return f"[{inner}]"
        parts = [
            f"{next_sp}{pretty_json(x, indent + indent_step, indent_step)}"
            for x in obj
        ]
        return "[\n" + ",\n".join(parts) + "\n" + sp + "]"

    if isinstance(obj, dict):
        if not obj:
            return "{}"
        parts = []
        for k, v in obj.items():
            key = json.dumps(k, ensure_ascii=False)
            val = pretty_json(v, indent + indent_step, indent_step)
            parts.append(f"{next_sp}{key}: {val}")
        return "{\n" + ",\n".join(parts) + "\n" + sp + "}"

    return json.dumps(obj, ensure_ascii=False)

def profile_token_matches(token: str, short_names: Iterable[str]) -> bool:
   # Return True when the profile token matches any of the provided short_names.
   # Supported token forms:
   # - short name (e.g., "jsonfg-dggs")
   # - CURIE form "ogc-profile:NAME"
   # - full URI forms "https://www.opengis.net/def/profile/ogc/0/NAME"
   #  and "http://www.opengis.net/def/profile/ogc/0/NAME"
   if not token:
      return False
   tok = token.strip()
   if not tok:
      return False

   # direct short-name match
   if tok in short_names:
      return True

   # CURIE form ogc-profile:NAME
   if tok.startswith("ogc-profile:"):
      name = tok.split(":", 1)[1]
      if name in short_names:
         return True

   # full URI forms
   for prefix in ("https://www.opengis.net/def/profile/ogc/0/",
                  "http://www.opengis.net/def/profile/ogc/0/"):
      if tok.startswith(prefix):
         name = tok[len(prefix):]
         if name in short_names:
            return True

   return False



================================================
FILE: high-vibes/ogcapi/common/collections.py
================================================
# ogcapi_collections.py
# OGC API - DGGS Collections

from flask import Blueprint, request, url_for, Response
import os
from dggsStore.store import get_store
from ..utils import (
   data_root,
   negotiate_format,
   make_link,
   label_for_link,
   html_response,
)
import json

bp = Blueprint("collections", __name__, url_prefix="/collections")

# ----------------------------------------------------------------------
# Templates (minimal presentation tweaks only)
# - Single modest "Explore list of DGGRSs" action placed once below spatial extent
# - Indent lat/lon lines and include degree symbol
# - Keep small spacing above description
# ----------------------------------------------------------------------

COLLECTIONS_HTML = """
{% block content %}
  <div class="small top-links">
    {% for l in top_links %}
      <a href="{{ l.href }}">{{ l.label }}</a>{% if not loop.last %} · {% endif %}
    {% endfor %}
  </div>

  <div class="grid">
  {% for c in collections %}
    <div class="card">
      <h2 class="collection-title"><a href="{{ c.self_href }}">{{ c.title }}</a></h2>
      <p class="description" style="margin-top:0.25rem;">{{ c.description }}</p>

      <div class="small">
        {% for l in c.sub_links %}
          <a href="{{ l.href }}">{{ l.label }}</a>{% if not loop.last %} · {% endif %}
        {% endfor %}
      </div>
    </div>
  {% endfor %}
  </div>
{% endblock %}
"""

COLLECTION_HTML = """
{% block content %}
  <div class="small top-links">
    {% for l in top_links %}
      <a href="{{ l.href }}">{{ l.label }}</a>{% if not loop.last %} · {% endif %}
    {% endfor %}
  </div>

  {# small spacing above description retained #}
  {% if collection.description %}
    <p style="margin-top:0.25rem;margin-bottom:0.5rem;color:#444;">{{ collection.description }}</p>
  {% endif %}

  {% if extent_lines %}
    <div style="margin:0.75rem 0;">
      <div style="font-weight:600;margin-bottom:0.25rem;">Spatial extent</div>
      <div style="margin-left:1rem;color:#333;">
        {% for line in extent_lines %}
          <div style="margin:0.15rem 0;">{{ line }}</div>
        {% endfor %}
      </div>
    </div>
  {% endif %}

  {# Single modest action placed only here (below spatial extent) #}
  {% if sub_links %}
    <div style="margin:0.5rem 0 0.75rem 0;">
      <a href="{{ sub_links[0].href }}" style="font-size:1.05rem;color:#0b74de;text-decoration:none;font-weight:600;">
        Explore list of DGGRSs
      </a>
    </div>
  {% endif %}
{% endblock %}
"""

# ----------------------------------------------------------------------
# Helpers
# ----------------------------------------------------------------------

def collections_base(root: str) -> str:
   path = os.path.join(root, "collections")
   return path if os.path.isdir(path) else root

def format_extent(extent):
   try:
      minx, miny, maxx, maxy = map(float, extent)
   except Exception:
      return []
   # include degree symbol
   return [
      f"Latitude: from {miny}° to {maxy}°",
      f"Longitude: from {minx}° to {maxx}°",
   ]

# ----------------------------------------------------------------------
# Routes
# ----------------------------------------------------------------------

@bp.route("", methods=["GET"])
def list_collections():
   root = data_root()
   base = collections_base(root)
   ids = sorted(d for d in os.listdir(base) if os.path.isdir(os.path.join(base, d)))

   fmt, _ = negotiate_format(request)

   collections = []
   for cid in ids:
      store = get_store(root, cid)
      cfg = getattr(store, "config", {}) or {}

      self_href = url_for("collections.get_collection", collectionId=cid)

      # JSON links (self + alternate + dggrs)
      links = [
         make_link(f"{self_href}?f=json", rel="self", type="application/json"),
         make_link(f"{self_href}?f=html", rel="alternate", type="text/html"),
         make_link(
            url_for("dggrs.list_collection_dggrs", collectionId=cid),
            rel="[ogc-rel:dggrs]",
            title="DGGRS list"
         )
      ]

      # HTML-only subresource links (kept as small text links)
      sub_links = [
         {"href": l["href"], "label": label_for_link(l)}
         for l in links if l.get("rel") == "[ogc-rel:dggrs]"
      ]

      collections.append({
         "id": cid,
         "title": cfg.get("title", cid),
         "description": cfg.get("description", ""),
         "self_href": self_href,
         "sub_links": sub_links,   # HTML only
         "links": links            # JSON only
      })

   if fmt == "html":
      top_links = [
         {"href": "/", "label": "Back to landing page"},
         {"href": f"{request.path}?f=json", "label": "JSON"},
      ]
      return html_response(
         COLLECTIONS_HTML,
         title="Collections",
         collections=collections,
         top_links=top_links,
      )

   # JSON output (NO sub_links)
   body = json.dumps({"collections": collections}, indent=2) + "\n"
   return Response(body, mimetype="application/json; charset=utf-8")


@bp.route("/<collectionId>", methods=["GET"])
def get_collection(collectionId: str):
   root = data_root()
   store = get_store(root, collectionId)
   if store is not None:
      cfg = getattr(store, "config", {}) or {}

      fmt, _ = negotiate_format(request)

      self_href = url_for("collections.get_collection", collectionId=collectionId)

      # JSON links (self + alternate + up + dggrs)
      links = [
         make_link(f"{self_href}?f=json", rel="self", type="application/json"),
         make_link(f"{self_href}?f=html", rel="alternate", type="text/html"),
         make_link(url_for("collections.list_collections"), rel="up"),
         make_link(
            url_for("dggrs.list_collection_dggrs", collectionId=collectionId),
            rel="[ogc-rel:dggrs]",
            title="DGGRS list"
         )
      ]

      resp = {
         "id": collectionId,
         "title": cfg.get("title", collectionId),
         "description": cfg.get("description", ""),
         "extent": {"spatial": {"bbox": [[-180, -90, 180, 90]]}},
         "links": links,
      }

      extent = resp["extent"]["spatial"]["bbox"][0]
      extent_lines = format_extent(extent)

      if fmt == "html":
         top_links = [
            {"href": url_for("collections.list_collections"), "label": "Back to Collections"},
            {"href": f"{request.path}?f=json", "label": "JSON"},
         ]

         sub_links = [
            {"href": l["href"], "label": label_for_link(l)}
            for l in links if l.get("rel") == "[ogc-rel:dggrs]"
         ]

         return html_response(
            COLLECTION_HTML,
            title=resp["title"],
            collection=resp,
            top_links=top_links,
            sub_links=sub_links,
            extent_lines=extent_lines,
         )

      body = json.dumps(resp, indent=2) + "\n"
      return Response(body, mimetype="application/json; charset=utf-8")
   else:
      return Response(b"", status=404, mimetype=None)



================================================
FILE: high-vibes/ogcapi/common/conformance.py
================================================
# ogcapi_conformance.py
# /conformance endpoint: returns OGC API conformance classes (JSON + HTML).

from flask import *
from ..utils import negotiate_format, html_response, pretty_json
from typing import List

bp = Blueprint("conformance", __name__)

CONFORMANCE_HTML = """
{% block content %}
  <div class="small top-links">
    {% for l in top_links %}
      <a href="{{ l.href }}">{{ l.title }}</a>{% if not loop.last %} · {% endif %}
    {% endfor %}
  </div>

  <div class="card">
    <p class="small">Conformance classes implemented by this server</p>

    <ul>
      {% for c in conformsTo %}
        <li><a href="{{ c }}">{{ c }}</a></li>
      {% endfor %}
    </ul>
  </div>
{% endblock %}
"""

DEFAULT_CONFORMANCE: List[str] = [
    "https://www.opengis.net/spec/ogcapi-dggs-1/1.0/conf/core",
    "https://www.opengis.net/spec/ogcapi-dggs-1/1.0/conf/data-retrieval",
    "https://www.opengis.net/spec/ogcapi-dggs-1/1.0/conf/data-custom-depths",
    "https://www.opengis.net/spec/ogcapi-dggs-1/1.0/conf/collection-dggs",
    "https://www.opengis.net/spec/ogcapi-dggs-1/1.0/conf/data-json",
    "https://www.opengis.net/spec/ogcapi-dggs-1/1.0/conf/data-ubjson"
]

@bp.route("/conformance", methods=["GET"])
def conformance():
    app = current_app._get_current_object() if hasattr(current_app, "_get_current_object") else current_app

    conforms = app.config.get("CONFORMANCE_CLASSES") or DEFAULT_CONFORMANCE

    html_self = url_for("conformance.conformance", _external=False)
    json_self = html_self + "?f=json"
    up_href = url_for("landing.root_index", _external=False)

    # HTML top bar
    top_links = [
        {"href": up_href, "title": "Back to landing page"},
        {"href": json_self, "title": "JSON"}
    ]

    # JSON links (NO landing page as alternate)
    links = [
        {"rel": "self", "type": "application/json", "href": json_self},
        {"rel": "alternate", "type": "text/html", "href": html_self},
        {"rel": "up", "href": up_href}
    ]

    payload = {
        "title": "DGGS API Conformance",
        "description": "Conformance declarations for this server",
        "links": links,
        "conformsTo": conforms
    }

    fmt, _ = negotiate_format(request, request.path)

    if fmt == "html":
        return html_response(
            CONFORMANCE_HTML,
            title="Conformance",
            conformsTo=conforms,
            top_links=top_links
        )

    return Response(pretty_json(payload) + "\n", mimetype="application/json; charset=utf-8")



================================================
FILE: high-vibes/ogcapi/common/landingPage.py
================================================
# ogcapi_landingPage.py
# Landing page for the DGGS API.

from flask import *
from ..utils import data_root, negotiate_format, html_response, pretty_json
import os
from typing import List, Dict, Any

bp = Blueprint("landing", __name__)

PAGE_TITLE = "DGGAL High Vibes DGGS Data Store"
PAGE_SUBTITLE = "A vibe-coded OGC API - DGGS implementation based on DGGAL"

ROOT_HTML = """
{% block content %}
  <div class="small top-links">
    {% for l in top_links %}
      <a href="{{ l.href }}">{{ l.title }}</a>{% if not loop.last %} · {% endif %}
    {% endfor %}
  </div>

  <div class="card">
    <p class="small">{{ subtitle }}</p>

    <div class="big-link" style="margin:0.5em 0; font-weight:600;">
      <a href="{{ data_collections_href }}">Browse Data Collections</a>
    </div>

    <div class="small mid-links">
      <a href="{{ conformance_href }}">Conformance declaration</a> ·
      <a href="{{ api_doc_href }}">API documentation</a> ·
      <a href="{{ openapi_href }}">OpenAPI definition</a>
    </div>
  </div>
{% endblock %}
"""

@bp.route("/", methods=["GET"])
def root_index():
   ROOT = data_root()

   # collections list removed per request (not enumerating directories)
   collections: List[Dict[str, Any]] = []

   base = None
   if ROOT and os.path.isdir(ROOT):
      # Prefer a "collections" subfolder if present
      coll_dir = os.path.join(ROOT, "collections")
      if os.path.isdir(coll_dir):
         base = coll_dir
      else:
         # Fall back to ROOT (not used for listing here)
         base = ROOT

   html_self = url_for("landing.root_index", _external=False)
   json_self = html_self + "?f=json"

   top_links = [
      {"href": json_self, "title": "JSON"}
   ]

   # Data Collections promoted separately
   data_collections_href = url_for("collections.list_collections")
   conformance_href = url_for("conformance.conformance")
   api_doc_href = "https://developer.ogc.org/api/dggs/index.html"
   openapi_href = "https://schemas.opengis.net/ogcapi/dggs/1.0/openapi/ogcapi-dggs-1.bundled.json"

   links = [
      {"rel": "self", "type": "application/json", "href": json_self},
      {"rel": "alternate", "type": "text/html", "href": html_self},
      {"rel": "data", "href": data_collections_href},
      {"rel": "conformance", "href": conformance_href},
      {"rel": "service-doc", "type" : "text/html", "href": api_doc_href},
      {"rel": "service-desc", "type": "application/vnd.oai.openapi+json;version=3.0", "href": openapi_href}
   ]

   fmt, _ = negotiate_format(request, request.path)

   if fmt == "json":
      payload = {
         "title": PAGE_TITLE,
         "description": PAGE_SUBTITLE,
         "links": links
      }
      return Response(pretty_json(payload) + "\n", mimetype="application/json; charset=utf-8")

   return html_response(
      ROOT_HTML,
      title=PAGE_TITLE,
      subtitle=PAGE_SUBTITLE,
      # collections intentionally left empty / unused in template
      top_links=top_links,
      data_collections_href=data_collections_href,
      conformance_href=conformance_href,
      api_doc_href=api_doc_href,
      openapi_href=openapi_href
   )



================================================
FILE: high-vibes/ogcapi/dggs/client.py
================================================
# ogcapi/dggs/client.py
from typing import List, Dict, Any, Optional, Tuple
from concurrent.futures import ThreadPoolExecutor, as_completed
from urllib.parse import urlparse
import requests

JSON_MIME = "application/json"
# UBJSON_MIME = "application/ub+json"
# GZIP_HEADER = "gzip"

TIMEOUT = 120


def parse_resource_url(resource_url: str) -> Tuple[str, str, str]:
   # Parse a resource URL like:
   #   http://host/.../ogcapi/collections/{collectionId}/dggs/{dggrsId}
   # Returns (landing_base, collectionId, dggrsId).
   p = urlparse(resource_url)
   parts = p.path.strip("/").split("/")
   ci = parts.index("collections")
   collectionId = parts[ci + 1]
   di = parts.index("dggs")
   dggrsId = parts[di + 1]
   landing_base = f"{p.scheme}://{p.netloc}"
   if "ogcapi" in parts:
      oi = parts.index("ogcapi")
      landing_base = f"{landing_base}/{'/'.join(parts[:oi+1])}"
   return landing_base, collectionId, dggrsId


def get_collection_info(landing: str, collectionId: str, timeout: int = TIMEOUT) -> Dict[str, Any]:
   # GET /collections/{collectionId} and return parsed JSON.
   url = f"{landing.rstrip('/')}/collections/{collectionId}"
   r = requests.get(url, headers={"Accept": JSON_MIME}, timeout=timeout)
   r.raise_for_status()
   return r.json()


def get_dggrs_description(landing: str, collectionId: str, dggrsId: str, timeout: int = TIMEOUT) -> Dict[str, Any]:
   # GET /collections/{collectionId}/dggs/{dggrsId} and return parsed JSON.
   url = f"{landing.rstrip('/')}/collections/{collectionId}/dggs/{dggrsId}"
   r = requests.get(url, headers={"Accept": JSON_MIME}, timeout=timeout)
   r.raise_for_status()
   return r.json()


def _zone_data_url(landing: str, collectionId: str, dggrsId: str, zoneId: str) -> str:
   return f"{landing.rstrip('/')}/collections/{collectionId}/dggs/{dggrsId}/zones/{zoneId}/data"


def fetch_zone_data_parallel(landing: str,
                             collectionId: str,
                             dggrsId: str,
                             zone_texts: List[str],
                             workers: int = 8,
                             timeout: int = TIMEOUT,
                             depth: Optional[int] = None,
                             use_ubjson: bool = False) -> Dict[str, Any]:
   # Fetch zone data objects in parallel.
   # Returns a dict mapping zone_text -> parsed object.
   # By default requests application/json. To request UBJSON+gzip set use_ubjson=True
   # and ensure server supports it (UBJSON handling is commented below).
   headers = {
      "Accept": JSON_MIME,
      "User-Agent": "dgg-fetch/1.0"
   }

   # For UBJSON + gzip from servers that support it, uncomment:
   # headers = {
   #    "Accept": UBJSON_MIME,
   #    "Accept-Encoding": GZIP_HEADER,
   #    "User-Agent": "dgg-fetch/1.0"
   # }

   params = {}
   if depth is not None:
      params["zone-depth"] = depth

   def _fetch(ztext: str):
      url = _zone_data_url(landing, collectionId, dggrsId, ztext)
      r = requests.get(url, params=params, headers=headers, timeout=timeout)

      if r.status_code in (400, 404):
         return ztext, None
      r.raise_for_status()   # It's normal to get some NODATA...
      # If UBJSON response handling is desired and server returns UBJSON bytes:
      # if use_ubjson:
      #    import gzip, ubjson
      #    data = r.content
      #    # if server sent gzip, decompress:
      #    # data = gzip.decompress(data)
      #    return ztext, ubjson.loadb(data)
      return ztext, r.json()

   out: Dict[str, Any] = {}
   with ThreadPoolExecutor(max_workers=workers) as ex:
      futures = [ex.submit(_fetch, z) for z in zone_texts]
      for fut in as_completed(futures):
         ztext, obj = fut.result()
         out[ztext] = obj
   return out



================================================
FILE: high-vibes/ogcapi/dggs/dggrs.py
================================================
from flask import Blueprint, request, url_for, Response, current_app
import logging
from dggsStore.store import get_store
from ..utils import negotiate_format, html_response, pretty_json

logger = logging.getLogger("dgg-serve.dggrs")

bp = Blueprint("dggrs", __name__, url_prefix="/collections/<collectionId>/dggs")


def build_dggrs_description(store, collectionId, dggrsId):
    cfg = store.config
    collection_title = cfg.get("title", collectionId)

    desc_href = f"/collections/{collectionId}/dggs/{dggrsId}"
    def_href = f"https://www.opengis.net/def/dggrs/OGC/1.0/{dggrsId}"
    collection_href = f"/collections/{collectionId}"
    zones_href = f"/collections/{collectionId}/dggs/{dggrsId}/zones"

    top_links = [
        {"rel": "self", "title": "Description", "href": desc_href},
        {"rel": "[ogc:geodata]", "title": "Collection", "href": collection_href},
    ]

    mid_links = [
        {"rel": "[ogc:dggrs-definition]", "title": "DGGRS Definition", "href": def_href},
        {"rel": "[ogc:dggrs-zone-query]", "title": "Zones", "href": zones_href},
    ]

    json_links = top_links + mid_links

    return {
        "id": dggrsId,
        "title": f"{dggrsId} DGGRS for {collection_title}",
        "uri": def_href,
        "defaultDepth": store.depth,
        "maxRefinementLevel": store.maxRefinementLevel,
        "links": json_links,
        "top_links": top_links,
        "mid_links": mid_links,
        "linkTemplates": [
            {
                "rel": "[ogc:dggrs-zone-data]",
                "title": f"{dggrsId} data for {collectionId}",
                "uriTemplate": f"/collections/{collectionId}/dggs/{dggrsId}/zones/{{zoneId}}/data"
            }
        ]
    }


DGGRS_LIST_HTML = """
{% block content %}
  <div class="small top-links">
    {% for l in top_links %}
      <a href="{{ l.href }}">{{ l.title }}</a>{% if not loop.last %} · {% endif %}
    {% endfor %}
  </div>

  <div class="card"><h2>Available DGGRSs</h2></div>

  {% for g in dggrs %}
    <div class="card">
      <h3><a href="{{ g.links[0].href }}">{{ g.title }}</a></h3>

      <div class="small">
        {% for l in g.mid_links %}
          <a href="{{ l.href }}">{{ l.title }}</a>{% if not loop.last %} · {% endif %}
        {% endfor %}
      </div>

      <div class="small">
        <strong>Zone Data Retrieval Link Template:</strong><br>
        {% for t in g.linkTemplates %}
          <code>{{ t.uriTemplate }}</code>{% if not loop.last %} · {% endif %}
        {% endfor %}
      </div>
    </div>
  {% endfor %}
{% endblock %}
"""

DGGRS_HTML = """
{% block content %}
  <div class="small top-links">
    {% for l in top_links %}
      <a href="{{ l.href }}">{{ l.title }}</a>{% if not loop.last %} · {% endif %}
    {% endfor %}
  </div>

  <div class="card">
    <h2>{{ dggrs.title }}</h2>

    <div class="small">
      {% for l in mid_links %}
        <a href="{{ l.href }}">{{ l.title }}</a>{% if not loop.last %} · {% endif %}
      {% endfor %}
    </div>

    <div class="small">
      <strong>Zone Data Retrieval Link Template:</strong><br>
      {% for t in dggrs.linkTemplates %}
        <code>{{ t.uriTemplate }}</code>{% if not loop.last %} · {% endif %}
      {% endfor %}
    </div>
  </div>
{% endblock %}
"""


@bp.route("", methods=["GET"])
def list_collection_dggrs(collectionId: str):
    try:
        DATA_ROOT = current_app.config.get("DATA_ROOT")
        store = get_store(DATA_ROOT, collectionId) if DATA_ROOT else None
        if not store:
            return Response(
                pretty_json({"error": "Collection not found"}) + "\n",
                status=404,
                mimetype="application/json; charset=utf-8",
            )

        cfg = store.config
        dggrs_id = cfg.get("dggrs")
        entries = []

        if dggrs_id:
            entries.append(build_dggrs_description(store, collectionId, dggrs_id))

        html_self = f"/collections/{collectionId}/dggs"
        json_self = html_self + "?f=json"
        html_alt = html_self + "?f=html"
        up_href = f"/collections/{collectionId}"

        fmt, _ = negotiate_format(request, request.path)

        if fmt == "json":
            payload = {
                "title": f"DGGRSs for collection {collectionId}",
                "links": [
                    {"rel": "self", "type": "application/json", "href": json_self},
                    {"rel": "alternate", "type": "text/html", "href": html_alt},
                    {"rel": "up", "href": up_href},
                ],
                "dggrs": [
                    {
                        "id": g["id"],
                        "title": g["title"],
                        "uri": g["uri"],
                        "defaultDepth": g["defaultDepth"],
                        "maxRefinementLevel": g["maxRefinementLevel"],
                        "links": g["links"],
                        "linkTemplates": g["linkTemplates"],
                    }
                    for g in entries
                ],
            }
            return Response(
                pretty_json(payload) + "\n",
                mimetype="application/json; charset=utf-8",
            )

        html_entries = []
        for g in entries:
            html_entries.append(g)

        top_links = [
            {"href": up_href, "title": "Back to collection"},
            {"href": json_self, "title": "JSON"},
        ]

        return html_response(
            DGGRS_LIST_HTML,
            title=f"DGGRSs for collection {collectionId}",
            collectionId=collectionId,
            dggrs=html_entries,
            top_links=top_links,
        )

    except Exception:
        logger.exception("list_collection_dggrs failed for %s", collectionId)
        return Response(
            pretty_json({"error": "Internal server error"}) + "\n",
            status=500,
            mimetype="application/json; charset=utf-8",
        )

@bp.route("/<dggrsId>", methods=["GET"])
def get_dggrs(collectionId: str, dggrsId: str):
    try:
        DATA_ROOT = current_app.config.get("DATA_ROOT")
        store = get_store(DATA_ROOT, collectionId) if DATA_ROOT else None
        if not store:
            return Response(
                pretty_json({"error": "Not found"}) + "\n",
                status=404,
                mimetype="application/json; charset=utf-8",
            )

        cfg = store.config
        if cfg.get("dggrs") != dggrsId:
            return Response(
                pretty_json({"error": "Not found"}) + "\n",
                status=404,
                mimetype="application/json; charset=utf-8",
            )

        payload = build_dggrs_description(store, collectionId, dggrsId)
        desc_href = f"/collections/{collectionId}/dggs/{dggrsId}"

        fmt, _ = negotiate_format(request, request.path)

        if fmt == "json":
            json_payload = {
                "id": payload["id"],
                "title": payload["title"],
                "uri": payload["uri"],
                "defaultDepth": payload["defaultDepth"],
                "maxRefinementLevel": payload["maxRefinementLevel"],
                "links": payload["links"],
                "linkTemplates": payload["linkTemplates"],
            }
            return Response(
                pretty_json(json_payload) + "\n",
                mimetype="application/json; charset=utf-8",
            )

        top_links = [
            {"href": f"/collections/{collectionId}/dggs", "title": "Back to DGGRSs"},
            {"href": f"/collections/{collectionId}", "title": "Back to collection"},
            {"href": desc_href + "?f=json", "title": "JSON"},
        ]

        return html_response(
            DGGRS_HTML,
            title=f"DGGRS {dggrsId}",
            dggrs=payload,
            collectionId=collectionId,
            top_links=top_links,
            mid_links=payload["mid_links"],
        )

    except Exception:
        logger.exception("get_dggrs failed for %s/%s", collectionId, dggrsId)
        return Response(
            pretty_json({"error": "Internal server error"}) + "\n",
            status=500,
            mimetype="application/json; charset=utf-8",
        )



================================================
FILE: high-vibes/ogcapi/dggs/zoneData.py
================================================
# ogcapi_dggs_zoneData.py
from flask import Blueprint, request, Response, current_app
import logging
import gzip
import json
import ubjson
from typing import Any, Dict, List

from dggsStore.store import *
from dggsStore.customDepths import assemble_zone_at_depth, parse_zone_depths, build_dggs_json_from_values
from fg.dggsJSONFG import read_dggs_json_fg

from ..utils import *

logger = logging.getLogger("dggs-serve.zoneData")

bp = Blueprint("dggs_zoneData", __name__, url_prefix="/collections/<collectionId>/dggs/<dggrsId>")

@bp.route("/zones/<zoneId>/data", methods=["GET"])
@bp.route("/zones/<zoneId>/data.json", methods=["GET"])
@bp.route("/zones/<zoneId>/data.ubjson", methods=["GET"])
@bp.route("/zones/<zoneId>/data.geojson", methods=["GET"])
def dggs_zone_data(collectionId: str, dggrsId: str, zoneId: str):

   payload_already_gzipped = False
   raw_blob: bytes | None = None
   dggs_json: object | None = None
   body_bytes: bytes | None = None

   DATA_ROOT = data_root()
   store = get_store(DATA_ROOT, collectionId)
   if store is not None and store.config['dggrs'] == dggrsId:
      is_vector = store.is_vector
      dggrs_impl = store.dggrs
      zone = dggrs_impl.getZoneFromTextID(zoneId)

      fmt, gzip_ok = negotiate_format(request, request.path)
      if is_vector:
         if fmt == "geojson" or fmt == "geoubjson":
            profile = "rfc7946"
         else:
            if fmt == "json":      fmt = "geojson"
            elif fmt == "ubjson":  fmt = "geoubjson"
            profile = "jsonfg-dggs"
         profile = negotiate_profile(request, fmt, profile)
         return_dggs_fg = not profile_token_matches(profile, GEOJSON_PROFILES)
      else:
         profile = None

      requested_depths = parse_zone_depths(request.args.get("zone-depth", str(store.depth)))

      if len(requested_depths) == 1 and requested_depths[0] == store.depth:
         pkg = store.compute_package_path_for_root_zone(zone)
         if pkg is not None:
            blob = store.read_zone_blob(pkg, zone)
            if blob is not None:
               # We can't return vector directly because we need to add attributes
               if fmt == "ubjson":
                  if gzip_ok:
                     raw_blob = blob
                     payload_already_gzipped = True
                  else:
                     raw_blob = decompress_blob(blob)
               else:
                  dggs_json = decode_blob(blob)
      elif not is_vector:
         collected_by_depth: CollectedValues = {}
         for d in requested_depths:
            if d == store.depth:
               pkg = store.compute_package_path_for_root_zone(zone)
               blob = store.read_zone_blob(pkg, zone) if pkg is not None else None
               obj = decode_blob(blob) if blob is not None else None
               values_for_depth = obj["values"] if obj is not None else None
            else:
               values_for_depth = assemble_zone_at_depth(store, zone, d)
            if values_for_depth is None:
               collected_by_depth = None
               break
            collected_by_depth[d] = values_for_depth
         if collected_by_depth is not None:
            dggs_json = build_dggs_json_from_values(store, zone, collected_by_depth)
      else:
         body_bytes = pretty_json({"error": "Custom depth not yet supported for vector data"}) + "\n",
         response_status = 400
         payload_mimetype = "application/json"

      if is_vector and dggs_json:
         features = dggs_json.get("features", []) or []
         if features:
            ids = [f.get("id") for f in features if f.get("id") is not None]
            if ids:
               attrs_map = store.get_attributes_for_feature_ids(ids)
               for feat in features:
                  fid = feat.get("id")
                  feat["properties"] = attrs_map.get(fid, {}) or {}
            if not return_dggs_fg:
               dggs_json = read_dggs_json_fg(dggs_json, refine_wgs84=1e-2)

   response_headers = None

   if raw_blob or dggs_json:
      response_status = 200
      if fmt == "geojson":
         body_bytes = pretty_json(dggs_json, indent=3, indent_step=2).encode("utf-8")
         payload_mimetype = "application/geo+json"
      elif fmt == "geoubjson":
         body_bytes = raw_blob if raw_blob is not None else ubjson.dumpb(dggs_json)
         payload_mimetype = "application/geo+ubjson"
      elif fmt == "ubjson":
         body_bytes = raw_blob if raw_blob is not None else ubjson.dumpb(dggs_json)
         payload_mimetype = "application/ubjson"
      else:
         body_bytes = pretty_json(dggs_json, indent=3, indent_step=2).encode("utf-8")
         payload_mimetype = "application/json"

      if gzip_ok:
         if not payload_already_gzipped:
            body_bytes = gzip.compress(body_bytes)
         response_headers = { "Content-Encoding": "gzip" }

      if profile:
         if not response_headers: response_headers = { }
         response_headers["Link"] = f'<https://www.opengis.net/def/profile/ogc/0/{profile}>; rel="profile"'

   elif not body_bytes:
      body_bytes = b""
      response_status = 404
      payload_mimetype = None

   return Response(body_bytes, status=response_status, mimetype=payload_mimetype, headers=response_headers)



================================================
FILE: high-vibes/ogcapi/dggs/zoneInfo.py
================================================
# ogcapi_dggs_zoneInfo.py
# Zone info endpoint (relies only on DGGRS implementation; no DGGS store access)
from dggal import *
from dggsStore.store import *
from ..utils import *
from flask import Blueprint, request, url_for, Response, current_app
from typing import Any, Dict, List
import logging
import ubjson

logger = logging.getLogger("dggs-serve.zoneInfo")

bp = Blueprint("dggs_zoneinfo", __name__, url_prefix="/collections/<collectionId>/dggs/<dggrsId>")

# HTML fragment: top links, card with zone info, then download links at the bottom
ZONE_HTML = """
{% block content %}
  <div class="small top-links">
    {% for l in top_links %}
      <a href="{{ l.href }}">{{ l.title }}</a>{% if not loop.last %} · {% endif %}
    {% endfor %}
  </div>

  <div class="card">
    <h2>Zone information for DGGRS {{ dggrsTitle }} and collection {{ collectionTitle }}</h2>

    {% if zone.level is defined %}
      <div class="small">Level: {{ zone.level }}</div>
    {% endif %}

    {% if zone.shapeType is defined %}
      <div class="small">Shape: {{ zone.shapeType }}</div>
    {% endif %}

    {% if zone.areaMetersSquare is defined %}
      <div class="small">Area (m²): {{ zone.areaMetersSquare }}</div>
    {% endif %}

    {% if zone.centroid is defined %}
      <div class="small">Centroid:</div>
      <div class="small" style="margin-left:20px">Latitude: {{ zone.centroid[1] }}</div>
      <div class="small" style="margin-left:20px">Longitude: {{ zone.centroid[0] }}</div>
    {% endif %}

    {% if zone.bbox is defined %}
      <div class="small">Extent:</div>
      <div class="small" style="margin-left:20px">Latitude: from {{ zone.bbox[1] }} to {{ zone.bbox[3] }}</div>
      <div class="small" style="margin-left:20px">Longitude: from {{ zone.bbox[0] }} to {{ zone.bbox[2] }}</div>
    {% endif %}

    {% if zone.geometry is defined %}
      <div class="small">Geometry (Polygon):</div>
      <pre style="background:#f8f8f8;padding:8px;border-radius:4px;overflow:auto;max-height:300px">{{ zone.geometry | pretty_json }}</pre>
    {% endif %}

    <div style="height:8px"></div>

    <div class="small">Download data for this zone:
      {% for dl in data_links %}
        <a href="{{ dl.href }}">{{ dl.title }}</a>{% if not loop.last %} · {% endif %}
      {% endfor %}
    </div>
  </div>
{% endblock %}
"""

# ---------------- Helpers ----------------

def polygon_geometry_from_zone(dggrs, zone):
   #Return a GeoJSON Polygon geometry for zone using DGGRS.getZoneRefinedWGS84Vertices.
   #- Calls dggrs.getZoneRefinedWGS84Vertices(zone, 0).
   #- Converts vertex objects to [lon, lat] float pairs.
   #- Ensures the ring is closed (last == first).
   #- Returns None if the vertex list is empty or None.
   #Note: returns the Polygon geometry directly (no Feature wrapper, no properties).
   if zone is None:
      return None
   verts = dggrs.getZoneRefinedWGS84Vertices(zone, 0)
   if not verts:
      return None
   coords = [[float(v.lon), float(v.lat)] for v in verts]
   if not coords:
      return None
   if coords[0] != coords[-1]:
      coords.append(coords[0])
   return {"type": "Polygon", "coordinates": [coords]}

# ---------------- Route: zone info ----------------

@bp.route("/zones/<zoneId>", methods=["GET"])
def get_zone_info(collectionId: str, dggrsId: str, zoneId: str):
   # Zone info endpoint that relies only on the DGGRS implementation for zone metadata.
   # The incoming path parameter is a text identifier; resolve it to a DGGRSZone using
   # dggrs.getZoneFromTextID(zoneId). All subsequent DGGRS calls use that DGGRSZone value.
   # Produces JSON / UBJSON / HTML.

   app = current_app._get_current_object() if hasattr(current_app, "_get_current_object") else current_app

   # Use store to obtain collection title
   root = data_root()
   store = get_store(root, collectionId)

   if store is None:
      payload = {"error": f"Invalid collection {collectionId}" }
      fmt, _ = negotiate_format(request, request.path)
      if fmt == "html":
         return html_response(f"<div class='card'><h2>Invalid collection: {collectionId}</h2></div>", status=404)
      return Response(pretty_json(payload) + "\n", status=404, mimetype="application/json; charset=utf-8")

   # Obtain DGGRS implementation instance by name
   dggrs = store.dggrs if store.config['dggrs'] == dggrsId else None #get_or_create_dggrs(dggrsId)
   if dggrs is None:
      payload = {"error": "DGGRS implementation not available", "dggrs": dggrsId}
      fmt, _ = negotiate_format(request, request.path)
      if fmt == "html":
         top_links = [
            {"href": f"/collections/{collectionId}/dggs/{dggrsId}/zones", "title": "Back to zones"},
            {"href": request.path + "?f=json", "title": "JSON"},
            {"href": request.path + "?f=ubjson", "title": "UBJSON"}
         ]
         return html_response("<div class='card'><h2>DGGRS not available</h2></div>",
            #{"title": "DGGRS not available", "top_links": top_links},
            status=404)
      return Response(pretty_json(payload) + "\n", status=404, mimetype="application/json; charset=utf-8")

   # Resolve the incoming text identifier to the DGGRSZone (internal 64-bit identifier)
   zone = dggrs.getZoneFromTextID(zoneId)
   if zone == nullZone:
      payload = {"error": "Invalid zone", "zone": zoneId}
      fmt, _ = negotiate_format(request, request.path)
      if fmt == "html":
         top_links = [
            {"href": f"/collections/{collectionId}/dggs/{dggrsId}/zones", "title": "Back to zones"},
            {"href": request.path + "?f=json", "title": "JSON"},
            {"href": request.path + "?f=ubjson", "title": "UBJSON"}
         ]
         return html_response("<div class='card'><h2>Invalid zone</h2></div>",
            #{"title": "Zone not found", "top_links": top_links},
            status=404)
      return Response(pretty_json(payload) + "\n", status=404, mimetype="application/json; charset=utf-8")

   # canonical text id for presentation / links (DGGRS provides text id)
   zone_id = dggrs.getZoneTextID(zone)

   # Titles for H2
   dggrs_title = dggrsId
   collection_title = store.config.get("title", collectionId)

   # Build fixed canonical links for this resource and its data subresource
   up_href = f"/collections/{collectionId}/dggs/{dggrsId}/zones"
   json_self = request.path + "?f=json"
   ubjson_self = request.path + "?f=ubjson"

   is_vector = store.is_vector
   data_links: List[Dict[str, Any]]
   data_json = f"/collections/{collectionId}/dggs/{dggrsId}/zones/{zone_id}/data?f=json"
   data_ubjson = f"/collections/{collectionId}/dggs/{dggrsId}/zones/{zone_id}/data?f=ubjson"
   if is_vector:
      data_geojson = f"/collections/{collectionId}/dggs/{dggrsId}/zones/{zone_id}/data?f=geojson"
      data_geoubjson = f"/collections/{collectionId}/dggs/{dggrsId}/zones/{zone_id}/data?f=geoubjson"
      data_links = [
         {
            "rel": "[ogc-rel:dggrs-zone-data]",
            "title": "DGGS-JSON-FG",
            "type": "application/geo+json",
            "profile": "[ogc-profile:jsonfg-dggs]",
            "href": data_json
         },
         {
            "rel": "[ogc-rel:dggrs-zone-data]",
            "title": "DGGS-UBJSON-FG",
            "type": "application/geo+ubjson",
            "profile": "[ogc-profile:jsonfg-dggs]",
            "href": data_ubjson
         },
         {
            "rel": "[ogc-rel:dggrs-zone-data]",
            "title": "GeoJSON",
            "type": "application/geo+json",
            "profile": "[ogc-profile:rfc7946]",
            "href": data_geojson
         },
         {
            "rel": "[ogc-rel:dggrs-zone-data]",
            "title": "GeoUBJSON",
            "type": "application/geo+ubjson",
            "profile": "[ogc-profile:rfc7946]",
            "href": data_geoubjson
         }
      ]
   else:
      data_links = [
         {
            "rel": "[ogc-rel:dggrs-zone-data]",
            "title": "DGGS-JSON",
            "type": "application/json",
            "href": data_json
         },
         {
            "rel": "[ogc-rel:dggrs-zone-data]",
            "title": "DGGS-UBJSON",
            "type": "application/ubjson",
            "href": data_ubjson
         }
      ]

   # Links presented in JSON responses: base resource links plus the canonical data links
   json_links: List[Dict[str, Any]] = [
      {"rel": "self", "type": "application/json", "href": json_self},
      {"rel": "alternate", "type": "text/html", "href": request.path + "?f=html"},
      {"rel": "alternate", "type": "application/ub+json", "href": ubjson_self},
   ]
   json_links.extend(data_links)

   # Top links for HTML: Back to zones then JSON and UBJSON alternates for this resource
   top_links = [
      {"href": up_href, "title": "Back to zones"},
      {"href": json_self, "title": "JSON"},
      {"href": ubjson_self, "title": "UBJSON"}
   ]

   zone_payload: Dict[str, Any] = {"id": zone_id, "links": json_links, "crs": "[OGC:CRS84]"}

   # level
   lvl = dggrs.getZoneLevel(zone)
   if lvl is not None:
      zone_payload["level"] = int(lvl)

   # shape type derived from edge count (only 3-6 handled)
   edges = dggrs.countZoneEdges(zone)
   if edges == 3:    zone_payload["shapeType"] = "triangle"
   elif edges == 4:  zone_payload["shapeType"] = "quadrilateral"
   elif edges == 5:  zone_payload["shapeType"] = "pentagon"
   elif edges == 6:  zone_payload["shapeType"] = "hexagon"

   # geometry included for response only (build Polygon geometry from refined WGS84 vertices)
   polygon_geom = polygon_geometry_from_zone(dggrs, zone)
   if polygon_geom:
      zone_payload["geometry"] = polygon_geom

   # centroid: use getZoneWGS84Centroid() which returns a GeoPoint with lat and lon
   gp = dggrs.getZoneWGS84Centroid(zone)
   if gp:
      # present as [lon, lat] internally; HTML template formats as Latitude/Longitude lines
      zone_payload["centroid"] = [float(gp.lon), float(gp.lat)]

   # area (present before extent)
   a = dggrs.getZoneArea(zone)
   if a is not None:
      zone_payload["areaMetersSquare"] = float(a)

   # bbox: use getZoneWGS84Extent(extent) which fills a GeoExtent object with ll and ur members
   extent = GeoExtent()
   dggrs.getZoneWGS84Extent(zone, extent)
   # canonical order [minx, miny, maxx, maxy]
   zone_payload["bbox"] = [float(extent.ll.lon), float(extent.ll.lat), float(extent.ur.lon), float(extent.ur.lat)]

   # Format negotiation and response
   fmt, _ = negotiate_format(request, request.path)

   if fmt == "html":
      app.jinja_env.filters['pretty_json'] = pretty_json
      # Render HTML with top_links and download links at the bottom; pass ubjson_self as well
      return html_response(
         ZONE_HTML,
         title=f"Zone {zone_id}",
         zone=zone_payload,
         collectionId=collectionId,
         dggrsId=dggrsId,
         dggrsTitle=dggrs_title,
         collectionTitle=collection_title,
         top_links=top_links,
         data_links=data_links,
         ubjson_self=ubjson_self
      )

   if fmt == "ubjson":
      payload = ubjson.dumpb(zone_payload)
      return Response(payload, status=200, mimetype="application/ub+json")

   # default JSON response
   return Response(pretty_json(zone_payload) + "\n", status=200, mimetype="application/json; charset=utf-8")



================================================
FILE: high-vibes/ogcapi/dggs/zones.py
================================================
# ogcapi-dggs-zones.py
# DGGRS zones listing endpoint:
#   GET /collections/<collectionId>/dggs/<dggrsId>/zones

from flask import Blueprint, request, Response, current_app
import logging

from dggsStore.store import get_store
from ..utils import pretty_json, html_response

ZONE_QUERY_LEVEL = 2

logger = logging.getLogger("dgg-serve.zones")

bp = Blueprint(
    "dggs_zones",
    __name__,
    url_prefix="/collections/<collectionId>/dggs/<dggrsId>"
)

ZONES_HTML = """
{% block content %}

  <div class="small top-links">
    {% for l in top_links %}
      <a href="{{ l.href }}">{{ l.title }}</a>{% if not loop.last %} · {% endif %}
    {% endfor %}
  </div>

  <div class="card">
    <div class="small">
      {% for l in mid_links %}
        <a href="{{ l.href }}">{{ l.title }}</a>{% if not loop.last %} · {% endif %}
      {% endfor %}
    </div>

    <div class="small">
      <strong>Zone Data Retrieval Link Template:</strong><br>
      {% for t in linkTemplates %}
        <code>{{ t.uriTemplate }}</code>{% if not loop.last %} · {% endif %}
      {% endfor %}
    </div>
  </div>

  <div class="card">
    <h2>Zones ({{ zones|length }} items)</h2>
    <ul>
      {% for z in zones %}
        <li>
          <a href="/collections/{{ collectionId }}/dggs/{{ dggrsId }}/zones/{{ z }}">
            {{ z }}
          </a>
        </li>
      {% endfor %}
    </ul>
  </div>

{% endblock %}
"""

@bp.route("/zones")
def list_zones(collectionId, dggrsId):
   DATA_ROOT = current_app.config.get("DATA_ROOT")

   store = get_store(DATA_ROOT, collectionId)
   if store is not None and store.config['dggrs'] == dggrsId:
      dggrs = store.dggrs

      # DGGS level is fixed for now
      level = ZONE_QUERY_LEVEL

      # Get zones as TEXT IDs
      zones = store.list_zones_with_data_at_level(level, as_textIDs=True)

      # Base href (no ?f=)
      zones_href = f"/collections/{collectionId}/dggs/{dggrsId}/zones"

      # Typed links (explicit representations)
      zones_href_json = zones_href + "?f=json"
      zones_href_html = zones_href + "?f=html"

      #
      # JSON REPRESENTATION
      #
      if request.args.get("f") == "json":
         payload = {
            "title": f"{dggrsId} DGGRS Zones for {store.config.get('title', collectionId)}",

            # Typed links → MUST include type + ?f=
            "links": [
               {
                  "rel": "self",
                  "title": "Zones (JSON)",
                  "href": zones_href_json,
                  "type": "application/json"
               },
               {
                  "rel": "alternate",
                  "title": "Zones (HTML)",
                  "href": zones_href_html,
                  "type": "text/html"
               }
            ],

            # URI templates (NOT real links)
            "linkTemplates": [
               {
                  "rel": "[ogc-rel:dggrs-zone-data]",
                  "title": "Zone Data Retrieval Link Template",
                  "uriTemplate": f"/collections/{collectionId}/dggs/{dggrsId}/zones/{{zoneId}}/data"
               }
            ],

            "zones": zones
         }

         return Response(
            pretty_json(payload) + "\n",
            mimetype="application/json; charset=utf-8"
         )

      #
      # HTML REPRESENTATION
      #
      return html_response(
         ZONES_HTML,

         title=f"{dggrsId} DGGRS Zones for {store.config.get('title', collectionId)}",
         collectionId=collectionId,
         dggrsId=dggrsId,
         zones=zones,

         #
         # Untyped navigation links → MUST NOT use ?f=
         #
         top_links=[
            {"href": f"/collections/{collectionId}/dggs/{dggrsId}", "title": "Back to DGGRS"},
            {"href": f"/collections/{collectionId}", "title": "Back to collection"},
         ],

         #
         # Typed links for explicit representations
         #
         links=[
            {
               "rel": "self",
               "title": "Zones (HTML)",
               "href": zones_href_html,
               "type": "text/html"
            },
            {
               "rel": "alternate",
               "title": "Zones (JSON)",
               "href": zones_href_json,
               "type": "application/json"
            }
         ],

         #
         # URI templates (NOT real links)
         #
         linkTemplates=[
            {
               "rel": "[ogc-rel:dggrs-zone-data]",
               "title": "Zone Data Retrieval Link Template",
               "uriTemplate": f"/collections/{collectionId}/dggs/{dggrsId}/zones/{{zoneId}}/data"
            }
         ]
      )
   else:
      return Response(b"", status=404, mimetype=None)



================================================
FILE: src/dggrs.ec
================================================
public import IMPORT_STATIC "ecrt"

private:

import "GeoExtent"

#include <stdio.h>

public define nullZone = 0xFFFFFFFFFFFFFFFFLL;

public struct CRSExtent
{
   CRS crs;
   Pointd tl, br;
};

public class DGGRSZone : uint64
{
   class_no_expansion;
private:
   uint level:5:59, row:29:30, col:30:0;
}

static double earthArea = 0; // 5.100656217240885092949E14;

static define stdMetersPerPixel = Meters { 0.00028 };       // 0.28 mm/pixels -- following standard WMS 1.3.0 [OGC 06-042], SE and WMTS
static define metersPerDegree = wgs84Major * (double)Pi/180;

define wgs84Authalic = 6371007.180918473897976252;

// #define USE_GEOGRAPHIC_LIB

#ifdef USE_GEOGRAPHIC_LIB
#include <geodesic.h>

struct geod_geodesic g;
struct geod_geodesic as;
#endif

public class DGGRS
{
#ifdef USE_GEOGRAPHIC_LIB
   DGGRS()
   {
      if(!g.a)
         geod_init(&g, wgs84Major, (wgs84Major - wgs84Minor) / wgs84Major);
      if(!as.a)
         geod_init(&as, wgs84Authalic, 0);
   }
#endif

public:
   // DGGH
   virtual uint64 countZones(int level) { return 0; }
   // This is the maximum level of the DGGRSZone type -- Sub-zones at greater depths relative from these zones may still be queried
   virtual int getMaxDGGRSZoneLevel() { return 0; }
   virtual int getRefinementRatio() { return 0; }

   virtual int getMaxParents() { return 0; }
   virtual int getMaxNeighbors() { return 0; }
   virtual int getMaxChildren() { return 0; }

   virtual DGGRSZone getZoneFromCRSCentroid(int level, CRS crs, const Pointd centroid) { return nullZone; }
   virtual DGGRSZone getZoneFromWGS84Centroid(int level, const GeoPoint centroid) { return nullZone; }

   virtual uint64 countSubZones(DGGRSZone zone, int depth) { return 0; }
   virtual int getZoneLevel(DGGRSZone zone) { return 0; }
   virtual int countZoneEdges(DGGRSZone zone) { return 0; } // This also corresponds to the number of vertices

   virtual void getZoneCRSCentroid(DGGRSZone zone, CRS crs, Pointd centroid) { centroid = { MAXDOUBLE, MAXDOUBLE }; }
   virtual void getZoneWGS84Centroid(DGGRSZone zone, GeoPoint centroid) { centroid = { MAXDOUBLE, MAXDOUBLE }; }

   virtual void getZoneCRSExtent(DGGRSZone zone, CRS crs, CRSExtent extent) { extent = { }; }
   virtual void getZoneWGS84Extent(DGGRSZone zone, GeoExtent extent) { extent.clear(); }
   virtual void getZoneWGS84ExtentApproximate(DGGRSZone zone, GeoExtent extent) { getZoneWGS84Extent(zone, extent); }

   virtual int getZoneCRSVertices(DGGRSZone zone, CRS crs, Pointd * vertices) { return 0; }
   virtual int getZoneWGS84Vertices(DGGRSZone zone, GeoPoint * vertices) { return 0; }

   // Automatic refinement selection if passing 0 for edgeRefinement (custom refinement not currently supported for ISEA9R)
   virtual Array<Pointd> getZoneRefinedCRSVertices(DGGRSZone zone, CRS crs, int edgeRefinement) { return 0; }
   virtual Array<GeoPoint> getZoneRefinedWGS84Vertices(DGGRSZone zone, int edgeRefinement) { return 0; }

   virtual double getZoneArea(DGGRSZone zone) { return 0; } // In meters square

   virtual int getZoneParents(DGGRSZone zone, DGGRSZone * parents) { return 0; }
   virtual int getZoneNeighbors(DGGRSZone zone, DGGRSZone * neighbors, int * nbType) { return 0; }
   virtual int getZoneChildren(DGGRSZone zone, DGGRSZone * children) { return 0; }

   // For DGGH with centroid parent concept (ISEA3H)
   virtual DGGRSZone getZoneCentroidParent(DGGRSZone zone) { return nullZone; }

   // For DGGH with centroid child concept (ISEA3H, ISEA9R?)
   // ISEA9R?:
   virtual DGGRSZone getZoneCentroidChild(DGGRSZone zone) { return nullZone; }
   // ISEA9R?:
   virtual bool isZoneCentroidChild(DGGRSZone zone) { return false; }

   virtual Array<DGGRSZone> listZones(int level, const GeoExtent bbox) { return null; }

   // Text ZIRS
   virtual void getZoneTextID(DGGRSZone zone, String zoneID) { zoneID[0] = 0; }
   virtual DGGRSZone getZoneFromTextID(const String zoneID) { return nullZone; }

   // Sub-zone Order
   virtual DGGRSZone getFirstSubZone(DGGRSZone zone, int relativeDepth) { return nullZone; }

   virtual Array<Pointd> getSubZoneCRSCentroids(DGGRSZone parent, CRS crs, int relativeDepth) { return null; }
   virtual Array<GeoPoint> getSubZoneWGS84Centroids(DGGRSZone parent, int relativeDepth) { return null; }

   // Compaction
   virtual void compactZones(Array<DGGRSZone> zones);

   // Utility methods or virtual methods with default implementations
   virtual int64 getSubZoneIndex(DGGRSZone parent, DGGRSZone subZone)
   {
      int64 ix = -1;
      int level = getZoneLevel(parent), szLevel = getZoneLevel(subZone);
      if(szLevel > level)
      {
         Array<DGGRSZone> subZones = getSubZones(parent, szLevel - level);
         if(subZones)
         {
            DGGRSZone * itPtr = (DGGRSZone *)subZones.Find(subZone);
            if(itPtr)
               ix = itPtr - subZones.array;
            delete subZones;
         }
      }
      return ix;
   }

   virtual DGGRSZone getSubZoneAtIndex(DGGRSZone parent, int relativeDepth, int64 index)
   {
      DGGRSZone subZone = nullZone;
      if(index >= 0 && index < countSubZones(parent, relativeDepth))
      {
         if(index == 0)
            return getFirstSubZone(parent, relativeDepth);
         else
         {
            Array<DGGRSZone> subZones = getSubZones(parent, relativeDepth);
            if(subZones && index < subZones.count)
               subZone = subZones[(uint)index];
            delete subZones;
         }
      }
      return subZone;
   }

   virtual bool zoneHasSubZone(DGGRSZone hayStack, DGGRSZone needle)
   {
      bool result = false;
      int zLevel = getZoneLevel(hayStack), szLevel = getZoneLevel(needle);
      if(szLevel > zLevel)
      {
         Pointd v[6], c;
         int n, i;
         DGGRSZone cChild = getZoneCentroidChild(needle);

         if(cChild == nullZone)
         {
            getZoneCRSCentroid(needle, 0, c);
            n = getZoneCRSVertices(needle, 0, v);
         }
         else
            n = getZoneCRSVertices(cChild, 0, v);

         for(i = 0; i < n; i++)
         {
            DGGRSZone tz;

            if(cChild == nullZone)
            {
               Pointd m {
                  (c.x + v[i].x) / 2,
                  (c.y + v[i].y) / 2
               };
               tz = getZoneFromCRSCentroid(zLevel, 0, m);
            }
            else
               tz = getZoneFromCRSCentroid(zLevel, 0, v[i]);

            if(tz == hayStack)
            {
               result = true;
               break;
            }
         }
      }
      return result;
   }

   // REVIEW: Allow override for faster implementation?
   virtual Array<DGGRSZone> getSubZones(DGGRSZone parent, int relativeDepth)
   {
      Array<DGGRSZone> result = null;
      int szLevel = getZoneLevel(parent) + relativeDepth;

      if(szLevel <= getMaxDGGRSZoneLevel())
      {
         Array<Pointd> centroids = getSubZoneCRSCentroids(parent, 0, relativeDepth);
         if(centroids)
         {
            int nSubZones = centroids.count;
            Array<DGGRSZone> zones { size = nSubZones };
            int i;

            for(i = 0; i < nSubZones; i++)
            {
               zones[i] = getZoneFromCRSCentroid(szLevel, 0, centroids[i]);
   #ifdef _DEBUG
               if(zones[i] == nullZone)
                  PrintLn("WARNING: fromCentroid() returned null tile key");
   #endif
            }
            delete centroids;
            result = zones;
         }
      }
      return result;
   }

   int get64KDepth()
   {
      return (int)(log(65536) / log(getRefinementRatio()) + 0.5);
   }

   // for getZone*Centroids*(), getSubZones()
   int getMaxDepth()
   {
      int depth64k = get64KDepth();
      // Avoiding ISEA3H pentagon at 0,0 at level 1 and 2
      DGGRSZone testZone = getZoneFromWGS84Centroid(2, { 0, 10 });
      int maxDepth = 2 * depth64k - 1;
      uint64 nSubZones;

      while(((nSubZones = countSubZones(testZone, maxDepth) << 4) > (1LL<<32)))
         maxDepth--;
      return maxDepth;
   }

   // For getSubZoneIndex(), getSubZoneAtIndex()
   virtual int getIndexMaxDepth()
   {
      return getMaxDepth();
   }

   // Refinement Levels
   int getLevelFromRefZoneArea(double metersSquared)
   {
      int maxLevel = getMaxDGGRSZoneLevel() + get64KDepth();
      int level;
      double targetZoneCount;
      if(!earthArea) earthArea = wholeWorld.geodeticArea;
      targetZoneCount = earthArea / metersSquared;

      for(level = 0; level < maxLevel; level++)
      {
         double zoneCount = countZones(level);
         if(zoneCount >= targetZoneCount)
            return level;
      }
      return level;
   }

   double getRefZoneArea(int level) // In meters squared
   {
      int maxLevel = getMaxDGGRSZoneLevel();
      // Counting zones above maximum level will overflow 64-bit integers
      double zoneCount = countZones(Min(level, maxLevel));
      if(zoneCount)
      {
         if(!earthArea) earthArea = wholeWorld.geodeticArea;
         if(level <= maxLevel)
            return earthArea / zoneCount;
         else
         {
            return earthArea / (zoneCount * pow(getRefinementRatio(), level - maxLevel));
         }
      }
      return 0;
   }

   int getLevelFromScaleDenominator(double scaleDenominator, int relativeDepth, double mmPerPixel) // defaults to 0.28 mm/pixel if 0
   {
      double displayMetersPerPixel = mmPerPixel ? mmPerPixel / 1000.0 : stdMetersPerPixel;
      double physicalMetersPerSubZone = scaleDenominator * displayMetersPerPixel;
      return Max(0, getLevelFromRefZoneArea(physicalMetersPerSubZone * physicalMetersPerSubZone) - relativeDepth);
   }

   double getScaleDenominatorFromLevel(int parentLevel, int relativeDepth, double mmPerPixel) // defaults to 0.28 mm/pixel if 0
   {
      double physicalMetersPerSubZone = sqrt(getRefZoneArea(parentLevel + relativeDepth));
      double displayMetersPerPixel = mmPerPixel ? mmPerPixel / 1000.0 : stdMetersPerPixel;
      return physicalMetersPerSubZone / displayMetersPerPixel;
   }

   int getLevelFromMetersPerSubZone(double physicalMetersPerSubZone, int relativeDepth)
   {
      return Max(0, getLevelFromRefZoneArea(physicalMetersPerSubZone * physicalMetersPerSubZone) - relativeDepth);
   }

   double getMetersPerSubZoneFromLevel(int parentLevel, int relativeDepth)
   {
      return sqrt(getRefZoneArea(parentLevel + relativeDepth));
   }

   int getLevelFromPixelsAndExtent(const GeoExtent extent, const Point pixels, int relativeDepth)
   {
      // REVIEW: Fix support for extent crossing dateline
      double diffLat = (double)(Degrees)(extent.ur.lat - extent.ll.lat);
      double diffLon = (double)(Degrees)(extent.ur.lon - extent.ll.lon);
      if(diffLat <= radEpsilon || diffLon <= radEpsilon)
      {
         int maxLevel = getMaxDGGRSZoneLevel() + get64KDepth();
         return Max(0, maxLevel - relativeDepth);
      }
      else
      {
         double latPixPerD = pixels.y  / diffLat;
         double lonPixPerD = pixels.x  / diffLon;
         return getLevelFromMetersPerSubZone(metersPerDegree / Max(latPixPerD, lonPixPerD), relativeDepth);
      }
   }

   private static bool isZoneAncestorOfWithTree(DGGRSZone ancestor, DGGRSZone descendant, int maxDepth, AVLTree<DGGRSZone> tree)
   {
      int aLevel = getZoneLevel(ancestor), dLevel = getZoneLevel(descendant);
      if(dLevel > aLevel && (!maxDepth || dLevel - aLevel <= maxDepth))
      {
         DGGRSZone parents[3];
         int nParents = getZoneParents(descendant, parents), i;
         for(i = 0; i < nParents; i++)
         {
            DGGRSZone parent = parents[i];
            if(parent == ancestor)
               return true;
            if(dLevel - aLevel > 1 && (!tree || !tree.Find(parent)))
            {
               if(tree) tree.Add(parent);
               if(isZoneAncestorOfWithTree(ancestor, parent, maxDepth ? maxDepth - 1 : 0, tree))
                  return true;
            }
         }
      }
      return false;
   }

   // Topological queries
   bool isZoneAncestorOf(DGGRSZone ancestor, DGGRSZone descendant, int maxDepth)
   {
      AVLTree<DGGRSZone> tree = getMaxParents() > 1 ? { } : null;
      bool result = isZoneAncestorOfWithTree(ancestor, descendant, maxDepth, tree);
      delete tree;
      return result;
   }

   bool areZonesSiblings(DGGRSZone a, DGGRSZone b)
   {
      int aLevel = getZoneLevel(a), bLevel = getZoneLevel(b);
      if(aLevel == bLevel && a != b)
      {
         DGGRSZone aParents[3], bParents[3];
         int nParentsA = getZoneParents(a, aParents), nParentsB = getZoneParents(b, bParents), i, j;
         for(i = 0; i < nParentsA; i++)
         {
            DGGRSZone pa = aParents[i];
            for(j = 0; j < nParentsB; j++)
            {
               if(bParents[j] == pa)
                  return true;
            }
         }
      }
      return false;
   }

   // Only considers neighbors of same level
   bool areZonesNeighbors(DGGRSZone a, DGGRSZone b)
   {
      int aLevel = getZoneLevel(a), bLevel = getZoneLevel(b);
      if(aLevel == bLevel && a != b)
      {
         DGGRSZone neighbors[6];
         int nNeighbors = getZoneNeighbors(a, neighbors, null), i;
         for(i = 0; i < nNeighbors; i++)
            if(neighbors[i] == b)
               return true;
      }
      return false;
   }

   bool isZoneDescendantOf(DGGRSZone descendant, DGGRSZone ancestor, int maxDepth)
   {
      return isZoneAncestorOf(ancestor, descendant, maxDepth);
   }

   bool isZoneImmediateParentOf(DGGRSZone parent, DGGRSZone child)
   {
      return isZoneAncestorOf(parent, child, 1);
   }

   bool isZoneImmediateChildOf(DGGRSZone child, DGGRSZone parent)
   {
      return isZoneAncestorOf(parent, child, 1);
   }

   bool doZonesOverlap(DGGRSZone a, DGGRSZone b)
   {
      bool result = false;
      int aLevel = getZoneLevel(a), bLevel = getZoneLevel(b);
      if(aLevel > bLevel)
         result = zoneHasSubZone(b, a);
      else if(aLevel < bLevel)
         result = zoneHasSubZone(a, b);
      return result;
   }

   bool doesZoneContain(DGGRSZone hayStack, DGGRSZone needle)
   {
      bool contains = false;
      if(zoneHasSubZone(hayStack, needle))
      {
         // For non-congruent grids: sub-zones are not contained if they are on the edge and overlap a neighbor
         DGGRSZone neighbors[6];
         int nNeighbors = getZoneNeighbors(hayStack, neighbors, null), i;
         for(i = 0; i < nNeighbors; i++)
            if(zoneHasSubZone(neighbors[i], needle))
               break;
         if(i == nNeighbors)
            contains = true;
      }
      return contains;
   }

   bool isZoneContainedIn(DGGRSZone needle, DGGRSZone hayStack)
   {
      return doesZoneContain(hayStack, needle);
   }

#ifdef USE_GEOGRAPHIC_LIB
   // DGGH
   private
   __attribute__ ((optimize("-fno-unsafe-math-optimizations")))
   double computeGeodesisZoneArea(DGGRSZone zone)
   {
      // REVIEW: Is this Goldberg Polyhedra space exactly equal area?
      double area = 0, perimeter = 0;

      Array<Pointd> points = getZoneRefinedCRSVertices(zone, CRS { ogc, 84 }, 1024);
      int i;
      double * lats = new double[points.count];
      double * lons = new double[points.count];

      for(i = 0; i < points.count; i++)
         lats[i] = points[i].y, lons[i] = points[i].x;

      geod_polygonarea(&g, lats, lons, points.count, &area, &perimeter);
      if(area < 0)
         area = -area;   // FIXME: Polar zones are in opposite order
      delete points;
      delete lats;
      delete lons;

      PrintLn("Computed geodesic area: ", area);
      return area;
   }
#endif
}



================================================
FILE: src/GeoExtent.ec
================================================
public import IMPORT_STATIC "ecrt"

private:

#include <float.h>

public define wholeWorld = GeoExtent { { -90, -180 }, { 90, 180 } };

public define wgs84InvFlattening = 298.257223563;
public define wgs84Major = Meters { 6378137.0 };
public define wgs84Minor = wgs84Major - (wgs84Major / wgs84InvFlattening); // 6356752.3142451792955399

static define epsilon = 1.0e-7;
define radEpsilon = Radians { 10 * DBL_EPSILON };

public enum CRSRegistry { epsg, ogc };

public class CRS : uint64
{
public:
   CRSRegistry registry:30;
   int crsID:32;
   bool h:1;
};

Radians wrapLon(Radians x)
{
   if(x < -Pi - radEpsilon)
      x += (2*Pi) * (floor((Pi - x) / (2*Pi)));
   else if(x > Pi + radEpsilon)
      x -= (2*Pi) * (floor((x + Pi) / (2*Pi)));
	return x;
}

Radians wrapLonAt(int q, Radians lon, Radians cLon)
{
   lon -= cLon;
   if(lon < -Pi - Radians { epsilon })
      lon += (2*Pi) * floor((Pi - lon) / (2*Pi));
   else if(lon > Pi + Radians { epsilon })
      lon -= (2*Pi) * floor((lon + Pi) / (2*Pi));
   if(q != -1 && (lon > Pi/2 || lon < -Pi/2))
   {
      Radians testLon = (-Pi + q*Pi/2+Pi/4);
      Radians wrap = wrapLon(testLon - cLon);
      int lh = (int)((wrap + Pi) * 4 / (2*Pi));
      if(lh == 0 && lon > 0)
         lon -= 2*Pi;
      else if(lh == 3 && lon < 0)
         lon += 2*Pi;
   }
	return lon;
}

void wrapCRS84Points(int count, GeoPoint * points, Radians lon)
{
   if(points)
   {
      int lonQuad = (int)(((Radians)lon + Pi) * (4 / (2*Pi)));
      int i;
      for(i = 0; i < count; i++)
         points[i].lon = wrapLonAt(lonQuad, points[i].lon, 0);
   }
}

public struct GeoPoint
{
   Degrees lat, lon;

   int OnCompare(GeoPoint b) //TODO: This doesn't give particularly detailed information about the values
   {
      if(lat < b.lat) return -1;
      if(lat > b.lat) return  1;
      if(lon < b.lon) return -1;
      if(lon > b.lon) return  1;
      return 0;
   }

   // TOFIX: Degrees unserialization keeps searching for the class...
   void OnUnserialize(IOChannel f)
   {
      double lat, lon;
      f.Get(lat);
      f.Get(lon);
      this.lat = Radians { lat };
      this.lon = Radians { lon };
   }

   void OnSerialize(IOChannel f)
   {
      f.Put((double)(Radians)lat);
      f.Put((double)(Radians)lon);
   }
};

public struct GeoExtent
{
   GeoPoint ll, ur;

   property bool nonNull { get { return ur.lat >= ll.lat && ur.lon >= ll.lon; } }

   void clear()
   {
      ll = { MAXDOUBLE, MAXDOUBLE };
      ur = { -MAXDOUBLE, -MAXDOUBLE };
   }

   property double geodeticArea
   {
      get
      {
         static const double ooa = 1.0 / wgs84Minor, aob = wgs84Minor / wgs84Major;
         static const double a2 = wgs84Minor * wgs84Minor;
         static const double bmabpa = (wgs84Major - wgs84Minor) * (wgs84Major + wgs84Minor);
         double srbmabpa = sqrt(bmabpa);
         double pl1 = fabs(fabs((Radians)ll.lat) - Pi/2) < 1E-12 ? Sgn(ll.lat) * Pi/2 : atan(aob * tan(ll.lat));
         double pl2 = fabs(fabs((Radians)ur.lat) - Pi/2) < 1E-12 ? Sgn(ur.lat) * Pi/2 : atan(aob * tan(ur.lat));
         double sinl1 = sin(pl1), sinl2 = sin(pl2);
         Radians dLon = ur.lon - ll.lon;
         if(dLon < 0) dLon += 2*Pi;

         return dLon *
            (wgs84Major *
               (a2 * wgs84Minor * (asinh(srbmabpa * sinl2 * ooa) - asinh(srbmabpa * sinl1 * ooa)) +
               fabs(wgs84Minor) * srbmabpa * (sinl2 * sqrt(bmabpa * sinl2 * sinl2 + a2) - sinl1 * sqrt(bmabpa * sinl1 * sinl1 + a2)))
            ) * 0.5 * ooa / srbmabpa;
      }
   }

   bool intersects(const GeoExtent b)
   {
      if(ll.lon < MAXDOUBLE && ll.lon > ur.lon)
      {
         GeoExtent a { { ll.lat, ll.lon }, { ur.lat, 180 } };
         GeoExtent c { { ll.lat, -180 }, { ur.lat, ur.lon } };
         return a.intersects(b) || c.intersects(b);
      }
      else if(b.ll.lon < MAXDOUBLE && b.ll.lon > b.ur.lon)
      {
         GeoExtent a { { b.ll.lat, b.ll.lon }, { b.ur.lat, 180 } };
         GeoExtent c { { b.ll.lat, -180 }, { b.ur.lat, b.ur.lon } };
         return intersects(a) || intersects(c);
      }
      else
      return (Radians)ll.lat < (Radians)b.ur.lat - radEpsilon &&
             (Radians)b.ll.lat < (Radians)ur.lat - radEpsilon &&
             (Radians)ll.lon < (Radians)b.ur.lon - radEpsilon &&
             (Radians)b.ll.lon < (Radians)ur.lon - radEpsilon;
   }

   bool clip(const GeoExtent e, const GeoExtent clipExtent)
   {
      if(e.intersects(clipExtent))
      {
         this = e;
         if (ll.lat < clipExtent.ll.lat) ll.lat = clipExtent.ll.lat;
         if (ll.lon < clipExtent.ll.lon) ll.lon = clipExtent.ll.lon;
         if (ur.lat > clipExtent.ur.lat) ur.lat = clipExtent.ur.lat;
         if (ur.lon > clipExtent.ur.lon) ur.lon = clipExtent.ur.lon;
         return true;
      }
      else
         clear();
      return false;
   }

   void doUnionDL(const GeoExtent e)
   {
      if(ll.lon > 10000)
         this = e;
      else if(e.ll.lon < 10000)
      {
         if(e.ll.lat < ll.lat) ll.lat = e.ll.lat;
         if(e.ur.lat > ur.lat) ur.lat = e.ur.lat;

         {
            bool empty = fabs(e.ur.lon - e.ll.lon) <= radEpsilon;
            Radians dLLon = fabs((Radians)e.ur.lon - (Radians)ll.lon);
            Radians dRLon = fabs((Radians)e.ll.lon - (Radians)ur.lon);
            Radians curDLon = ur.lon - ll.lon + (ll.lon > ur.lon ? 2 * Pi : 0);
            if(dLLon > Pi) dLLon = fabs(dLLon - 2*Pi);
            if(dRLon > Pi) dRLon = fabs(dRLon - 2*Pi);

            if(dRLon < dLLon)
            {
               if(e.ur.lon > ur.lon || (e.ur.lon <= ll.lon && ur.lon > ll.lon))
                  ur.lon = e.ur.lon;
               if(ur.lon > ll.lon && e.ll.lon < ll.lon)
                  ll.lon = e.ll.lon;
            }
            else
            {
               if(e.ll.lon < ll.lon || (e.ll.lon >= ur.lon && ll.lon < ur.lon))
                  ll.lon = e.ll.lon;
               if(ur.lon > ll.lon && e.ur.lon > ur.lon)
                  ur.lon = e.ur.lon;
            }
            if(!empty && (Radians)ur.lon - (Radians)ll.lon + (((Radians)ll.lon < (Radians)ur.lon) ? 2 * Pi : 0) < curDLon)
            {
               ll.lon = -180, ur.lon = 180;
               if(ll.lat < 0) ll.lat = -90;
               if(ur.lat > 0) ur.lat =  90;
            }
         }
      }
   }

   bool clipHandlingDateline(const GeoExtent e, const GeoExtent clipExtent)
   {
      if(e.intersects(clipExtent))
      {
         if(e.ll.lon < MAXDOUBLE && e.ll.lon > e.ur.lon)
         {
            GeoExtent a { { e.ll.lat, e.ll.lon }, { e.ur.lat, 180 } };
            GeoExtent c { { e.ll.lat, -180 }, { e.ur.lat, e.ur.lon } };
            GeoExtent tmp;
            tmp.clipHandlingDateline(a, clipExtent);
            clipHandlingDateline(c, clipExtent);
            doUnionDL(tmp);
         }
         else if(clipExtent.ll.lon < MAXDOUBLE && clipExtent.ll.lon > clipExtent.ur.lon)
         {
            GeoExtent a { { clipExtent.ll.lat, clipExtent.ll.lon }, { clipExtent.ur.lat, 180 } };
            GeoExtent c { { clipExtent.ll.lat, -180 }, { clipExtent.ur.lat, clipExtent.ur.lon } };
            GeoExtent r1, r2;
            r1.clip(a, e);
            r2.clip(c, e);
            this = r1;
            doUnionDL(r2);
         }
         else
         {
            this = e;
            if (ll.lat < clipExtent.ll.lat) ll.lat = clipExtent.ll.lat;
            if (ll.lon < clipExtent.ll.lon) ll.lon = clipExtent.ll.lon;
            if (ur.lat > clipExtent.ur.lat) ur.lat = clipExtent.ur.lat;
            if (ur.lon > clipExtent.ur.lon) ur.lon = clipExtent.ur.lon;
            return true;
         }
      }
      else
         clear();
      return false;
   }
};



================================================
FILE: src/dggrs/BCTA3H.ec
================================================
public import IMPORT_STATIC "ecrt"
private:

import "RI3H"
import "barycentric5x6"

// This DGGRS mapping barycentric coordinates to spherical triangle areas is not equal-area
public class BCTA3H : RhombicIcosahedral3H
{
   BCTA3H() { pj = BarycentricSphericalTriAreaProjection { }; incref pj; }
   ~BCTA3H() { delete pj; }
}



================================================
FILE: src/dggrs/GNOSISGlobalGrid.ec
================================================
public import IMPORT_STATIC "ecrt"
private:

import "dggrs"

#include <stdio.h>

enum GGGNeighborType
{
   north, north2, west, east, south, south2
};

public class GNOSISGlobalGrid : DGGRS
{
   // DGGH
   uint64 countZones(int level)
   {
      return 8LL * GGGZone { }.getSubZonesCount(level);
   }

   int getMaxDGGRSZoneLevel() { return maxGGGZoomLevel; }
   int getRefinementRatio() { return 4; }
   int getMaxParents() { return 1; }
   int getMaxNeighbors() { return 5; }
   int getMaxChildren() { return 4; }

   uint64 countSubZones(GGGZone zone, int depth)
   {
      return zone.getSubZonesCount(depth);
   }

   int getZoneLevel(GGGZone zone)
   {
      return zone.level;
   }

   int countZoneEdges(GGGZone zone)
   {
      // Polar zone have 3 egdes
      int row = zone.row;
      return (!row || row == (2 << zone.level) - 1) ? 3 : 4;
   }

   __attribute__ ((optimize("-fno-unsafe-math-optimizations")))
   double getZoneArea(GGGZone zoneID)
   {
      GeoExtent extent = zoneID.toClassic().extent;
      //PrintLn(extent);
      return extent.geodeticArea;
   }

   DGGRSZone getZoneFromWGS84Centroid(int level, const GeoPoint centroid)
   {
      if(level <= maxGGGZoomLevel)
      {
         GeoExtent e { centroid, centroid };
         return ClassicGGGKey::fromExtent(e, level, true).toGGG();
      }
      return nullZone;
   }

   DGGRSZone getZoneFromCRSCentroid(int level, CRS crs, const Pointd centroid)
   {
      if(level <= maxGGGZoomLevel)
      {
         switch(crs)
         {
            case 0: return getZoneFromWGS84Centroid(level, (GeoPoint)centroid);
            case CRS { ogc, 84 }: return getZoneFromWGS84Centroid(level, { centroid.y, centroid.x });
            case CRS { epsg, 4326 }: return getZoneFromWGS84Centroid(level, { centroid.x, centroid.y });
            default: return nullZone;
         }
      }
      return nullZone;
   }

   void getZoneCRSCentroid(GGGZone zone, CRS crs, Pointd centroid)
   {
      GeoPoint c;
      getZoneWGS84Centroid(zone, c);
      switch(crs)
      {
         case 0: centroid = { (Radians)c.lat, (Radians)c.lon }; break;
         case CRS { ogc, 84 }: centroid = { c.lon, c.lat }; break;
         case CRS { epsg, 4326 }: centroid = { c.lat, c.lon }; break;
         default: centroid = { MAXDOUBLE, MAXDOUBLE }; break;
      }
   }

   void getZoneWGS84Centroid(GGGZone zone, GeoPoint centroid)
   {
      GeoExtent e = zone.toClassic().extent;
      centroid =
      {
         ((Radians)e.ll.lat + (Radians)e.ur.lat) / 2,
         ((Radians)e.ll.lon + (Radians)e.ur.lon) / 2
      };
   }

   int getZoneCRSVertices(GGGZone zone, CRS crs, Pointd * vertices)
   {
      int count = 0;
      if(!crs || crs == { ogc, 84 } || crs == { epsg, 4326 })
      {
         GeoPoint v[4];
         int i;

         count = getZoneWGS84Vertices(zone, v);

         switch(crs)
         {
            case 0: memcpy(vertices, v, sizeof(GeoPoint) * count); break;
            case CRS { ogc, 84 }:
               for(i = 0; i < count; i++)
                  vertices[i] = { v[i].lon, v[i].lat };
               break;
            case CRS { epsg, 4326 }:
               for(i = 0; i < count; i++)
                  vertices[i] = { v[i].lat, v[i].lon };
               break;
         }
      }
      return count;
   }

   int getZoneWGS84Vertices(GGGZone zone, GeoPoint * vertices)
   {
      int row = zone.row;
      bool np = !row, sp = row == (2 << zone.level) - 1;
      GeoExtent e = zone.toClassic().extent;
      int count = 0;

      vertices[count++] = { e.ur.lat, e.ll.lon };
      vertices[count++] = { e.ll.lat, e.ll.lon };
      if(!sp) vertices[count++] = { e.ll.lat, e.ur.lon };
      if(!np) vertices[count++] = { e.ur.lat, e.ur.lon };
      return count;
   }

   Array<Pointd> getZoneRefinedCRSVertices(GGGZone zone, CRS crs, int edgeRefinement)
   {
      if(!crs || crs == { ogc, 84 } || crs == { epsg, 4326 })
      {
         GeoPoint v[4];
         uint count = 4, i;
         Array<Pointd> vertices { size = count };
         GeoExtent e = zone.toClassic().extent;
         v[0] = { e.ur.lat, e.ll.lon };
         v[1] = { e.ll.lat, e.ll.lon };
         v[2] = { e.ll.lat, e.ur.lon };
         v[3] = { e.ur.lat, e.ur.lon };

         switch(crs)
         {
            case 0: memcpy(vertices.array, v, sizeof(GeoPoint) * count); break;
            case CRS { ogc, 84 }:
               for(i = 0; i < count; i++)
                  vertices[i] = { v[i].lon, v[i].lat };
               break;
            case CRS { epsg, 4326 }:
               for(i = 0; i < count; i++)
                  vertices[i] = { v[i].lat, v[i].lon };
               break;
         }
         return vertices;
      }
      return null;
   }

   Array<GeoPoint> getZoneRefinedWGS84Vertices(GGGZone zone, int edgeRefinement)
   {
      Array<GeoPoint> vertices { size = 4 };
      GeoExtent e = zone.toClassic().extent;
      vertices[0] = { e.ur.lat, e.ll.lon };
      vertices[1] = { e.ll.lat, e.ll.lon };
      vertices[2] = { e.ll.lat, e.ur.lon };
      vertices[3] = { e.ur.lat, e.ur.lon };
      return vertices;
   }

   void getZoneCRSExtent(GGGZone zone, CRS crs, CRSExtent extent)
   {
      GeoExtent geo = zone.toClassic().extent;

      switch(crs)
      {
         case 0:
            extent.crs = 0; // EPSG:4326 but in Radians
            extent.tl = { (Radians)geo.ur.lat, (Radians)geo.ll.lon };
            extent.br = { (Radians)geo.ll.lat, (Radians)geo.ur.lon };
            break;
         case CRS { ogc, 84 }:
            extent.crs = crs;
            extent.tl = { geo.ur.lat, geo.ll.lon };
            extent.br = { geo.ll.lat, geo.ur.lon };
            break;
         case CRS { epsg, 4326 }:
            extent.crs = crs;
            extent.tl = { geo.ll.lon, geo.ur.lat };
            extent.br = { geo.ur.lon, geo.ll.lat };
            break;
         default:
            extent.crs = 0;
            extent.tl = { MAXDOUBLE, MAXDOUBLE };
            extent.br = { -MAXDOUBLE, -MAXDOUBLE };
            break;
      }
   }

   void getZoneWGS84Extent(GGGZone zone, GeoExtent extent)
   {
      extent = zone.toClassic().extent;
   }

   int getZoneParents(GGGZone zone, GGGZone * parents)
   {
      int level = zone.level;
      GGGZone parent = level ? zone.toClassic().getLowerResZone(level-1).toGGG() : nullZone;
      parents[0] = parent;
      return parent != nullZone;
   }

   int getZoneChildren(GGGZone zone, GGGZone * children)
   {
      uint l = zone.level+1;
      if(l <= maxGGGZoomLevel)
      {
         int nChildren = 0;
         uint numRow = 1 << l;
         uint midRow = numRow >> 1;
         uint row1 = zone.row << 1, row2 = row1 | 1;
         uint c = 1 << GGGZone { l, zone.row >= midRow ? row1 : row2 }.getCoalesceShift();
         uint col1 = zone.col << 1, col2 = col1 + c;
         uint lastRow = numRow-1;
         children[nChildren++] = { l, row1, col1 };
         children[nChildren++] = { l, row2, col1 };
         if(zone.row)
            children[nChildren++] = { l, row1, col2 };
         if(zone.row < lastRow)
            children[nChildren++] = { l, row2, col2 };
         return nChildren;
      }
      return 0;
   }

   int getZoneNeighbors(GGGZone zone, GGGZone * neighbors, GGGNeighborType * nbType)
   {
      int l = zone.level;
      int numNeighbors = 0;
      uint c = 1 << zone.getCoalesceShift();
      uint northRow = zone.row - 1, southRow = zone.row + 1;
      uint cNorth = 1 << GGGZone { l, northRow }.getCoalesceShift();
      uint cSouth = 1 << GGGZone { l, southRow }.getCoalesceShift();
      uint numRows = 2 << l, numCol = 4 << l;
      uint lastRow = numRows-1; // uint midRow = numRows >> 1;

      // North
      if(zone.row > 0)
      {
         neighbors[numNeighbors] = { l, northRow, zone.col - (zone.col % cNorth) };
         if(nbType) nbType[numNeighbors] = north;
         numNeighbors++;
      }
      if(zone.row > 0 && cNorth < c)
      {
         neighbors[numNeighbors] = GGGZone { l, northRow, zone.col + (c >> 1) };
         if(nbType) nbType[numNeighbors] = north2;
         numNeighbors++;
      }

      // West
      neighbors[numNeighbors] = zone.col == 0 ? GGGZone { l, zone.row, numCol - c } : GGGZone { l, zone.row, zone.col - c };
      if(nbType) nbType[numNeighbors] = west;
      numNeighbors++;

      // East
      neighbors[numNeighbors] = zone.col == numCol - c ? GGGZone { l, zone.row, 0 } : GGGZone { l, zone.row, zone.col + c };
      if(nbType) nbType[numNeighbors] = east;
      numNeighbors++;

      // South
      if(zone.row < lastRow)
      {
         neighbors[numNeighbors] = GGGZone { l, southRow, zone.col - (zone.col % cSouth) };
         if(nbType) nbType[numNeighbors] = south;
         numNeighbors++;
      }
      if(zone.row < lastRow && cSouth < c)
      {
         neighbors[numNeighbors] = GGGZone { l, southRow, zone.col + (c >> 1) };
         if(nbType) nbType[numNeighbors] = south2;
         numNeighbors++;
      }
      return numNeighbors;
   }

   Array<DGGRSZone> listZones(int level, const GeoExtent bbox)
   {
      Array<GGGZone> zones { };
      listGGGZones(zones, level, bbox, 0);
      if(!zones.count)
         delete zones;
      return (Array<DGGRSZone>)zones;
   }

   // Text ZIRS
   void getZoneTextID(GGGZone zone, String zoneID)
   {
      sprintf(zoneID, "%X-%X-%X", zone.level, zone.row, zone.col);
   }

   GGGZone getZoneFromTextID(const String zoneID)
   {
      GGGZone result = nullZone;
      int reqLevel, tileRow, tileCol;
      int c = sscanf(zoneID, "%X-%X-%X", &reqLevel, &tileRow, &tileCol);
      GGGZone key { reqLevel, tileRow, tileCol };
      ClassicGGGKey cKey = key.toClassic();
      if(c == 3 && cKey.isValid() && !(tileCol % (1 << key.getCoalesceShift())))
         result = key;
      return result;
   }

   // Sub-zone Order
   GGGZone getFirstSubZone(GGGZone zone, int depth)
   {
      GeoExtent extent = zone.toClassic().extent;
      uint64 d = 2LL << depth;
      extent.ur.lon = extent.ll.lon + (extent.ur.lon - extent.ll.lon) / d;
      extent.ll.lat = extent.ur.lat + (extent.ll.lat - extent.ur.lat) / d;
      return ClassicGGGKey::fromExtent(extent, zone.level + depth, true).toGGG();
   }

   Array<Pointd> getSubZoneCRSCentroids(GGGZone parent, CRS crs, int depth)
   {
      Array<GeoPoint> geo = parent.toClassic().getSubZoneCentroids(depth);
      if(geo)
      {
         uint count = geo.count, i;
         Array<Pointd> centroids { size = count };

         switch(crs)
         {
            case 0:
               for(i = 0; i < count; i++)
                  centroids[i] = { (Radians)geo[i].lat, (Radians)geo[i].lon };
               break;
            case CRS { ogc, 84 }:
               for(i = 0; i < count; i++)
                  centroids[i] = { geo[i].lon, geo[i].lat };
               break;
            case CRS { epsg, 4326 }:
               for(i = 0; i < count; i++)
                  centroids[i] = { geo[i].lat, geo[i].lon };
               break;
            default:
               delete centroids;
         }
         delete geo;
         return centroids;
      }
      return null;
   }

   Array<GeoPoint> getSubZoneWGS84Centroids(GGGZone parent, int depth)
   {
      return parent.toClassic().getSubZoneCentroids(depth);
   }

   void compactZones(Array<DGGRSZone> zones)
   {
      int maxLevel = 0, i, count = zones.count;

      for(i = 0; i < count; i++)
      {
         GGGZone zone = (GGGZone)zones[i];
         if(zone != nullZone)
         {
            int level = zone.level;
            if(level > maxLevel)
               maxLevel = level;
         }
      }

      compactGGGZones((Array<GGGZone>)zones, 0, maxLevel);
   }
}

// Methods and definitions for the GNOSIS Global Grid
static define firstZoomLevelRadians = Pi/2;
static define maxGGGZoomLevel = 28;     // Maximum level we can reach with a 64 bit GGGZone; A tile at zoom level 28 covers ~3 cm (~0.1 mm resolution with 256 tile resolution)

static define zoneEpsilon = Radians { 0.000000001 };

static Radians floorDelta(Radians value, Radians delta)
{
   return floor(value / delta + zoneEpsilon) * delta;
}

static Radians ceilDelta(Radians value, Radians delta)
{
   return ceil(value / delta - zoneEpsilon) * delta;
}

// These classic keys have rows flipped North-South, and columns numbering does not skip for coalescing regions
// TODO: Adapt code to always use GGGZone, implementing these methods directly in GGGZone instead
static class ClassicGGGKey : uint64
{
public:
   uint level:5:59, row:29:30, col:30:0;

   GGGZone toGGG()
   {
      int coalesce = getCoalesceShift();
      int numRows = 2 << level;
      if(row > numRows - 1) row = numRows - 1;
      return { level, numRows-1-row, col << coalesce };
   }

   int getCoalesceShift()
   {
      return ((GGGZone)this).getCoalesceShift();
   }

   Array<GeoPoint> getSubZoneCentroids(int rDepth)
   {
      // The same getSubZonesCount() implementation also works with classic key
      uint64 nSubZones = ((GGGZone)this).getSubZonesCount(rDepth);
      if(nSubZones < 1LL<<31)
      {
         int level = this.level + rDepth;
         GeoExtent extent = this.extent;
         int i = 0;
         Array<GeoPoint> centroids { size = (uint)nSubZones };
         Array<GGGZone> subZones { minAllocSize = (uint)nSubZones };

         // REVIEW: Optimize this
         listGGGZones(subZones, level, extent, 0);

   #ifdef _DEBUG
         if(nSubZones != subZones.count)
            PrintLn("WARNING: mismatched GGG sub-zone count");
   #endif

         for(i = 0; i < nSubZones && i < subZones.count; i++)
         {
            const GeoExtent e = subZones[i].toClassic().extent;
            centroids[i] =
            {
               ((Radians)e.ll.lat + (Radians)e.ur.lat) / 2,
               ((Radians)e.ll.lon + (Radians)e.ur.lon) / 2
            };
         }
         delete subZones;
         return centroids;
      }
      return null;
   }

   property GeoExtent extent
   {
      get
      {
         Radians diffLat { Pi / (2 << level) };
         Radians diffLong = ((GGGZone)this).getTileDeltaLon();

         value.ll.lat = -Pi / 2 + row * diffLat;
         value.ur.lat = value.ll.lat + diffLat;
         value.ll.lon = wrapLon(col * diffLong - Pi);
         value.ur.lon = Min((Radians)Pi, (Radians)value.ll.lon + diffLong); // Values over Pi were problematic with wrapLon()
      }
   }

   ClassicGGGKey ::fromExtent(const GeoExtent extent, int level, bool wrap)
   {
      Radians diffLat { Pi / (2 << level) };
      GeoPoint middle
      {
         (extent.ll.lat + extent.ur.lat) / 2,
         wrap ? wrapLon((extent.ll.lon + extent.ur.lon) / 2) : (extent.ll.lon + extent.ur.lon) / 2
      };
      int row = (int)(double)((middle.lat + Pi / 2) / diffLat);
      Radians llLat = -Pi / 2 + row * diffLat, urLat = llLat + diffLat;
      // NOTE: This was breaking in Antarctica with identical extent ll & ur on exactly tile boundary
      Radians diffLong = GGGZone::getDeltaLon(llLat, urLat, level);
      int col;
      if(middle.lon >= Pi - radEpsilon) middle.lon -= 2*Pi;  // wrapLon() doesn't wrap exactly 180. Should it?
      col = (int)(double)((middle.lon + Pi) / diffLong);
      return { level, row, col };
   }

   // Returns a ClassicGGGKey for a lower level version of the ClassicGGGKey.
   // The level is determined by the lowLevel parameter.
   // lowLevel must be lower than the level of the ClassicGGGKey.
   ClassicGGGKey getLowerResZone(int lowLevel)
   {
      if(level < lowLevel)
         return nullZone;
      else if(level == lowLevel)
         return this;
      else
      {
         int coalesce = getCoalesceShift();
         int d = level - lowLevel;
         ClassicGGGKey key { lowLevel, row >> d, (col << coalesce) >> d };
         // key.lon >>= key.getCoalesceShift(); // FIXME: bit class bug?
         key.col = key.col >> key.getCoalesceShift();
         return key;
      }
   }

   bool isValid()
   {
      int level = this.level;
      Radians diffLat { Pi / (2 << level) };
      Radians lat = -Pi/2 + diffLat * row;
      if(lat < Pi/2)
      {
         Radians diffLon = ((GGGZone)this).getTileDeltaLon();
         Radians lon = -Pi + col * diffLon;
         if(lon < Pi)
            return true;
      }
      return false;
   }
}

// Public for use in test
public class GGGZone : private DGGRSZone
{
public:
   uint level:5:59, row:29:30, col:30:0;

private:
   ClassicGGGKey toClassic()
   {
      int coalesce = getCoalesceShift();
      int numRows = 2 << level;
      return { level, numRows-1-row, col >> coalesce };
   }

   Radians ::getDeltaLon(Radians lat1, Radians lat2, int level)
   {
      Radians lat { Abs((lat1 + lat2) / 2 + zoneEpsilon) };
      int numRows = 2 << level;
      int row = (int)((Pi/2 - lat) * numRows / Pi);
      return GGGZone { level, row }.getTileDeltaLon();
   }

   Radians getTileDeltaLon()
   {
      return 2*Pi / (4 << level >> getCoalesceShift());
   }

   int getCoalesceShift()
   {
      uint row = this.row, level = this.level;
      int numRows = 2 << level;
      if(row >= 0 && row < numRows)
      {
         int hr = numRows >> 1, r = row >= hr ? numRows-1-row : row, coalesce = 0, i;
         for(i = 0; i < level; i++, r >>= 1)
            if(!r)
               coalesce++;
         return coalesce;
      }
      else
         return 0;
   }

   int OnCompare(GGGZone b)
   {
      // NOTE: CustomAVLTree Optimization currently assume signed 64-bit integers and this would result in mismatch comparisons
      if((int64)this < (int64)b) return -1;
      if((int64)this > (int64)b) return 1;
      return 0;
   }

   bool isValidDGGRSZone()
   {
      return toClassic().isValid() && !(col % (1 << getCoalesceShift()));
   }

   int64 getSubZonesCount(int depth)
   {
      int64 count;

      if(depth > 0)
      {
         int level = this.level, row = this.row;

         if(!row || row == ((2LL << level)-1))
            // https://oeis.org/A007583
            /*
            count = 3;
            while(--depth)
               count += 2 * (pow(4, depth)) + POW_EPSILON;
            */
            count = ((1LL << (2*depth + 1)) + 1)/3;
         else
            // count = (int)(pow(4, depth) + POW_EPSILON);
            count = 1LL << depth, count *= count;
      }
      else
         count = 1;
      return count;
   }

   // REVIEW: More efficient way to obtain deterministic order
   private bool orderGGGZones(int zoneLevel, AVLTree<GGGZone> tsZones, Array<GGGZone> zones)
   {
      Array<GeoPoint> centroids = toClassic().getSubZoneCentroids(zoneLevel - level);
      if(centroids)
      {
         int nSubZones = centroids.count;
         int i;

         tsZones.Free();
         for(z : zones)
            tsZones.Add(z);
         zones.Free();

         for(i = 0; i < nSubZones; i++)
         {
            GGGZone key = ClassicGGGKey::fromExtent( { centroids[i], centroids[i] }, zoneLevel, true).toGGG();

            if(tsZones.Find(key))
               zones.Add(key);
            else
            {
      #if 0 //def _DEBUG
               PrintLn("WARNING: mismatched sub-zone");
      #endif
            }
         }
         delete centroids;
      }
      return true;
   }
};

private static uint addGGGRow(Array<GGGZone> tiles, int level, GeoExtent origExtent, Radians diffLon)
{
   int count = (int) ceil(((Radians)origExtent.ur.lon - (Radians)origExtent.ll.lon) / diffLon - zoneEpsilon);
   if(tiles)
   {
      GeoExtent curExtent = origExtent;
      GGGZone * t;
      int i;

      if(tiles.count + count > tiles.minAllocSize)
         tiles.minAllocSize = tiles.count + count + (tiles.minAllocSize >> 1);
      t = tiles.array + tiles.count;
      for(i = 0; i < count; i++, t++)
      {
         curExtent.ur.lon = curExtent.ll.lon + diffLon;
         *t = ClassicGGGKey::fromExtent(curExtent, level, false).toGGG();
         curExtent.ll.lon = curExtent.ur.lon;
      }
      tiles.count += count;
   }
   return count;
}

static uint listGGGZones(Array<GGGZone> zones, int level, const GeoExtent extentArg, uint max)
{
   uint count = 0;
   Radians dLat = firstZoomLevelRadians / (1 << level);
   int rowCount;
   GeoExtent _extent, snapped;

   if(extentArg != null)
      _extent = extentArg;
   else
      _extent = wholeWorld;

   snapped =
   {
      ll.lat = floorDelta(Max((Radians)_extent.ll.lat + 0.00001*dLat, -Pi/2), dLat),
      ur.lat = ceilDelta (Min((Radians)_extent.ur.lat - 0.00001*dLat,  Pi/2), dLat)
   };

   if(snapped.ur.lat <= snapped.ll.lat && _extent.ur.lat > _extent.ll.lat)
      // Correct polar tile snapping that might result in a null extent
      // due to level's dLat being bigger than extent delta
      snapped.ll.lat = snapped.ur.lat - dLat;
   rowCount = (int)ceil((snapped.ur.lat - snapped.ll.lat) / dLat - zoneEpsilon);

   if(max && level > 0 && rowCount > max)
      return MAXINT;

   if(rowCount)
   {
      int i;
      bool dateLine = false;
      GeoExtent extent;
      Radians llLon = wrapLon(_extent.ll.lon), urLon = wrapLon(_extent.ur.lon);

      if(_extent.ur.lon - _extent.ll.lon > 2*Pi - radEpsilon)
         llLon = -Pi, urLon = Pi;
      else if(llLon > urLon + 0.000001)   // Turned a - into a + here as small extent caused date line to be true!
         dateLine = true;

      if(zones && zones.minAllocSize < 8)
         zones.minAllocSize = 8;
      for(i = 0, extent.ur.lat = snapped.ur.lat; i < rowCount; i++)
      {
         bool pastSouth = (extent.ll.lat = extent.ur.lat - dLat) < -Pi/2 - 0.000001;
         bool pastNorth = extent.ll.lat > Pi/2 + 0.000001;
         Radians dLon = GGGZone::getDeltaLon(extent.ll.lat, extent.ur.lat, level);
         snapped.ll.lon = floorDelta(llLon + 0.00001*dLon, dLon);
         snapped.ur.lon = ceilDelta (urLon - 0.00001*dLon, dLon);
         if((pastSouth && (Radians)extent.ll.lat < -Pi/2 - 0.000001) ||
            (pastNorth && (Radians)extent.ur.lat >  Pi/2 + 0.000001))
            snapped.ll.lon = -Pi, snapped.ur.lon = Pi;
         else if(snapped.ur.lon <= snapped.ll.lon && urLon > llLon)
            // Correct polar tile snapping that might result in a null extent
            snapped.ur.lon = snapped.ll.lon + dLon;

         if(dateLine)
         {
            if(snapped.ur.lon > snapped.ll.lon - 0.000001)
               extent.ll.lon = -Pi, extent.ur.lon = Pi;
            else
            {
               extent.ll.lon = -Pi, extent.ur.lon = snapped.ur.lon;
               addGGGRow(zones, level, extent, dLon);

               extent.ll.lon = snapped.ll.lon, extent.ur.lon = Pi;
            }
            count += addGGGRow(zones, level, extent, dLon);
         }
         else
         {
            extent.ll.lon = snapped.ll.lon, extent.ur.lon = snapped.ur.lon;
            count += addGGGRow(zones, level, extent, dLon);
         }
         extent.ur.lat = extent.ll.lat;

         if(max && level > 0 && count > max)
            return MAXINT;
      }
   }
   return count;
}

public /*static */void compactGGGZones(Array<GGGZone> zones, int start, int maxLevel)
{
   HashTable<GGGZone> orig { initSize = zones.count - start };
   int l;

   for(l = maxLevel; l > 0; l--)
   {
      int i;
      uint numParentLat = 2 << (l-1);
      uint midLat = numParentLat >> 1;
      uint parentLastLat = numParentLat-1;

      for(i = start; i < zones.count; i++)
         orig.Add(zones[i]);

      for(i = start; i < zones.count; i++)
      {
         GGGZone key = zones[i];
         if(key.level == l && orig.Find(key))
         {
            GGGZone parent = key.toClassic().getLowerResZone(l-1).toGGG();
            uint lat1 = parent.row << 1, lat2 = lat1 | 1;
            uint c = 1 << GGGZone { l, parent.row >= midLat ? lat1 : lat2 }.getCoalesceShift();
            uint lon1 = parent.col << 1, lon2 = lon1 + c;
            GGGZone children[4] =
            {
               GGGZone { l, lat1, lon1 },
               GGGZone { l, lat2, lon1 },
               !parent.row                 ? nullZone : { l, lat1, lon2 },
               parent.row == parentLastLat ? nullZone : { l, lat2, lon2 }
            };
            bool missingSibling = false;
            int j;

            for(j = 0; j < 4; j++)
            {
               GGGZone sKey = children[j];
               if(sKey != nullZone && sKey != key && !orig.Find(sKey))
               {
                  missingSibling = true;
                  break;
               }
            }
            if(!missingSibling)
            {
               for(j = 0; j < 4; j++)
               {
                  GGGZone sKey = children[j];
                  if(sKey != nullZone)
                     orig.TakeOut(sKey);
               }
               orig.Add(parent);
            }
         }
      }
      i = start;
      for(k : orig)
         zones[i++] = k;
      zones.count = i;
      orig.Free();
   }
   delete orig;
}



================================================
FILE: src/dggrs/GPP3H.ec
================================================
public import IMPORT_STATIC "ecrt"
private:

import "RI3H"
import "barycentric5x6"

// This DGGRS projecting the aperture 3 hexagonal pattern on the faces of the icosahedron to the sphere
// corresponds to Golberg Polyhedra. It is not equal area.
public class GPP3H : RhombicIcosahedral3H
{
   GPP3H() { pj = GoldbergPolyhedraProjection { }; incref pj; }
   ~GPP3H() { delete pj; }
}



================================================
FILE: src/dggrs/HEALPixGrid.ec
================================================
public import IMPORT_STATIC "ecrt"
private:

import "dggrs"
import "rHEALPix"

import "Vector3D"

#include <stdio.h>

static define POW_EPSILON = 0.1;

define HP_MAX_VERTICES = 200; // * 1024;

public class HPZone : private DGGRSZone
{
public:
   uint level:5:56;
   uint rootRhombus:4:52;
   uint64 subIndex:52:0;

private:
   // These are only to avoid mistakingly accessing the invalid base DGGRSZone row and col properties
   // The formulas should be used directly to avoid the property overhead.
   property int row
   {
      get { return (int)(subIndex >> level); }
   }
   property int col
   {
      get { return (int)(subIndex - (((int64)(subIndex >> level)) << level)); }
   }

   property HPZone parent
   {
      get
      {
         int level = this.level;
         if(level > 0)
         {
            int row = (int)(subIndex >> level);
            int col = (int)(subIndex - ((int64)row << level));
            int pLevel = level - 1;
            return { pLevel, rootRhombus, ((row >> 1) << pLevel) | (col >> 1) };
         }
         return nullZone;
      }
   }

   property Pointd centroid
   {
      get
      {
         int root = rootRhombus, rCol = root & 3, rRow = (root >> 2);
         int64 p = 1LL << level;
         double oop = 1.0 / p;
         int row = (int)(subIndex >> level);
         int col = (int)(subIndex - ((int64)row << level));
         double x = rCol + (int)(rRow == 0) + col * oop;
         double y = rCol + (int)(rRow == 2) + row * oop;

         value =
         {
            x = (x + y + oop) * Pi/4 - 5*Pi/4,
            y = -(y - x) * Pi/4
         };
      }
   }

   property CRSExtent hpExtent
   {
      get
      {
         int root = rootRhombus, rCol = root & 3, rRow = (root >> 2);
         int64 p = 1LL << level;
         double oop = 1.0 / p;
         int row = (int)(subIndex >> level);
         int col = (int)(subIndex - ((int64)row << level));
         double x = rCol + (int)(rRow == 0) + col * oop;
         double y = rCol + (int)(rRow == 2) + row * oop;

         /*
         Conversion from 4x6 to HEALPix:
            x = (x + y) * Pi/4 - 5*Pi/4,
            y = -(y - x) * Pi/4
         */

         value.tl = {
            x = (x + y) * Pi/4 - 5*Pi/4,
            y = -(y - (x + oop)) * Pi/4
         };
         value.br = {
            x = (x + y + 2*oop) * Pi/4 - 5*Pi/4,
            y = -((y + oop) - x) * Pi/4
         };
      }
   }

   HPZone ::fromPoint(const Pointd v, int level)
   {
      HPZone zone = nullZone;
      int64 p = 1LL << level;
      // Conversion from HEALPix to 4x6 space:
      double x = (v.y + v.x + 5 * Pi / 4) * 2/Pi;
      double y = v.x * 4 / Pi + 5 - x;
      int cx = (int)(x + 1E-11);
      int cy = (int)(y + 1E-11);
      double sx = x - cx, sy = y - cy;
      bool addX = cx > cy, addY = cy > cx;
      int rCol = cx - addX; // or cy - addY
      int rRow = addX ? 0 : addY ? 2 : 1;
      int64 col = (int64)(sx * p);
      int64 row = (int64)(sy * p);
      int root = (rRow << 2) | rCol;

      if(rCol >= 0 && rCol <= 4 && rRow >= 0 && rRow <= 2 && col >= 0 && col < p && row >= 0 && row < p)
         zone = { level, root, ((int64)row << level) | col };
      return zone;
   }

   Array<Pointd> getSubZoneCentroids(int depth)
   {
      uint dm = 1 << depth;
      Array<Pointd> centroids { size = dm * dm };
      int r, c, i = 0;
      CRSExtent e = hpExtent;
      double w = e.br.x - e.tl.x, h = e.br.y - e.tl.y;

      for(r = 0; r < dm; r++)
         for(c = 0; c < dm; c++, i++)
            centroids[i] = { e.tl.x + c * w / dm, e.tl.y + r * h / dm };
      return centroids;
   }

   int getChildren(HPZone * children)
   {
      int level = this.level;
      uint rootRhombus = this.rootRhombus;
      uint64 subIndex = this.subIndex;
      uint64 p = 1LL << level;
      uint row = (uint)(subIndex / p), col = (uint)(subIndex - row * p);

      if(level < 25)
      {
         int r, c;

         for(r = 0; r < 2; r++)
            for(c = 0; c < 2; c++)
               children[r * 2 + c] = HPZone { level + 1, rootRhombus, (row * 2 + r) * (2*p) + (col * 2 + c) };
         return 4;
      }
      return 0;
   }
}

public class HEALPix : DGGRS
{
   HEALPixProjection pj { };

   void ::cartesianToGeo(const Vector3D c, GeoPoint out)
   {
      double p = sqrt(c.x*c.x + c.z*c.z);

      out = { (Radians)atan2(-c.y, p), (Radians)atan2(c.x, -c.z) };
   }

   uint64 countZones(int level)
   {
      return (uint64)(12 * (pow(4, level)) + POW_EPSILON);
   }

   double getZoneArea(HPZone zoneID)
   {
      double area;
      double zoneCount = 12 * pow(4, zoneID.level);
      static double earthArea = 0;
      if(!earthArea) earthArea = wholeWorld.geodeticArea;

      area = earthArea / zoneCount;
      return area;
   }

   int getMaxDGGRSZoneLevel() { return 26; }
   int getRefinementRatio() { return 4; }
   int getMaxParents() { return 1; }
   int getMaxNeighbors() { return 4; }
   int getMaxChildren() { return 4; }

   uint64 countSubZones(HPZone zone, int depth)
   {
      return 1LL << (2 * depth);
   }

   int getZoneLevel(HPZone zone)
   {
      return zone.level;
   }

   int countZoneEdges(HPZone zone) { return 4; }

   int getZoneParents(HPZone zone, HPZone * parents)
   {
      parents[0] = nullZone;
      if(zone.level > 0)
         parents[0] = zone.parent;
      return parents[0] != nullZone;
   }

   int getZoneChildren(HPZone zone, HPZone * children)
   {
      return zone.getChildren(children);
   }

   int getZoneNeighbors(HPZone zone, HPZone * neighbors, int * nbType)
   {
      int level = zone.level, root = zone.rootRhombus;
      uint64 subIndex = zone.subIndex;
      int row = (int)(subIndex >> level);
      int col = (int)(subIndex - ((int64)row << level));
      int64 p = 1LL << level;

      // Left
      if(col > 0)
         neighbors[0] = { level, root, ((int64)row << level) | (col - 1) };
      else if(root >= 8)
      {
         // Crossing interruption to the left
         int lRoot = root == 8 ? 0xB : root - 1;
         neighbors[0] = { level, lRoot, ((int64)(p-1) << level) | (p-1-row) };
      }
      else
      {
         int lRoot =
            root <= 3 ? root + 4 :
            root >= 5 && root <= 7 ? root + 3 :
            /*root == 4 ? */0xB;
         neighbors[0] = { level, lRoot, ((int64)row << level) | (p - 1) };
      }

      // Right
      if(col < p-1)
         neighbors[1] = { level, root, ((int64)row << level) | (col + 1) };
      else if(root <= 3)
      {
         // Crossing interruption to the right
         int rRoot = root == 3 ? 0 : root + 1;
         neighbors[1] = { level, rRoot, ((int64)0 << level) | (p-1-row) };
      }
      else
      {
         int rRoot =
            root >= 4 && root <= 7 ? root - 4 :
            root >= 8 && root <= 0xA ? root - 3 :
            /*root == 0xB ? */4;
         neighbors[1] = { level, rRoot, ((int64)row << level) | 0 };
      }

      // Top
      if(row > 0)
         neighbors[2] = { level, root, ((int64)(row - 1) << level) | col };
      else if(root <= 3)
      {
         // Crossing interruption to the left
         int tRoot = root == 0 ? 3 : root - 1;
         neighbors[2] = { level, tRoot, ((int64)(p-1-col) << level) | (p - 1) };
      }
      else
      {
         int tRoot =
            root >= 8 && root <= 0xB ? root - 4 :
            root >= 5 && root <= 7 ? root - 5 :
            /*root == 4 ? **/ 3;
         neighbors[2] = { level, tRoot, ((int64)(p - 1) << level) | col };
      }

      // Bottom
      if(row < p-1)
         neighbors[3] = { level, root, ((int64)(row + 1) << level) | col };
      else if(root >= 8)
      {
         // Crossing interruption to the right
         int bRoot = root == 0xB ? 8 : root + 1;
         neighbors[3] = { level, bRoot, ((int64)(p-1-col) << level) | 0 };
      }
      else
      {
         int bRoot =
            root >= 4 && root <= 7 ? root + 4 :
            root >= 0 && root <= 2 ? root + 5 :
            /*root == 3 ? */4;
         neighbors[3] = { level, bRoot, ((int64)0 << level) | col };
      }

      if(nbType)
         nbType[0] = 0, nbType[1] = 1, nbType[2] = 2, nbType[3] = 3;
      return 4;
   }

   HPZone getZoneFromWGS84Centroid(int level, const GeoPoint centroid)
   {
      if(level <= 26)
      {
         Pointd v;

         pj.forward(centroid, v);

         return HPZone::fromPoint(v, level);
      }
      return nullZone;
   }

   void getZoneWGS84Centroid(HPZone zone, GeoPoint centroid)
   {
      pj.inverse(zone.centroid, centroid, false);
   }

   // Text ZIRS
   void getZoneTextID(HPZone zone, String zoneID)
   {
      int level = zone.level;
      int root = zone.rootRhombus;
      uint64 subIndex = zone.subIndex;
      sprintf(zoneID, __runtimePlatform == win32 ? "%c%X-%I64X" : "%c%X-%llX",
         (char)(level + 'A'), root, subIndex);
   }

   DGGRSZone getZoneFromTextID(const String zoneID)
   {
      HPZone result = nullZone;
      char levelChar;
      uint root;
      uint64 ix;

      if(sscanf(zoneID, __runtimePlatform == win32 ? "%c%X-%I64X" : "%c%X-%llX", &levelChar, &root, &ix) == 3 &&
         levelChar >= 'A' && levelChar <= 'Z' && root <= 0xB)
      {
         int level = levelChar - 'A';
         if(ix < (1LL << (level<<1)))
            result = { level, root, ix };
      }
      return result;
   }

   // Sub-zone Order
   HPZone getFirstSubZone(HPZone parent, int depth)
   {
      int pLevel = parent.level, level = pLevel + depth;
      if(level <= 26)
      {
         uint root = parent.rootRhombus;
         uint64 pSubIndex = parent.subIndex;
         uint dm = 1 << depth;
         int pRow = (int)(pSubIndex >> pLevel);
         int pCol = (int)(pSubIndex - ((int64)pRow << pLevel));
         return HPZone { level, root, (((uint64)pRow * dm) << level) | (pCol * dm) };
      }
      return nullZone;
   }

   Array<DGGRSZone> getSubZones(HPZone parent, int relativeDepth)
   {
      int pLevel = parent.level, level = pLevel + relativeDepth;
      if(level <= 26)
      {
         uint root = parent.rootRhombus;
         uint64 pSubIndex = parent.subIndex;
         uint dm = 1 << relativeDepth;
         int pRow = (int)(pSubIndex >> pLevel);
         int pCol = (int)(pSubIndex - ((int64)pRow << pLevel));
         Array<DGGRSZone> subZones { size = dm * dm };
         int r, c, i = 0;

         for(r = 0; r < dm; r++)
            for(c = 0; c < dm; c++, i++)
               subZones[i] = HPZone { level, root, (((uint64)pRow * dm + r) << level) | (pCol * dm + c) };
         return subZones;
      }
      return null;
   }

   Array<Pointd> getSubZoneCRSCentroids(HPZone parent, CRS crs, int depth)
   {
      Array<Pointd> centroids = parent.getSubZoneCentroids(depth);
      if(centroids)
      {
         uint count = centroids.count, i;
         switch(crs)
         {
            case 0: case CRS { ogc, 99999 }: break;
            case CRS { epsg, 4326 }:
            case CRS { ogc, 84 }:
               for(i = 0; i < count; i++)
               {
                  GeoPoint geo;
                  pj.inverse(centroids[i], geo, false);
                  centroids[i] = crs == { ogc, 84 } ? { geo.lon, geo.lat } : { geo.lat, geo.lon };
               }
               break;
            default: delete centroids;
         }
      }
      return centroids;
   }

   Array<GeoPoint> getSubZoneWGS84Centroids(HPZone parent, int depth)
   {
      Array<GeoPoint> geo = null;
      Array<Pointd> centroids = parent.getSubZoneCentroids(depth);
      if(centroids)
      {
         uint count = centroids.count;
         int i;

         geo = { size = count };
         for(i = 0; i < count; i++)
            pj.inverse(centroids[i], geo[i], false);
         delete centroids;
      }
      return geo;
   }

   void compactZones(Array<DGGRSZone> zones)
   {
      int maxLevel = 0, i, count = zones.count;
      AVLTree<HPZone> zonesTree { };

      for(i = 0; i < count; i++)
      {
         HPZone zone = (HPZone)zones[i];
         if(zone != nullZone)
         {
            int level = zone.level;
            if(level > maxLevel)
               maxLevel = level;
            zonesTree.Add(zone);
         }
      }

      compactHPZones(zonesTree, maxLevel);
      zones.Free();

      count = zonesTree.count;
      zones.size = count;
      i = 0;
      for(z : zonesTree)
         zones[i++] = z;
      delete zonesTree;
   }

   /*
   void addPolarZones(AVLTree<HPZone> zonesTree, HPZone pZone, int level, const GeoExtent bbox)
   {
      GeoExtent e;
      getZoneWGS84Extent(pZone, e);

      if(e.intersects(bbox))
      {
         int zLevel = pZone.level;
         if(level == zLevel)
            zonesTree.Add(pZone);
         else
         {
            int sr = pZone.row * 3, sc = pZone.col * 3, r, c;

            for(r = sr; r < sr + 3; r++)
               for(c = sc; c < sc + 3; c++)
                  addPolarZones(zonesTree, { zLevel + 1, r, c }, level, bbox);
         }
      }
   }
   */

   Array<DGGRSZone> listZones(int level, const GeoExtent bbox)
   {
      AVLTree<HPZone> zonesTree { };
      Array<HPZone> zones { };
      int root;
      int l;

      for(root = 0; root < 12; root++)
         zonesTree.Add({ 0, root, 0 });

      if(level == 0 && bbox != null)
      {
         AVLTree<HPZone> tmp { };

         for(z : zonesTree)
         {
            HPZone zone = (HPZone)z;
            GeoExtent e;
            getZoneWGS84Extent(zone, e);
            if(e.intersects(bbox))
               tmp.Add(zone);
         }
         delete zonesTree;
         zonesTree = tmp;
      }

      for(l = 1; l <= level; l++)
      {
         AVLTree<HPZone> tmp { };

         for(z : zonesTree)
         {
            HPZone zz = z;
            HPZone children[4];
            int i;
            int n = zz.getChildren(children);

            for(i = 0; i < n; i++)
            {
               HPZone c = children[i];
               if(bbox != null)
               {
                  GeoExtent e;
                  if(!tmp.Find(c))
                  {
                     getZoneWGS84Extent(c, e);
                     if(!e.intersects(bbox))
                        continue;
                  }
                  else
                     continue;
               }
               tmp.Add(children[i]);
            }
         }
         delete zonesTree;
         zonesTree = tmp;
      }

/*
      // TODO:
      Radians bound = pj.latAuthalicToGeodetic(asin(2/3.0));
      GeoExtent equatorial, north, south;
      int r, c;

      equatorial.clip(bbox, { { -bound, -180 }, { bound, 180 } });
      north.clip(bbox, { { bound, -180 }, { 90, 180 } });
      south.clip(bbox, { { -90, -180 }, { -bound, 180 } });

      if(equatorial.nonNull)
      {
         // REVIEW: Dateline handling
         Pointd ll, ur;
         HPZone tlZone, brZone;
         Radians dLon = equatorial.ur.lon - equatorial.ll.lon;
         if(dLon < 0) dLon += 2 * Pi;

         pj.forward(equatorial.ll, ll);
         pj.forward(equatorial.ur, ur);

         if(fabs(ur.x - ll.x) < dLon / 2)
            ll.x = -Pi, ur.x = Pi;

         tlZone = HPZone::fromPoint({ ll.x + 1E-15, ur.y - 1E-15 }, level);
         brZone = HPZone::fromPoint({ ur.x - 1E-15, ll.y + 1E-15 }, level);

         for(r = tlZone.row; r <= brZone.row; r++)
         {
            if(brZone.col >= tlZone.col)
            {
               for(c = tlZone.col; c <= brZone.col; c++)
                  zonesTree.Add({ level, r, c });
            }
            else
            {
               for(c = 0; c <= tlZone.col; c++)
                  zonesTree.Add({ level, r, c });

               for(c = brZone.col; c < 4 * POW3(level); c++)
                  zonesTree.Add({ level, r, c });
            }
         }
      }

      if(north.nonNull)
         addPolarZones(zonesTree, { 0, 0, 0 }, level, north);
      if(south.nonNull)
         addPolarZones(zonesTree, { 0, 2, 0 }, level, south);
*/

      zones.minAllocSize = zonesTree.count;
      for(t : zonesTree)
         zones.Add(t);
      zones.minAllocSize = 0;
      if(!zones.count)
         delete zones;

      delete zonesTree;
      return (Array<DGGRSZone>)zones;
   }

   // edge refinement is not supported
   Array<GeoPoint> getZoneRefinedWGS84Vertices(HPZone zone, int edgeRefinement)
   {
      GeoPoint v[HP_MAX_VERTICES];
      int count = getHPRefinedWGS84Vertices(this, zone, v);
      Array<GeoPoint> vertices { size = count };
      memcpy(vertices.array, v, sizeof(GeoPoint) * count);
      return vertices;
   }

   int getZoneWGS84Vertices(HPZone zone, GeoPoint * vertices)
   {
      Pointd v[4];
      int level = zone.level;
      int root = zone.rootRhombus, rCol = root & 3, rRow = (root >> 2);
      uint64 subIndex = zone.subIndex;
      int64 p = 1LL << level;
      double oop = 1.0 / p;
      int row = (int)(subIndex >> level);
      int col = (int)(subIndex - ((int64)row << level));
      double x = rCol + (int)(rRow == 0) + col * oop;
      double y = rCol + (int)(rRow == 2) + row * oop;
      uint count = 4, i;

      /*
      Conversion from 4x6 to HEALPix:
         x =  (x + y) * Pi/4 - 5*Pi/4,
         y = -(y - x) * Pi/4
      */

      v[0].x = (x + y) * Pi/4 - 5*Pi/4;
      v[0].y = -(y - x) * Pi/4;

      v[1].x = (x + y + oop) * Pi/4 - 5*Pi/4;
      v[1].y = -(y + oop - x) * Pi/4;

      v[2].x = (x + y + 2*oop) * Pi/4 - 5*Pi/4;
      v[2].y = -(y - x) * Pi/4;

      v[3].x = (x + oop + y) * Pi/4 - 5*Pi/4;
      v[3].y = -(y - x - oop) * Pi/4;

      for(i = 0; i < count; i++)
         pj.inverse(v[i], vertices[i], false);
      return count;
   }

   void getZoneWGS84Extent(HPZone zone, GeoExtent value)
   {
      CRSExtent e = zone.hpExtent;
      GeoPoint v[4];
      int i;
      double midX = (e.tl.x + e.br.x) / 2;
      double midY = (e.tl.y + e.br.y) / 2;

      pj.inverse({ e.tl.x, midY }, v[0], false);
      pj.inverse({ midX, e.br.y }, v[1], false);
      pj.inverse({ e.br.x, midY }, v[2], false);
      pj.inverse({ midX, e.tl.y }, v[3], false);

      value.clear();
      for(i = 0; i < 4; i++)
      {
         if(v[i].lat < value.ll.lat) value.ll.lat = v[i].lat;
         if(v[i].lat > value.ur.lat) value.ur.lat = v[i].lat;

         if(fabs(fabs((Radians)v[i].lat) - Pi/2) > 1E-11)
         {
            if(v[i].lon < value.ll.lon) value.ll.lon = v[i].lon;
            if(v[i].lon > value.ur.lon) value.ur.lon = v[i].lon;
         }
      }
      if(value.ur.lon - value.ll.lon > Pi)
      {
         value.ll.lon = Pi;
         value.ur.lon = -Pi;
         for(i = 0; i < 4; i++)
         {
            if(v[i].lon > 0 && v[i].lon < value.ll.lon) value.ll.lon = v[i].lon;
            if(v[i].lon < 0 && v[i].lon > value.ur.lon) value.ur.lon = v[i].lon;
         }
      }

      if(value.ll.lon < -180)
         value.ll.lon += 360;
      if(value.ur.lon < -180)
         value.ur.lon += 360;
   }

   HPZone getZoneFromCRSCentroid(int level, CRS crs, const Pointd centroid)
   {
      if(level <= 26)
      {
         switch(crs)
         {
            case 0: case CRS { ogc, 99999 }: return HPZone::fromPoint(centroid, level);
            case CRS { epsg, 4326 }:
            case CRS { ogc, 84 }:
               return (HPZone)getZoneFromWGS84Centroid(level,
                  crs == { ogc, 84 } ?
                     { centroid.y, centroid.x } :
                     { centroid.x, centroid.y });
         }
      }
      return nullZone;
   }

   void getZoneCRSCentroid(HPZone zone, CRS crs, Pointd centroid)
   {
      switch(crs)
      {
         case 0: case CRS { ogc, 99999 }: centroid = zone.centroid; break;
         case CRS { epsg, 4326 }:
         case CRS { ogc, 84 }:
         {
            GeoPoint geo;

            getZoneWGS84Centroid(zone, geo);
            centroid = crs == { ogc, 84 } ?
               { geo.lon, geo.lat } :
               { geo.lat, geo.lon };
            break;
         }
      }
   }

   int getZoneCRSVertices(HPZone zone, CRS crs, Pointd * vertices)
   {
      uint count = 0, i;
      Pointd v[4];
      int level = zone.level;
      int root = zone.rootRhombus, rCol = root & 3, rRow = (root >> 2);
      uint64 subIndex = zone.subIndex;
      int64 p = 1LL << level;
      double oop = 1.0 / p;
      int row = (int)(subIndex >> level);
      int col = (int)(subIndex - ((int64)row << level));
      double x = rCol + (int)(rRow == 0) + col * oop;
      double y = rCol + (int)(rRow == 2) + row * oop;

      /*
      Conversion from 4x6 to HEALPix:
         x =  (x + y) * Pi/4 - 5*Pi/4,
         y = -(y - x) * Pi/4
      */

      v[0].x = (x + y) * Pi/4 - 5*Pi/4;
      v[0].y = -(y - x) * Pi/4;

      v[1].x = (x + y + oop) * Pi/4 - 5*Pi/4;
      v[1].y = -(y + oop - x) * Pi/4;

      v[2].x = (x + y + 2*oop) * Pi/4 - 5*Pi/4;
      v[2].y = -(y - x) * Pi/4;

      v[3].x = (x + oop + y) * Pi/4 - 5*Pi/4;
      v[3].y = -(y - x - oop) * Pi/4;

      switch(crs)
      {
         case 0: case CRS { ogc, 99999 }:
            count = 4;
            memcpy(vertices, v, sizeof(Pointd) * 4);
            break;
         case CRS { ogc, 84 }:
         case CRS { epsg, 4326 }:
            count = 4;
            for(i = 0; i < count; i++)
            {
               GeoPoint geo;
               pj.inverse(v[i], geo, false);
               vertices[i] = crs == { ogc, 84 } ? { geo.lon, geo.lat } : { geo.lat, geo.lon };
            }
            break;
      }
      return count;
   }

   Array<Pointd> getZoneRefinedCRSVertices(HPZone zone, CRS crs, int edgeRefinement)
   {
      switch(crs)
      {
         case 0: case CRS { ogc, 99999 }:
         {
            Array<Pointd> vertices { size = 4 };
            getZoneCRSVertices(zone, crs, vertices.array);
            return vertices;
         }
         case CRS { ogc, 84 }: case CRS { epsg, 4326 }:
         {
            GeoPoint v[HP_MAX_VERTICES];
            int count = getHPRefinedWGS84Vertices(this, zone, v), i;
            Array<Pointd> vertices { size = count };
            for(i = 0; i < count; i++)
               vertices[i] = crs == { ogc, 84 } ? { v[i].lat, v[i].lon } : { v[i].lon, v[i].lat };
            return vertices;
         }
      }
      return null;
   }

   void getZoneCRSExtent(HPZone zone, CRS crs, CRSExtent extent)
   {
      switch(crs)
      {
         case 0: case CRS { ogc, 99999 }: extent = zone.hpExtent; break;
         case CRS { epsg, 4326 }:
         case CRS { ogc, 84 }:
         {
            GeoExtent geo;
            getZoneWGS84Extent(zone, geo);
            extent.crs = crs;
            if(crs == { ogc, 84 })
            {
               extent.tl = { geo.ll.lon, geo.ur.lat };
               extent.br = { geo.ur.lon, geo.ll.lat };
            }
            else
            {
               extent.tl = { geo.ur.lat, geo.ll.lon };
               extent.br = { geo.ll.lat, geo.ur.lon };
            }
            break;
         }
      }
   }
}

static void compactHPZones(AVLTree<HPZone> zones, int level)
{
   AVLTree<HPZone> output { };
   AVLTree<HPZone> next { };
   int l;

   for(l = level - 1; l >= 0; l--)
   {
      int i;
      for(z : zones)
      {
         HPZone zone = z, parent = zone.parent;
         if(!next.Find(parent))
         {
            bool parentAllIn = true;
            HPZone children[4];
            int n = parent.getChildren(children);

            for(i = 0; i < n; i++)
            {
               HPZone ch = children[i];
               if(ch != nullZone && !zones.Find(ch))
               {
                  parentAllIn = false;
                  break;
               }
            }

            if(parentAllIn)
               next.Add(parent);
            else
               output.Add(zone);
         }
      }

      if(l - 1 >= 0 && next.count)
      {
         // Not done -- next level becomes zones to compact
         zones.copySrc = next;
         next.Free();
      }
      else
      {
         // Done -- next is combined with output into final zones
         zones.copySrc = output;
         for(z : next)
            zones.Add(z);
         //break;
      }
   }

   delete output;
   delete next;
}

   // NOTE: custom edgeRefinement not currently supported

static uint getHPRefinedWGS84Vertices(HEALPix dggrs, HPZone zone, GeoPoint * outVertices)
{
   #define NUM_HP_ANCHORS 30
   uint count = 0;
   Pointd dp[4];
   Radians maxDLon = -99999, urLon = -MAXDOUBLE;
   Radians minDLon =  99999, llLon =  MAXDOUBLE;
   GeoPoint centroid;
   int i;
   HEALPixProjection pj = dggrs.pj;
   //bool includesNorthPole = e.tl.y > Pi/2 && e.br.y < Pi/2 && e.tl.x < -3*Pi/4 && e.br.x > -3*Pi/4;
   //bool includesSouthPole = e.tl.y > -Pi/2 && e.br.y < -Pi/2 && e.tl.x < -3*Pi/4 && e.br.x > -3*Pi/4;

   dggrs.getZoneCRSVertices(zone, 0, dp);

   dggrs.getZoneWGS84Centroid(zone, centroid);

   for(i = 0; i < 4; i++)
   {
      const Pointd * p = &dp[i], * np = &dp[i == 3 ? 0 : i+1];
      int numAnchors = NUM_HP_ANCHORS;
      int j;
      double dx = np->x - p->x, dy = np->y - p->y;

      for(j = 0; j < numAnchors; j++)
      {
         Pointd in { p->x + dx * j / numAnchors, p->y + dy * j / numAnchors };
         GeoPoint out;
         // Pointd nin { p->x + dx * (j+1) / numAnchors, p->y + dy * (j+1) / numAnchors };

         if(pj.inverse(in, out, false))
         {
            Radians dLon = out.lon - centroid.lon;

            if(dLon > Pi) dLon -= 2*Pi, out.lon -= 2*Pi;
            if(dLon <-Pi) dLon += 2*Pi, out.lon += 2*Pi;

            if(dLon > maxDLon)
               maxDLon = dLon, urLon = out.lon;
            if(dLon < minDLon)
               minDLon = dLon, llLon = out.lon;

            if(fabs((Radians)out.lat) > Pi/2 - 0.1 /*1E-9*/ && count && fabs((Radians)out.lon - (Radians)outVertices[count-1].lon) > Pi/6)
            {
               GeoPoint outLon;
               in.y = in.y - Sgn(in.y) * 1E-11;
               pj.inverse(in, outLon, false);
               out.lon = outLon.lon;

               if(Pi/2 - fabs((Radians)outVertices[count-1].lat) > 0.001)
               {
                  outVertices[count].lat = Sgn(out.lat) * Pi/2;
                  outVertices[count].lon = outVertices[count-1].lon;
                  count++;
               }
               else if(fabs((Radians)outVertices[count-1].lon - (Radians)out.lon) > Pi/6)
               {
                  outVertices[count].lat = Sgn(out.lat) * Pi/2;
                  outVertices[count].lon = out.lon;
                  count++;
               }
            }

            outVertices[count++] = out;

            /*
            if(crossingDateline && includesSouthPole)
            {
               if(fabs((Radians)out.lon - -Pi) > 1E-9)
                  outVertices[count++] = { out.lat, -180 };
               outVertices[count++] = { -90, -180 };
               outVertices[count++] = { -90, 180 };
               if(fabs((Radians)out.lon - Pi) > 1E-9)
                  outVertices[count++] = { out.lat, 180 };
            }
            if(crossingDateline && includesNorthPole)
            {
               if(fabs((Radians)out.lon - Pi) > 1E-9)
                  outVertices[count++] = { out.lat, 180 };
               outVertices[count++] = { 90, 180 };
               outVertices[count++] = { 90, -180 };
               if(fabs((Radians)out.lon - -Pi) > 1E-9)
                  outVertices[count++] = { out.lat, -180 };
            }
            */
         }
#ifdef _DEBUG
         else
         {
            PrintLn("WARNING: Failure to inverse project");
            // pj.inverse(in, out, false);
         }
#endif
      }
   }

   if(fabs(llLon - -Pi) < 1E-9)
      urLon = Pi;
   if(fabs(urLon - Pi) < 1E-9)
      llLon = -Pi;

   for(i = 0; i < count; i++)
      if((Radians)outVertices[i].lon > (Radians)urLon + 1E-11)
         outVertices[i].lon -= 2*Pi;
      else if(outVertices[i].lon < (Radians)llLon - 1E-11)
         outVertices[i].lon += 2*Pi;
   return count;
}



================================================
FILE: src/dggrs/ISEA3H.ec
================================================
public import IMPORT_STATIC "ecrt"
private:

import "RI3H"
import "icoVertexGreatCircle"

public class ISEA3H : RhombicIcosahedral3H
{
   equalArea = true;

   ISEA3H() { pj = ISEAProjection { }; incref pj; }
   ~ISEA3H() { delete pj; }
}



================================================
FILE: src/dggrs/ISEA4R.ec
================================================
public import IMPORT_STATIC "ecrt"
private:

import "RI4R"
import "icoVertexGreatCircle"

public class ISEA4R : RhombicIcosahedral4R
{
   equalArea = true;

   ISEA4R() { pj = ISEAProjection { }; incref pj; }
   ~ISEA4R() { delete pj; }
}



================================================
FILE: src/dggrs/ISEA7H.ec
================================================
public import IMPORT_STATIC "ecrt"
private:

import "RI7H"
import "icoVertexGreatCircle"

public class ISEA7H : RhombicIcosahedral7H
{
   equalArea = true;

   ISEA7H() { pj = ISEAProjection { }; incref pj; }
   ~ISEA7H() { delete pj; }
}



================================================
FILE: src/dggrs/ISEA7H_Z7.ec
================================================
public import IMPORT_STATIC "ecrt"
private:

import "RI7H_Z7"

#define Z7_DGGRSZONE

#ifdef Z7_DGGRSZONE
// Using Z7Zone natively for DGGRSZone, at the cost of some performance impact
import "icoVertexGreatCircle"

public class ISEA7H_Z7 : RI7H_Z7
{
   equalArea = true;

   ISEA7H_Z7() { pj = ISEAProjection { }; incref pj; }
   ~ISEA7H_Z7() { delete pj; }
}

#else
// To still use I7HZone for 64-bit integer DGGRSZone...
import "ISEA7H"

public class ISEA7H_Z7 : ISEA7H
{
   I7HZone getZoneFromTextID(const String zoneID)
   {
      return Z7Zone::fromTextID(zoneID).to7H();
   }

   void getZoneTextID(I7HZone zone, String zoneID)
   {
      Z7Zone::from7H(zone).getTextID(zoneID);
   }
}

#endif



================================================
FILE: src/dggrs/ISEA9R.ec
================================================
public import IMPORT_STATIC "ecrt"
private:

import "RI9R"
import "icoVertexGreatCircle"

#include <stdio.h>

public class ISEA9R : RhombicIcosahedral9R
{
   equalArea = true;

   ISEA9R() { pj = ISEAProjection { }; incref pj; }
   ~ISEA9R() { delete pj; }
}



================================================
FILE: src/dggrs/IVEA3H.ec
================================================
public import IMPORT_STATIC "ecrt"
private:

import "RI3H"
import "icoVertexGreatCircle"

public class IVEA3H : RhombicIcosahedral3H
{
   equalArea = true;

   IVEA3H() { pj = SliceAndDiceGreatCircleIcosahedralProjection { }; incref pj; }
   ~IVEA3H() { delete pj; }
}



================================================
FILE: src/dggrs/IVEA4R.ec
================================================
public import IMPORT_STATIC "ecrt"
private:

import "RI4R"
import "icoVertexGreatCircle"

public class IVEA4R : RhombicIcosahedral4R
{
   equalArea = true;

   IVEA4R() { pj = SliceAndDiceGreatCircleIcosahedralProjection { }; incref pj; }
   ~IVEA4R() { delete pj; }
}



================================================
FILE: src/dggrs/IVEA7H.ec
================================================
public import IMPORT_STATIC "ecrt"
private:

import "RI7H"
import "icoVertexGreatCircle"

public class IVEA7H : RhombicIcosahedral7H
{
   equalArea = true;

   IVEA7H() { pj = SliceAndDiceGreatCircleIcosahedralProjection { }; incref pj; }
   ~IVEA7H() { delete pj; }
}



================================================
FILE: src/dggrs/IVEA7H_Z7.ec
================================================
public import IMPORT_STATIC "ecrt"
private:

import "RI7H_Z7"

#define Z7_DGGRSZONE

#ifdef Z7_DGGRSZONE
// Using Z7Zone natively for DGGRSZone, at the cost of some performance impact
import "icoVertexGreatCircle"

public class IVEA7H_Z7 : RI7H_Z7
{
   equalArea = true;

   IVEA7H_Z7() { pj = SliceAndDiceGreatCircleIcosahedralProjection { }; incref pj; }
   ~IVEA7H_Z7() { delete pj; }
}

#else
// To still use I7HZone for 64-bit integer DGGRSZone...
import "IVEA7H"

public class IVEA7H_Z7 : IVEA7H
{
   I7HZone getZoneFromTextID(const String zoneID)
   {
      return Z7Zone::fromTextID(zoneID).to7H();
   }

   void getZoneTextID(I7HZone zone, String zoneID)
   {
      Z7Zone::from7H(zone).getTextID(zoneID);
   }
}

#endif



================================================
FILE: src/dggrs/IVEA9R.ec
================================================
public import IMPORT_STATIC "ecrt"
private:

import "RI9R"
import "icoVertexGreatCircle"

public class IVEA9R : RhombicIcosahedral9R
{
   equalArea = true;

   IVEA9R() { pj = SliceAndDiceGreatCircleIcosahedralProjection { }; incref pj; }
   ~IVEA9R() { delete pj; }
}



================================================
FILE: src/dggrs/rHEALPixGrid.ec
================================================
public import IMPORT_STATIC "ecrt"
private:

import "dggrs"
import "rHEALPix"

#include <stdio.h>

static define POW_EPSILON = 0.1;

define RHP_MAX_VERTICES = 200; // * 1024;

extern uint64 powersOf3[34]; // in RI3H.ec

#define POW3(x) ((x) < sizeof(powersOf3) / sizeof(powersOf3[0]) ? (uint64)powersOf3[x] : (uint64)(pow(3, x) + POW_EPSILON))

public class RHPZone : private DGGRSZone
{
public:
   uint level:5:59, row:29:30, col:30:0;

private:
   property RHPZone parent
   {
      get
      {
         int level = this.level;
         if(level > 0)
            return { level - 1, row / 3, col / 3 };
         return nullZone;
      }
   }

   property Pointd centroid
   {
      get
      {
         int64 p = (int64)(pow(3, level) + POW_EPSILON);
         value.x = -Pi    + (col + 0.5) * Pi/2 / p;
         value.y = 3*Pi/4 - (row + 0.5) * Pi/2 / p;
      }
   }

   property CRSExtent rhpExtent
   {
      get
      {
         int64 p = (int64)(pow(3, level) + POW_EPSILON);
         value.tl.y = 3*Pi/4 - row * Pi/2 / p;
         value.tl.x = -Pi    + col * Pi/2 / p;
         value.br.x = value.tl.x + Pi/2 / p;
         value.br.y = value.tl.y - Pi/2 / p;
      }
   }

   RHPZone ::fromPoint(const Pointd v, int level)
   {
      int row, col;
      int p = (int)(pow(3, level) + POW_EPSILON);

      row = Max(0, Min(3 * p - 1, (int)((3*Pi/4 - v.y) * p / (Pi/2))));
      col = Max(0, Min(((row / p) == 1 ? 4 * p : p) - 1, (int)((v.x + Pi) * p / (Pi/2))));
      return { level, row, col };
   }

   Array<Pointd> getSubZoneCentroids(int depth)
   {
      int p = (int)(pow(3, depth) + POW_EPSILON);
      Array<Pointd> centroids { size = p * p };
      int r, c, i = 0;
      CRSExtent e = rhpExtent;
      double w = e.br.x - e.tl.x, h = e.br.y - e.tl.y;

      for(r = 0; r < p; r++)
         for(c = 0; c < p; c++, i++)
            centroids[i] = { e.tl.x + c * w / p, e.tl.y + r * h / p };
      return centroids;
   }

   int getChildren(RHPZone * children)
   {
      int level = this.level, row = this.row, col = this.col;

      if(level < 16)
      {
         int r, c;

         for(r = 0; r < 3; r++)
            for(c = 0; c < 3; c++)
               children[r * 3 + c] = RHPZone { level + 1, row * 3 + r, col * 3 + c };
         return 9;
      }
      return 0;
   }
}

public class rHEALPix : DGGRS
{
   rHEALPixProjection pj { };

   uint64 countZones(int level)
   {
      return (uint64)(6 * (pow(9, level)) + POW_EPSILON);
   }

   double getZoneArea(RHPZone zoneID)
   {
      double area;
      double zoneCount = 6 * pow(9, zoneID.level);
      static double earthArea = 0;
      if(!earthArea) earthArea = wholeWorld.geodeticArea;

      area = earthArea / zoneCount;
      return area;
   }

   int getMaxDGGRSZoneLevel() { return 16; }
   int getRefinementRatio() { return 9; }
   int getMaxParents() { return 1; }
   int getMaxNeighbors() { return 4; }
   int getMaxChildren() { return 9; }

   uint64 countSubZones(RHPZone zone, int depth)
   {
      return (uint64)(pow(9, depth) + POW_EPSILON);
   }

   int getZoneLevel(RHPZone zone)
   {
      return zone.level;
   }

   int countZoneEdges(RHPZone zone) { return 4; }

   int getZoneParents(RHPZone zone, RHPZone * parents)
   {
      parents[0] = nullZone;
      if(zone.level > 0)
         parents[0] = zone.parent;
      return parents[0] != nullZone;
   }

   int getZoneChildren(RHPZone zone, RHPZone * children)
   {
      return zone.getChildren(children);
   }

   int getZoneNeighbors(RHPZone zone, RHPZone * neighbors, int * nbType)
   {
      int level = zone.level, row = zone.row, col = zone.col;
      int p = (int)(pow(3, level) + POW_EPSILON);
      int rr = row / p;

      // Left
      if(col > 0)
         neighbors[0] = { level, row, col - 1 };
      else if(rr == 1) // Equatorial wrap around
         neighbors[0] = { level, row, 4 * p - 1 };
      else if(rr == 0) // North -> equatorial
         neighbors[0] = { level, p, 4 * p - (p-row) };
      else if(rr == 2) // South -> equatorial
         neighbors[0] = { level, 2*p-1, 4 * p - 1 - (row - 2*p) };

      // Right
      if(col < (rr == 1 ? 4*p : p) - 1)
         neighbors[1] = { level, row, col + 1 };
      else if(rr == 1) // Equatorial wrap around
         neighbors[1] = { level, row, 0 };
      else if(rr == 0) // North -> equatorial
         neighbors[1] = { level, p, p + (p-1-row) };
      else if(rr == 2) // South -> equatorial
         neighbors[1] = { level, 2*p-1, p + (row - 2*p) };

      // Top
      if(row > 0 && (col < p || row > p))
         neighbors[2] = { level, row - 1, col };
      else if(rr == 0) // North -> equatorial
         neighbors[2] = { level, p, 2*p + (p-1-col) };
      else if(rr == 1) // Equatorial -> North
      {
         if(col < 2 * p)
            neighbors[2] = { level, (p - (col - p)) - 1, p-1 };  // FIXME: eC bug here if using row =  or col =
         else if(col < 3 * p)
            neighbors[2] = { level, 0, p - 1 - (col - 2*p) };
         else
            neighbors[2] = { level, col - 3*p, 0 };
      }

      // Bottom
      if(row < 3*p-1 && (col < p || row < 2*p-1))
         neighbors[3] = { level, row + 1, col };
      else if(rr == 2) // South -> equatorial
         neighbors[3] = { level, 2*p-1, 2*p + (p-col) - 1 };
      else if(rr == 1) // Equatorial -> South
      {
         if(col < 2 * p)
            neighbors[3] = { level, 2*p + (col - p), p-1 };
         else if(col < 3 * p)
            neighbors[3] = { level, 3*p-1, p - 1 - (col - 2*p) };
         else
            neighbors[3] = { level, 2*p + p - (col - 3*p) - 1, 0 };
      }

      if(nbType)
         nbType[0] = 0, nbType[1] = 1, nbType[2] = 2, nbType[3] = 3;
      return 4;
   }

   RHPZone getZoneFromWGS84Centroid(int level, const GeoPoint centroid)
   {
      if(level <= 16)
      {
         Pointd v;

         pj.forward(centroid, v);

         return RHPZone::fromPoint(v, level);
      }
      return nullZone;
   }

   void getZoneWGS84Centroid(RHPZone zone, GeoPoint centroid)
   {
      pj.inverse(zone.centroid, centroid, false);
   }

   // Text ZIRS
   void getZoneTextID(RHPZone zone, String zoneID)
   {
      int level = zone.level;
      int64 p = (int64)(pow(3, level) + POW_EPSILON);
      int row = zone.row, col = zone.col;
      int r = (int)(row / p), c = (int)(col / p);
      int i;

      zoneID[0] = r == 0 ? 'N' : r == 2 ? 'S' : (char)('O' + c);
      for(i = 1; i <= level; i++)
      {
         row -= r * p;
         col -= c * p;
         p /= 3;
         r = (int)(row / p);
         c = (int)(col / p);
         zoneID[i] = (char)('0' + r * 3 + c);
      }
      zoneID[i] = 0;
   }

   DGGRSZone getZoneFromTextID(const String zoneID)
   {
      char ch = zoneID[0];
      int r = ch == 'N' ? 0 : ch == 'S' ? 2 : (ch >= 'O' && ch <= 'R') ? 1 : -1;
      if(r == -1)
         return nullZone;
      else
      {
         int c = r == 1 ? ch - 'O' : 0;
         int level = 0;
         while((ch = zoneID[level+1]))
         {
            if(level < 16 && ch >= '0' && ch <= '8')
            {
               int n = ch - '0';
               c *= 3;
               r *= 3;
               r += n / 3;
               c += n % 3;
               level++;
            }
            else
               return nullZone;
         }
         return RHPZone { level, r, c };
      }
   }

   // Sub-zone Order
   RHPZone getFirstSubZone(RHPZone parent, int depth)
   {
      int level = parent.level + depth;
      if(level <= 16)
      {
         int p = (int)(pow(3, depth) + POW_EPSILON);
         return RHPZone { level, parent.row * p, parent.col * p };
      }
      return nullZone;
   }


   void compactZones(Array<DGGRSZone> zones)
   {
      int maxLevel = 0, i, count = zones.count;
      AVLTree<RHPZone> zonesTree { };

      for(i = 0; i < count; i++)
      {
         RHPZone zone = (RHPZone)zones[i];
         if(zone != nullZone)
         {
            int level = zone.level;
            if(level > maxLevel)
               maxLevel = level;
            zonesTree.Add(zone);
         }
      }

      compactRHPZones(zonesTree, maxLevel);
      zones.Free();

      count = zonesTree.count;
      zones.size = count;
      i = 0;
      for(z : zonesTree)
         zones[i++] = z;
      delete zonesTree;
   }

   void addPolarZones(AVLTree<RHPZone> zonesTree, RHPZone pZone, int level, const GeoExtent bbox)
   {
      GeoExtent e;
      getZoneWGS84Extent(pZone, e);

      if(e.intersects(bbox))
      {
         int zLevel = pZone.level;
         if(level == zLevel)
            zonesTree.Add(pZone);
         else
         {
            int sr = pZone.row * 3, sc = pZone.col * 3, r, c;

            for(r = sr; r < sr + 3; r++)
               for(c = sc; c < sc + 3; c++)
                  addPolarZones(zonesTree, { zLevel + 1, r, c }, level, bbox);
         }
      }
   }

   Array<DGGRSZone> listZones(int level, const GeoExtent bboxArg)
   {
      AVLTree<RHPZone> zonesTree { };
      Array<RHPZone> zones { };
      Radians bound = pj.latAuthalicToGeodetic(asin(2/3.0));
      GeoExtent equatorial, north, south;
      int r, c;
      GeoExtent bbox;

      if(bboxArg != null)
         bbox = bboxArg;
      else
         bbox = wholeWorld;

      equatorial.clip(bbox, { { -bound, -180 }, { bound, 180 } });
      north.clip(bbox, { { bound, -180 }, { 90, 180 } });
      south.clip(bbox, { { -90, -180 }, { -bound, 180 } });

      if(equatorial.nonNull)
      {
         // REVIEW: Dateline handling
         Pointd ll, ur;
         RHPZone tlZone, brZone;
         Radians dLon = equatorial.ur.lon - equatorial.ll.lon;
         if(dLon < 0) dLon += 2 * Pi;

         pj.forward(equatorial.ll, ll);
         pj.forward(equatorial.ur, ur);

         if(fabs(ur.x - ll.x) < dLon / 2)
            ll.x = -Pi, ur.x = Pi;

         tlZone = RHPZone::fromPoint({ ll.x + 1E-15, ur.y - 1E-15 }, level);
         brZone = RHPZone::fromPoint({ ur.x - 1E-15, ll.y + 1E-15 }, level);

         for(r = tlZone.row; r <= brZone.row; r++)
         {
            if(brZone.col >= tlZone.col)
            {
               for(c = tlZone.col; c <= brZone.col; c++)
                  zonesTree.Add({ level, r, c });
            }
            else
            {
               for(c = 0; c <= tlZone.col; c++)
                  zonesTree.Add({ level, r, c });

               for(c = brZone.col; c < 4 * POW3(level); c++)
                  zonesTree.Add({ level, r, c });
            }
         }
      }

      if(north.nonNull)
         addPolarZones(zonesTree, { 0, 0, 0 }, level, north);
      if(south.nonNull)
         addPolarZones(zonesTree, { 0, 2, 0 }, level, south);

      zones.minAllocSize = zonesTree.count;
      for(t : zonesTree)
         zones.Add(t);
      zones.minAllocSize = 0;
      if(!zones.count)
         delete zones;

      delete zonesTree;
      return (Array<DGGRSZone>)zones;
   }

   Array<GeoPoint> getSubZoneWGS84Centroids(RHPZone parent, int depth)
   {
      Array<GeoPoint> geo = null;
      Array<Pointd> centroids = parent.getSubZoneCentroids(depth);
      if(centroids)
      {
         uint count = centroids.count;
         int i;

         geo = { size = count };
         for(i = 0; i < count; i++)
            pj.inverse(centroids[i], geo[i], false);
         delete centroids;
      }
      return geo;
   }

   // edge refinement is not supported
   Array<GeoPoint> getZoneRefinedWGS84Vertices(RHPZone zone, int edgeRefinement)
   {
      GeoPoint v[RHP_MAX_VERTICES];
      int count = getRHPRefinedWGS84Vertices(this, zone, v);
      Array<GeoPoint> vertices { size = count };
      memcpy(vertices.array, v, sizeof(GeoPoint) * count);
      return vertices;
   }

   int getZoneWGS84Vertices(RHPZone zone, GeoPoint * vertices)
   {
      CRSExtent extent = zone.rhpExtent;
      Pointd v5x6[4] =
      {
         extent.tl,
         { extent.tl.x, extent.br.y },
         extent.br,
         { extent.br.x, extent.tl.y }
      };
      uint count = 4, i;
      for(i = 0; i < count; i++)
         pj.inverse(v5x6[i], vertices[i], false);
      return count;
   }

   void getZoneWGS84Extent(RHPZone zone, GeoExtent value)
   {
      CRSExtent e = zone.rhpExtent;
      GeoPoint v[4];
      int i;
      bool includesNorthPole = e.tl.y > Pi/2 && e.br.y < Pi/2 && e.tl.x < -3*Pi/4 && e.br.x > -3*Pi/4;
      bool includesSouthPole = e.tl.y > -Pi/2 && e.br.y < -Pi/2 && e.tl.x < -3*Pi/4 && e.br.x > -3*Pi/4;

      pj.inverse(e.tl, v[0], false);
      pj.inverse({ e.tl.x, e.br.y }, v[1], false);
      pj.inverse(e.br, v[2], false);
      pj.inverse({ e.br.x, e.tl.y }, v[3], false);

      value.clear();
      for(i = 0; i < 4; i++)
      {
         if(v[i].lat < value.ll.lat) value.ll.lat = v[i].lat;
         if(v[i].lat > value.ur.lat) value.ur.lat = v[i].lat;
         if(v[i].lon < value.ll.lon) value.ll.lon = v[i].lon;
         if(v[i].lon > value.ur.lon) value.ur.lon = v[i].lon;
      }
      if(value.ur.lon - value.ll.lon > Pi)
      {
         value.ll.lon = Pi;
         value.ur.lon = -Pi;
         for(i = 0; i < 4; i++)
         {
            if(v[i].lon > 0 && v[i].lon < value.ll.lon) value.ll.lon = v[i].lon;
            if(v[i].lon < 0 && v[i].lon > value.ur.lon) value.ur.lon = v[i].lon;
         }
      }
      if(includesNorthPole)
      {
         value.ll.lon = -180;
         value.ur.lon =  180;
         value.ur.lat =  90;
      }
      else if(includesSouthPole)
      {
         value.ll.lon = -180;
         value.ur.lon =  180;
         value.ll.lat =  -90;
      }
   }

   RHPZone getZoneFromCRSCentroid(int level, CRS crs, const Pointd centroid)
   {
      if(level <= 16)
      {
         switch(crs)
         {
            case 0: case CRS { ogc, 99999 }: return RHPZone::fromPoint(centroid, level);
            case CRS { epsg, 4326 }:
            case CRS { ogc, 84 }:
               return (RHPZone)getZoneFromWGS84Centroid(level,
                  crs == { ogc, 84 } ?
                     { centroid.y, centroid.x } :
                     { centroid.x, centroid.y });
         }
      }
      return nullZone;
   }

   Array<DGGRSZone> getSubZones(DGGRSZone parent, int relativeDepth)
   {
      int level = parent.level + relativeDepth;
      int row = parent.row, col = parent.col;
      int p = (int)(pow(3, relativeDepth) + POW_EPSILON);
      Array<DGGRSZone> subZones { size = p * p };
      int r, c, i = 0;

      for(r = 0; r < p; r++)
         for(c = 0; c < p; c++, i++)
            subZones[i] = RHPZone { level, row * p + r, col * p + c };
      return subZones;
   }

   void getZoneCRSCentroid(RHPZone zone, CRS crs, Pointd centroid)
   {
      switch(crs)
      {
         case 0: case CRS { ogc, 99999 }: centroid = zone.centroid; break;
         case CRS { epsg, 4326 }:
         case CRS { ogc, 84 }:
         {
            GeoPoint geo;

            getZoneWGS84Centroid(zone, geo);
            centroid = crs == { ogc, 84 } ?
               { geo.lon, geo.lat } :
               { geo.lat, geo.lon };
            break;
         }
      }
   }

   int getZoneCRSVertices(RHPZone zone, CRS crs, Pointd * vertices)
   {
      uint count = 0, i;
      CRSExtent extent = zone.rhpExtent;
      Pointd v[4] =
      {
         extent.tl,
         { extent.tl.x, extent.br.y },
         extent.br,
         { extent.br.x, extent.tl.y }
      };

      switch(crs)
      {
         case 0: case CRS { ogc, 99999 }:
            count = 4;
            memcpy(vertices, v, sizeof(Pointd) * 4);
            break;
         case CRS { ogc, 84 }:
         case CRS { epsg, 4326 }:
            count = 4;
            for(i = 0; i < count; i++)
            {
               GeoPoint geo;
               pj.inverse(v[i], geo, false);
               vertices[i] = crs == { ogc, 84 } ? { geo.lon, geo.lat } : { geo.lat, geo.lon };
            }
            break;
      }
      return count;
   }

   // No refinement needed in ISEA CRSs
   Array<Pointd> getZoneRefinedCRSVertices(RHPZone zone, CRS crs, int edgeRefinement)
   {
      switch(crs)
      {
         case 0: case CRS { ogc, 99999 }:
         {
            Array<Pointd> vertices { size = 4 };
            getZoneCRSVertices(zone, crs, vertices.array);
            return vertices;
         }
         case CRS { ogc, 84 }: case CRS { epsg, 4326 }:
         {
            GeoPoint v[RHP_MAX_VERTICES];
            int count = getRHPRefinedWGS84Vertices(this, zone, v), i;
            Array<Pointd> vertices { size = count };
            for(i = 0; i < count; i++)
               vertices[i] = crs == { ogc, 84 } ? { v[i].lat, v[i].lon } : { v[i].lon, v[i].lat };
            return vertices;
         }
      }
      return null;
   }

   void getZoneCRSExtent(RHPZone zone, CRS crs, CRSExtent extent)
   {
      switch(crs)
      {
         case 0: case CRS { ogc, 99999 }: extent = zone.rhpExtent; break;
         case CRS { epsg, 4326 }:
         case CRS { ogc, 84 }:
         {
            GeoExtent geo;
            getZoneWGS84Extent(zone, geo);
            extent.crs = crs;
            if(crs == { ogc, 84 })
            {
               extent.tl = { geo.ll.lon, geo.ur.lat };
               extent.br = { geo.ur.lon, geo.ll.lat };
            }
            else
            {
               extent.tl = { geo.ur.lat, geo.ll.lon };
               extent.br = { geo.ll.lat, geo.ur.lon };
            }
            break;
         }
      }
   }

   Array<Pointd> getSubZoneCRSCentroids(RHPZone parent, CRS crs, int depth)
   {
      Array<Pointd> centroids = parent.getSubZoneCentroids(depth);
      if(centroids)
      {
         uint count = centroids.count, i;
         switch(crs)
         {
            case 0: case CRS { ogc, 99999 }: break;
            case CRS { epsg, 4326 }:
            case CRS { ogc, 84 }:
               for(i = 0; i < count; i++)
               {
                  GeoPoint geo;
                  pj.inverse(centroids[i], geo, false);
                  centroids[i] = crs == { ogc, 84 } ? { geo.lon, geo.lat } : { geo.lat, geo.lon };
               }
               break;
            default: delete centroids;
         }
      }
      return centroids;
   }
}

static void compactRHPZones(AVLTree<RHPZone> zones, int level)
{
   AVLTree<RHPZone> output { };
   AVLTree<RHPZone> next { };
   int l;

   for(l = level - 1; l >= 0; l--)
   {
      int i;
      for(z : zones)
      {
         RHPZone zone = z, parent = zone.parent;
         if(!next.Find(parent))
         {
            bool parentAllIn = true;
            RHPZone children[9];

            parent.getChildren(children);

            for(i = 0; i < 9; i++)
            {
               RHPZone ch = children[i];
               if(ch != nullZone && !zones.Find(ch))
               {
                  parentAllIn = false;
                  break;
               }
            }

            if(parentAllIn)
               next.Add(parent);
            else
               output.Add(zone);
         }
      }

      if(l - 1 >= 0 && next.count)
      {
         // Not done -- next level becomes zones to compact
         zones.copySrc = next;
         next.Free();
      }
      else
      {
         // Done -- next is combined with output into final zones
         zones.copySrc = output;
         for(z : next)
            zones.Add(z);
         //break;
      }
   }

   delete output;
   delete next;
}

   // NOTE: custom edgeRefinement not currently supported
static uint getRHPRefinedWGS84Vertices(rHEALPix dggrs, RHPZone zone, GeoPoint * outVertices)
{
   #define NUM_RHP_ANCHORS 30
   uint count = 0;
   CRSExtent e = zone.rhpExtent;
   Pointd dp[4] = { {e.tl.x, e.tl.y}, {e.tl.x, e.br.y}, {e.br.x, e.br.y}, {e.br.x, e.tl.y} };
   Radians maxDLon = -99999, urLon = -MAXDOUBLE;
   Radians minDLon =  99999, llLon =  MAXDOUBLE;
   GeoPoint centroid;
   int i;
   rHEALPixProjection pj = dggrs.pj;
   bool includesNorthPole = e.tl.y > Pi/2 && e.br.y < Pi/2 && e.tl.x < -3*Pi/4 && e.br.x > -3*Pi/4;
   bool includesSouthPole = e.tl.y > -Pi/2 && e.br.y < -Pi/2 && e.tl.x < -3*Pi/4 && e.br.x > -3*Pi/4;

   dggrs.getZoneWGS84Centroid(zone, centroid);

   for(i = 0; i < 4; i++)
   {
      const Pointd * p = &dp[i], * np = &dp[i == 3 ? 0 : i+1];
      int numAnchors = NUM_RHP_ANCHORS;
      int j;
      double dx = np->x - p->x, dy = np->y - p->y;

      for(j = 0; j < numAnchors; j++)
      {
         Pointd in { p->x + dx * j / numAnchors, p->y + dy * j / numAnchors };
         GeoPoint out;
         Pointd nin { p->x + dx * (j+1) / numAnchors, p->y + dy * (j+1) / numAnchors };
         int ps = pj.getPolarSection(in), nps = pj.getPolarSection(nin);
         bool crossingDateline = includesNorthPole ? (ps == 3 && nps == 0) : (ps == 0 && nps == 3);

         if(crossingDateline)
            nps = pj.getPolarSection(nin);

         if(pj.inverse(in, out, false))
         {
            Radians dLon = out.lon - centroid.lon;

            if(dLon > Pi) dLon -= 2*Pi, out.lon -= 2*Pi;
            if(dLon <-Pi) dLon += 2*Pi, out.lon += 2*Pi;

            if(dLon > maxDLon)
               maxDLon = dLon, urLon = out.lon;
            if(dLon < minDLon)
               minDLon = dLon, llLon = out.lon;

            outVertices[count++] = out;

            if(crossingDateline && includesSouthPole)
            {
               if(fabs((Radians)out.lon - -Pi) > 1E-9)
                  outVertices[count++] = { out.lat, -180 };
               outVertices[count++] = { -90, -180 };
               outVertices[count++] = { -90, 180 };
               if(fabs((Radians)out.lon - Pi) > 1E-9)
                  outVertices[count++] = { out.lat, 180 };
            }
            if(crossingDateline && includesNorthPole)
            {
               if(fabs((Radians)out.lon - Pi) > 1E-9)
                  outVertices[count++] = { out.lat, 180 };
               outVertices[count++] = { 90, 180 };
               outVertices[count++] = { 90, -180 };
               if(fabs((Radians)out.lon - -Pi) > 1E-9)
                  outVertices[count++] = { out.lat, -180 };
            }
         }
      }
   }

   if(fabs(llLon - -Pi) < 1E-9)
      urLon = Pi;
   if(fabs(urLon - Pi) < 1E-9)
      llLon = -Pi;

   for(i = 0; i < count; i++)
      if((Radians)outVertices[i].lon > (Radians)urLon + 1E-11)
         outVertices[i].lon -= 2*Pi;
      else if(outVertices[i].lon < (Radians)llLon - 1E-11)
         outVertices[i].lon += 2*Pi;
   return count;
}



================================================
FILE: src/dggrs/RI4R.ec
================================================
// This serves as a basis for aperture 4 rhombic grids
// using different projections based on the Rhombic Icosahedral 5x6 space
public import IMPORT_STATIC "ecrt"
private:

import "dggrs"
import "ri5x6"

#include <stdio.h>

define I4R_MAX_VERTICES = 200; // * 1024;

static define max4RLevel = 25;

public class RhombicIcosahedral4R : DGGRS
{
   bool equalArea;
   RI5x6Projection pj;

   uint64 countZones(int level)
   {
      return (uint64)(10 * (1LL << (level<<1)));
   }

   __attribute__ ((optimize("-fno-unsafe-math-optimizations")))
   double getZoneArea(I4RZone zoneID)
   {
      double area;
      if(equalArea)
      {
         double zoneCount = 10 * (1LL << (zoneID.level<<1));
         static double earthArea = 0;
         if(!earthArea) earthArea = wholeWorld.geodeticArea;

         area = earthArea / zoneCount;
      }
      else
         area = 0;

      return area;
   }

   int getMaxDGGRSZoneLevel() { return max4RLevel; }
   int getRefinementRatio() { return 4; }
   int getMaxParents() { return 1; }
   int getMaxNeighbors() { return 4; }
   int getMaxChildren() { return 4; }

   uint64 countSubZones(I4RZone zone, int depth)
   {
      return (uint64)(1LL << (depth << 1));
   }

   int getZoneLevel(I4RZone zone)
   {
      return zone.level;
   }

   int countZoneEdges(I4RZone zone) { return 4; }

   int getZoneParents(I4RZone zone, I4RZone * parents)
   {
      parents[0] = nullZone;
      if(zone.level > 0)
         parents[0] = zone.parent;
      return parents[0] != nullZone;
   }

   int getZoneChildren(I4RZone zone, I4RZone * children)
   {
      zone.getChildren(children);
      return 4;
   }

   int getZoneNeighbors(I4RZone zone, I4RZone * neighbors, int * nbType)
   {
      zone.getNeighbors(neighbors);
      if(nbType)
         nbType[0] = 0, nbType[1] = 1, nbType[2] = 2, nbType[3] = 3;
      return 4;
   }

   I4RZone getZoneFromWGS84Centroid(int level, const GeoPoint centroid)
   {
      if(level <= max4RLevel)
      {
         Pointd v;
         pj.forward(centroid, v);
         return I4RZone::fromCRSExtent(v, v, level);
      }
      return nullZone;
   }

   void getZoneWGS84Centroid(I4RZone zone, GeoPoint centroid)
   {
      pj.inverse(zone.centroid, centroid, false);
   }

   // Text ZIRS
   void getZoneTextID(I4RZone zone, String zoneID)
   {
      zone.getZoneID(zoneID);
   }

   DGGRSZone getZoneFromTextID(const String zoneID)
   {
      return I4RZone::fromZoneID(zoneID);
   }

   // Sub-zone Order
   I4RZone getFirstSubZone(I4RZone parent, int depth)
   {
      CRSExtent e = parent.ri5x6Extent;
      double dx, dy;
      double d = 2 * (1LL << depth);

      dx = (e.br.x - e.tl.x) / d, dy = (e.br.y - e.tl.y) / d;
      return I4RZone::fromCRSExtent(e.tl, { e.tl.x + dx, e.tl.y + dy }, parent.level + depth );
   }

   void compactZones(Array<DGGRSZone> zones)
   {
      int maxLevel = 0, i, count = zones.count;
      AVLTree<I4RZone> zonesTree { };

      for(i = 0; i < count; i++)
      {
         I4RZone zone = (I4RZone)zones[i];
         if(zone != nullZone)
         {
            int level = zone.level;
            if(level > maxLevel)
               maxLevel = level;
            zonesTree.Add(zone);
         }
      }

      compactI4RZones(zonesTree, maxLevel);
      zones.Free();

      count = zonesTree.count;
      zones.size = count;
      i = 0;
      for(z : zonesTree)
         zones[i++] = z;
      delete zonesTree;
   }

   Array<DGGRSZone> listZones(int level, const GeoExtent bbox)
   {
      uint64 p = (uint64)(1LL << level);
      uint64 numCols = 5*p, numRows = 6*p;
      AVLTree<I4RZone> zonesTree { };
      Array<I4RZone> zones { };
      Pointd tl, br;
      int row, col, y1, y2, x1, x2;
      bool extentCheck = true;

      if(bbox != null && bbox.OnCompare(wholeWorld))
      {
         // Avoid the possibility of including extra zones for single point boxes
         if(fabs((Radians)bbox.ur.lat - (Radians)bbox.ll.lat) < 1E-11 &&
            fabs((Radians)bbox.ur.lon - (Radians)bbox.ll.lon) < 1E-11)
         {
            DGGRSZone zone = getZoneFromWGS84Centroid(level, bbox.ll);
            if(zone != nullZone)
               zones = { [ (I4RZone)zone ] };
            return (Array<DGGRSZone>)zones;
         }

         pj.extent5x6FromWGS84(bbox, tl, br);
      }
      else
         extentCheck = false, pj.extent5x6FromWGS84(wholeWorld, tl, br);
      x1 = Min(Max(0, (int64)(tl.x * p)), numCols-1);
      y1 = Min(Max(0, (int64)(tl.y * p)), numRows-1);
      x2 = Min(Max(0, (int64)(br.x * p)), numCols-1);
      y2 = Min(Max(0, (int64)(br.y * p)), numRows-1);

      for(row = y1; row <= y2; row++)
      {
         for(col = x1; col <= x2; col++)
         {
            // Eliminate rows outside the ISEA staircase
            uint rowOP = (uint)(row / p), colOP = (uint)(col / p);
            int root = rowOP + colOP;
            int y = (int)(row - rowOP * p), x = (int)(col - colOP * p);
            uint64 ix = y * p + x;
            int rRow, rCol;
            if(iLRC4FromLRtI((char)('A' + level), root, ix, &rRow, &rCol) != -1 && row == rRow && col == rCol)
            {
               I4RZone zone { level, row, col };
               if(extentCheck)
               {
                  GeoExtent e;

                  getZoneWGS84Extent(zone, e);
                  if(!e.intersects(bbox))
                     continue;
               }
               zonesTree.Add(zone);
            }
         }
      }

      zones.minAllocSize = zonesTree.count;
      for(t : zonesTree)
         zones.Add(t);
      zones.minAllocSize = 0;
      if(!zones.count)
         delete zones;

      delete zonesTree;
      return (Array<DGGRSZone>)zones;
   }

   Array<GeoPoint> getSubZoneWGS84Centroids(I4RZone parent, int depth)
   {
      Array<GeoPoint> geo = null;
      Array<Pointd> centroids = parent.getSubZoneCentroids(depth);
      if(centroids)
      {
         uint count = centroids.count;
         int i;

         geo = { size = count };
         for(i = 0; i < count; i++)
            pj.inverse(centroids[i], geo[i], false);
         delete centroids;
      }
      return geo;
   }

   // edge refinement is not supported
   Array<GeoPoint> getZoneRefinedWGS84Vertices(I4RZone zone, int edgeRefinement)
   {
      GeoPoint v[I4R_MAX_VERTICES];
      int count = getI4RRefinedWGS84Vertices(this, zone, v);
      Array<GeoPoint> vertices { size = count };
      memcpy(vertices.array, v, sizeof(GeoPoint) * count);
      return vertices;
   }

   int getZoneWGS84Vertices(I4RZone zone, GeoPoint * vertices)
   {
      CRSExtent extent = zone.ri5x6Extent;
      Pointd v5x6[4] =
      {
         extent.tl,
         { extent.tl.x, extent.br.y },
         extent.br,
         { extent.br.x, extent.tl.y }
      };
      uint count = 4, i;
      for(i = 0; i < count; i++)
         pj.inverse(v5x6[i], vertices[i], false);
      return count;
   }

   void getZoneWGS84Extent(I4RZone zone, GeoExtent value)
   {
      int i;
      GeoPoint centroid;
      Radians minDLon = 99999, maxDLon = -99999;
      GeoPoint vertices[I4R_MAX_VERTICES];
      int nVertices = getI4RRefinedWGS84Vertices(this, zone, vertices);

      getZoneWGS84Centroid(zone, centroid);

      value.clear();
      for(i = 0; i < nVertices; i++)
      {
         GeoPoint p = vertices[i];
         Radians dLon = p.lon - centroid.lon;

         if(dLon > Pi) dLon -= 2* Pi;
         if(dLon < -Pi) dLon += 2* Pi;

         if(p.lat > value.ur.lat) value.ur.lat = p.lat;
         if(p.lat < value.ll.lat) value.ll.lat = p.lat;

         if(dLon > maxDLon)
            maxDLon = dLon, value.ur.lon = p.lon;
         if(dLon < minDLon)
            minDLon = dLon, value.ll.lon = p.lon;
      }
      if((Radians)value.ll.lon < -Pi)
         value.ll.lon += 2*Pi;
      if((Radians)value.ur.lon > Pi)
         value.ur.lon -= 2*Pi;
   }

   I4RZone getZoneFromCRSCentroid(int level, CRS crs, const Pointd centroid)
   {
      if(level <= max4RLevel)
      {
         switch(crs)
         {
            case 0: case CRS { ogc, 153456 }: return I4RZone::fromCRSExtent(centroid, centroid, level);
            case CRS { ogc, 1534 }:
            {
               Pointd c5x6;
               RI5x6Projection::fromIcosahedronNet(centroid, c5x6);
               return I4RZone::fromCRSExtent(c5x6, c5x6, level);
            }
            case CRS { epsg, 4326 }:
            case CRS { ogc, 84 }:
               return (I4RZone)getZoneFromWGS84Centroid(level,
                  crs == { ogc, 84 } ?
                     { centroid.y, centroid.x } :
                     { centroid.x, centroid.y });
         }
      }
      return nullZone;
   }

   void getZoneCRSCentroid(I4RZone zone, CRS crs, Pointd centroid)
   {
      switch(crs)
      {
         case CRS { ogc, 1534 }:
         {
            Pointd c5x6 = zone.centroid;
            RI5x6Projection::toIcosahedronNet(c5x6, centroid);
            break;
         }
         case 0: case CRS { ogc, 153456 }: centroid = zone.centroid; break;
         case CRS { epsg, 4326 }:
         case CRS { ogc, 84 }:
         {
            GeoPoint geo;

            getZoneWGS84Centroid(zone, geo);
            centroid = crs == { ogc, 84 } ?
               { geo.lon, geo.lat } :
               { geo.lat, geo.lon };
            break;
         }
      }
   }

   int getZoneCRSVertices(I4RZone zone, CRS crs, Pointd * vertices)
   {
      uint count = 0, i;
      CRSExtent extent = zone.ri5x6Extent;
      Pointd v[4] =
      {
         extent.tl,
         { extent.tl.x, extent.br.y },
         extent.br,
         { extent.br.x, extent.tl.y }
      };

      switch(crs)
      {
         case CRS { ogc, 153456 }: case 0:
            count = 4;
            memcpy(vertices, v, sizeof(Pointd) * 4);
            break;
         case CRS { ogc, 1534 }:
         {
            uint count = 4, i;
            CRSExtent extent = zone.ri5x6Extent;
            Pointd v[4] =
            {
               extent.tl,
               { extent.tl.x, extent.br.y },
               extent.br,
               { extent.br.x, extent.tl.y }
            };

            for(i = 0; i < count; i++)
               RI5x6Projection::toIcosahedronNet(v[i], vertices[i]);
            return count;
         }
         case CRS { ogc, 84 }:
         case CRS { epsg, 4326 }:
            count = 4;
            for(i = 0; i < count; i++)
            {
               GeoPoint geo;
               pj.inverse(v[i], geo, false);
               vertices[i] = crs == { ogc, 84 } ? { geo.lon, geo.lat } : { geo.lat, geo.lon };
            }
            break;
      }
      return count;
   }

   // No refinement needed in ISEA CRSs
   Array<Pointd> getZoneRefinedCRSVertices(I4RZone zone, CRS crs, int edgeRefinement)
   {
      switch(crs)
      {
         case CRS { ogc, 1534 }:
         {
            Array<Pointd> vertices { size = 4 };
            getZoneCRSVertices(zone, crs, vertices.array);
            return vertices;
         }
         case 0: case CRS { ogc, 153456 }:
         {
            Array<Pointd> vertices { size = 4 };
            getZoneCRSVertices(zone, crs, vertices.array);
            return vertices;
         }
         case CRS { ogc, 84 }: case CRS { epsg, 4326 }:
         {
            GeoPoint v[I4R_MAX_VERTICES];
            int count = getI4RRefinedWGS84Vertices(this, zone, v), i;
            Array<Pointd> vertices { size = count };
            for(i = 0; i < count; i++)
               vertices[i] = crs == { ogc, 84 } ? { v[i].lat, v[i].lon } : { v[i].lon, v[i].lat };
            return vertices;
         }
      }
      return null;
   }

   void getZoneCRSExtent(I4RZone zone, CRS crs, CRSExtent extent)
   {
      switch(crs)
      {
         case 0: case CRS { ogc, 153456 }: extent = zone.ri5x6Extent; break;
         case CRS { ogc, 1534 }:
            getIcoNetExtentFromVertices(/*this, */zone, extent);
            break;
         case CRS { epsg, 4326 }:
         case CRS { ogc, 84 }:
         {
            GeoExtent geo;
            getZoneWGS84Extent(zone, geo);
            extent.crs = crs;
            if(crs == { ogc, 84 })
            {
               extent.tl = { geo.ll.lon, geo.ur.lat };
               extent.br = { geo.ur.lon, geo.ll.lat };
            }
            else
            {
               extent.tl = { geo.ur.lat, geo.ll.lon };
               extent.br = { geo.ll.lat, geo.ur.lon };
            }
            break;
         }
      }
   }

   Array<Pointd> getSubZoneCRSCentroids(I4RZone parent, CRS crs, int depth)
   {
      Array<Pointd> centroids = parent.getSubZoneCentroids(depth);
      if(centroids)
      {
         uint count = centroids.count, i;
         switch(crs)
         {
            case CRS { ogc, 1534 }:
               for(i = 0; i < count; i++)
                  RI5x6Projection::toIcosahedronNet(centroids[i], centroids[i]);
               break;
            case CRS { ogc, 153456 }: case 0: break;
            case CRS { epsg, 4326 }:
            case CRS { ogc, 84 }:
               for(i = 0; i < count; i++)
               {
                  GeoPoint geo;
                  pj.inverse(centroids[i], geo, false);
                  centroids[i] = crs == { ogc, 84 } ? { geo.lon, geo.lat } : { geo.lat, geo.lon };
               }
               break;
            default: delete centroids;
         }
      }
      return centroids;
   }
}

// public for use in tests
public class I4RZone : private DGGRSZone
{
public:
   uint level:5:59, row:29:30, col:30:0;

private:
   property I4RZone parent
   {
      get
      {
         int l = level;
         return (l > 0) ? I4RZone { l - 1, row / 2, col / 2 } : nullZone;
      }
   }

   Array<Pointd> getSubZoneCentroids(int rDepth)
   {
      uint64 s = (int64)(1LL << rDepth), nSubZones = s * s;
      if(nSubZones < 1LL<<31)
      {
         Array<Pointd> centroids { size = (uint)nSubZones };
         int i = 0, y, x;
         CRSExtent e = ri5x6Extent;
         double dx = (e.br.x - e.tl.x) / s, dy = (e.br.y - e.tl.y) / s;

         for(y = 0; y < s; y++)
         {
            double yy = e.tl.y + (y + 0.5) * dy;
            for(x = 0; x < s; x++, i++)
            {
               centroids[i].x = e.tl.x + (x + 0.5) * dx;
               centroids[i].y = yy;
            }
         }
         return centroids;
      }
      return null;
   }

   property CRSExtent ri5x6Extent
   {
      get
      {
         double z = 1.0 / (1LL << level);
         value.tl = { col * z, row * z };
         value.br = { value.tl.x + z, value.tl.y + z };
         value.crs = { ogc, 153456 };
      }
   }

   property Pointd centroid
   {
      get
      {
         double z = 1.0 / (1LL << level);
         value = { (col + 0.5) * z, (row + 0.5) * z };
      }
   }

   // This function generates the proposed ISEA9R DGGS Zone ID string
   // in the form {LevelChar}{RootRhombus}-{HexIndexWithinRootRhombus}
   // from an ISEA9R TileMatrixSet Level, Row, Column
   void getZoneID(String zoneID)
   {
      if(this == nullZone)
         strcpy(zoneID,"(null)");
      else
      {
         int level = this.level;
         uint row = this.row, col = this.col;
         uint64 p = (uint64)(1LL << level);
         uint rowOP = (uint)(row / p), colOP = (uint)(col / p);
         int root = rowOP + colOP;
         int y = (int)(row - rowOP * p), x = (int)(col - colOP * p);
         uint64 ix = y * p + x;
         sprintf(zoneID,
            __runtimePlatform == win32 ? "%c%d-%I64X" : "%c%d-%llX",
            'A' + level, root, ix);
      }
   }

   I4RZone ::fromCRSExtent(const Pointd topLeft, const Pointd bottomRight, int level)
   {
      uint64 p = (uint64)(1LL << level);
      int64 numRows = 6 * p, numCols = 5 * p;
      Pointd mid
      {
         (topLeft.x + bottomRight.x) / 2,
         (topLeft.y + bottomRight.y) / 2
      };
      int row = Min(Max(0, (int)(mid.y * p)), numRows-1);
      int col = Min(Max(0, (int)(mid.x * p)), numCols-1);
      // WARNING: Cannot return negative level in DGGRSZone
      return I4RZone { Max(0, level), row, col };
   }

   I4RZone ::fromZoneID(const String zoneID)
   {
      I4RZone result = nullZone;
      char levelChar;
      uint root;
      uint64 ix;
      int row, col, l4r = -1;

      if(sscanf(zoneID, __runtimePlatform == win32 ? "%c%d-%I64X" : "%c%d-%llX", &levelChar, &root, &ix) == 3)
      {
         l4r = iLRC4FromLRtI(levelChar, root, ix, &row, &col);
         if(l4r != -1)
         {
            char id[256];
            result = { l4r, row, col };
            result.getZoneID(id);
            // Further validation (ISEA3H zones still validated as ISEA9R)
            if(strcmp(id, zoneID))
               result = nullZone;
         }
      }
      return result;
   }

   void getChildren(I4RZone children[4])
   {
      uint l = level+1;
      uint row1 = row * 2;
      uint col1 = col * 2;
      int x, y;

      for(y = 0; y < 2; y++)
         for(x = 0; x < 2; x++)
         {
            I4RZone key = I4RZone { l, row1 + y, col1 + x};
#if 0
            if(key.lat != row1 + y)
               Print("Ybug");
            if(key.lon != col1 + x)
               Print("Xbug");
#endif
            children[y * 2 + x] = key;
         }
   }

   void getNeighbors(I4RZone neighbors[4])
   {
      uint l = level;
      int row = this.row, col = this.col;
      int p = (int)(1LL << l);
      uint numRows = 6 * p, numCols = 5 * p;
      int colOP = col / p, rowOP = row / p;
      int topDelta = (row - 1) / p - colOP;
      int leftDelta = rowOP - (col - 1) / p;
      int bottomDelta = (row + 1) / p - colOP;
      int rightDelta = rowOP - (col + 1) / p;

      // Top
      if(row == 0 || (topDelta && topDelta != 1))
      {
         // Crossing over top interruption to the left
         int r = (rowOP ? rowOP - 1 : 4) * p + p - 1 - (col - colOP * p);
         int c = (rowOP ? colOP - 1 : 4) * p + p - 1;
         neighbors[0] = I4RZone { l, r, c };
      }
      else
         neighbors[0] = I4RZone { l, row - 1, col };

      // Left
      if(col == 0 || (leftDelta && leftDelta != 1))
      {
         int r, c;
         if((leftDelta && leftDelta != 1) || (col == 0 && rowOP > colOP))
         {
            // Crossing over bottom interruption to the left
            r = (colOP ? rowOP - 1 : 5) * p + p - 1;
            c = (colOP ? colOP - 1 : 4) * p + p - 1 - (row - rowOP * p);
         }
         else
         {
            // Wrapping to the left
            r = row + 5 * p;
            c = col - 1 + 5 * p;
         }
         neighbors[1] = I4RZone { l, r, c };
      }
      else
         neighbors[1] = I4RZone { l, row, col - 1 };

      // Right
      if(col == numCols-1 || (rightDelta && rightDelta != 1))
      {
         int r, c;
         if((rightDelta && rightDelta != 1) || (col == numCols-1 && rowOP == colOP))
         {
            // Crossing over top interruption to the right
            r = (colOP < 4 ? rowOP + 1 : 0) * p + 0;
            c = (colOP < 4 ? colOP + 1 : 0) * p + p - 1 - (row - rowOP * p);
         }
         else
         {
            // Wrapping to the right
            r = row - 5 * p;
            c = col + 1 - 5 * p;
         }
         neighbors[2] = I4RZone { l, r, c };
      }
      else
         neighbors[2] = I4RZone { l, row, col + 1 };

      // Bottom
      if(row == numRows-1 || (bottomDelta && bottomDelta != 1))
      {
         // Crossing over bottom interruption to the right
         int r = (rowOP < 5 ? rowOP + 1 : 1) * p + p - 1 - (col - colOP * p);
         int c = (rowOP < 5 ? colOP + 1 : 0) * p + 0;
         neighbors[3] = I4RZone { l, r, c };
      }
      else
         neighbors[3] = I4RZone { l, row + 1, col };
   }
}


// This function returns an I4R TileMatrixSet Level, Row, Column
// from the LevelChar, RootDiamond and IndexWithinRootDiamond components
// of the proposed I4R DGGRS Zone ID string
int iLRC4FromLRtI(char levelChar, int root, uint64 ix, int * row, int * col)
{
   int level = levelChar - 'A';
   if(level >= 0 && level <= max4RLevel && root >= 0 && root <= 9)
   {
      uint64 p = (uint64)(1LL << level);
      if(ix >= 0 && ix < p * p)
      {
         int rowOP = (root + 1) >> 1, colOP = root >> 1;
         int ixOP = (int)(ix / p);
         *row = (int)(rowOP * p + ixOP);
         *col = (int)((colOP - ixOP) * p + ix); // distributivity on: ix - (ixOP * p) for (ix % p)
         return level;
      }
   }
   *row = -1, *col = -1;
   return -1;
}

static void compactI4RZones(AVLTree<I4RZone> zones, int level)
{
   AVLTree<I4RZone> output { };
   AVLTree<I4RZone> next { };
   int l;

   for(l = level - 1; l >= 0; l--)
   {
      int i;
      for(z : zones)
      {
         I4RZone zone = z, parent = zone.parent;
         if(!next.Find(parent))
         {
            bool parentAllIn = true;
            I4RZone children[4];

            parent.getChildren(children);

            for(i = 0; i < 4; i++)
            {
               I4RZone ch = children[i];
               if(ch != nullZone && !zones.Find(ch))
               {
                  parentAllIn = false;
                  break;
               }
            }

            if(parentAllIn)
               next.Add(parent);
            else
               output.Add(zone);
         }
      }

      if(l - 1 >= 0 && next.count)
      {
         // Not done -- next level becomes zones to compact
         zones.copySrc = next;
         next.Free();
      }
      else
      {
         // Done -- next is combined with output into final zones
         zones.copySrc = output;
         for(z : next)
            zones.Add(z);
         //break;
      }
   }

   delete output;
   delete next;
}

   // NOTE: custom edgeRefinement not currently supported
static uint getI4RRefinedWGS84Vertices(RhombicIcosahedral4R dggrs, I4RZone zone, GeoPoint * outVertices)
{
   #define NUM_ISEA4R_ANCHORS 30
   uint count = 0;
   CRSExtent e = zone.ri5x6Extent;
   Pointd dp[4] = { {e.tl.x, e.tl.y}, {e.tl.x, e.br.y}, {e.br.x, e.br.y}, {e.br.x, e.tl.y} };
   GeoPoint centroid;
   int i;
   RI5x6Projection pj = dggrs.pj;
   double poleOffset = 0.001 * (1LL << zone.level);

   dggrs.getZoneWGS84Centroid(zone, centroid);

   // REVIEW: Should centroid ever be outside -Pi..Pi?
   if(centroid.lon < - Pi - 1E-9)
      centroid.lon += 2*Pi;
   if(centroid.lon > Pi + 1E-9)
      centroid.lon -= 2*Pi;

   for(i = 0; i < 4; i++)
   {
      const Pointd * p = &dp[i], * np = &dp[i == 3 ? 0 : i+1];
      const Pointd * pp = &dp[i == 0 ? 3 : i-1];
      int numAnchors = NUM_ISEA4R_ANCHORS;
      int j;
      double dx = np->x - p->x, dy = np->y - p->y;

      for(j = 0; j < numAnchors; j++)
      {
         Pointd in { p->x + dx * j / numAnchors, p->y + dy * j / numAnchors };
         GeoPoint out;

         if(pj.inverse(in, out, false))
         {
            if(fabs((double)out.lat) > 89.999999)
            {
               double ddx1 = j ? -dx : pp->x - p->x;
               double ddy1 = j ? -dy : pp->y - p->y;
               double ddx2 =  dx, ddy2 =  dy;
               Pointd in1 { in.x + ddx1 * poleOffset, in.y + ddy1 * poleOffset };
               Pointd in2 { in.x + ddx2 * poleOffset, in.y + ddy2 * poleOffset };
               GeoPoint out1, out2;
               if(pj.inverse(in1, out1, true))
                  outVertices[count++] = { Sgn(out1.lat) * 90, out1.lon };
               if(pj.inverse(in2, out2, true))
                  outVertices[count++] = { Sgn(out2.lat) * 90, out2.lon };
            }
            else
               outVertices[count++] = out;
         }
      }
   }

   for(i = 0; i < count; i++)
   {
      GeoPoint * point = &outVertices[i];
      point->lon = wrapLonAt(-1, point->lon, centroid.lon - Degrees { 0.05 }) + centroid.lon - Degrees { 0.05 }; // REVIEW: wrapLonAt() doesn't add back centroid.lon ?
   }
   return count;
}

static void getIcoNetExtentFromVertices(I4RZone zone, CRSExtent value)
{
   CRSExtent k = zone.ri5x6Extent;
   Pointd p[4];

   RI5x6Projection::toIcosahedronNet({k.tl.x, k.tl.y }, p[0]);
   RI5x6Projection::toIcosahedronNet({k.tl.x, k.br.y }, p[1]);
   RI5x6Projection::toIcosahedronNet({k.br.x, k.br.y }, p[2]);
   RI5x6Projection::toIcosahedronNet({k.br.x, k.tl.y }, p[3]);
   value.crs = { ogc, 1534 };
   value.tl.x = Min(Min(p[0].x, p[1].x), Min(p[2].x, p[3].x));
   value.tl.y = Max(Max(p[0].y, p[1].y), Max(p[2].y, p[3].y));
   value.br.x = Max(Max(p[0].x, p[1].x), Max(p[2].x, p[3].x));
   value.br.y = Min(Min(p[0].y, p[1].y), Min(p[2].y, p[3].y));
}

/*
static void getIcoNetExtentFromVertices(I4RZone zone, CRS crs, CRSExtent value)
{
   int i;
   Array<Pointd> vertices = dggrs.getZoneRefinedCRSVertices(zone, crs, 0); //, false);
   int nVertices = vertices ? vertices.count : 0;

   value.crs = crs;
   value.tl.x = MAXDOUBLE, value.tl.y = -MAXDOUBLE;
   value.br.x = -MAXDOUBLE, value.br.y = MAXDOUBLE;
   for(i = 0; i < nVertices; i++)
   {
      const Pointd * v = &vertices[i];
      double x = v->x, y = v->y;

      if(y < value.br.y) value.br.y = y;
      if(y > value.tl.y) value.tl.y = y;
      if(x > value.br.x) value.br.x = x;
      if(x < value.tl.x) value.tl.x = x;
   }
   delete vertices;
}
*/



================================================
FILE: src/dggrs/RI7H_Z7.ec
================================================
public import IMPORT_STATIC "ecrt"
private:

#include <stdio.h>

import "RI7H"

static const int cMap   [7] = { 0, 3, 1, 5, 4, 6, 2 };
static const int invCMap[7] = { 0, 2, 6, 1, 4, 3, 5 };
static const int rootMap   [12] = { 1, 6, 2, 7, 3, 8, 4, 9, 5, 10, 0, 11 };
static const int invRootMap[12] = { 10, 0, 2, 4, 6, 8, 1, 3, 5, 7, 9, 11 };

public class Z7Zone : private DGGRSZone
{
public:
   uint rootPentagon:4:60;
   uint64 ancestry:60:0;

   int OnCompare(Z7Zone b)
   {
      if(this == b)
         return 0;
      else
      {
         uint l = this.level, bl = b.level;
         if(l < bl) return -1;
         else if(l > bl) return 1;
         else return this < b ? -1 : 1;
      }
   }

private:
   property int level
   {
      get
      {
         if(this == nullZone)
            return -1;
         else
         {
            uint64 ancestry = this.ancestry;
            int shift = 19 * 3;
            int l;
            int level = 0;

            for(l = 0; l < 20; l++, shift -= 3)
            {
               int b = (int)((ancestry & (7LL << shift)) >> shift);
               if(b == 7)
                  break;
               level++;
            }
            return level;
         }
      }
   }

   property Z7Zone centroidChild
   {
      get
      {
         if(this == nullZone || (ancestry & 7) != 7)
            return nullZone;
         else
         {
            uint64 ancestry = this.ancestry;
            int shift = 19 * 3;
            int l;

            for(l = 0; l < 20; l++, shift -= 3)
            {
               int b = (int)((ancestry & (7LL << shift)) >> shift);
               if(b == 7)
                  break;
            }
            return { rootPentagon, ancestry & ~(7LL << shift) };
         }
      }
   }

   property bool isCentroidChild
   {
      get
      {
         if(this == nullZone)
            return false;
         else
         {
            uint64 ancestry = this.ancestry;
            int shift = 19 * 3;
            int l, lastB = 7;

            for(l = 0; l < 20; l++, shift -= 3)
            {
               int b = (int)((ancestry & (7LL << shift)) >> shift);
               if(b == 7)
                  break;
               lastB = b;
            }
            return lastB == 0;
         }
      }
   }

   property int nPoints
   {
      get
      {
         if(this == nullZone)
            return 0;
         else
         {
            uint64 ancestry = this.ancestry;
            int shift = 19 * 3;
            int l;
            int nPoints = 5;

            for(l = 0; l < 20; l++, shift -= 3)
            {
               int b = (int)((ancestry & (7LL << shift)) >> shift);
               if(b == 7)
                  break;
               if(b != 0)
               {
                  nPoints = 6;
                  break;
               }
            }
            return nPoints;
         }
      }
   }

   private static int ::getChildPosition(I7HZone parent, I7HZone zone)
   {
      if(zone.level & 1)
         return zone.subHex - 1;
      else
      {
         I7HZone children[7];
         int nc = parent.getPrimaryChildren(children), i;

         for(i = 0; i < nc; i++)
            if(children[i] == zone)
               break;
         return i;
      }
   }

   private static int ::adjustZ7PentagonChildPosition(int i, int level, int pRoot)
   {
      if(i)
      {
         bool southPRhombus = pRoot & 1;
         bool oddLevel = level & 1;

         if(pRoot == 10) // North polar pentagons
            i = ((i + 1) % 5) + 1;
         else if(pRoot == 11) // South polar pentagons
            i = ((i + (oddLevel ? 3 : 4)) % 5) + 1;
         else if(!oddLevel && !southPRhombus) // Parent is an odd level northern non-polar pentagon
            i = ((i + 5) % 5) + 1;
         if(southPRhombus && i >= 3)
            i++;
      }
      return i;
   }

   private static int ::deadjustZ7PentagonChildPosition(int i, int level, int pRoot)
   {
      if(i)
      {
         bool southPRhombus = pRoot & 1;
         bool oddLevel = level & 1;

         if(southPRhombus && i >= 4)
            i--;

         if(pRoot == 10) // North polar pentagons
            i = ((i - 1 + 3) % 5) + 1;
         else if(pRoot == 11) // South polar pentagons
            i = ((i - 1 + (oddLevel ? 1 : 5)) % 5) + 1;
         else if(!oddLevel && !southPRhombus) // Parent is an odd level northern non-polar pentagon
            i = ((i - 1 + 4) % 5) + 1;
      }
      return i;
   }

   public int ::getParentRotationOffset(I7HZone zone)
   {
      I7HZone parents[19];
      computeParents(zone, parents);
      return getParentRotationOffsetInternal(zone, parents);
   }

   private static inline int ::getLevelRotationOffset(int l, int i, I7HZone zone, I7HZone parent, I7HZone grandParent)
   {
      int offset = 0;

      if(i == -1)
         i = getChildPosition(parent, zone);
      if(i)
      {
         uint pRoot = parent.rootRhombus;
         uint pnPoints = parent.nPoints;
         bool oddLevel = l & 1;
         bool southPRhombus = pRoot & 1;
         bool isEdgeHex = !oddLevel && zone.isEdgeHex;
         bool pEdgeHex = oddLevel && parent.isEdgeHex;
         bool gpEdgeHex = !oddLevel && grandParent.isEdgeHex;

         if(pnPoints == 5)
            i = adjustZ7PentagonChildPosition(i, l, pRoot);

         if(pRoot >= 10)
         {
            if(pnPoints == 5)
               offset += i + (oddLevel ? (southPRhombus ? 0 : 3) : (southPRhombus ? 5 : 2));
            else if(isEdgeHex && (!southPRhombus || zone != parent.centroidChild))
               offset += 5;
         }

         if(southPRhombus && isEdgeHex)
            offset++;
         if(pEdgeHex)
         {
            // This rule is necessary starting from Level 4
            if(!southPRhombus && i >= 4)
               offset++;
            else if(southPRhombus && (i == 0 || (i >= 3 && i <= 5)))
               offset += 5;
         }
         else if(gpEdgeHex)
         {
            I7HZone c[7], pc[7];
            grandParent.getPrimaryChildren(pc);
            parent.getPrimaryChildren(c);
            if(southPRhombus ?
               pc[1] == parent && c[2].rootRhombus != c[5].rootRhombus && (i == 4 || i == 5) :
               pc[4] == parent && (i == 1 || i == 2)) // Root rhombuses are the same for northern case
               offset += 5;

            if(parent == grandParent.centroidChild)
            {
               if(southPRhombus)
               {
                  if(i > 2)
                     offset += 5;
               }
               else
               {
                  if(i == 5 || i == 6)
                     offset++;
               }
            }
            if(southPRhombus && isEdgeHex)
            {
               if(i == 4 || i == 5)
                  offset += 5;
            }
         }
      }
      return offset;
   }

   private static int ::getParentRotationOffsetInternal(I7HZone zone, const I7HZone * parents)
   {
      int offset = 0;
      int level = zone.level, l = level;
      int pIndex = 0;
      I7HZone parent = l > 0 ? parents[pIndex] : nullZone;

      while(l > 0)
      {
         I7HZone grandParent = l > 1 ? parents[pIndex + 1] : nullZone;
         offset += getLevelRotationOffset(l, -1, zone, parent, grandParent);
         offset %= 6;
         zone = parent;
         parent = grandParent;
         pIndex++;
         l--;
      }
      return offset;
   }

   private static int ::computeParents(I7HZone zone, I7HZone parents[19])
   {
      int level = zone.level, l = level, pIndex = 0;
      while(l > 0)
      {
         parents[pIndex] = (l == level ? zone : parents[pIndex-1]).parent0;
         pIndex++;
         l--;
      }
      return pIndex;
   }

   public I7HZone to7H()
   {
      I7HZone zone = nullZone;
      if(this != nullZone && rootPentagon < 12)
      {
         int level;
         I7HZone parents[19];
         int offset = 0;
         uint64 ancestry = this.ancestry;
         int shift = 19 * 3;
         int prevCIX = 0;

         if((this & 7) != 7)
            return nullZone; // I7HZone are only valid up to level 19

         zone = { 0, invRootMap[rootPentagon], 0, 0 };

         for(level = 0; level < 20; level++, shift -= 3)
         {
            int pStart = 18 - level;
            int nPoints = zone.nPoints;
            int b = (int)((ancestry & (7LL << shift)) >> shift);

            parents[pStart] = zone;

            if(b == 7)
               break;
            else
            {
               int cix = invCMap[b];

               if(cix || level < 19)
                  offset = (offset + getLevelRotationOffset(level, prevCIX,
                     zone,
                     level > 0 ? parents[pStart + 1] : nullZone,
                     level > 1 ? parents[pStart + 2] : nullZone)
                     ) % 6;
               if(cix)
               {
                  cix = cix - 1 - offset;
                  if(cix < 0)
                     cix += 6;
                  cix++;
                  if(nPoints == 5)
                     cix = deadjustZ7PentagonChildPosition(cix, level + 1, zone.rootRhombus);
               }
               prevCIX = cix;

               if(!(level & 1))
                  zone = { zone.levelI49R, zone.rootRhombus, zone.rhombusIX, 1 + cix };
               else if(level == 19)
               {
                  // 7H does not support level 20 zones
                  zone = nullZone;
                  break;
               }
               else
               {
                  I7HZone children[7];
                  int n = zone.getPrimaryChildren(children);
                  if(cix < n)
                     zone = children[cix];
                  else
                  {
                     zone = nullZone;
                     break;
                  }
               }
            }
         }
      }
      return zone;
   }

   public Z7Zone ::from7H(I7HZone zone)
   {
      Z7Zone result = nullZone;
      if(zone != nullZone)
      {
         int level = zone.level;
         I7HZone parents[19];
         uint64 ancestry = 0;
         int shift, pIndex, l;
         int offset = 0;
         int prevI = 0;

         if(level > 19) return nullZone; // This should never happen

         computeParents(zone, parents);
         for(l = 1, pIndex = level-1, shift = 3 * 19; l <= level; l++, pIndex--, shift -= 3)
         {
            I7HZone z = l == level ? zone : parents[pIndex - 1];
            I7HZone parent = parents[pIndex];
            I7HZone grandParent = l > 1 ? parents[pIndex + 1] : nullZone;
            int i = getChildPosition(parent, z);

            offset = (offset + getLevelRotationOffset(l-1, prevI, parent, grandParent, l > 2 ? parents[pIndex + 2] : nullZone)) % 6;
            prevI = i;

            if(i)
            {
               //int fullOffset = getParentRotationOffsetInternal(parent, parents + pIndex + 1);
               if(parent.nPoints == 5)
                  i = adjustZ7PentagonChildPosition(i, l, parent.rootRhombus);
               i = ((i - 1) + offset) % 6 + 1;
            }

            ancestry |= ((int64)cMap[i] << shift);
         }
         while(shift >= 0)
         {
            ancestry |= ((int64)7LL << shift);
            shift -= 3;
         }
         result.rootPentagon = rootMap[(level == 0 ? zone : parents[level-1]).rootRhombus];
         result.ancestry = ancestry;
      }
      return result;
   }

   public Z7Zone ::fromTextID(const String zoneID)
   {
      Z7Zone zone = nullZone;

      int len = zoneID ? strlen(zoneID) : 0;
      if(len >= 2 && len <= 22)
      {
         int root;
         int r = sscanf(zoneID, "%2d", &root);

         if(r && root >= 0 && root <= 11)
         {
            bool parentIsPentagon = true, south = root >= 6;
            int i;
            uint64 ancestry = 0;
            int shift = 3 * 19;
            zone = { root };
            for(i = 2; i < len; i++)
            {
               char c = zoneID[i];
               if((c < '0' || c > '6') || (parentIsPentagon && c == (south ? '5' : '2')))
               {
                  zone = nullZone;
                  break;
               }
               else
                  ancestry |= (uint64)(c - '0') << shift;
               shift -= 3;
               if(c != '0')
                  parentIsPentagon = false;
            }
            while(shift >= 0)
            {
               ancestry |= ((int64)7LL << shift);
               shift -= 3;
            }
            if(zone != nullZone)
               zone.ancestry = ancestry;
         }
      }
      return zone;
   }

   public void getTextID(String zoneID)
   {
      if(this == nullZone)
         strcpy(zoneID, "(null)");
      else
      {
         uint64 ancestry = this.ancestry;
         int shift = 19 * 3;
         int l;

         sprintf(zoneID, "%02d", rootPentagon);

         for(l = 0; l < 20; l++, shift -= 3)
         {
            int b = (int)((ancestry & (7LL << shift)) >> shift);
            if(b == 7)
               break;
            zoneID[2 + l] = (byte)('0' + b);
         }
         zoneID[2 + l] = 0;
      }
   }
}

static define POW_EPSILON = 0.1;

#define POW7(x) ((x) < sizeof(powersOf7) / sizeof(powersOf7[0]) ? (uint64)powersOf7[x] : (uint64)(pow(7, x) + POW_EPSILON))

// This DGGRS base class uses Z7Zone natively for DGGRSZone, at the cost of some performance impact
public class RI7H_Z7 : RhombicIcosahedral7H
{
   uint64 countSubZones(Z7Zone zone, int rDepth)
   {
      if(rDepth > 0)
      {
         int64 nHexSubZones = POW7(rDepth) + ((rDepth & 1) ? 5 * POW7((rDepth-1)/2) + 1 : POW7(rDepth/2) - 1);
         return (nHexSubZones * zone.nPoints + 5) / 6;
      }
      return 1;
   }

   int getZoneLevel(Z7Zone zone)
   {
      return zone.level;
   }

   int countZoneEdges(Z7Zone zone) { return zone.nPoints; }

   bool isZoneCentroidChild(Z7Zone zone)
   {
      return zone.isCentroidChild;
   }

   double getZoneArea(Z7Zone zone)
   {
      double area = 0;
      if(equalArea)
      {
         uint64 zoneCount = countZones(zone.level);
         static double earthArea = 0;
         if(!earthArea) earthArea = wholeWorld.geodeticArea;
         area = earthArea / (zoneCount - 2) * (zone.nPoints == 5 ? 5/6.0 : 1);
      }
      return area;
   }

   Z7Zone getZoneFromCRSCentroid(int level, CRS crs, const Pointd centroid)
   {
      return Z7Zone::from7H((I7HZone)RhombicIcosahedral7H::getZoneFromCRSCentroid(level, crs, centroid));
   }

   int getZoneNeighbors(Z7Zone zone, Z7Zone * neighbors, I7HNeighbor * nbType)
   {
      int n = RhombicIcosahedral7H::getZoneNeighbors(zone.to7H(), neighbors, nbType), i;
      for(i = 0; i < n; i++)
         neighbors[i] = Z7Zone::from7H((I7HZone)neighbors[i]);
      return n;
   }

   Z7Zone getZoneCentroidParent(Z7Zone zone)
   {
      return Z7Zone::from7H((I7HZone)RhombicIcosahedral7H::getZoneCentroidParent(zone.to7H()));
   }

   Z7Zone getZoneCentroidChild(Z7Zone zone)
   {
      return zone.centroidChild;
   }

   int getZoneParents(Z7Zone zone, Z7Zone * parents)
   {
      int n = RhombicIcosahedral7H::getZoneParents(zone.to7H(), parents), i;
      for(i = 0; i < n; i++)
         parents[i] = Z7Zone::from7H((I7HZone)parents[i]);
      return n;
   }

   int getZoneChildren(Z7Zone zone, Z7Zone * children)
   {
      int n = RhombicIcosahedral7H::getZoneChildren(zone.to7H(), children), i;
      for(i = 0; i < n; i++)
         children[i] = Z7Zone::from7H((I7HZone)children[i]);
      return n;
   }

   void getZoneTextID(Z7Zone zone, String zoneID)
   {
      zone.getTextID(zoneID);
   }

   Z7Zone getZoneFromTextID(const String zoneID)
   {
      return Z7Zone::fromTextID(zoneID);
   }

   Z7Zone getFirstSubZone(Z7Zone zone, int depth)
   {
      return Z7Zone::from7H((I7HZone)RhombicIcosahedral7H::getFirstSubZone(zone.to7H(), depth));
   }

   void compactZones(Array<DGGRSZone> zones)
   {
      if(zones)
      {
         int i, count = zones.count;

         for(i = 0; i < count; i++)
            zones[i] = ((Z7Zone)zones[i]).to7H();

         RhombicIcosahedral7H::compactZones(zones);

         count = zones.count;

         for(i = 0; i < count; i++)
            zones[i] = Z7Zone::from7H((I7HZone)zones[i]);
      }
   }

   int64 getSubZoneIndex(Z7Zone parent, Z7Zone subZone)
   {
      return RhombicIcosahedral7H::getSubZoneIndex(parent.to7H(), subZone.to7H());
   }

   Z7Zone getSubZoneAtIndex(Z7Zone parent, int relativeDepth, int64 index)
   {
      return Z7Zone::from7H((I7HZone)RhombicIcosahedral7H::getSubZoneAtIndex(parent.to7H(), relativeDepth, index));
   }

   bool zoneHasSubZone(Z7Zone hayStack, Z7Zone needle)
   {
      return RhombicIcosahedral7H::zoneHasSubZone(hayStack.to7H(), needle.to7H());
   }

   Z7Zone getZoneFromWGS84Centroid(int level, const GeoPoint centroid)
   {
      return Z7Zone::from7H((I7HZone)RhombicIcosahedral7H::getZoneFromWGS84Centroid(level, centroid));
   }

   void getZoneCRSCentroid(Z7Zone zone, CRS crs, Pointd centroid)
   {
      RhombicIcosahedral7H::getZoneCRSCentroid(zone.to7H(), crs, centroid);
   }

   void getZoneWGS84Centroid(Z7Zone zone, GeoPoint centroid)
   {
      RhombicIcosahedral7H::getZoneWGS84Centroid(zone.to7H(), centroid);
   }

   void getZoneCRSExtent(Z7Zone zone, CRS crs, CRSExtent extent)
   {
      RhombicIcosahedral7H::getZoneCRSExtent(zone.to7H(), crs, extent);
   }

   void getZoneWGS84Extent(Z7Zone zone, GeoExtent extent)
   {
      RhombicIcosahedral7H::getZoneWGS84Extent(zone.to7H(), extent);
   }

   int getZoneCRSVertices(Z7Zone zone, CRS crs, Pointd * vertices)
   {
      return RhombicIcosahedral7H::getZoneCRSVertices(zone.to7H(), crs, vertices);
   }

   int getZoneWGS84Vertices(Z7Zone zone, GeoPoint * vertices)
   {
      return RhombicIcosahedral7H::getZoneWGS84Vertices(zone.to7H(), vertices);
   }

   Array<Pointd> getZoneRefinedCRSVertices(Z7Zone zone, CRS crs, int edgeRefinement)
   {
      return RhombicIcosahedral7H::getZoneRefinedCRSVertices(zone.to7H(), crs, edgeRefinement);
   }

   Array<GeoPoint> getZoneRefinedWGS84Vertices(Z7Zone zone, int edgeRefinement)
   {
      return RhombicIcosahedral7H::getZoneRefinedWGS84Vertices(zone.to7H(), edgeRefinement);
   }

   void getApproxWGS84Extent(Z7Zone zone, GeoExtent extent)
   {
      return RhombicIcosahedral7H::getApproxWGS84Extent(zone.to7H(), extent);
   }

   Array<Pointd> getSubZoneCRSCentroids(Z7Zone parent, CRS crs, int depth)
   {
      return RhombicIcosahedral7H::getSubZoneCRSCentroids(parent.to7H(), crs, depth);
   }

   Array<GeoPoint> getSubZoneWGS84Centroids(Z7Zone parent, int depth)
   {
      return RhombicIcosahedral7H::getSubZoneWGS84Centroids(parent.to7H(), depth);
   }

   static Array<DGGRSZone> listZones(int zoneLevel, const GeoExtent bbox)
   {
      Array<DGGRSZone> zones = RhombicIcosahedral7H::listZones(zoneLevel, bbox);
      if(zones)
      {
         Array<Z7Zone> z7Zones { size = zones.count };
         int i;

         for(i = 0; i < zones.count; i++)
            z7Zones[i] = Z7Zone::from7H((I7HZone)zones[i]);

         delete zones;
         zones = (Array<DGGRSZone>)z7Zones;

         // NOTE: zones will still be sorted based on I7HZone::OnCompare() (by levels first) unless the array returned is sorted again

         // NOTE: We could just update the type information, but that would require
         //       a new eC function to do this correctly by updating the Class::count of alive instances for the old and new classes,
         //       while locking the memory mutex or using atomics.
         // zones._class = class(Array<Z7Zone>);
      }
      return zones;
   }
}



================================================
FILE: src/dggrs/RI9R.ec
================================================
// This serves as a basis for aperture 9 rhombic grids
// using different projections based on the Rhombic Icosahedral 5x6 space
public import IMPORT_STATIC "ecrt"
private:

import "dggrs"
import "ri5x6"

#include <stdio.h>

#define POW3(x) ((x) < sizeof(powersOf3) / sizeof(powersOf3[0]) ? (uint64)powersOf3[x] : (uint64)(pow(3, x) + POW_EPSILON))
#define POW9(x) POW3((x)*2)

extern uint64 powersOf3[34]; // in RI3H.ec

static define POW_EPSILON = 0.1;

define I9R_MAX_VERTICES = 200; // * 1024;

public class RhombicIcosahedral9R : DGGRS
{
   bool equalArea;
   RI5x6Projection pj;

   uint64 countZones(int level)
   {
      return (uint64)(10 * POW9(level));
   }

   __attribute__ ((optimize("-fno-unsafe-math-optimizations")))
   double getZoneArea(I9RZone zoneID)
   {
      double area;
      if(equalArea)
      {
         double zoneCount = 10 * POW9(zoneID.level);
         static double earthArea = 0;
         if(!earthArea) earthArea = wholeWorld.geodeticArea;

         area = earthArea / zoneCount;
      }
      else
         area = 0;

      return area;
   }

   int getMaxDGGRSZoneLevel() { return 16; }
   int getRefinementRatio() { return 9; }
   int getMaxParents() { return 1; }
   int getMaxNeighbors() { return 4; }
   int getMaxChildren() { return 9; }

   uint64 countSubZones(I9RZone zone, int depth)
   {
      return POW9(depth);
   }

   int getZoneLevel(I9RZone zone)
   {
      return zone.level;
   }

   int countZoneEdges(I9RZone zone) { return 4; }

   int getZoneParents(I9RZone zone, I9RZone * parents)
   {
      parents[0] = nullZone;
      if(zone.level > 0)
         parents[0] = zone.parent;
      return parents[0] != nullZone;
   }

   int getZoneChildren(I9RZone zone, I9RZone * children)
   {
      zone.getChildren(children);
      return 9;
   }

   int getZoneNeighbors(I9RZone zone, I9RZone * neighbors, int * nbType)
   {
      zone.getNeighbors(neighbors);
      if(nbType)
         nbType[0] = 0, nbType[1] = 1, nbType[2] = 2, nbType[3] = 3;
      return 4;
   }

   I9RZone getZoneFromWGS84Centroid(int level, const GeoPoint centroid)
   {
      if(level <= 16)
      {
         Pointd v;
         pj.forward(centroid, v);
         return I9RZone::fromCRSExtent(v, v, level);
      }
      return nullZone;
   }

   void getZoneWGS84Centroid(I9RZone zone, GeoPoint centroid)
   {
      pj.inverse(zone.centroid, centroid, false);
   }

   // Text ZIRS
   void getZoneTextID(I9RZone zone, String zoneID)
   {
      zone.getZoneID(zoneID);
   }

   DGGRSZone getZoneFromTextID(const String zoneID)
   {
      return I9RZone::fromZoneID(zoneID);
   }

   // Sub-zone Order
   I9RZone getFirstSubZone(I9RZone parent, int depth)
   {
      CRSExtent e = parent.ri5x6Extent;
      double dx, dy;
      double d = 2 * POW3(depth);

      dx = (e.br.x - e.tl.x) / d, dy = (e.br.y - e.tl.y) / d;
      return I9RZone::fromCRSExtent(e.tl, { e.tl.x + dx, e.tl.y + dy }, parent.level + depth );
   }

   void compactZones(Array<DGGRSZone> zones)
   {
      int maxLevel = 0, i, count = zones.count;
      AVLTree<I9RZone> zonesTree { };

      for(i = 0; i < count; i++)
      {
         I9RZone zone = (I9RZone)zones[i];
         if(zone != nullZone)
         {
            int level = zone.level;
            if(level > maxLevel)
               maxLevel = level;
            zonesTree.Add(zone);
         }
      }

      compactI9RZones(zonesTree, maxLevel);
      zones.Free();

      count = zonesTree.count;
      zones.size = count;
      i = 0;
      for(z : zonesTree)
         zones[i++] = z;
      delete zonesTree;
   }

   Array<DGGRSZone> listZones(int level, const GeoExtent bbox)
   {
      uint64 p = POW3(level);
      uint64 numCols = 5*p, numRows = 6*p;
      AVLTree<I9RZone> zonesTree { };
      Array<I9RZone> zones { };
      Pointd tl, br;
      int row, col, y1, y2, x1, x2;
      bool extentCheck = true;

      if(bbox != null && bbox.OnCompare(wholeWorld))
      {
         // Avoid the possibility of including extra zones for single point boxes
         if(fabs((Radians)bbox.ur.lat - (Radians)bbox.ll.lat) < 1E-11 &&
            fabs((Radians)bbox.ur.lon - (Radians)bbox.ll.lon) < 1E-11)
         {
            DGGRSZone zone = getZoneFromWGS84Centroid(level, bbox.ll);
            if(zone != nullZone)
               zones = { [ (I9RZone)zone ] };
            return (Array<DGGRSZone>)zones;
         }

         pj.extent5x6FromWGS84(bbox, tl, br);
      }
      else
         extentCheck = false, pj.extent5x6FromWGS84(wholeWorld, tl, br);
      x1 = Min(Max(0, (int64)(tl.x * p)), numCols-1);
      y1 = Min(Max(0, (int64)(tl.y * p)), numRows-1);
      x2 = Min(Max(0, (int64)(br.x * p)), numCols-1);
      y2 = Min(Max(0, (int64)(br.y * p)), numRows-1);

      if(!p)
         y2 = y1-1; // Avoid divisions by 0, returning null for negative levels

      for(row = y1; row <= y2; row++)
      {
         for(col = x1; col <= x2; col++)
         {
            // Eliminate rows outside the ISEA staircase
            uint rowOP = (uint)(row / p), colOP = (uint)(col / p);
            int root = rowOP + colOP;
            int y = (int)(row - rowOP * p), x = (int)(col - colOP * p);
            uint64 ix = y * p + x;
            int rRow, rCol;
            if(iLRCFromLRtI((char)('A' + level), root, ix, &rRow, &rCol) != -1 && row == rRow && col == rCol)
            {
               I9RZone zone { level, row, col };
               if(extentCheck)
               {
                  GeoExtent e;

                  getZoneWGS84Extent(zone, e);
                  if(!e.intersects(bbox))
                     continue;
               }
               zonesTree.Add(zone);
            }
         }
      }

      zones.minAllocSize = zonesTree.count;
      for(t : zonesTree)
         zones.Add(t);
      zones.minAllocSize = 0;
      if(!zones.count)
         delete zones;

      delete zonesTree;
      return (Array<DGGRSZone>)zones;
   }

   Array<GeoPoint> getSubZoneWGS84Centroids(I9RZone parent, int depth)
   {
      Array<GeoPoint> geo = null;
      Array<Pointd> centroids = parent.getSubZoneCentroids(depth);
      if(centroids)
      {
         uint count = centroids.count;
         int i;

         geo = { size = count };
         for(i = 0; i < count; i++)
            pj.inverse(centroids[i], geo[i], false);
         delete centroids;
      }
      return geo;
   }

   // edge refinement is not supported
   Array<GeoPoint> getZoneRefinedWGS84Vertices(I9RZone zone, int edgeRefinement)
   {
      GeoPoint v[I9R_MAX_VERTICES];
      int count = getI9RRefinedWGS84Vertices(this, zone, v);
      Array<GeoPoint> vertices { size = count };
      memcpy(vertices.array, v, sizeof(GeoPoint) * count);
      return vertices;
   }

   int getZoneWGS84Vertices(I9RZone zone, GeoPoint * vertices)
   {
      CRSExtent extent = zone.ri5x6Extent;
      Pointd v5x6[4] =
      {
         extent.tl,
         { extent.tl.x, extent.br.y },
         extent.br,
         { extent.br.x, extent.tl.y }
      };
      uint count = 4, i;
      for(i = 0; i < count; i++)
         pj.inverse(v5x6[i], vertices[i], false);
      return count;
   }

   void getZoneWGS84Extent(I9RZone zone, GeoExtent value)
   {
      int i;
      GeoPoint centroid;
      Radians minDLon = 99999, maxDLon = -99999;
      GeoPoint vertices[I9R_MAX_VERTICES];
      int nVertices = getI9RRefinedWGS84Vertices(this, zone, vertices);

      getZoneWGS84Centroid(zone, centroid);

      value.clear();
      for(i = 0; i < nVertices; i++)
      {
         GeoPoint p = vertices[i];
         Radians dLon = p.lon - centroid.lon;

         if(dLon > Pi) dLon -= 2* Pi;
         if(dLon < -Pi) dLon += 2* Pi;

         if(p.lat > value.ur.lat) value.ur.lat = p.lat;
         if(p.lat < value.ll.lat) value.ll.lat = p.lat;

         if(dLon > maxDLon)
            maxDLon = dLon, value.ur.lon = p.lon;
         if(dLon < minDLon)
            minDLon = dLon, value.ll.lon = p.lon;
      }
      if((Radians)value.ll.lon < -Pi)
         value.ll.lon += 2*Pi;
      if((Radians)value.ur.lon > Pi)
         value.ur.lon -= 2*Pi;
   }

   I9RZone getZoneFromCRSCentroid(int level, CRS crs, const Pointd centroid)
   {
      if(level <= 16)
      {
         switch(crs)
         {
            case 0: case CRS { ogc, 153456 }: return I9RZone::fromCRSExtent(centroid, centroid, level);
            case CRS { ogc, 1534 }:
            {
               Pointd c5x6;
               RI5x6Projection::fromIcosahedronNet(centroid, c5x6);
               return I9RZone::fromCRSExtent(c5x6, c5x6, level);
            }
            case CRS { epsg, 4326 }:
            case CRS { ogc, 84 }:
               return (I9RZone)getZoneFromWGS84Centroid(level,
                  crs == { ogc, 84 } ?
                     { centroid.y, centroid.x } :
                     { centroid.x, centroid.y });
         }
      }
      return nullZone;
   }

   void getZoneCRSCentroid(I9RZone zone, CRS crs, Pointd centroid)
   {
      switch(crs)
      {
         case CRS { ogc, 1534 }:
         {
            Pointd c5x6 = zone.centroid;
            RI5x6Projection::toIcosahedronNet(c5x6, centroid);
            break;
         }
         case 0: case CRS { ogc, 153456 }: centroid = zone.centroid; break;
         case CRS { epsg, 4326 }:
         case CRS { ogc, 84 }:
         {
            GeoPoint geo;

            getZoneWGS84Centroid(zone, geo);
            centroid = crs == { ogc, 84 } ?
               { geo.lon, geo.lat } :
               { geo.lat, geo.lon };
            break;
         }
      }
   }

   int getZoneCRSVertices(I9RZone zone, CRS crs, Pointd * vertices)
   {
      uint count = 0, i;
      CRSExtent extent = zone.ri5x6Extent;
      Pointd v[4] =
      {
         extent.tl,
         { extent.tl.x, extent.br.y },
         extent.br,
         { extent.br.x, extent.tl.y }
      };

      switch(crs)
      {
         case CRS { ogc, 153456 }: case 0:
            count = 4;
            memcpy(vertices, v, sizeof(Pointd) * 4);
            break;
         case CRS { ogc, 1534 }:
         {
            uint count = 4, i;
            CRSExtent extent = zone.ri5x6Extent;
            Pointd v[4] =
            {
               extent.tl,
               { extent.tl.x, extent.br.y },
               extent.br,
               { extent.br.x, extent.tl.y }
            };

            for(i = 0; i < count; i++)
               RI5x6Projection::toIcosahedronNet(v[i], vertices[i]);
            return count;
         }
         case CRS { ogc, 84 }:
         case CRS { epsg, 4326 }:
            count = 4;
            for(i = 0; i < count; i++)
            {
               GeoPoint geo;
               pj.inverse(v[i], geo, false);
               vertices[i] = crs == { ogc, 84 } ? { geo.lon, geo.lat } : { geo.lat, geo.lon };
            }
            break;
      }
      return count;
   }

   // No refinement needed in ISEA CRSs
   Array<Pointd> getZoneRefinedCRSVertices(I9RZone zone, CRS crs, int edgeRefinement)
   {
      switch(crs)
      {
         case CRS { ogc, 1534 }:
         {
            Array<Pointd> vertices { size = 4 };
            getZoneCRSVertices(zone, crs, vertices.array);
            return vertices;
         }
         case 0: case CRS { ogc, 153456 }:
         {
            Array<Pointd> vertices { size = 4 };
            getZoneCRSVertices(zone, crs, vertices.array);
            return vertices;
         }
         case CRS { ogc, 84 }: case CRS { epsg, 4326 }:
         {
            GeoPoint v[I9R_MAX_VERTICES];
            int count = getI9RRefinedWGS84Vertices(this, zone, v), i;
            Array<Pointd> vertices { size = count };
            for(i = 0; i < count; i++)
               vertices[i] = crs == { ogc, 84 } ? { v[i].lat, v[i].lon } : { v[i].lon, v[i].lat };
            return vertices;
         }
      }
      return null;
   }

   void getZoneCRSExtent(I9RZone zone, CRS crs, CRSExtent extent)
   {
      switch(crs)
      {
         case 0: case CRS { ogc, 153456 }: extent = zone.ri5x6Extent; break;
         case CRS { ogc, 1534 }:
            getIcoNetExtentFromVertices(/*this, */zone, extent);
            break;
         case CRS { epsg, 4326 }:
         case CRS { ogc, 84 }:
         {
            GeoExtent geo;
            getZoneWGS84Extent(zone, geo);
            extent.crs = crs;
            if(crs == { ogc, 84 })
            {
               extent.tl = { geo.ll.lon, geo.ur.lat };
               extent.br = { geo.ur.lon, geo.ll.lat };
            }
            else
            {
               extent.tl = { geo.ur.lat, geo.ll.lon };
               extent.br = { geo.ll.lat, geo.ur.lon };
            }
            break;
         }
      }
   }

   Array<Pointd> getSubZoneCRSCentroids(I9RZone parent, CRS crs, int depth)
   {
      Array<Pointd> centroids = parent.getSubZoneCentroids(depth);
      if(centroids)
      {
         uint count = centroids.count, i;
         switch(crs)
         {
            case CRS { ogc, 1534 }:
               for(i = 0; i < count; i++)
                  RI5x6Projection::toIcosahedronNet(centroids[i], centroids[i]);
               break;
            case CRS { ogc, 153456 }: case 0: break;
            case CRS { epsg, 4326 }:
            case CRS { ogc, 84 }:
               for(i = 0; i < count; i++)
               {
                  GeoPoint geo;
                  pj.inverse(centroids[i], geo, false);
                  centroids[i] = crs == { ogc, 84 } ? { geo.lon, geo.lat } : { geo.lat, geo.lon };
               }
               break;
            default: delete centroids;
         }
      }
      return centroids;
   }
}

// public for use in tests
public class I9RZone : private DGGRSZone
{
public:
   uint level:5:59, row:29:30, col:30:0;

private:
   property I9RZone parent
   {
      get
      {
         int l = level;
         return (l > 0) ? I9RZone { l - 1, row / 3, col / 3 } : nullZone;
      }
   }

   Array<Pointd> getSubZoneCentroids(int rDepth)
   {
      uint64 s = POW3(rDepth), nSubZones = s * s;
      if(nSubZones < 1LL<<31)
      {
         Array<Pointd> centroids { size = (uint)nSubZones };
         int i = 0, y, x;
         CRSExtent e = ri5x6Extent;
         double dx = (e.br.x - e.tl.x) / s, dy = (e.br.y - e.tl.y) / s;

         for(y = 0; y < s; y++)
         {
            double yy = e.tl.y + (y + 0.5) * dy;
            for(x = 0; x < s; x++, i++)
            {
               centroids[i].x = e.tl.x + (x + 0.5) * dx;
               centroids[i].y = yy;
            }
         }
         return centroids;
      }
      return null;
   }

   property CRSExtent ri5x6Extent
   {
      get
      {
         double z = 1.0 / POW3(level);
         value.tl = { col * z, row * z };
         value.br = { value.tl.x + z, value.tl.y + z };
         value.crs = { ogc, 153456 };
      }
   }

   property Pointd centroid
   {
      get
      {
         double z = 1.0 / POW3(level);
         value = { (col + 0.5) * z, (row + 0.5) * z };
      }
   }

   // This function generates the proposed ISEA9R DGGS Zone ID string
   // in the form {LevelChar}{RootRhombus}-{HexIndexWithinRootRhombus}
   // from an ISEA9R TileMatrixSet Level, Row, Column
   void getZoneID(String zoneID)
   {
      if(this == nullZone)
         strcpy(zoneID, "(null)");
      else
      {
         int level = this.level;
         uint row = this.row, col = this.col;
         uint64 p = POW3(level);
         uint rowOP = (uint)(row / p), colOP = (uint)(col / p);
         int root = rowOP + colOP;
         int y = (int)(row - rowOP * p), x = (int)(col - colOP * p);
         uint64 ix = y * p + x;
         sprintf(zoneID,
            __runtimePlatform == win32 ? "%c%d-%I64X" : "%c%d-%llX",
            'A' + level, root, ix);
      }
   }

   I9RZone ::fromCRSExtent(const Pointd topLeft, const Pointd bottomRight, int level)
   {
      uint64 p = POW3(level);
      int64 numRows = 6 * p, numCols = 5 * p;
      Pointd mid
      {
         (topLeft.x + bottomRight.x) / 2,
         (topLeft.y + bottomRight.y) / 2
      };
      int row = Min(Max(0, (int)(mid.y * p)), numRows-1);
      int col = Min(Max(0, (int)(mid.x * p)), numCols-1);
      // WARNING: Cannot return negative level in DGGRSZone
      return I9RZone { Max(0, level), row, col };
   }

   I9RZone ::fromZoneID(const String zoneID)
   {
      I9RZone result = nullZone;
      char levelChar;
      uint root;
      uint64 ix;
      int row, col, l9r = -1;

      if(sscanf(zoneID, __runtimePlatform == win32 ? "%c%d-%I64X" : "%c%d-%llX", &levelChar, &root, &ix) == 3)
      {
         l9r = iLRCFromLRtI(levelChar, root, ix, &row, &col);
         if(l9r != -1)
         {
            char id[256];
            result = { l9r, row, col };
            result.getZoneID(id);
            // Further validation (ISEA3H zones still validated as ISEA9R)
            if(strcmp(id, zoneID))
               result = nullZone;
         }
      }
      return result;
   }

   void getChildren(I9RZone children[9])
   {
      uint l = level+1;
      uint row1 = row * 3;
      uint col1 = col * 3;
      int x, y;

      for(y = 0; y < 3; y++)
         for(x = 0; x < 3; x++)
         {
            I9RZone key = I9RZone { l, row1 + y, col1 + x};
#if 0
            if(key.lat != row1 + y)
               Print("Ybug");
            if(key.lon != col1 + x)
               Print("Xbug");
#endif
            children[y * 3 + x] = key;
         }
   }

   void getNeighbors(I9RZone neighbors[4])
   {
      uint l = level;
      int row = this.row, col = this.col;
      int64 p = (int64)POW3(l);
      uint numRows = (uint)(6 * p), numCols = (uint)(5 * p);
      int colOP = (int)(col / p), rowOP = (int)(row / p);
      int topDelta = (int)((row - 1) / p - colOP);
      int leftDelta = (int)(rowOP - (col - 1) / p);
      int bottomDelta = (int)((row + 1) / p - colOP);
      int rightDelta = (int)(rowOP - (col + 1) / p);

      // Top
      if(row == 0 || (topDelta && topDelta != 1))
      {
         // Crossing over top interruption to the left
         int r = (int)((rowOP ? rowOP - 1 : 4) * p + p - 1 - (col - colOP * p));
         int c = (int)((rowOP ? colOP - 1 : 4) * p + p - 1);
         neighbors[0] = I9RZone { l, r, c };
      }
      else
         neighbors[0] = I9RZone { l, row - 1, col };

      // Left
      if(col == 0 || (leftDelta && leftDelta != 1))
      {
         int r, c;
         if((leftDelta && leftDelta != 1) || (col == 0 && rowOP > colOP))
         {
            // Crossing over bottom interruption to the left
            r = (int)((colOP ? rowOP - 1 : 5) * p + p - 1);
            c = (int)((colOP ? colOP - 1 : 4) * p + p - 1 - (row - rowOP * p));
         }
         else
         {
            // Wrapping to the left
            r = (int)(row + 5 * p);
            c = (int)(col - 1 + 5 * p);
         }
         neighbors[1] = I9RZone { l, r, c };
      }
      else
         neighbors[1] = I9RZone { l, row, col - 1 };

      // Right
      if(col == numCols-1 || (rightDelta && rightDelta != 1))
      {
         int r, c;
         if((rightDelta && rightDelta != 1) || (col == numCols-1 && rowOP == colOP))
         {
            // Crossing over top interruption to the right
            r = (int)((colOP < 4 ? rowOP + 1 : 0) * p + 0);
            c = (int)((colOP < 4 ? colOP + 1 : 0) * p + p - 1 - (row - rowOP * p));
         }
         else
         {
            // Wrapping to the right
            r = (int)(row - 5 * p);
            c = (int)(col + 1 - 5 * p);
         }
         neighbors[2] = I9RZone { l, r, c };
      }
      else
         neighbors[2] = I9RZone { l, row, col + 1 };

      // Bottom
      if(row == numRows-1 || (bottomDelta && bottomDelta != 1))
      {
         // Crossing over bottom interruption to the right
         int r = (int)((rowOP < 5 ? rowOP + 1 : 1) * p + p - 1 - (col - colOP * p));
         int c = (int)((rowOP < 5 ? colOP + 1 : 0) * p + 0);
         neighbors[3] = I9RZone { l, r, c };
      }
      else
         neighbors[3] = I9RZone { l, row + 1, col };
   }
}


// This function returns an I9R TileMatrixSet Level, Row, Column
// from the LevelChar, RootDiamond and IndexWithinRootDiamond components
// of the proposed I9R DGGRS Zone ID string
int iLRCFromLRtI(char levelChar, int root, uint64 ix, int * row, int * col)
{
   int level = levelChar - 'A';

   if(level >= 0 && level <= 16 && root >= 0 && root <= 9)
   {
      uint64 p = POW3(level);
      if(ix >= 0 && ix < p * p)
      {
         int rowOP = (root + 1) >> 1, colOP = root >> 1;
         int ixOP = (int)(ix / p);
         *row = (int)(rowOP * p + ixOP);
         *col = (int)((colOP - ixOP) * p + ix); // distributivity on: ix - (ixOP * p) for (ix % p)

         return level;
      }
   }
   *row = -1, *col = -1;
   return -1;
}

static void compactI9RZones(AVLTree<I9RZone> zones, int level)
{
   AVLTree<I9RZone> output { };
   AVLTree<I9RZone> next { };
   int l;

   for(l = level - 1; l >= 0; l--)
   {
      int i;
      for(z : zones)
      {
         I9RZone zone = z, parent = zone.parent;
         if(!next.Find(parent))
         {
            bool parentAllIn = true;
            I9RZone children[9];

            parent.getChildren(children);

            for(i = 0; i < 9; i++)
            {
               I9RZone ch = children[i];
               if(ch != nullZone && !zones.Find(ch))
               {
                  parentAllIn = false;
                  break;
               }
            }

            if(parentAllIn)
               next.Add(parent);
            else
               output.Add(zone);
         }
      }

      if(l - 1 >= 0 && next.count)
      {
         // Not done -- next level becomes zones to compact
         zones.copySrc = next;
         next.Free();
      }
      else
      {
         // Done -- next is combined with output into final zones
         zones.copySrc = output;
         for(z : next)
            zones.Add(z);
         //break;
      }
   }

   delete output;
   delete next;
}

   // NOTE: custom edgeRefinement not currently supported
static uint getI9RRefinedWGS84Vertices(RhombicIcosahedral9R dggrs, I9RZone zone, GeoPoint * outVertices)
{
   #define NUM_ISEA9R_ANCHORS 30
   uint count = 0;
   CRSExtent e = zone.ri5x6Extent;
   Pointd dp[4] = { {e.tl.x, e.tl.y}, {e.tl.x, e.br.y}, {e.br.x, e.br.y}, {e.br.x, e.tl.y} };
   GeoPoint centroid;
   int i;
   RI5x6Projection pj = dggrs.pj;
   double poleOffset = 0.001 * (1LL << zone.level);

   dggrs.getZoneWGS84Centroid(zone, centroid);

   // REVIEW: Should centroid ever be outside -Pi..Pi?
   if(centroid.lon < - Pi - 1E-9)
      centroid.lon += 2*Pi;
   if(centroid.lon > Pi + 1E-9)
      centroid.lon -= 2*Pi;

   for(i = 0; i < 4; i++)
   {
      const Pointd * p = &dp[i], * np = &dp[i == 3 ? 0 : i+1];
      const Pointd * pp = &dp[i == 0 ? 3 : i-1];
      int numAnchors = NUM_ISEA9R_ANCHORS;
      int j;
      double dx = np->x - p->x, dy = np->y - p->y;

      for(j = 0; j < numAnchors; j++)
      {
         Pointd in { p->x + dx * j / numAnchors, p->y + dy * j / numAnchors };
         GeoPoint out;

         if(pj.inverse(in, out, false))
         {
            if(fabs((double)out.lat) > 89.999999)
            {
               double ddx1 = j ? -dx : pp->x - p->x;
               double ddy1 = j ? -dy : pp->y - p->y;
               double ddx2 =  dx, ddy2 =  dy;
               Pointd in1 { in.x + ddx1 * poleOffset, in.y + ddy1 * poleOffset };
               Pointd in2 { in.x + ddx2 * poleOffset, in.y + ddy2 * poleOffset };
               GeoPoint out1, out2;
               if(pj.inverse(in1, out1, true))
                  outVertices[count++] = { Sgn(out1.lat) * 90, out1.lon };
               if(pj.inverse(in2, out2, true))
                  outVertices[count++] = { Sgn(out2.lat) * 90, out2.lon };
            }
            else
               outVertices[count++] = out;
         }
      }
   }

   for(i = 0; i < count; i++)
   {
      GeoPoint * point = &outVertices[i];
      point->lon = wrapLonAt(-1, point->lon, centroid.lon - Degrees { 0.05 }) + centroid.lon - Degrees { 0.05 }; // REVIEW: wrapLonAt() doesn't add back centroid.lon ?
   }
   return count;
}

static void getIcoNetExtentFromVertices(I9RZone zone, CRSExtent value)
{
   CRSExtent k = zone.ri5x6Extent;
   Pointd p[4];

   RI5x6Projection::toIcosahedronNet({k.tl.x, k.tl.y }, p[0]);
   RI5x6Projection::toIcosahedronNet({k.tl.x, k.br.y }, p[1]);
   RI5x6Projection::toIcosahedronNet({k.br.x, k.br.y }, p[2]);
   RI5x6Projection::toIcosahedronNet({k.br.x, k.tl.y }, p[3]);
   value.crs = { ogc, 1534 };
   value.tl.x = Min(Min(p[0].x, p[1].x), Min(p[2].x, p[3].x));
   value.tl.y = Max(Max(p[0].y, p[1].y), Max(p[2].y, p[3].y));
   value.br.x = Max(Max(p[0].x, p[1].x), Max(p[2].x, p[3].x));
   value.br.y = Min(Min(p[0].y, p[1].y), Min(p[2].y, p[3].y));
}

/*
static void getIcoNetExtentFromVertices(I9RZone zone, CRS crs, CRSExtent value)
{
   int i;
   Array<Pointd> vertices = dggrs.getZoneRefinedCRSVertices(zone, crs, 0); //, false);
   int nVertices = vertices ? vertices.count : 0;

   value.crs = crs;
   value.tl.x = MAXDOUBLE, value.tl.y = -MAXDOUBLE;
   value.br.x = -MAXDOUBLE, value.br.y = MAXDOUBLE;
   for(i = 0; i < nVertices; i++)
   {
      const Pointd * v = &vertices[i];
      double x = v->x, y = v->y;

      if(y < value.br.y) value.br.y = y;
      if(y > value.tl.y) value.tl.y = y;
      if(x > value.br.x) value.br.x = x;
      if(x < value.tl.x) value.tl.x = x;
   }
   delete vertices;
}
*/



================================================
FILE: src/dggrs/RTEA3H.ec
================================================
public import IMPORT_STATIC "ecrt"
private:

import "RI3H"
import "icoVertexGreatCircle"

public class RTEA3H : RhombicIcosahedral3H
{
   equalArea = true;

   RTEA3H() { pj = RTEAProjection { }; incref pj; }
   ~RTEA3H() { delete pj; }
}



================================================
FILE: src/dggrs/RTEA4R.ec
================================================
public import IMPORT_STATIC "ecrt"
private:

import "RI4R"
import "icoVertexGreatCircle"

public class RTEA4R : RhombicIcosahedral4R
{
   equalArea = true;

   RTEA4R() { pj = RTEAProjection { }; incref pj; }
   ~RTEA4R() { delete pj; }
}



================================================
FILE: src/dggrs/RTEA7H.ec
================================================
public import IMPORT_STATIC "ecrt"
private:

import "RI7H"
import "icoVertexGreatCircle"

public class RTEA7H : RhombicIcosahedral7H
{
   equalArea = true;

   RTEA7H() { pj = RTEAProjection { }; incref pj; }
   ~RTEA7H() { delete pj; }
}



================================================
FILE: src/dggrs/RTEA7H_Z7.ec
================================================
public import IMPORT_STATIC "ecrt"
private:

import "RI7H_Z7"

#define Z7_DGGRSZONE

#ifdef Z7_DGGRSZONE
// Using Z7Zone natively for DGGRSZone, at the cost of some performance impact
import "icoVertexGreatCircle"

public class RTEA7H_Z7 : RI7H_Z7
{
   equalArea = true;

   RTEA7H_Z7() { pj = RTEAProjection { }; incref pj; }
   ~RTEA7H_Z7() { delete pj; }
}

#else
// To still use I7HZone for 64-bit integer DGGRSZone...
import "RTEA7H"

public class RTEA7H_Z7 : RTEA7H
{
   I7HZone getZoneFromTextID(const String zoneID)
   {
      return Z7Zone::fromTextID(zoneID).to7H();
   }

   void getZoneTextID(I7HZone zone, String zoneID)
   {
      Z7Zone::from7H(zone).getTextID(zoneID);
   }
}

#endif



================================================
FILE: src/dggrs/RTEA9R.ec
================================================
public import IMPORT_STATIC "ecrt"
private:

import "RI9R"
import "icoVertexGreatCircle"

public class RTEA9R : RhombicIcosahedral9R
{
   equalArea = true;

   RTEA9R() { pj = RTEAProjection { }; incref pj; }
   ~RTEA9R() { delete pj; }
}



================================================
FILE: src/dggsJSON/dggsJSON.ec
================================================
public import IMPORT_STATIC "ecrt"

import "JSONSchema"

public class DGGSJSONShape
{
public:
   int count;
   int subZones;
   Map<String, int> dimensions;

   ~DGGSJSONShape()
   {
      delete dimensions;
   }
}

public class DGGSJSONGrid
{
public:
   int cellsCount;
   double resolution;
   Array<FieldValue> coordinates;
   Array<FieldValue> boundsCoordinates;
   Array<FieldValue> relativeBounds;
   FieldValue firstCoordinate;

   ~DGGSJSONGrid()
   {
      if(coordinates) coordinates.Free(), delete coordinates;
      if(relativeBounds) relativeBounds.Free(), delete relativeBounds;
      firstCoordinate.OnFree();
   }
}

public class DGGSJSONDimension
{
public:
   String name;
   Array<FieldValue> interval;
   DGGSJSONGrid grid;
   String definition;
   String unit;
   String unitLang;

   ~DGGSJSONDimension()
   {
      delete unit;
      delete unitLang;
      delete definition;
      delete name;
      if(interval) interval.Free(), delete interval;
      delete grid;
   }
}

public class DGGSJSONDepth
{
public:
   int depth;
   DGGSJSONShape shape;
   Array<FieldValue> data;

   ~DGGSJSONDepth()
   {
      delete shape;
      delete data;
   }
}

public class DGGSJSON
{
public:
   // $schema
   String dggrs;
   String zoneId;
   Array<int> depths;
   String representedValue;
   JSONSchema schema;
   Array<DGGSJSONDimension> dimensions;
   Map<String, Array<DGGSJSONDepth>> values;

   ~DGGSJSON()
   {
      delete dggrs;
      delete zoneId;
      delete depths;
      delete representedValue;
      delete schema;
      if(dimensions) dimensions.Free(), delete dimensions;
      if(values) values.Free(), delete values;
   };

}

public DGGSJSON readDGGSJSON(File f)
{
   DGGSJSON dggsJSON = null;
   JSONParser parser { f  };
   if(parser.GetObject(class(DGGSJSON), &dggsJSON) != success)
      delete dggsJSON;
   delete parser;
   return dggsJSON;
}



================================================
FILE: src/ecere3D/Plane.ec
================================================
public import IMPORT_STATIC "ecrt"

import "Vector3D"

public struct Plane
{
   union
   {
      struct { double a, b, c; };
      Vector3D normal;
   };
   double d;

   void FromPoints(const Vector3D v1, const Vector3D v2, const Vector3D v3)
   {
      Vector3D a, b;

      a.Subtract(v3, v1);
      b.Subtract(v2, v1);
      normal.CrossProduct(a, b);
      normal.Normalize(normal);

      d = -normal.DotProduct(v1);
   }
};



================================================
FILE: src/ecere3D/Quaternion.ec
================================================
public import IMPORT_STATIC "ecrt"

import "Vector3D"
import "Quaternion"

public struct Quaternion
{
   double w, x, y, z;

   void YawPitch(Degrees yaw, Degrees pitch)
   {
      double sYaw   = sin( yaw / 2 );
      double cYaw   = cos( yaw / 2 );
      double sPitch = sin( pitch / 2 );
      double cPitch = cos( pitch / 2 );

      w = cPitch * cYaw;
      x = sPitch * cYaw;
      y = cPitch * sYaw;
      z = sPitch * sYaw;
   }
};



================================================
FILE: src/ecere3D/Vector3D.ec
================================================
public import IMPORT_STATIC "ecrt"

import "Vector3D"
import "Quaternion"

public struct Vector3D
{
   double x, y, z;

   void Subtract(const Vector3D vector1, const Vector3D vector2)
   {
      x = vector1.x - vector2.x;
      y = vector1.y - vector2.y;
      z = vector1.z - vector2.z;
   }

   double DotProduct(const Vector3D vector2)
   {
      return x * vector2.x + y * vector2.y + z * vector2.z;
   }

   void CrossProduct(const Vector3D vector1, const Vector3D vector2)
   {
      x = vector1.y * vector2.z - vector1.z * vector2.y;
      y = vector1.z * vector2.x - vector1.x * vector2.z;
      z = vector1.x * vector2.y - vector1.y * vector2.x;
   }

   void Normalize(const Vector3D source)
   {
      double m = (double)sqrt(source.x * source.x + source.y * source.y + source.z * source.z);
      if(m)
      {
         x = source.x/m;
         y = source.y/m;
         z = source.z/m;
      }
      else
         x = y = z = 0;
   }

   property double length { get { return (double)sqrt(x * x + y * y + z * z); } };

   void MultQuaternion(const Vector3D s, const Quaternion quat)
   {
      Vector3D v { quat.x, quat.y, quat.z };
      double w = quat.w, a = w*w - (v.x*v.x+v.y*v.y+v.z*v.z) /*DotProduct(v)*/, dotVS = v.x*s.x+v.y*s.y+v.z*s.z /*v.DotProduct(s)*/;
      Vector3D cross
      {
         s.y * v.z - s.z * v.y,
         s.z * v.x - s.x * v.z,
         s.x * v.y - s.y * v.x
      };
      //cross.CrossProduct(s, v);
      x = 2 * dotVS * v.x + a * s.x + 2 * w * cross.x;
      y = 2 * dotVS * v.y + a * s.y + 2 * w * cross.y;
      z = 2 * dotVS * v.z + a * s.z + 2 * w * cross.z;
   }
};



================================================
FILE: src/projections/authalic.ec
================================================
public import IMPORT_STATIC "ecrt"
private:

// Authalic / Geodetic latitude conversion as defined by Charles Karney's "On auxiliary latitudes"
// https://arxiv.org/pdf/2212.05818

public /*private static */define AUTH_ORDER = 6;

/*private inline */public Radians latGeodeticToAuthalic(const double cp[2][AUTH_ORDER], Radians phi)
{
   return applyCoefficients(cp[0], phi);
}

/*static inline */public Radians latAuthalicToGeodetic(const double cp[2][AUTH_ORDER], Radians phi)
{
   return applyCoefficients(cp[1], phi);
}

static const double Cxiphi[21] = // Cξφ (A19) - coefficients to convert geodetic latitude to authalic latitude
{
   -4/3.0,    -4/45.0,    88/ 315.0,       538/ 4725.0,     20824/467775.0,      -44732/   2837835.0,
              34/45.0,     8/ 105.0,     -2482/14175.0,    -37192/467775.0,   -12467764/ 212837625.0,
                       -1532/2835.0,      -898/14175.0,     54968/467775.0,   100320856/1915538625.0,
                                          6007/14175.0,     24496/467775.0,    -5884124/  70945875.0,
                                                           -23356/ 66825.0,     -839792/  19348875.0,
                                                                              570284222/1915538625.0
};

static const double Cphixi[21] = // Cφξ (A20) - coefficients to convert authalic latitude to geodetic latitude
{
   4 / 3.0,  4 / 45.0,   -16/35.0,  -2582 /14175.0,  60136 /467775.0,    28112932/ 212837625.0,
            46 / 45.0,  152/945.0, -11966 /14175.0, -21016 / 51975.0,   251310128/ 638512875.0,
                      3044/2835.0,   3802 /14175.0, -94388 / 66825.0,    -8797648/  10945935.0,
                                     6059 / 4725.0,  41072 / 93555.0, -1472637812/ 638512875.0,
                                                    768272 /467775.0,  -455935736/ 638512875.0,
                                                                       4210684958/1915538625.0
};

// ∆η(ζ) = S^(L)(ζ) · Cηζ · P^(M) (n) + O(n^L+1)    -- (20)
static void precomputeCoefficients(double a, double b, const double C[21], double cp[AUTH_ORDER])
{
   // Precomputing coefficients based on Horner's method
   double n = (a - b) / (a + b);  // Third flattening
   double d = n;

   cp[0] = (((((C[ 5] * n + C[ 4]) * n + C[ 3]) * n + C[ 2]) * n + C[ 1]) * n + C[ 0]) * d, d *= n;
   cp[1] = ((((             C[10]  * n + C[ 9]) * n + C[ 8]) * n + C[ 7]) * n + C[ 6]) * d, d *= n;
   cp[2] = (((                           C[14]  * n + C[13]) * n + C[12]) * n + C[11]) * d, d *= n;
   cp[3] = ((                                         C[17]  * n + C[16]) * n + C[15]) * d, d *= n;
   cp[4] = (                                                       C[19]  * n + C[18]) * d, d *= n;
   cp[5] =                                                                      C[20]  * d;
}

/*static inline */Radians applyCoefficients(const double * cp, Radians phi)
{
   // Using Clenshaw summation algorithm (order 6)
   double szeta = sin(phi), czeta = cos(phi);
   double X = 2 * (czeta - szeta) * (czeta + szeta); // 2 * cos(2*zeta)
   double u0, u1; // accumulators for sum

   u0 = X * cp[5]   + cp[4];
   u1 = X * u0      + cp[3];
   u0 = X * u1 - u0 + cp[2];
   u1 = X * u0 - u1 + cp[1];
   u0 = X * u1 - u0 + cp[0];

   return phi + /* sin(2*zeta) * u0 */ 2 * szeta * czeta * u0;
}

/*static */public void authalicSetup(double a, double b, double cp[2][AUTH_ORDER])
{
   precomputeCoefficients(a, b, Cxiphi, cp[0]); // geodetic -> authalic
   precomputeCoefficients(a, b, Cphixi, cp[1]); // authalic -> geodetic
}



================================================
FILE: src/projections/barycentric5x6.ec
================================================
public import IMPORT_STATIC "ecrt"
private:

import "ri5x6"

import "Vector3D"

public class GoldbergPolyhedraProjection : BarycentricSphericalTriAreaProjection
{
   projectedGP = true;
}

public class BarycentricSphericalTriAreaProjection : RI5x6Projection
{
   bool projectedGP; projectedGP = false;

   __attribute__ ((unused))
   __attribute__ ((optimize("-fno-unsafe-math-optimizations")))
   void inverseIcoFace(int face, const Pointd v,
      const Pointd p1, const Pointd p2, const Pointd p3,
      const Vector3D v1, const Vector3D v2, const Vector3D v3,
      Vector3D out)
   {
      double b[3];
      double u1, u2, u3;

      cartesianToBary(b, v, p1, p2, p3, 0);
      if(b[0] < 0) b[0] = 0;
      if(b[1] < 0) b[1] = 0;
      if(b[2] < 0) b[2] = 0;

      if(projectedGP)
      {
         // Directly using the barycentric coordinates here projects the grid as defined on the face of the icosahedron
         // directly to the sphere, and is equivalent to splitting the icosahedron into Goldberg Polyhedra
         u1 = b[0], u2 = b[1], u3 = b[2];
      }
      else
      {
         // https://math.stackexchange.com/questions/1151428/point-within-a-spherical-triangle-given-areas
         double omega = (4 * Pi) / 20, tau = tan(omega / 2), beta = phi - 1;
         double l1 = tan(b[0] * omega/2) / tau;
         double l2 = tan(b[1] * omega/2) / tau;
         double l3 = tan(b[2] * omega/2) / tau;
         double vi = l1 / ((1 + beta) + (1 - beta) * l1);
         double vj = l2 / ((1 + beta) + (1 - beta) * l2);
         double vk = l3 / ((1 + beta) + (1 - beta) * l3);
         double od = 1.0 / (1 - vi - vj - vk);

         u1 = vi * od;
         u2 = vj * od;
         u3 = vk * od;
      }
      out = {
         u1 * v1.x + u2 * v2.x + u3 * v3.x,
         u1 * v1.y + u2 * v2.y + u3 * v3.y,
         u1 * v1.z + u2 * v2.z + u3 * v3.z
      };
      out.Normalize(out);
   }

   void forwardIcoFace(int face, const Vector3D v, const Vector3D v1, const Vector3D v2, const Vector3D v3, const Pointd p1, const Pointd p2, const Pointd p3, Pointd out)
   {
      double b[3];
      if(projectedGP)
      {
         Vector3D c12, c23, c31;
         double lv, lu;
         double u1, u2, u3;

         // NOTE: These could be constant for each of the 120 spherical triangles
         c12.CrossProduct(v1, v2);
         c23.CrossProduct(v2, v3);
         c31.CrossProduct(v3, v1);

         lv = 1.0 / v1.DotProduct(c23);

         u1 = c23.DotProduct(v) * lv;
         u2 = c31.DotProduct(v) * lv;
         u3 = c12.DotProduct(v) * lv;

         lu = 1.0 / (u1 + u2 + u3);
         u1 *= lu;
         u2 *= lu;
         u3 *= lu;

         b[0] = u1, b[1] = u2, b[2] = u3;
      }
      else
      {
         double omega = (4 * Pi) / 20;
         Vector3D mid12, mid23, mid31, midv1, midv2, midv3, cross32v, cross13v, cross21v;

         // NOTE: These first 3 could be constant for each of the 120 spherical triangles
         mid12.Normalize({ (v1.x + v2.x) / 2, (v1.y + v2.y) / 2, (v1.z + v2.z) / 2 });
         mid23.Normalize({ (v2.x + v3.x) / 2, (v2.y + v3.y) / 2, (v2.z + v3.z) / 2 });
         mid31.Normalize({ (v3.x + v1.x) / 2, (v3.y + v1.y) / 2, (v3.z + v1.z) / 2 });

         midv1.Normalize({ (v1.x + v.x) / 2, (v1.y + v.y) / 2, (v1.z + v.z) / 2 });
         midv2.Normalize({ (v2.x + v.x) / 2, (v2.y + v.y) / 2, (v2.z + v.z) / 2 });
         midv3.Normalize({ (v3.x + v.x) / 2, (v3.y + v.y) / 2, (v3.z + v.z) / 2 });

         cross32v.CrossProduct(midv3, midv2);
         cross13v.CrossProduct(midv1, midv3);
         cross21v.CrossProduct(midv2, midv1);

         // b[0] = sphericalTriArea(v2, v3, v) / omega;
         b[0] = asin(Max(-1.0, Min(1.0, mid23.DotProduct(cross32v)))) * 2 / omega;
         // b[1] = sphericalTriArea(v3, v1, v) / omega;
         b[1] = asin(Max(-1.0, Min(1.0, mid31.DotProduct(cross13v)))) * 2 / omega;
         // b[2] = sphericalTriArea(v1, v2, v) / omega;
         b[2] = asin(Max(-1.0, Min(1.0, mid12.DotProduct(cross21v)))) * 2 / omega;
      }
      baryToCartesian(b, out, p1, p2, p3);
   }
}



================================================
FILE: src/projections/icoVertexGreatCircle.ec
================================================
/*
   This implements the Slice & Dice Vertex great circle equal area projection for an icosahedron.
   https://doi.org/10.1559/152304006779500687
   The 120 spherical triangles used correspond to those of a spherical disdyakis triacontahedron
   (the fundamental domain of the icosahedral spherical symmetry Ih).
   There are three options for the vertex from which great circles are mapped to straight lines:
   - IVEA is the vertex-oriented projection as described in the paper
   - ISEA (swapping vertices B and C) is equivalent to Snyder's 1992 projection on the icosahedron
   - RTEA (swapping vertices A and B) corresponds to extending Snyder's 1992 projection to the rhombic triacontahedron
     (the vertex in the center of the 30 rhombic faces is used as radial vertex B)

   For the trigonometric approach, most of the equations are based on basic spherical trigonometry,
   solving the spherical triangles for unknown sides and angles.

   Spherical excess:
      E = A + B + C - Pi

   Law of sines:
      sin A   sin B   sin C
      ----- = ----- = -----
      sin a   sin b   sin c

   Law of cosines (for sides):
      cos a = cos b cos c + sin b sin c cos A
      cos b = cos c cos a + sin c sin a cos B
      cos c = cos a cos b + sin a sin b cos C

   for angles:
      cos A = -cos B cos C + sin B sin C cos a
      cos B = -cos C cos A + sin C sin A cos b
      cos C = -cos A cos B + sin A sin B cos c

   Half angle formulas, e.g.:

      S = (A + B + C) / 2
                        cos(S - B) cos(S - C)
      cos(a/2) = sqrt( ---------------------- )
                            sin(B) sin(C)

   yielding, based on half angle identity:

           a               1 + cos(a)
      cos(---) = +/- sqrt( ---------- )
           2                   2

      2 cos^2(a/2) = 1 + cos(a)

      cos(a) = 2 cos^2(a/2) - 1

                            cos(S - B) cos(S - C)
      cos(a) = 2 * sqrt( ---------------------- ) ^ 2 - 1
                              sin(B) sin(C)

                2 * cos(S - B) cos(S - C)
      cos(a) = -------------------------- - 1
                      sin(B) sin(C)

   Half side formulas, e.g.:
                        sin(s) sin(s - a)
      cos(A/2) = sqrt( ---------------------- )
                          sin(b) sin(c)

   An interesting special case for RTEA (where ABD triangle does not have a right angle) is that it is possible to solve a spherical triangle when
   knowing the spherical excess (area E), one angle and its adjacent side:

    Cosine difference identity:
       cos(a - b) = cos a cos b + sin a sin b

    Y = E + Pi - B = A + C
    C = Y - A

    cos C                     = -cos A cos B + sin A sin B cos c (cosine rule for angle)
    cos(Y - A) =              = -cos A cos B + sin A sin B cos c
    cos Y cos A + sin Y sin A = -cos A cos B + sin A sin B cos c
    sin Y sin A - sin A sin B cos c = -cos A cos B - cos Y cos A
    sin A (sin Y - sin B) cos c = cos A (-cos B - cosY)
             sin A    -cos Y - cos B
    tan A = ------- = --------------------
             cos A     sin Y - sin B cos c

   which corresponds to the formula at bottom of page 39 in John Hall DT DGGS (https://ucalgary.scholaris.ca/items/1bd11f8c-5a71-48dc-a9a8-b4a8b9021008)
   citing S. Lee and D. Mortari, 2017
       Quasi‐equal area subdivision algorithm for uniform points on a sphere with application to any geographical data distribution. 103:142–151.

   However, the signs of the numerator and denumerator are negated here, which results in the correct angle when using atan2()
*/

public import IMPORT_STATIC "ecrt"
private:

import "ri5x6"
import "Vector3D"

// Define this to use the vectorial approach based on Brenton R S Recht's blog entry at
// https://brsr.github.io/2021/08/31/snyder-equal-area.html
// with further replacement of trigonometry by vector operation for the inverse as well
// The spherical trigonometry approach will still be used as a fallback for degenerate cases
// where the vectorial inverse cannot produce an accurate result.

public enum VGCRadialVertex { isea, ivea, rtea };

public class IVEAProjection : SliceAndDiceGreatCircleIcosahedralProjection
{
}

public class ISEAProjection : SliceAndDiceGreatCircleIcosahedralProjection
{
   radialVertex = isea;
}

public class RTEAProjection : SliceAndDiceGreatCircleIcosahedralProjection
{
   radialVertex = rtea;
}

public class SliceAndDiceGreatCircleIcosahedralProjection : RI5x6Projection
{
   VGCRadialVertex radialVertex; property::radialVertex = ivea;

   property VGCRadialVertex radialVertex
   {
      set
      {
         radialVertex = value;
         switch(value)
         {
            case isea:
               va = 0, vb = 2, vc = 1;
               alpha = Degrees { 90 };
               beta = Degrees { 60 };
               gamma = Degrees { 36 };
               AB = acos(sqrt((phi + 1)/3));
               AC = atan(1/phi);
               BC = atan(2/(phi*phi));
               break;
            case ivea:
               va = 0, vb = 1, vc = 2;
               alpha = Degrees { 90 };
               beta = Degrees { 36 };
               gamma = Degrees { 60 };
               AB = atan(1/phi);
               AC = acos(sqrt((phi + 1)/3));
               BC = atan(2/(phi*phi));
               break;
            case rtea:
               va = 1, vb = 0, vc = 2;
               alpha = Degrees { 36 };
               beta = Degrees { 90 };
               gamma = Degrees { 60 };
               AB = atan(1/phi);
               AC = atan(2/(phi*phi));
               BC = acos(sqrt((phi + 1)/3));
               break;
         }
         // poleFixIVEA = value == ivea;
         cosAB = cos(AB);
         cosAC = cos(AC);
         sinAC = sin(AC);
         cosBC = cos(BC);

      }
   }

   Radians beta, gamma, alpha;
   Radians AB, AC, BC;
   double cosAB, sinAC, cosAC, cosBC;
   int va, vb, vc;

   __attribute__ ((optimize("-fno-unsafe-math-optimizations")))
   static void inverseVector(const Pointd pi,
      const Pointd pai, const Pointd pbi, const Pointd pci,
      const Vector3D A, const Vector3D B, const Vector3D C,
      Vector3D P, bool bIsA)
   {
      static const Radians areaABC = Degrees { 6 }; //sphericalTriArea(A, B, C);
      double b[3];

      cartesianToBary(b, pi, pai, pbi, pci, -6);

           if(b[0] > 1 - 1E-15) { P = A; return; }
      else if(b[1] > 1 - 1E-15) { P = B; return; }
      else if(b[2] > 1 - 1E-15) { P = C; return; }

      {
         const double h = 1 - b[0];
         const double b2oh = b[2] / h;
         const Radians b2ohABC = b2oh * areaABC;
         const double halfC = sin(b2ohABC / 2);
         const double halfC2 = halfC * halfC;
         const double CC = 2 * halfC2; // Half-angle identity; 1 - sqrt(1 - S * S) is quite imprecise
         const double S = 2 * halfC * sqrt(1 - halfC2);
         const double c01 = bIsA ? cosAB : cosBC; //A.x * B.x + A.y * B.y + A.z * B.z; //A.DotProduct(B);
         const double c12 = cosAC; //B.x * C.x + B.y * C.y + B.z * C.z; //B.DotProduct(C);
         const double c20 = bIsA ? cosBC : cosAB; //C.x * A.x + C.y * A.y + C.z * A.z; //C.DotProduct(A);
         const double s12 = sinAC; // also sqrt(1 - c12*c12) and c1.length
         const double f = S * parallelepipedV + CC * (c01 * c12 - c20);
         const double g = CC * s12 * (1 + c01);
         const double f2 = f * f, g2 = g * g, gf = g * f;
         const double numerator = s12 * (f2 - g2) - 2 * gf * c12;
         const double divisor = s12 * (f2 + g2);

         if((fabs(numerator) > 1E-9 && fabs(divisor) > 1E-9))
         {
            // Optimized trigonometry-free branch equivalent to 2 SLERPs for non-degnerate cases
            const double oODivisor = 1.0 / divisor;
            const double ap = Max(0.0, numerator * oODivisor);
            const double bp = Min(1.0, 2 * gf * oODivisor);
            const Vector3D p
            {
               ap * B.x + bp * C.x,
               ap * B.y + bp * C.y,
               ap * B.z + bp * C.z
            };

            const double av = A.x * p.x + A.y * p.y + A.z * p.z; //A.DotProduct(p);
            const double bv = 1 + h*h * (av - 1);
            const double bvp = h * sqrt((1 + bv) / (1 + av));
            const double avp = bv - av * bvp;

            P =
            {
               avp * A.x + bvp * p.x,
               avp * A.y + bvp * p.y,
               avp * A.z + bvp * p.z
            };
         }
         else
         {
            // 2-SLERPs fallback for the degenerate cases where the optimized linear algebra version breaks down
            Vector3D D;
            const Radians areaABC = Degrees { 6 }; //beta + gamma + alpha - Pi;
            const double b1pb2 = b[1] + b[2];
            const double upOverupPvp = b1pb2 < 1E-11 ? 0 : b[bIsA ? 1 : 2] / b1pb2;
            const Radians rhoPlusDelta = beta + gamma - upOverupPvp * areaABC; //(beta + gamma + alpha - Pi);
            const Radians areaABD = rhoPlusDelta + alpha - Pi;  // T-U = rho + delta + alpha - Pi
            Radians BD, x;

            if(fabs(areaABD) < 1E-11)
            {
               // (B or C) vertex at angle alpha (90 degrees for ISEA and IVEA)
               if(bIsA) D = B; else D = C;
               BD = AB;
            }
            else if(fabs(areaABD - areaABC) < 1E-13)
            {
               // (B or C) vertex at angle gamma
               if(bIsA) D = C; else D = B;
               BD = BC;
            }
            else
            {
               Radians AD = 2 * atan2(g, f);
               slerpAngle(D, B, C, AC, AD);
               BD = acos(Max(-1.0, Min(1.0, A.x * D.x + A.y * D.y + A.z * D.z)));
            }

            // A is the vertex from which great circles radiate (angle beta)
            x = 2 * asin((1 - b[0]) * sin(BD/2)); // x' / (x' + y') = 1 - b_0
            slerpAngle(P, A, D, BD, x);
         }
      }
   }

   __attribute__ ((optimize("-fno-unsafe-math-optimizations")))
   void inverseIcoFace(int face, const Pointd v,
      const Pointd p1, const Pointd p2, const Pointd p3,
      const Vector3D v1, const Vector3D v2, const Vector3D v3,
      Vector3D out)
   {
      double b[3];
      cartesianToBary(b, v, p1, p2, p3, -1);
      {
         int subTri =
            (b[0] <= b[1] && b[0] <= b[2]) ? (b[1] < b[2] ? 0 : 1) :
            (b[1] <= b[0] && b[1] <= b[2]) ? (b[0] < b[2] ? 2 : 3) :
          /*(b[2] <= b[0] && b[2] <= b[1]) ?*/b[0] < b[1] ? 4 : 5;
         int tri3rd = subTri >> 1;
         const Pointd * p5x6[3] =
         {
            &ico56Mids[face][tri3rd],
            subTri == 0 || subTri == 2 ? p3 :
            subTri == 1 || subTri == 4 ? p2 : p1, //subTri == 3 || subTri == 5
            &ico56Center[face]
         };
         const Vector3D * v3D[3] =
         {
            &ico3rdMids[face][tri3rd],
            subTri == 0 || subTri == 2 ? v3 :
            subTri == 1 || subTri == 4 ? v2 : v1, //subTri == 3 || subTri == 5
            &icoCentroids[face]
         };
         bool bIsA = (radialVertex == ivea) ^ (subTri == 0 || subTri == 3 || subTri == 4);
         {
            int a = vb, b = bIsA ? va : vc, c = bIsA ? vc : va;
            inverseVector(v, p5x6[a], p5x6[b], p5x6[c], v3D[a], v3D[b], v3D[c], out, bIsA);
         }
      }
   }

   private static inline double ::sqrtOneMinusDotOver2(const Vector3D a, const Vector3D b)
   {
      // This returns the equivalent of √((1 - (a ⋅ b)) / 2)
      // avoid is used to avoid catastrophic cancellation between 1 and a dot product close to 1
      // Credits to Felix Palmer @ a5geo.org for this approach using the normalized midpoint
      Vector3D midAB, c;
      double D;

      midAB.Normalize({ (a.x + b.x) / 2, (a.y + b.y) / 2, (a.z + b.z) / 2 });
      c.CrossProduct(a, midAB);
      D = c.length;
      if(D < 1E-8)
         D = Vector3D { a.x - b.x, a.y - b.y, a.z - b.z }.length / 2;
      return D;
   }

   __attribute__ ((optimize("-fno-unsafe-math-optimizations")))
   static void forwardVector(const Vector3D v,
      const Vector3D A, const Vector3D B, const Vector3D C,
      const Pointd pai, const Pointd pbi, const Pointd pci,
      Pointd out)
   {
      Vector3D c1, c2, p;
      double h, b[3];
       // The SDT triangle area is always 6 degrees
      static const Radians areaABC = Degrees { 6 }; //sphericalTriArea(A, B, C);
      Radians areaABp;

      // c1.CrossProduct(A, v);
      c1.x = A.y * v.z - A.z * v.y;
      c1.y = A.z * v.x - A.x * v.z;
      c1.z = A.x * v.y - A.y * v.x;

      // c2.CrossProduct(B, C);
      c2.x = B.y * C.z - B.z * C.y;
      c2.y = B.z * C.x - B.x * C.z;
      c2.z = B.x * C.y - B.y * C.x;

      // p.CrossProduct(c1, c2);
      p.x = c1.y * c2.z - c1.z * c2.y;
      p.y = c1.z * c2.x - c1.x * c2.z;
      p.z = c1.x * c2.y - c1.y * c2.x;

      p.Normalize(p);

      areaABp = Max(0.0, sphericalTriArea(A, B, p));

      h = sqrtOneMinusDotOver2(A, v) / sqrtOneMinusDotOver2(A, p);

      b[0] = 1 - h;
      b[2] = Min(h, h * areaABp / areaABC);
      b[1] = h - b[2];
      baryToCartesian(b, out, pai, pbi, pci);
   }

   private static inline int findSubTri(int face, const Vector3D v)
   {
      int best3rd = 0, best6th = 0, i;
      double d, bestDot = -MAXDOUBLE;
      const Vector3D * c;
      // This is the cosine of the half distance to the nearest centroid over all (which is on different icosahedron triangle)
      // cos(15.4210090071508551/2)
      // (sqrt(6)*sqrt(480 + 216*sqrt(5) + sqrt(3)*sqrt(2*sqrt(5) + 5)*(47*sqrt(5) + 109)))/(6*sqrt(80 + 36*sqrt(5) + sqrt(3)*sqrt(2*sqrt(5) + 5)*(8*sqrt(5) + 19)))

      // This is the cosine of the half distance to the nearest centroid within the same icosahedron face
      // cos(22.8025282605464/2)
      // sqrt((5 + 5/sqrt(5) + 8*(1 + 2/sqrt(5))/sqrt(3 + 6/sqrt(5))) / (2*(3 + 2/sqrt(5) + 4*(1 + 2/sqrt(5))/sqrt(3 + 6/sqrt(5)))))
      static const double earlyAccept3rd = 0.9802668134226932631948092150332116;

      // Cosine of the half distance between the two sibling SDT's centroids (within same 1/3rd face)
      // cos(21.2120235137118/2)
      /*{ // These are symbological representations of that value using radicals (which unfortunately does not seem to simplify further)
         double s5 = sqrt(5), r2 = sqrt(2), r3 = sqrt(3), r6 = sqrt(6), r10 = sqrt(10), r15 = sqrt(15), r30 = sqrt(30);
         double A = sqrt(s5 + 5), B = sqrt(2*s5 + 5), C = sqrt(3*s5 + 7), D = sqrt(4*s5 + 9), E = sqrt(11*s5 + 25);
         double G = sqrt(29*s5 + 65), H = sqrt((s5 + 3) * (s5 + 3) * (s5 + 3));
         double tv1 = 3 * r2 * C, tv2 = r6 * H, tv3 = 3 * (r2 + r10) * C, tv4 = 2 * r6 * H;
         double F1 = 6 * E + 12 * r2 * D + r6 * H * A;
         double F2 = 3 * r2 * (r2 + r10) * E + 2 * r6 * H * A + 12 * r2 * (1 + s5) * D;
         double L1 = 3 * r30 * E + 7 * r6 * E + 18 * s5 * B + 42 * B + 8 * r15 * D + 20 * r3 * D + 99 * s5 + 225;
         double M1 = r6 * (s5 + 3) * A + 3 * r2 * G + 3 * r2 * (1 + s5) * C;
         double M2 = s5 * A + 3 * A + 2 * r3 * C + r3 * G;
         double P = 25 * 11 * 509 * s5 + 5 * 59 * 1061 + (4 * r6 * (199*s5 + 445)) * B * E
              + 20 * D * ((r2 * (55*s5 + 123)) * E + (r3 * (110*s5 + 246)) * B)
              + 60 * ((r6 * (72*s5 + 161)) * E + ((432*s5 + 2 * 3 * 7 * 23)) * B + (r3 * (199*s5 + 445)) * D);
         double sqrtP = sqrt(P);
         double P_quarter = sqrt(sqrt(P));
         double S = r6 * r10 * (4 * (tv1 + tv2) * F1 + (tv3 + tv4) * F2);
         double inner = S + 48 * (24 * sqrtP + (r6 * M1 * M2 * sqrtP) / L1);
         double result = sqrt(inner) / (48 * P_quarter);
         printf("Final result = %.15f\n", result);
      }*/
      // sqrt(sqrt(6)*(sqrt(10)*(4*(3*sqrt(2)*sqrt(3*sqrt(5) + 7) + sqrt(6)*(sqrt(5) + 3)^(1.5))*(6*sqrt(11*sqrt(5) + 25) + 12*sqrt(2)*sqrt(4*sqrt(5) + 9) + sqrt(6)*(sqrt(5) + 3)^(1.5)*sqrt(sqrt(5) + 5)) + (3*(sqrt(2) + sqrt(10))*sqrt(3*sqrt(5) + 7) + 2*sqrt(6)*(sqrt(5) + 3)^(1.5))*(3*sqrt(2)*(sqrt(2) + sqrt(10))*sqrt(11*sqrt(5) + 25) + 2*sqrt(6)*(sqrt(5) + 3)^(1.5)*sqrt(sqrt(5) + 5) + 12*sqrt(2)*(1 + sqrt(5))*sqrt(4*sqrt(5) + 9)))*(3*sqrt(30)*sqrt(11*sqrt(5) + 25) + 7*sqrt(6)*sqrt(11*sqrt(5) + 25) + 18*sqrt(5)*sqrt(2*sqrt(5) + 5) + 42*sqrt(2*sqrt(5) + 5) + 8*sqrt(15)*sqrt(4*sqrt(5) + 9) + 20*sqrt(3)*sqrt(4*sqrt(5) + 9) + 99*sqrt(5) + 225) + 48*(sqrt(6)*(sqrt(5) + 3)*sqrt(sqrt(5) + 5) + 3*sqrt(2)*sqrt(29*sqrt(5) + 65) + 3*sqrt(2)*(1 + sqrt(5))*sqrt(3*sqrt(5) + 7))*(sqrt(5)*sqrt(sqrt(5) + 5) + 3*sqrt(sqrt(5) + 5) + 2*sqrt(3)*sqrt(3*sqrt(5) + 7) + sqrt(3)*sqrt(29*sqrt(5) + 65))*sqrt(398*sqrt(5)*(11*sqrt(5) + 25) + 2388*sqrt(5)*(2*sqrt(5) + 5) + 1520*sqrt(5)*(4*sqrt(5) + 9) + 796*sqrt(30)*sqrt(2*sqrt(5) + 5)*sqrt(11*sqrt(5) + 25) + 1780*sqrt(6)*sqrt(2*sqrt(5) + 5)*sqrt(11*sqrt(5) + 25) + 1100*sqrt(10)*sqrt(4*sqrt(5) + 9)*sqrt(11*sqrt(5) + 25) + 2460*sqrt(2)*sqrt(4*sqrt(5) + 9)*sqrt(11*sqrt(5) + 25) + 2200*sqrt(15)*sqrt(2*sqrt(5) + 5)*sqrt(4*sqrt(5) + 9) + 4920*sqrt(3)*sqrt(2*sqrt(5) + 5)*sqrt(4*sqrt(5) + 9) + 4320*sqrt(30)*sqrt(11*sqrt(5) + 25) + 9660*sqrt(6)*sqrt(11*sqrt(5) + 25) + 25920*sqrt(5)*sqrt(2*sqrt(5) + 5) + 57960*sqrt(2*sqrt(5) + 5) + 11940*sqrt(15)*sqrt(4*sqrt(5) + 9) + 26700*sqrt(3)*sqrt(4*sqrt(5) + 9) + 104405*sqrt(5) + 236825)) + 1152*(3*sqrt(30)*sqrt(11*sqrt(5) + 25) + 7*sqrt(6)*sqrt(11*sqrt(5) + 25) + 18*sqrt(5)*sqrt(2*sqrt(5) + 5) + 42*sqrt(2*sqrt(5) + 5) + 8*sqrt(15)*sqrt(4*sqrt(5) + 9) + 20*sqrt(3)*sqrt(4*sqrt(5) + 9) + 99*sqrt(5) + 225)*sqrt(398*sqrt(5)*(11*sqrt(5) + 25) + 2388*sqrt(5)*(2*sqrt(5) + 5) + 1520*sqrt(5)*(4*sqrt(5) + 9) + 796*sqrt(30)*sqrt(2*sqrt(5) + 5)*sqrt(11*sqrt(5) + 25) + 1780*sqrt(6)*sqrt(2*sqrt(5) + 5)*sqrt(11*sqrt(5) + 25) + 1100*sqrt(10)*sqrt(4*sqrt(5) + 9)*sqrt(11*sqrt(5) + 25) + 2460*sqrt(2)*sqrt(4*sqrt(5) + 9)*sqrt(11*sqrt(5) + 25) + 2200*sqrt(15)*sqrt(2*sqrt(5) + 5)*sqrt(4*sqrt(5) + 9) + 4920*sqrt(3)*sqrt(2*sqrt(5) + 5)*sqrt(4*sqrt(5) + 9) + 4320*sqrt(30)*sqrt(11*sqrt(5) + 25) + 9660*sqrt(6)*sqrt(11*sqrt(5) + 25) + 25920*sqrt(5)*sqrt(2*sqrt(5) + 5) + 57960*sqrt(2*sqrt(5) + 5) + 11940*sqrt(15)*sqrt(4*sqrt(5) + 9) + 26700*sqrt(3)*sqrt(4*sqrt(5) + 9) + 104405*sqrt(5) + 236825))/(48*sqrt(3*sqrt(30)*sqrt(11*sqrt(5) + 25) + 7*sqrt(6)*sqrt(11*sqrt(5) + 25) + 18*sqrt(5)*sqrt(2*sqrt(5) + 5) + 42*sqrt(2*sqrt(5) + 5) + 8*sqrt(15)*sqrt(4*sqrt(5) + 9) + 20*sqrt(3)*sqrt(4*sqrt(5) + 9) + 99*sqrt(5) + 225)*(398*sqrt(5)*(11*sqrt(5) + 25) + 2388*sqrt(5)*(2*sqrt(5) + 5) + 1520*sqrt(5)*(4*sqrt(5) + 9) + 796*sqrt(30)*sqrt(2*sqrt(5) + 5)*sqrt(11*sqrt(5) + 25) + 1780*sqrt(6)*sqrt(2*sqrt(5) + 5)*sqrt(11*sqrt(5) + 25) + 1100*sqrt(10)*sqrt(4*sqrt(5) + 9)*sqrt(11*sqrt(5) + 25) + 2460*sqrt(2)*sqrt(4*sqrt(5) + 9)*sqrt(11*sqrt(5) + 25) + 2200*sqrt(15)*sqrt(2*sqrt(5) + 5)*sqrt(4*sqrt(5) + 9) + 4920*sqrt(3)*sqrt(2*sqrt(5) + 5)*sqrt(4*sqrt(5) + 9) + 4320*sqrt(30)*sqrt(11*sqrt(5) + 25) + 9660*sqrt(6)*sqrt(11*sqrt(5) + 25) + 25920*sqrt(5)*sqrt(2*sqrt(5) + 5) + 57960*sqrt(2*sqrt(5) + 5) + 11940*sqrt(15)*sqrt(4*sqrt(5) + 9) + 26700*sqrt(3)*sqrt(4*sqrt(5) + 9) + 104405*sqrt(5) + 236825)^(0.25))
      static const double earlyAccept6th = 0.9829160426524585629980328985973081873244;

      for(i = 0; i < 3; i++)
      {
         c = &ico3rdCentroids[face][i];
         d = c->x * v.x + c->y * v.y + c->z * v.z;
         if(d > bestDot)
         {
            bestDot = d, best3rd = i;
            if(d > earlyAccept3rd)
               break;
         }
      }

      bestDot = -MAXDOUBLE;
      for(i = 0; i < 2; i++)
      {
         c = &ico6thCentroids[face][best3rd][i];
         d = c->x * v.x + c->y * v.y + c->z * v.z;
         if(d > bestDot)
         {
            bestDot = d, best6th = i;
            if(d > earlyAccept6th)
               break;
         }
      }
      return 2 * best3rd + best6th;
   }

   void forwardIcoFace(int face, const Vector3D v,
      const Vector3D v1, const Vector3D v2, const Vector3D v3,
      const Pointd p1, const Pointd p2, const Pointd p3,
      Pointd out)
   {
      int subTri = findSubTri(face, v), tri3rd = subTri >> 1;
      const Pointd * p5x6[3] =
      {
         &ico56Mids[face][tri3rd],
         subTri == 0 || subTri == 2 ? p3 :
         subTri == 1 || subTri == 4 ? p2 : p1, //subTri == 3 || subTri == 5
         &ico56Center[face]
      };
      const Vector3D * v3D[3] =
      {
         &ico3rdMids[face][tri3rd],
         subTri == 0 || subTri == 2 ? v3 :
         subTri == 1 || subTri == 4 ? v2 : v1, //subTri == 3 || subTri == 5
         &icoCentroids[face]
      };
      bool bIsA = (radialVertex == ivea) ^ (subTri == 0 || subTri == 3 || subTri == 4);
      int a = vb, b = bIsA ? va : vc, c = bIsA ? vc : va;
      forwardVector(v, v3D[a], v3D[b], v3D[c], p5x6[a], p5x6[b], p5x6[c], out);
   }
}



================================================
FILE: src/projections/rHEALPix.ec
================================================
public import IMPORT_STATIC "ecrt"
private:

import "GeoExtent"
import "authalic"

public class HEALPixProjection
{
   double cp[2][AUTH_ORDER];

   HEALPixProjection()
   {
      authalicSetup(wgs84Major, wgs84Minor, cp);
   }

   Radians latAuthalicToGeodetic(Radians phi)
   {
      return applyCoefficients(cp[1], phi);
   }

   Radians latGeodeticToAuthalic(Radians phi)
   {
      return applyCoefficients(cp[0], phi);
   }

   public virtual bool forward(const GeoPoint p, Pointd v)
   {
      double sinLat = sin(latGeodeticToAuthalic(p.lat));
      if(fabs(sinLat) <= 2/3.0)
      {
         // Equatorial regions
         v.x = (Radians)p.lon;
         v.y = 3 * Pi/8 * sinLat;
      }
      else
      {
         // Polar caps
         int n = (Radians)p.lon > Pi/2 ? 3 : (Radians)p.lon > 0 ? 2 : (Radians)p.lon > -Pi / 2 ? 1 : 0;
         double s = sqrt(1 - fabs(sinLat));
         Radians dLon = (Radians)p.lon - (-Pi + Pi/2 * n);
         double width = sqrt(3) * Pi/2 * s;
         v.x = -Pi + Pi/2 * n + (Pi/2 - width) / 2 + dLon * width / (Pi/2);
         v.y = Sgn((Radians)p.lat) * (Pi - width) / 2;
      }
      return true;
   }

   public virtual bool inverse(const Pointd v, GeoPoint result, bool oddGrid)
   {
      bool r = true;
      if(fabs(v.y) <= Pi/4)
      {
         // Equatorial region
         result.lon = (Radians)v.x + (((Radians)v.x < -Pi - 1E-11) ? 2 * Pi : 0);
         result.lat = latAuthalicToGeodetic(asin(8 * v.y / (3 * Pi)));
      }
      else
      {
         // Polar caps
         int n = (Radians)v.x > Pi/2 ? 3 : (Radians)v.x > 0 ? 2 : (Radians)v.x > -Pi / 2 ? 1 : 0;
         double width = Pi - 2*fabs(v.y);
         if(width > 1E-15)
         {
            double s = 2 * width / (sqrt(3) * Pi);
            Radians dLon = (v.x - (- Pi + Pi/2 * n + (Pi/2 - width) / 2)) * Pi/2 / width;
            if(dLon < 0 || dLon > Pi/2 + 1E-15)
            {
               if(dLon < 0 && dLon > -1E-11)
                  dLon = 0;
               else if(dLon > 0 && dLon < Pi/2 + 1E-11)
                  dLon = Pi/2;
               else
                  r = false;
            }
            result.lat = Sgn(v.y) * latAuthalicToGeodetic(asin(1 - s*s));
            result.lon = dLon + (-Pi + Pi/2 * n);
         }
         else
            result = { Sgn(v.y) * 90, 0 };
      }
      return r;
   }
}

public class rHEALPixProjection : HEALPixProjection
{
   Degrees meridian; meridian = 50;

   public virtual bool forward(const GeoPoint ip, Pointd v)
   {
      int sgn;
      double y;
      GeoPoint p { ip.lat, wrapLon(ip.lon - meridian) };

      HEALPixProjection::forward(p, v);

      sgn = v.y < 0 ? -1 : 1;
      y = v.y * sgn;
      if(y <= Pi/4)
         // Equatorial region
         return true;
      else
      {
         // Polar caps
         int n = (Radians)p.lon > Pi/2 ? 3 : (Radians)p.lon > 0 ? 2 : (Radians)p.lon > -Pi / 2 ? 1 : 0;
         switch(n)
         {
            case 0: return true;
            case 1: v = { -Pi/4 - y, sgn * (v.x + 3*Pi/4) }; break;
            case 2: v = { - Pi/2 - v.x, sgn * (Pi - y) }; break;
            case 3: v = { y - 5*Pi/4, sgn * (5*Pi/4 - v.x) }; break;
         }
      }
      return true;
   }

   int getPolarSection(const Pointd v)
   {
      int n = -1;
      int sgn = v.y < 0 ? -1 : 1;
      double y = v.y * sgn;
      if(y >= Pi/4 && v.x <= -Pi/2)
      {
         double dx = Pi + v.x, dy = 3*Pi/4 - y, mdx = Pi/2 - dx;
         // The epsilon here helps with detecting crossing dateline
         n = (dx > dy) ? (mdx > dy ? 2 : 1) : (mdx > dy + 1E-15 ? 3 : 0);
      }
      return n;
   }

   public virtual bool inverse(const Pointd v, GeoPoint result, bool oddGrid)
   {
      bool r = false;
      int sgn = v.y < 0 ? -1 : 1;
      double y = v.y * sgn;
      if(y <= Pi/4 + 1E-15)
         // Equatorial region
         r = HEALPixProjection::inverse(v, result, oddGrid);
      else if(v.x <= -Pi/2)
      {
         // Polar caps
         double dx = Pi + v.x, dy = 3*Pi/4 - y, mdx = Pi/2 - dx;
         int n = (dx > dy) ? (mdx > dy ? 2 : 1) : (mdx > dy ? 3 : 0);
         Pointd vv;

         switch(n)
         {
            case 0: vv = v; break;
            case 1: vv = { y - 3*Pi/4, sgn * (-Pi/4 - v.x) }; break;
            case 2: vv = { -v.x - Pi/2, sgn * (Pi - y) }; break;
            case 3: vv = { 5*Pi/4 - y, sgn * (5*Pi/4 + v.x) }; break;
         }
         r = HEALPixProjection::inverse(vv, result, oddGrid);
      }
      if(r && fabs(fabs((Radians)result.lat) - Pi/2) > 1E-11)
         result.lon = wrapLon(result.lon + meridian);
      return r;
   }
}



================================================
FILE: tests/dggalTest.ec
================================================
public import IMPORT_STATIC "ecrt"
import "testingFramework"
import IMPORT_STATIC "dggal"

import "isea3HTests"

public class DGGSUnitTest : eTest
{
   void test(DGGSTestCase c)
   {
      DGGRS dggrs = null;
      String testCase = PrintString(c.dggrs, "/", c.zoneID);
      char zoneID[100];
      Class dggrsClass = eSystem_FindClass(__thisModule, c.dggrs);

      if(dggrsClass)
         dggrs = eInstance_New(dggrsClass);

      if(!dggrs)
         fail("DGGRS", testCase, "of unrecognized DGGRS");

      dggrs.getZoneTextID(c.key, zoneID);

      if(strcmp(zoneID, c.zoneID))
         fail("ZoneID", testCase, "of mismatched ZoneID");
      else
      {
         GeoPoint centroid { };
         GeoExtent extent { };
         Array<DGGRSZone> parents = null, children = null, neighbors = null;
         double area = dggrs.getZoneArea(c.key);
         bool mismatchedParent = false, mismatchedChild = false, mismatchedNeighbor = false;
         bool badCentroidParent = false, badCentroidChild = false;
         int i;
         DGGRSZone key64bit = nullZone;
         DGGRSZone cParent = nullZone, cChild = nullZone;
         bool badIsCChild = false;
         bool badEdgeCount = false;
         bool mismatchedFirstSubZone = false, mismatchedSubZones = false;
         bool mismatchedExtent = false;
         DGGRSZone key = c.key;
         DGGRSZone p[3], n[6], ch[9];
         int num;

         key64bit = dggrs.getZoneFromTextID(c.zoneID);

         dggrs.getZoneWGS84Centroid(key, centroid);
         dggrs.getZoneWGS84Extent(key, extent);

         num = dggrs.getZoneParents(key, p);
         parents = { size = num };
         memcpy(parents.array, p, sizeof(DGGRSZone) * num);

         num = dggrs.getZoneNeighbors(key, n, null);
         if(dggrs.countZoneEdges(key) != num)
            badEdgeCount = true;
         neighbors = { size = num };
         memcpy(neighbors.array, n, sizeof(DGGRSZone) * num);

         num = dggrs.getZoneChildren(key, ch);
         children = { size = num };
         memcpy(children.array, ch, sizeof(DGGRSZone) * num);

         cParent = dggrs.getZoneCentroidParent(key);
         cChild = dggrs.getZoneCentroidChild(key);

         if(dggrs.isZoneCentroidChild(key) != (!c.parents || (c.parents && c.parents.GetCount() == 1)))
            badIsCChild = true;

         if(c.firstSubZones)
         {
            for(s : c.firstSubZones)
            {
               int d = &s;
               const String k = s;
               DGGRSZone sz = dggrs.getFirstSubZone(key, d);
               char szID[100];

               dggrs.getZoneTextID(sz, szID);
               if(strcmp(szID, k))
               {
                  PrintLn("Mismatched first sub zone of relative depth ", d, " (", szID, " where ", k, " expected)");
                  mismatchedFirstSubZone = true;
                  break;
               }
            }
         }

         if(c.subZones)
         {
            for(s : c.subZones)
            {
               int d = &s;
               Array<const String> expectedSZ = s;
               Array<DGGRSZone> sz = dggrs.getSubZones(key, d);
               int i;

               if(!sz || sz.count != expectedSZ.count)
               {
                  PrintLn("Mismatched number of sub zones for relative depth ", d, " (", sz ? sz.count : 0, " where ", expectedSZ.count, " expected)");
                  mismatchedSubZones = true;
                  break;
               }

               for(i = 0; i < sz.count; i++)
               {
                  DGGRSZone k = sz[i];
                  char szID[100];
                  dggrs.getZoneTextID(k, szID);
                  if(strcmp(szID, expectedSZ[i]))
                  {
                     PrintLn("Mismatched sub zone for relative depth ", d, " (", szID, " where ", expectedSZ[i], " expected)");
                     mismatchedSubZones = true;
                     break;
                  }
               }
            }
         }

         if((c.centroidChild == null) != (cChild == nullZone))
            badCentroidChild = true;
         else if(c.centroidChild)
         {
            char cZone[100];

            dggrs.getZoneTextID(cChild, cZone);
            if(!c.centroidChild || strcmp(cZone, c.centroidChild))
            {
               PrintLn("Centroid child is: ", cZone);
               badCentroidChild = true;
            }
         }

         if((c.centroidParent == null) != (cParent == nullZone))
            badCentroidParent = true;
         else if(c.centroidParent)
         {
            char pZone[100];

            dggrs.getZoneTextID(cParent, pZone);
            if(strcmp(pZone, c.centroidParent))
            {
               PrintLn("Centroid parent is: ", pZone);
               badCentroidParent = true;
            }
         }

         if((c.parents ? c.parents.GetCount() : 0) != (parents ? parents.count : 0))
            mismatchedParent = true;
         else if(c.parents)
         {
            for(i = 0; i < c.parents.GetCount(); i++)
            {
               char pZone[100];

               dggrs.getZoneTextID(parents[i], pZone);
               if(strcmp(pZone, c.parents[i]))
               {
                  mismatchedParent = true;
                  break;
               }
            }
         }

         if((c.children ? c.children.GetCount() : 0) != (children ? children.count : 0))
            mismatchedChild = true;
         else if(c.children)
         {
            for(i = 0; i < c.children.GetCount(); i++)
            {
               char cZone[100];

               dggrs.getZoneTextID(children[i], cZone);
               if(strcmp(cZone, c.children[i]))
               {
                  mismatchedChild = true;
                  break;
               }
            }
         }

         if((c.neighbors ? c.neighbors.GetCount() : 0) != (neighbors ? neighbors.count : 0))
            mismatchedNeighbor = true;
         else if(c.children)
         {
            for(i = 0; i < c.neighbors.GetCount(); i++)
            {
               char nZone[100];

               dggrs.getZoneTextID(neighbors[i], nZone);
               if(strcmp(nZone, c.neighbors[i]))
               {
                  mismatchedNeighbor = true;
                  break;
               }
            }
         }

         if(fabs((double)extent.ll.lat - (double)c.wgs84Extent.ll.lat) > epsilonExtent ||
            fabs((double)extent.ll.lon - (double)c.wgs84Extent.ll.lon) > epsilonExtent ||
            fabs((double)extent.ur.lat - (double)c.wgs84Extent.ur.lat) > epsilonExtent ||
            fabs((double)extent.ur.lon - (double)c.wgs84Extent.ur.lon) > epsilonExtent)
         {
            if((fabs((double)extent.ll.lat - -90) > 1E-11 && fabs((double)extent.ur.lat - 90) > 1E-11) ||
               fabs((double)extent.ll.lat - (double)c.wgs84Extent.ll.lat) > epsilonExtentPole ||
               fabs((double)extent.ll.lon - (double)c.wgs84Extent.ll.lon) > epsilonExtentPole ||
               fabs((double)extent.ur.lat - (double)c.wgs84Extent.ur.lat) > epsilonExtentPole ||
               fabs((double)extent.ur.lon - (double)c.wgs84Extent.ur.lon) > epsilonExtentPole)
               mismatchedExtent = true;
         }

         delete parents;
         delete children;
         delete neighbors;

         if(key64bit != c.key)
            fail("Zone key", testCase, "of mismatched 64-bit key");
         else if(badEdgeCount)
            fail("Edge Count", testCase, "of mismatched count of edges");
         else if(badIsCChild)
            fail("IsCentroidChild", testCase, "of wrong isCentroidChild property");
         else if(fabs(area - c.area) / c.area > epsilonArea)
         {
            PrintLn("area: ", area, " but expected ", c.area, " (", c.area - area, " delta)");
            fail("Zone area", testCase, "of mismatched zone area");
         }
         else if(fabs((double)centroid.lat - (double)c.centroid.lat) > epsilonCentroid ||
                 fabs((double)centroid.lon - (double)c.centroid.lon) > epsilonCentroid)
         {
            PrintLn("centroid: ", centroid, " but expected ", c.centroid,
               " (", (double)c.centroid.lat - (double)centroid.lat, ", ", (double)c.centroid.lon - (double)centroid.lon, " delta)");
            fail("Centroid", testCase, "of mismatched centroid");
         }
         else if(mismatchedExtent)
         {
            PrintLn("extent: ", extent, " but expected ", c.wgs84Extent);
            fail("Extent", testCase, "of mismatched extent");
         }
         else if(badCentroidParent)
            fail("Centroid Parent", testCase, "of mismatched centroid parent");
         else if(badCentroidChild)
            fail("Centroid Child", testCase, "of mismatched centroid child");
         else if(mismatchedParent)
            fail("Parents", testCase, "of mismatched parents");
         else if(mismatchedChild)
            fail("Children", testCase, "of mismatched children");
         else if(mismatchedNeighbor)
            fail("Neighbors", testCase, "of mismatched neighbors");
         else if(mismatchedFirstSubZone)
            fail("FirstSubZones", testCase, "of mismatched first subzones");
         else if(mismatchedSubZones)
            fail("SubZones", testCase, "of mismatched subzones");
         else
            pass("DGGS zone checks", testCase);
      }
      delete dggrs;
      delete testCase;
   }

   void testSubZones(subclass(DGGRS) dggrsClass, int maxParentLevel, int maxDepth)
   {
      int pLevel;
      bool success = true;
      DGGRS dggrs = eInstance_New(dggrsClass);
      char thisTest[256];

      sprintf(thisTest, "%s parent level 0..%d / depth 0..%d",
         ((Class)dggrsClass).name, maxParentLevel, maxDepth);

      PrintLn("Testing ", ((Class)dggrsClass).name, "...");

      for(pLevel = 0; pLevel <= maxParentLevel; pLevel++)
      {
         Array<DGGRSZone> allZones = dggrs.listZones(pLevel, wholeWorld);
         if(allZones)
         {
            uint64 expectedZones = dggrs.countZones(pLevel);
            int depth;
            PrintLn("Testing sub-zones of level ", pLevel, " zones");

            if(allZones.count != expectedZones)
            {
               PrintLn("Expected: ", expectedZones, " zones, but ", allZones.count, " returned");
               fail("DGGS sub-zones", thisTest, "of unexpected number of top-level zones listed");
               success = false;
            }

            for(depth = 0; depth <= maxDepth; depth++)
            {
               for(z : allZones)
               {
                  DGGRSZone zone = z;
                  int64 nz = dggrs.countSubZones(zone, depth);
                  Array<DGGRSZone> subZones = dggrs.getSubZones(zone, depth);
                  char zoneID[100];

                  dggrs.getZoneTextID(zone, zoneID);

                  if(!subZones)
                  {
                     skip("DGGS sub-zones", zoneID /*thisTest*/, "of null sub-zones returned");
                     //break;
                  }
                  else if(nz != (subZones ? subZones.count : 0))
                  {
                     PrintLn("Parent Level ", pLevel, ", Depth ", depth, ", Zone { ", zoneID, " }: "
                        "subZones count: ", subZones ? subZones.count : 0, ", expected: ", nz);
                     fail("DGGS sub-zones", thisTest, "of mismatched sub-zones count");
                     success = false;
                  }
                  else if(subZones)
                  {
                     HashTable<DGGRSZone> table { initSize = subZones.count };
                     int i;
                     for(i = 0; i < subZones.count; i++)
                     {
                        char szID[256];
                        dggrs.getZoneTextID(subZones[i], szID);

                        if(subZones[i] == nullZone)
                        {
                           PrintLn("Parent Level ", pLevel, ", Depth ", depth, ", Zone ", zoneID, ": null sub-zone at index ", i);
                           fail("DGGS sub-zones", thisTest, "of bad sub-zone");
                           success = false;
                           break;
                        }
                        else if(!table.Add(subZones[i]))
                        {
                           PrintLn("Parent Level ", pLevel, ", Depth ", depth, ", Zone ", zoneID, ": duplicate sub-zone at index ", i);
                           fail("DGGS sub-zones", thisTest, "of duplicate sub-zone");
                           success = false;
                           break;
                        }
                        else if(depth > 0 && !dggrs.zoneHasSubZone(zone, subZones[i]))
                        {
                           PrintLn("Parent Level ", pLevel, ", Depth ", depth, ", Zone ", zoneID, ": sub-zone ", szID, " not recognized");
                           fail("DGGS sub-zones", thisTest, "of undetected sub-zone");
                           // dggrs.zoneHasSubZone(zone, subZones[i]);
                           success = false;
                        }
                        /*else if(depth > 0 && dggrs.getSubZoneAtIndex(zone, depth, i) != subZones[i])
                        {
                           // DGGRSZone sz2 = dggrs.DGGRS::getSubZoneAtIndex(zone, depth, i);
                           // DGGRSZone sz = dggrs.getSubZoneAtIndex(zone, depth, i);
                           fail("DGGS sub-zones", thisTest, "of unexpected result from getSubZoneAtIndex()");
                           success = false;
                        }
                        else if(depth > 0 && dggrs.getSubZoneIndex(zone, subZones[i]) != i)
                        {
                           // int64 index2 = dggrs.DGGRS::getSubZoneIndex(zone, subZones[i]);
                           // int64 index = dggrs.getSubZoneIndex(zone, subZones[i]);
                           fail("DGGS sub-zones", thisTest, "of unexpected result from getSubZoneIndex()");
                           success = false;
                        }*/
                     }
                     if(success && depth > 0)
                     {
                        for(i = 0; i < subZones.count; i++)
                        {
                           DGGRSZone sz = subZones[i];
                           DGGRSZone nb[6];
                           int j, n;

                           n = dggrs.getZoneNeighbors(sz, nb, null);

                           for(j = 0; j < n; j++)
                           {
                              if(!table.Find(nb[j]))
                              {
                                 if(dggrs.zoneHasSubZone(zone, nb[j]))
                                 {
                                    char szID[256];
                                    dggrs.getZoneTextID(nb[j], szID);

                                    PrintLn("Parent Level ", pLevel, ", Depth ", depth, ", Zone ", zoneID, ": sub-zone ", szID, " wrongly recognized");
                                    fail("DGGS sub-zones", thisTest, "of bad sub-zone result");

                                    dggrs.zoneHasSubZone(zone, nb[j]);
                                    success = false;
                                 }
                              }
                           }
                        }
                     }
                     delete table;
                  }

                  delete subZones;
               }
            }

            PrintLn("Testing reciprocity of level ", pLevel, " zone neighbors");

            for(z : allZones)
            {
               DGGRSZone zone = z;
               DGGRSZone neighbors[6];
               int nbTypes[6];
               int nSides = dggrs.countZoneEdges(zone);
               int n = dggrs.getZoneNeighbors(zone, neighbors, nbTypes), i, j;
                                 // GGG zones can have 2 neighbors on one side
               if(n != nSides && (n != nSides + 1 || dggrs._class != class(GNOSISGlobalGrid)))
                  fail("DGGS neighbors", thisTest, "of mismatched neighbor count for zone");

               for(i = 0; i < n; i++)
               {
                  if(neighbors[i] == nullZone)
                  {
                     char zID[256];
                     dggrs.getZoneTextID(zone, zID);
                     PrintLn("Null neighbor for zone ", zID);

                     fail("DGGS neighbors", thisTest, "of null neighbor zone");
                     i = n;
                     break;
                  }

                  for(j = 0; j < n; j++)
                     if(i != j && neighbors[i] == neighbors[j])
                        break;
                  if(j < n)
                     break;
               }
               if(i < n)
               {
                  char zID[256];
                  dggrs.getZoneTextID(zone, zID);
                  PrintLn("Duplicate neighbors for zone ", zID);

                  fail("DGGS neighbors", thisTest, "of duplicate neighbors for zone");
               }

               for(i = 0; i < n; i++)
               {
                  DGGRSZone rNeighbors[6];
                  int rNBTypes[6];
                  int nr = dggrs.getZoneNeighbors(neighbors[i], rNeighbors, rNBTypes);

                  for(j = 0; j < nr; j++)
                     if(rNeighbors[j] == zone)
                        break;
                  if(j == nr)
                  {
                     char zID[256], nID[256];
                     dggrs.getZoneTextID(zone, zID);
                     dggrs.getZoneTextID(neighbors[i], nID);
                     PrintLn("Non reciprocal neighbors: ", zID, " and ", nID);

                     PrintLn("Computed neighbors for ", nID, " which ", zID, " considers its neighbor are:");
                     for(j = 0; j < nr; j++)
                     {
                        dggrs.getZoneTextID(rNeighbors[j], nID);
                        PrintLn("   ", nID);
                     }
                     break;
                  }
               }
               if(i < n)
                  fail("DGGS neighbors", thisTest, "of non-reciprocal neighbors for zone");
            }

            PrintLn("Testing reciprocity of level ", pLevel, " zone parents / children");

            for(z : allZones)
            {
               DGGRSZone zone = z;
               DGGRSZone children[13];
               int n = dggrs.getZoneChildren(zone, children), i, j;

               for(i = 0; i < n; i++)
               {
                  for(j = 0; j < n; j++)
                     if(i != j && children[i] == children[j])
                        break;
                  if(j < n)
                     break;
               }
               if(i < n)
                  fail("DGGS children", thisTest, "of duplicate children for zone");

               for(i = 0; i < n; i++)
               {
                  DGGRSZone parents[3];
                  int np = dggrs.getZoneParents(children[i], parents);

                  for(j = 0; j < np; j++)
                     if(parents[j] == zone)
                        break;

                  if(np == 0)
                  {
                     char cID[256];
                     dggrs.getZoneTextID(children[i], cID);
                     PrintLn("Failure to determine parents of ", cID);
                     np = dggrs.getZoneParents(children[i], parents);
                  }
                  else if(j == np)
                  {
                     char zID[256], cID[256];
                     dggrs.getZoneTextID(zone, zID);
                     dggrs.getZoneTextID(children[i], cID);
                     PrintLn("Non reciprocal parent / child: ", zID, " and ", cID);

#if 0
                     PrintLn("Calculated parents of ", cID, " which is thought to be a child of ", zID, " are:");
                     for(j = 0; j < np; j++)
                     {
                        char pID[256];
                        dggrs.getZoneTextID(parents[j], pID);
                        PrintLn("   ", pID);
                     }
                     PrintLn("Calculated children of ", zID, " are:");
                     for(j = 0; j < n; j++)
                     {
                        char cID[256];
                        dggrs.getZoneTextID(children[j], cID);
                        PrintLn("   ", cID);
                     }

                     PrintLn("\n\n\n=================================\n\n");
                     np = dggrs.getZoneParents(children[i], parents);
                     dggrs.getZoneChildren(zone, children);
#endif
                     break;
                  }
               }
               if(i < n)
                  fail("DGGS children", thisTest, "of non-reciprocal parents / children for zone");
            }

            for(z : allZones)
            {
               DGGRSZone zone = z;
               DGGRSZone parents[3];
               int n = dggrs.getZoneParents(zone, parents), i, j;

               for(i = 0; i < n; i++)
               {
                  for(j = 0; j < n; j++)
                     if(i != j && parents[i] == parents[j])
                        break;
                  if(j < n)
                     break;
               }
               if(i < n)
                  fail("DGGS parents", thisTest, "of duplicate parents for zone");

               for(i = 0; i < n; i++)
               {
                  DGGRSZone children[13];
                  int np = dggrs.getZoneChildren(parents[i], children);

                  for(j = 0; j < np; j++)
                     if(children[j] == zone)
                        break;
                  if(j == np)
                  {
                     char zID[256], pID[256];
                     dggrs.getZoneTextID(zone, zID);
                     dggrs.getZoneTextID(parents[i], pID);
                     PrintLn("Non reciprocal child / parent: ", zID, " and ", pID);
                     break;
                  }
               }
               if(i < n)
                  fail("DGGS parents", thisTest, "of non-reciprocal parents / children for zone");
            }

            PrintLn("Testing reciprocity of level ", pLevel, " zone centroid / from centroid");

            for(z : allZones)
            {
               DGGRSZone zone = z, r;
               GeoPoint centroid;
               Pointd crsCentroid;

               dggrs.getZoneCRSCentroid(zone, 0, crsCentroid);
               r = dggrs.getZoneFromCRSCentroid(pLevel, 0, crsCentroid);

               if(r != zone)
               {
                  char zID[256];
                  dggrs.getZoneTextID(zone, zID);
                  PrintLn("Failed from CRS centroid test for zone ", zID);
                  fail("DGGS zones from CRS centroid", thisTest, "of non-reciprocal centroid / zone");
               }

               dggrs.getZoneWGS84Centroid(zone, centroid);
               r = dggrs.getZoneFromWGS84Centroid(pLevel, centroid);

               if(r != zone)
               {
                  char zID[256];
                  dggrs.getZoneTextID(zone, zID);
                  PrintLn("Failed from WGS84 centroid test for zone ", zID);
                  fail("DGGS zones from WGS84 centroid", thisTest, "of non-reciprocal centroid / zone");
               }
            }

            delete allZones;
         }
         else
         {
            PrintLn("Sub Zones for parent level ", pLevel);
            fail("DGGS sub-zones", thisTest, "of failure to list parent zones");
         }
      }
      if(success)
         pass("DGGS sub-zones", thisTest);

      delete dggrs;
   }

   void executeTests()
   {
      for(t : isea3HTestCases)
         test(t);

      testSubZones(class(ISEA3H), 4, 8);
      testSubZones(class(ISEA9R), 2, 4);
      testSubZones(class(GNOSISGlobalGrid), 6, 3);
      testSubZones(class(rHEALPix), 3, 3);
      testSubZones(class(ISEA7H), 3, 4); // Passing 5, 4
      testSubZones(class(HEALPix), 4, 3);
      testSubZones(class(ISEA4R), 4, 3);

      testSubZones(class(IVEA3H), 4, 0);
      testSubZones(class(IVEA7H), 4, 1);
      testSubZones(class(RTEA7H), 4, 0);
      testSubZones(class(RTEA3H), 4, 0);
      testSubZones(class(ISEA7H_Z7), 4, 1);
      testSubZones(class(IVEA7H_Z7), 4, 0);
      testSubZones(class(RTEA7H_Z7), 4, 0);
   }
}



================================================
FILE: tests/dggalTest.epj
================================================
{
   "Version" : 0.2,
   "ModuleName" : "dggalTest",
   "Options" : {
      "Warnings" : "All",
      "TargetType" : "Executable",
      "TargetFileName" : "dggalTest",
      "Libraries" : [
         "ecrt"
      ],
      "Console" : true
   },
   "Platforms" : [
      {
         "Name" : "linux",
         "Options" : {
            "Libraries" : [
               "m"
            ]
         }
      }
   ],
   "Configurations" : [
      {
         "Name" : "Debug",
         "Options" : {
            "Debug" : true,
            "Optimization" : "None",
            "PreprocessorDefinitions" : [
               "_DEBUG",
               "IMPORT_STATIC=\"\""
            ],
            "FastMath" : false
         }
      },
      {
         "Name" : "Release",
         "Options" : {
            "Debug" : false,
            "Optimization" : "Speed",
            "PreprocessorDefinitions" : [
               "IMPORT_STATIC=\"\""
            ],
            "FastMath" : true
         }
      }
   ],
   "Files" : [
      {
         "Folder" : "dggrs",
         "Files" : [
            "isea3HTests.ec"
         ]
      },
      "$(EC_SDK_SRC)/extras/testing/testingFramework.ec",
      "dggalTest.ec",
      "dggrsTestCase.ec"
   ],
   "ResourcesPath" : "",
   "Resources" : [

   ]
}



================================================
FILE: tests/dggrsTestCase.ec
================================================
public import IMPORT_STATIC "ecrt"

import IMPORT_STATIC "dggal"

define epsilonCentroid = 1E-5; // 1E-11; // REVIEW: Why do automated builds have such a large delta?
define epsilonExtent = 1E-5;//8; // 1E-11;
define epsilonExtentPole = 1E-5; //1E-3;
define epsilonArea = 1E-6;

define earthSurfaceArea = 5.100656217240885092949E14;

struct DGGSTestCase
{
   const String dggrs;
   const String zoneID;
   DGGRSZone key;
   GeoPoint centroid;
   GeoExtent wgs84Extent;
   const String centroidParent;
   const String centroidChild;
   Array<const String> parents;
   Array<const String> children;
   Array<const String> neighbors;
   double area;
   Map<int, const String> firstSubZones; // Depth to ID
   Map<int, Array<const String>> subZones; // Depth to list of zones

   void OnFree()
   {
      delete parents;
      delete children;
      delete neighbors;
   }
};



================================================
FILE: tests/Makefile
================================================
.PHONY: all objdir cleantarget clean realclean distclean test

# CORE VARIABLES

MODULE := dggalTest
VERSION :=
CONFIG := release
ifndef COMPILER
COMPILER := default
endif

TARGET_TYPE = executable

# FLAGS

ECFLAGS =
ifndef DEBIAN_PACKAGE
CFLAGS =
LDFLAGS =
endif
PRJ_CFLAGS =
CECFLAGS =
OFLAGS =
LIBS =

ifdef DEBUG
NOSTRIP := y
endif

CONSOLE = -mconsole

# INCLUDES

DGGAL_ABSPATH := $(dir $(realpath $(firstword $(MAKEFILE_LIST))))../

ifndef EC_SDK_SRC
EC_SDK_SRC := $(DGGAL_ABSPATH)../eC
endif

RUNNER =

_CF_DIR = $(EC_SDK_SRC)/
include $(_CF_DIR)crossplatform.mk
include $(_CF_DIR)default.cf
ifndef WINDOWS_HOST
ifdef OSX_HOST
export DYLD_LIBRARY_PATH := $(DYLD_LIBRARY_PATH):$(DGGAL_ABSPATH)obj/$(CONFIG).$(HOST_PLATFORM)$(COMPILER_SUFFIX)$(DEBUG_SUFFIX)/
else
export LD_LIBRARY_PATH := $(LD_LIBRARY_PATH):$(DGGAL_ABSPATH)obj/$(CONFIG).$(HOST_PLATFORM)$(COMPILER_SUFFIX)$(DEBUG_SUFFIX)/
endif
ifdef WINDOWS_TARGET
export WINEPATH := $(WINEPATH);$(DGGAL_ABSPATH)obj/$(CONFIG).$(PLATFORM)$(COMPILER_SUFFIX)$(DEBUG_SUFFIX)/;$(EC_SDK_SRC)/obj/$(PLATFORM)$(COMPILER_SUFFIX)$(DEBUG_SUFFIX)/bin/
RUNNER = wine
endif
else
export PATH := $(PATH);$(EC_SDK_SRC)/obj/$(HOST_PLATFORM)$(COMPILER_SUFFIX)/bin/;$(DGGAL_ABSPATH)obj/$(CONFIG).$(HOST_PLATFORM)$(COMPILER_SUFFIX)$(DEBUG_SUFFIX)/
endif

# POST-INCLUDES VARIABLES

OBJ = obj/$(CONFIG).$(PLATFORM)$(COMPILER_SUFFIX)$(DEBUG_SUFFIX)/

RES =

TARGET_NAME := dggalTest

TARGET = obj/$(CONFIG).$(PLATFORM)$(COMPILER_SUFFIX)$(DEBUG_SUFFIX)/$(TARGET_NAME)$(OUT)

_ECSOURCES = \
	dggrs/isea3HTests.ec \
	$(EC_SDK_SRC)/extras/testing/testingFramework.ec \
	dggalTest.ec \
	dggrsTestCase.ec

ECSOURCES = $(call shwspace,$(_ECSOURCES))

_COBJECTS = $(addprefix $(OBJ),$(patsubst %.ec,%$(C),$(notdir $(_ECSOURCES))))

_SYMBOLS = $(addprefix $(OBJ),$(patsubst %.ec,%$(S),$(notdir $(_ECSOURCES))))

_IMPORTS = $(addprefix $(OBJ),$(patsubst %.ec,%$(I),$(notdir $(_ECSOURCES))))

_ECOBJECTS = $(addprefix $(OBJ),$(patsubst %.ec,%$(O),$(notdir $(_ECSOURCES))))

_BOWLS = $(addprefix $(OBJ),$(patsubst %.ec,%$(B),$(notdir $(_ECSOURCES))))

COBJECTS = $(call shwspace,$(_COBJECTS))

SYMBOLS = $(call shwspace,$(_SYMBOLS))

IMPORTS = $(call shwspace,$(_IMPORTS))

ECOBJECTS = $(call shwspace,$(_ECOBJECTS))

BOWLS = $(call shwspace,$(_BOWLS))

OBJECTS = $(ECOBJECTS) $(OBJ)$(MODULE).main$(O)

SOURCES = $(ECSOURCES)

RESOURCES =

ifdef USE_RESOURCES_EAR
RESOURCES_EAR =
else
RESOURCES_EAR = $(RESOURCES)
endif

LIBS += $(SHAREDLIB) $(EXECUTABLE) $(LINKOPT)

ifndef STATIC_LIBRARY_TARGET
LIBS += \
	$(call _L,ecrt)
endif

PRJ_CFLAGS += \
	 $(if $(DEBUG), -g, -O2 -ffast-math) $(FPIC) -Wall -DREPOSITORY_VERSION="\"$(REPOSITORY_VER)\"" \
			 -DIMPORT_STATIC=\"\"

ECFLAGS += -module $(MODULE)
# PLATFORM-SPECIFIC OPTIONS

ifdef WINDOWS_TARGET
OFLAGS += \
	$(if $(EC_SDK_SRC)/deps/zlib-1.2.8/obj/release.$(PLATFORM)$(COMPILER_SUFFIX),-L$(call quote_path,$(EC_SDK_SRC)/deps/zlib-1.2.8/obj/release.$(PLATFORM)$(COMPILER_SUFFIX)),) \
	$(if $(EC_SDK_SRC)/obj/$(PLATFORM)$(COMPILER_SUFFIX)/bin,-L$(call quote_path,$(EC_SDK_SRC)/obj/$(PLATFORM)$(COMPILER_SUFFIX)/bin),) \
	-static-libgcc
else
OFLAGS += $(if $(EC_SDK_SRC)/obj/$(PLATFORM)$(COMPILER_SUFFIX)/lib,-L$(call quote_path,$(EC_SDK_SRC)/obj/$(PLATFORM)$(COMPILER_SUFFIX)/lib),)
endif

ifdef LINUX_TARGET
LIBS += \
	$(call _L,m)
endif

CECFLAGS += -cpp $(_CPP)

# TARGETS

all: objdir $(TARGET)

objdir:
	$(if $(wildcard $(OBJ)),,$(call mkdir,$(OBJ)))
	$(if $(EC_SDK_SRC),$(if $(wildcard $(call escspace,$(EC_SDK_SRC)/crossplatform.mk)),,@$(call echo,eC SDK Source Warning: The value of EC_SDK_SRC is pointing to an incorrect ($(EC_SDK_SRC)) location.)),)
	$(if $(EC_SDK_SRC),,$(if $(ECP_DEBUG)$(ECC_DEBUG)$(ECS_DEBUG),@$(call echo,ECC Debug Warning: Please define EC_SDK_SRC before using ECP_DEBUG, ECC_DEBUG or ECS_DEBUG),))

$(OBJ)$(MODULE).main.ec: $(SYMBOLS) $(COBJECTS)
	@$(call rm,$(OBJ)symbols.lst)
	@$(call touch,$(OBJ)symbols.lst)
	$(call addtolistfile,$(SYMBOLS),$(OBJ)symbols.lst)
	$(call addtolistfile,$(IMPORTS),$(OBJ)symbols.lst)
	$(ECS) -console $(ARCH_FLAGS) $(ECSLIBOPT) @$(OBJ)symbols.lst -symbols obj/$(CONFIG).$(PLATFORM)$(COMPILER_SUFFIX)$(DEBUG_SUFFIX) -o $(call quote_path,$@)

$(OBJ)$(MODULE).main.c: $(OBJ)$(MODULE).main.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(OBJ)$(MODULE).main.ec -o $(OBJ)$(MODULE).main.sym -symbols $(OBJ)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(OBJ)$(MODULE).main.ec -o $(call quote_path,$@) -symbols $(OBJ)

$(SYMBOLS): | objdir
$(OBJECTS): | objdir
$(TARGET): $(SOURCES) $(RESOURCES_EAR) $(SYMBOLS) $(OBJECTS) | objdir
	@$(call rm,$(OBJ)objects.lst)
	@$(call touch,$(OBJ)objects.lst)
	$(call addtolistfile,$(OBJ)$(MODULE).main$(O),$(OBJ)objects.lst)
	$(call addtolistfile,$(ECOBJECTS),$(OBJ)objects.lst)
ifndef STATIC_LIBRARY_TARGET
	$(LD) $(OFLAGS) @$(OBJ)objects.lst $(LIBS) -o $(TARGET) $(INSTALLNAME) $(SONAME)
ifndef NOSTRIP
	$(STRIP) $(STRIPOPT) $(TARGET)
endif
else
ifdef WINDOWS_HOST
	$(AR) rcs $(TARGET) @$(OBJ)objects.lst $(LIBS)
else
	$(AR) rcs $(TARGET) $(OBJECTS) $(LIBS)
endif
endif
ifdef SHARED_LIBRARY_TARGET
ifdef LINUX_TARGET
ifdef LINUX_HOST
	$(if $(basename $(VER)),ln -sf $(LP)$(MODULE)$(SO)$(VER) $(OBJ)$(LP)$(MODULE)$(SO)$(basename $(VER)),)
	$(if $(VER),ln -sf $(LP)$(MODULE)$(SO)$(VER) $(OBJ)$(LP)$(MODULE)$(SO),)
endif
endif
endif

# SYMBOL RULES

$(OBJ)isea3HTests.sym: dggrs/isea3HTests.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,dggrs/isea3HTests.ec) -o $(call quote_path,$@)

$(OBJ)testingFramework.sym: $(EC_SDK_SRC)/extras/testing/testingFramework.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,$(EC_SDK_SRC)/extras/testing/testingFramework.ec) -o $(call quote_path,$@)

$(OBJ)dggalTest.sym: dggalTest.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,dggalTest.ec) -o $(call quote_path,$@)

$(OBJ)dggrsTestCase.sym: dggrsTestCase.ec
	$(ECP) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) -c $(call quote_path,dggrsTestCase.ec) -o $(call quote_path,$@)

# C OBJECT RULES

$(OBJ)isea3HTests.c: dggrs/isea3HTests.ec $(OBJ)isea3HTests.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,dggrs/isea3HTests.ec) -o $(call quote_path,$@) -symbols $(OBJ)

$(OBJ)testingFramework.c: $(EC_SDK_SRC)/extras/testing/testingFramework.ec $(OBJ)testingFramework.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(EC_SDK_SRC)/extras/testing/testingFramework.ec) -o $(call quote_path,$@) -symbols $(OBJ)

$(OBJ)dggalTest.c: dggalTest.ec $(OBJ)dggalTest.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,dggalTest.ec) -o $(call quote_path,$@) -symbols $(OBJ)

$(OBJ)dggrsTestCase.c: dggrsTestCase.ec $(OBJ)dggrsTestCase.sym | $(SYMBOLS)
	$(ECC) $(CFLAGS) $(CECFLAGS) $(ECFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,dggrsTestCase.ec) -o $(call quote_path,$@) -symbols $(OBJ)

# OBJECT RULES

$(OBJ)isea3HTests$(O): $(OBJ)isea3HTests.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)isea3HTests.c) -o $(call quote_path,$@)

$(OBJ)testingFramework$(O): $(OBJ)testingFramework.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)testingFramework.c) -o $(call quote_path,$@)

$(OBJ)dggalTest$(O): $(OBJ)dggalTest.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)dggalTest.c) -o $(call quote_path,$@)

$(OBJ)dggrsTestCase$(O): $(OBJ)dggrsTestCase.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(call quote_path,$(OBJ)dggrsTestCase.c) -o $(call quote_path,$@)

$(OBJ)$(MODULE).main$(O): $(OBJ)$(MODULE).main.c
	$(CC) $(CFLAGS) $(PRJ_CFLAGS) $(FVISIBILITY) -c $(OBJ)$(MODULE).main.c -o $(call quote_path,$@)

cleantarget:
	$(call rm,$(OBJ)$(MODULE).main$(O) $(OBJ)$(MODULE).main.c $(OBJ)$(MODULE).main.ec $(OBJ)$(MODULE).main$(I) $(OBJ)$(MODULE).main$(S))
	$(call rm,$(OBJ)symbols.lst)
	$(call rm,$(OBJ)objects.lst)
	$(call rm,$(TARGET))
ifdef SHARED_LIBRARY_TARGET
ifdef LINUX_TARGET
ifdef LINUX_HOST
	$(call rm,$(OBJ)$(LP)$(MODULE)$(SO)$(basename $(VER)))
	$(call rm,$(OBJ)$(LP)$(MODULE)$(SO))
endif
endif
endif

clean: cleantarget
	$(call rm,$(_OBJECTS))
	$(call rm,$(_ECOBJECTS))
	$(call rm,$(_COBJECTS))
	$(call rm,$(_BOWLS))
	$(call rm,$(_IMPORTS))
	$(call rm,$(_SYMBOLS))

realclean: cleantarget
	$(call rmr,$(OBJ))

distclean: cleantarget
	$(call rmr,obj/)
	$(call rmr,.configs/)
	$(call rm,*.ews)
	$(call rm,*.Makefile)

test: $(TARGET)
	$(RUNNER) $(TARGET)



================================================
FILE: tests/z7Test.ec
================================================
public import IMPORT_STATIC "ecrt"
import "testingFramework"
import IMPORT_STATIC "dggal"
import IMPORT_STATIC "SFCollections"

define testMaxLevel = 8;

Array<const String> pointsFiles
{ [
   "points7H-L0.geojson",
   "points7H-L1.geojson",
   "points7H-L2.geojson",
   "points7H-L3.geojson",
   "points7H-L4.geojson",
   "points7H-L5.geojson",
   "points7H-L6.geojson",
   "points7H-L7.geojson",
   "points7H-L8-nz.geojson"
] };

double authCP[2][AUTH_ORDER];

public class DGGSUnitTest : eTest
{
   void testZ7Indices(int level, const String z7PointsGeoJSON)
   {
      DGGRS dggrs = ISEA7H_Z7 { };
      bool passed = true;
      File f = FileOpen(z7PointsGeoJSON, read);
      if(f)
      {
         HashMap<int64, Map<String, FieldValue>> attribs { };
         FeatureCollection<PointFeature> fc;

         PrintLn("Loading input file ", z7PointsGeoJSON);
         fc = (FeatureCollection<PointFeature>)loadGeoJSON(f, attribs, false);
         if(fc)
         {
            int count = ((Array)fc).GetCount(), i;

            PrintLn("Testing ", count, " ISEA7H-Z7 zones for level ", level);

            for(i = 0; i < count; i++)
            {
               PointFeature * pf = &((Array<PointFeature>)fc)[i];
               uint64 id = pf->id;
               Map<String, FieldValue> attr = attribs[id];
               if(attr)
               {
                  HashMapIterator<String, FieldValue> it { map = (void *)attr };
                  if(it.Index("Name", false) || it.Index("name", false))
                  {
                     FieldValue * fv = (FieldValue *)(uintptr)it.GetData();
                     if(fv)
                     {
                        const String z7ID = fv->type.type == text ? fv->s : null;
                        if(z7ID)
                        {
                           Array<GeoPoint> geom = (Array<GeoPoint>)pf->geometry;
                           if(geom && geom.count == 1)
                           {
                              DGGRSZone zone;
                              GeoPoint geodetic = geom[0];

                              geodetic.lat = latAuthalicToGeodetic(authCP, geodetic.lat);

                              zone = dggrs.getZoneFromWGS84Centroid(level, geodetic);
                              if(zone != nullZone)
                              {
                                 I7HZone i7;
                                 Z7Zone z7;
                                 char dggalZ7[256];
                                 dggrs.getZoneTextID(zone, dggalZ7);

                                 i7 = ((Z7Zone)zone).to7H();
                                 z7 = Z7Zone::from7H(i7);
                                 if(z7 != zone)
                                    fail("Z7", z7ID, "of Z7 round-trip conversion error"), passed = false;

                                 if(strcmp(z7ID, dggalZ7))
                                 {
                                    PrintLn("DGGRID Z7 ID: ", z7ID, "; DGGAL Z7 ID: ", dggalZ7);
                                    fail("Z7", z7ID, "of Z7 identifier mismatch"), passed = false;
                                    passed = false;
                                 }
                              }
                              else
                                 fail("Z7", z7PointsGeoJSON, "of failure to resolve zone from centroid"), passed = false;
                           }
                           else
                              fail("Z7", z7PointsGeoJSON, "of invalid Point geometry in input GeoJSON"), passed = false;
                        }
                        else
                           fail("Z7", z7PointsGeoJSON, "of null zone identifier in input GeoJSON"), passed = false;
                     }
                     else
                        fail("Z7", z7PointsGeoJSON, "of null zone identifier in input GeoJSON"), passed = false;
                  }
                  else
                     fail("Z7", z7PointsGeoJSON, "of failure to look up zone identifier \"Name\" attribute in input GeoJSON"), passed = false;
               }
            }
            if(passed)
               pass("Z7 Identifier checks", z7PointsGeoJSON);
            else
               fail("Z7", z7PointsGeoJSON, "of Z7 identifier mismatches");

            delete fc;
         }
         else
            fail("Z7", z7PointsGeoJSON, "of failure to load GeoJSON input points");

         attribs.Free();
         delete attribs;
         delete f;
      }
      else
         fail("Z7", z7PointsGeoJSON, "of failure to open input points file");

      delete dggrs;
   }

   bool prepareTests()
   {
      int i;

      for(i = 0; i <= testMaxLevel; i++)
      {
         char fn[MAX_LOCATION];

         strcpy(fn, inputPath);
         PathCat(fn, pointsFiles[i]);
         if(!FileExists(fn).isFile)
         {
            PrintLn("Failure to open input points file: ", fn);
            return false;
         }
      }
      return true;
   }

   void executeTests()
   {
      int i;

      authalicSetup(wgs84Major, wgs84Minor, authCP);

      for(i = 0; i <= testMaxLevel; i++)
      {
         char fn[MAX_LOCATION];

         strcpy(fn, inputPath);
         PathCat(fn, pointsFiles[i]);
         testZ7Indices(i, fn);
      }

      Sleep(0.1);
   }
}



================================================
FILE: tests/z7Test.epj
================================================
{
   "Version" : 0.2,
   "ModuleName" : "z7Test",
   "Options" : {
      "Warnings" : "All",
      "TargetType" : "Executable",
      "TargetFileName" : "z7Test",
      "Libraries" : [
         "ecrt"
      ],
      "Console" : true
   },
   "Platforms" : [
      {
         "Name" : "linux",
         "Options" : {
            "Libraries" : [
               "m"
            ]
         }
      }
   ],
   "Configurations" : [
      {
         "Name" : "Debug",
         "Options" : {
            "Debug" : true,
            "Optimization" : "None",
            "PreprocessorDefinitions" : [
               "_DEBUG",
               "IMPORT_STATIC=\"\""
            ],
            "FastMath" : false
         }
      },
      {
         "Name" : "Release",
         "Options" : {
            "Debug" : false,
            "Optimization" : "Speed",
            "PreprocessorDefinitions" : [
               "IMPORT_STATIC=\"\""
            ],
            "FastMath" : true
         }
      }
   ],
   "Files" : [
      "$(EC_SDK_SRC)/extras/testing/testingFramework.ec",
      "z7Test.ec"
   ],
   "ResourcesPath" : "",
   "Resources" : [

   ]
}



================================================
FILE: tests/testProjections/testProjections.ec
================================================
import "dggal"

class App : Application
{
   void Main()
   {
      // SliceAndDiceGreatCircleIcosahedralProjection ivea { };
      // RTEAProjection ivea { };
      ISEAProjection ivea { };
      int i, j;
      Radians maxDLat = 0, maxDLon = 0;
      Time startTime = GetTime(), endTime;

      for(i = -18000; i <= 18000; i++)
      {
         for(j = -9000; j <= 9000; j++)
         {
            GeoPoint geo { j / 100.0, i / 100.0 };

            Pointd p { -999, -999 };

            geo.lat += GetRandom(0, 10000) / 1000000.0;
            geo.lon += GetRandom(0, 10000) / 1000000.0;
            if((Radians)geo.lat > (Radians)Degrees { 90 }) geo.lat = 90;
            if((Radians)geo.lon > (Radians)Degrees { 180 }) geo.lon = 180;

            //geo = { -32.304465, -77.042623 }; // ISEA

            //geo = { 0.00000000035136977, -0.0062499800021024 };
            //geo = { 89.9994, -179.63132 };
            //geo = { 89.929742, 11.200041 };
            //geo = { 89.999997, -178.815156 };
            //geo = { -88.588346, -168.800054 };
            //geo = { -88.588345998998, -168.800054 };
            //geo = { -83.552797, -168.800004 };
            //geo = { 89.99977, -168.824602 };
            //geo = { 89.929742, 11.200041 };
            //geo = { 0.188382, -78.8 };
            //geo = { -33.764607,       93.125187 };
            //geo = { -64.600688, -179.99351 };
            //geo = { 89.999997, -178.815156 };
            //geo = { -64.582619, -179.979945 };
            //geo = { -56.13751, -178.962374 };
            //geo = { 36.108603, 131.114345 };
            //geo = { 0.188382, -78.8 };
            //geo = { -64.600688, -179.99351 };
            //geo = { -59.758218, -179.995962 };
            //geo = { 89.999989, -179.527249 };
            //geo = { 89.999997, -178.815156 };
            //geo = { -47.328938, -179.990413 };
            //geo = { 31.791509, -78.652105 };

            if(ivea.forward(geo, p))
            {
               bool newMax = false;
               Radians dLat, dLon;
               GeoPoint g { };

               if(!ivea.inverse(p, g, false))
               {
                  ivea.forward(geo, p);
                  ivea.inverse(p, g, false);
                  PrintLn("Failed to inverse project ", p, " to ", geo);
               }

               dLat = fabs((Radians)g.lat - (Radians)geo.lat);
               dLon = fabs((Radians)g.lon - (Radians)geo.lon);
               if(dLon > Pi) dLon -= 2 * Pi;
               dLon *= cos(geo.lat);

               if(dLon > maxDLon)
                  maxDLon = dLon, newMax = true;
               if(dLat > maxDLat)
                  maxDLat = dLat, newMax = true;

               if(newMax)/* && (dLat > (Radians)Degrees { 0.000000001 } ||
                             dLon > (Radians)Degrees { 0.000000001 }))*/
               {
                  PrintLn("Input: ", geo);
                  PrintLn("5x6: ", p);
                  PrintLn("Output: ", g);

                  PrintLn("dlat: ", (double)(dLat * wgs84Major * 1000), " mm");
                  PrintLn("dlon: ", (double)(dLon * wgs84Major * 1000), " mm");
               }
            }
            else
               PrintLn("Failed forward projection");
         }
      }
      endTime = GetTime();

      PrintLn("648,054,001 projection roundtrips in ", endTime - startTime);

      PrintLn("dlat: ", (double)(maxDLat * wgs84Major * 1000), " mm");
      PrintLn("dlon: ", (double)(maxDLon * wgs84Major * 1000), " mm");

      delete ivea;
   }
}



================================================
FILE: tests/testProjections/testProjections.epj
================================================
{
   "Version" : 0.2,
   "ModuleName" : "testProjections",
   "Options" : {
      "Warnings" : "All",
      "TargetType" : "Executable",
      "TargetFileName" : "testProjections",
      "Libraries" : [
         "ecrt"
      ],
      "Console" : true
   },
   "Platforms" : [
      {
         "Name" : "linux",
         "Options" : {
            "Libraries" : [
               "m"
            ]
         }
      }
   ],
   "Configurations" : [
      {
         "Name" : "Debug",
         "Options" : {
            "Debug" : true,
            "Optimization" : "None",
            "PreprocessorDefinitions" : [
               "_DEBUG"
            ],
            "FastMath" : false
         }
      },
      {
         "Name" : "Release",
         "Options" : {
            "Debug" : false,
            "Optimization" : "Speed",
            "FastMath" : true
         }
      }
   ],
   "Files" : [
      "testProjections.ec"
   ],
   "ResourcesPath" : "",
   "Resources" : [

   ]
}


